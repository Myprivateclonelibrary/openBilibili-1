// Code generated by $GOPATH/src/go-common/app/tool/cache/mc. DO NOT EDIT.

/*
  Package testdata is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=articleKey
		CacheArticles(c context.Context, keys []int64) (map[int64]*Article, error)
		// mc: -key=articleKey
		CacheArticle(c context.Context, key int64) (*Article, error)
		// mc: -key=keyMid
		CacheArticle1(c context.Context, key int64, mid int64) (*Article, error)
		// mc: -key=noneKey
		CacheNone(c context.Context) (*Article, error)
		// mc: -key=articleKey
		CacheString(c context.Context, key int64) (string, error)

		// mc: -key=articleKey -expire=d.articleExpire -encode=json
		AddCacheArticles(c context.Context, values map[int64]*Article) error
		// 这里也支持自定义注释 会替换默认的注释
		// mc: -key=articleKey -expire=d.articleExpire -encode=json|gzip
		AddCacheArticle(c context.Context, key int64, value *Article) error
		// mc: -key=keyMid -expire=d.articleExpire -encode=gob
		AddCacheArticle1(c context.Context, key int64, value *Article, mid int64) error
		// mc: -key=noneKey
		AddCacheNone(c context.Context, value *Article) error
		// mc: -key=articleKey -expire=d.articleExpire
		AddCacheString(c context.Context, key int64, value string) error

		// mc: -key=articleKey
		DelCacheArticles(c context.Context, keys []int64) error
		// mc: -key=articleKey
		DelCacheArticle(c context.Context, key int64) error
		// mc: -key=keyMid
		DelCacheArticle1(c context.Context, key int64, mid int64) error
		// mc: -key=noneKey
		DelCacheNone(c context.Context) error
	}
*/

package testdata

import (
	"context"
	"fmt"

	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
)

var _ _mc

// CacheArticles get data from mc
func (d *Dao) CacheArticles(c context.Context, ids []int64) (res map[int64]*Article, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := articleKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	replies, err := conn.GetMulti(keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheArticles")
		log.Errorv(c, log.KV("CacheArticles", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for key, reply := range replies {
		var v *Article
		v = &Article{}
		err = conn.Scan(reply, v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheArticles")
			log.Errorv(c, log.KV("CacheArticles", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*Article, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// CacheArticle get data from mc
func (d *Dao) CacheArticle(c context.Context, id int64) (res *Article, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := articleKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheArticle")
		log.Errorv(c, log.KV("CacheArticle", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &Article{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheArticle")
		log.Errorv(c, log.KV("CacheArticle", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheArticle1 get data from mc
func (d *Dao) CacheArticle1(c context.Context, id int64, mid int64) (res *Article, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := keyMid(id, mid)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheArticle1")
		log.Errorv(c, log.KV("CacheArticle1", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &Article{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheArticle1")
		log.Errorv(c, log.KV("CacheArticle1", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheNone get data from mc
func (d *Dao) CacheNone(c context.Context) (res *Article, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := noneKey()
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheNone")
		log.Errorv(c, log.KV("CacheNone", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &Article{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheNone")
		log.Errorv(c, log.KV("CacheNone", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheString get data from mc
func (d *Dao) CacheString(c context.Context, id int64) (res string, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := articleKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheString")
		log.Errorv(c, log.KV("CacheString", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	err = conn.Scan(reply, &res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheString")
		log.Errorv(c, log.KV("CacheString", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheArticles Set data to mc
func (d *Dao) AddCacheArticles(c context.Context, values map[int64]*Article) (err error) {
	if len(values) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	for id, val := range values {
		key := articleKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.articleExpire, Flags: memcache.FlagJSON}
		if err = conn.Set(item); err != nil {
			prom.BusinessErrCount.Incr("mc:AddCacheArticles")
			log.Errorv(c, log.KV("AddCacheArticles", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// AddCacheArticle 这里也支持自定义注释 会替换默认的注释
func (d *Dao) AddCacheArticle(c context.Context, id int64, val *Article) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := articleKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.articleExpire, Flags: memcache.FlagJSON | memcache.FlagGzip}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheArticle")
		log.Errorv(c, log.KV("AddCacheArticle", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheArticle1 Set data to mc
func (d *Dao) AddCacheArticle1(c context.Context, id int64, val *Article, mid int64) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := keyMid(id, mid)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.articleExpire, Flags: memcache.FlagGOB}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheArticle1")
		log.Errorv(c, log.KV("AddCacheArticle1", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheNone Set data to mc
func (d *Dao) AddCacheNone(c context.Context, val *Article) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := noneKey()
	item := &memcache.Item{Key: key, Object: val, Expiration: d.articleExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheNone")
		log.Errorv(c, log.KV("AddCacheNone", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheString Set data to mc
func (d *Dao) AddCacheString(c context.Context, id int64, val string) (err error) {
	if len(val) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := articleKey(id)
	bs := []byte(val)
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.articleExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheString")
		log.Errorv(c, log.KV("AddCacheString", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheArticles delete data from mc
func (d *Dao) DelCacheArticles(c context.Context, ids []int64) (err error) {
	if len(ids) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	for _, id := range ids {
		key := articleKey(id)
		if err = conn.Delete(key); err != nil {
			if err == memcache.ErrNotFound {
				err = nil
				continue
			}
			prom.BusinessErrCount.Incr("mc:DelCacheArticles")
			log.Errorv(c, log.KV("DelCacheArticles", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// DelCacheArticle delete data from mc
func (d *Dao) DelCacheArticle(c context.Context, id int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := articleKey(id)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheArticle")
		log.Errorv(c, log.KV("DelCacheArticle", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheArticle1 delete data from mc
func (d *Dao) DelCacheArticle1(c context.Context, id int64, mid int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := keyMid(id, mid)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheArticle1")
		log.Errorv(c, log.KV("DelCacheArticle1", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheNone delete data from mc
func (d *Dao) DelCacheNone(c context.Context) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := noneKey()
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheNone")
		log.Errorv(c, log.KV("DelCacheNone", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
