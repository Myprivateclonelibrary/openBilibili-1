// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/bbq/video/api/grpc/v1/api.proto

/*
	Package v1 is a generated protocol buffer package.

	It is generated from these files:
		app/service/bbq/video/api/grpc/v1/api.proto

	It has these top-level messages:
		ImportVideoInfo
		VideoBase
		SyncVideoTagRequest
		TagInfo
		SvStatisticsInfoReq
		SvStatisticsInfoRes
		SvStInfo
		SyncMidRequset
		SyncUserBaseResponse
		SyncMidsRequset
		BVideoTransRequset
		BVCTransBackRequset
		SvPic
		BVCTransInfo
		CreateIDRequest
		CreateIDResponse
		VideoInfo
		ListVideoInfoRequest
		ListVideoInfoResponse
		ModifyLimitsRequest
		ModifyLimitsResponse
		PreUploadRequest
		PreUploadResponse
		CallBackRequest
		VideoUnshelfRequest
		VideoDeleteRequest
		UploadingVideo
		PrepareVideoRequest
		PrepareVideoResponse
		HomeImgCreateRequest
		PlayInfoRequest
		PlayInfoResponse
		PlayInfo
		FileInfo
*/
package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/golang/protobuf/ptypes/empty"

import go_common_library_time "go-common/library/time"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ImportVideoInfo struct {
	AVID          int64  `protobuf:"varint,1,opt,name=avid,proto3" json:"avid" form:"avid"`
	CID           int64  `protobuf:"varint,2,opt,name=cid,proto3" json:"cid" form:"avid"`
	MID           int64  `protobuf:"varint,3,opt,name=mid,proto3" json:"mid" form:"mid"`
	Title         string `protobuf:"bytes,4,opt,name=title,proto3" json:"title" form:"title"`
	Content       string `protobuf:"bytes,5,opt,name=content,proto3" json:"content" form:"content"`
	Original      int64  `protobuf:"varint,6,opt,name=original,proto3" json:"original" form:"original"`
	Duration      int64  `protobuf:"varint,7,opt,name=duration,proto3" json:"duration" form:"duration"`
	State         int64  `protobuf:"varint,8,opt,name=state,proto3" json:"state" form:"state"`
	Tag           string `protobuf:"bytes,9,opt,name=tag,proto3" json:"tag" form:"tag"`
	Pubtime       string `protobuf:"bytes,10,opt,name=pubtime,proto3" json:"pubtime" form:"pubtime"`
	TID           int64  `protobuf:"varint,11,opt,name=tid,proto3" json:"tid" form:"tid"`
	SubTID        int64  `protobuf:"varint,12,opt,name=sub_tid,json=subTid,proto3" json:"sub_tid" form:"sub_tid"`
	IsFullScreen  int64  `protobuf:"varint,13,opt,name=is_full_screen,json=isFullScreen,proto3" json:"is_full_screen" form:"is_full_screen"`
	CoverUrl      string `protobuf:"bytes,14,opt,name=cover_url,json=coverUrl,proto3" json:"cover_url" form:"cover_url"`
	CoverWidth    int64  `protobuf:"varint,15,opt,name=cover_width,json=coverWidth,proto3" json:"cover_width" form:"cover_width"`
	CoverHeight   int64  `protobuf:"varint,16,opt,name=cover_height,json=coverHeight,proto3" json:"cover_height" form:"cover_height"`
	From          int64  `protobuf:"varint,17,opt,name=from,proto3" json:"from" form:"from"`
	Svid          int64  `protobuf:"varint,18,opt,name=svid,proto3" json:"svid" form:"svid"`
	HomeImgUrl    string `protobuf:"bytes,19,opt,name=home_img_url,json=homeImgUrl,proto3" json:"home_img_url" form:"home_img_url"`
	HomeImgWidth  int64  `protobuf:"varint,20,opt,name=home_img_width,json=homeImgWidth,proto3" json:"home_img_width" form:"home_img_width"`
	HomeImgHeight int64  `protobuf:"varint,21,opt,name=home_img_height,json=homeImgHeight,proto3" json:"home_img_height" form:"home_img_height"`
}

func (m *ImportVideoInfo) Reset()                    { *m = ImportVideoInfo{} }
func (*ImportVideoInfo) ProtoMessage()               {}
func (*ImportVideoInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

type VideoBase struct {
	Avid         int64                       `protobuf:"varint,1,opt,name=avid,proto3" json:"avid" form:"avid"`
	Cid          int64                       `protobuf:"varint,2,opt,name=cid,proto3" json:"cid" form:"avid"`
	Mid          int64                       `protobuf:"varint,3,opt,name=mid,proto3" json:"mid" form:"mid"`
	Title        string                      `protobuf:"bytes,4,opt,name=title,proto3" json:"title" form:"title"`
	Content      string                      `protobuf:"bytes,5,opt,name=content,proto3" json:"content" form:"content"`
	Original     int64                       `protobuf:"varint,6,opt,name=original,proto3" json:"original" form:"original"`
	Duration     int64                       `protobuf:"varint,7,opt,name=duration,proto3" json:"duration" form:"duration"`
	State        int64                       `protobuf:"varint,8,opt,name=state,proto3" json:"state" form:"state"`
	Tag          string                      `protobuf:"bytes,9,opt,name=tag,proto3" json:"tag" form:"tag"`
	Pubtime      go_common_library_time.Time `protobuf:"varint,10,opt,name=pubtime,proto3,casttype=go-common/library/time.Time" json:"pubtime" form:"tag"`
	Tid          int64                       `protobuf:"varint,11,opt,name=tid,proto3" json:"tid" form:"tid"`
	SubTid       int64                       `protobuf:"varint,12,opt,name=sub_tid,json=subTid,proto3" json:"sub_tid" form:"sub_tid"`
	IsFullScreen int64                       `protobuf:"varint,13,opt,name=is_full_screen,json=isFullScreen,proto3" json:"is_full_screen" form:"is_full_screen"`
	CoverUrl     string                      `protobuf:"bytes,14,opt,name=cover_url,json=coverUrl,proto3" json:"cover_url" form:"cover_url"`
	CoverWidth   int64                       `protobuf:"varint,15,opt,name=cover_width,json=coverWidth,proto3" json:"cover_width" form:"cover_width"`
	CoverHeight  int64                       `protobuf:"varint,16,opt,name=cover_height,json=coverHeight,proto3" json:"cover_height" form:"cover_height"`
	From         int64                       `protobuf:"varint,17,opt,name=from,proto3" json:"from" form:"from"`
	Svid         int64                       `protobuf:"varint,18,opt,name=svid,proto3" json:"svid" form:"svid"`
	Limits       uint64                      `protobuf:"varint,19,opt,name=limits,proto3" json:"limits"`
}

func (m *VideoBase) Reset()                    { *m = VideoBase{} }
func (*VideoBase) ProtoMessage()               {}
func (*VideoBase) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

type SyncVideoTagRequest struct {
	TagInfos []*TagInfo `protobuf:"bytes,1,rep,name=tag_infos,json=tagInfos" json:"tag_infos" form:"tag_infos"`
}

func (m *SyncVideoTagRequest) Reset()                    { *m = SyncVideoTagRequest{} }
func (*SyncVideoTagRequest) ProtoMessage()               {}
func (*SyncVideoTagRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

type TagInfo struct {
	TagType int32  `protobuf:"varint,1,opt,name=tag_type,json=tagType,proto3" json:"tag_type" form:"tag_type"`
	TagName string `protobuf:"bytes,2,opt,name=tag_name,json=tagName,proto3" json:"tag_name" form:"tag_name"`
}

func (m *TagInfo) Reset()                    { *m = TagInfo{} }
func (*TagInfo) ProtoMessage()               {}
func (*TagInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

type SvStatisticsInfoReq struct {
	SvidList []int64 `protobuf:"varint,1,rep,packed,name=svid_list,json=svidList" json:"svid_list" form:"svid_list"`
}

func (m *SvStatisticsInfoReq) Reset()                    { *m = SvStatisticsInfoReq{} }
func (*SvStatisticsInfoReq) ProtoMessage()               {}
func (*SvStatisticsInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

type SvStatisticsInfoRes struct {
	SvstInfoMap map[int64]*SvStInfo `protobuf:"bytes,1,rep,name=svst_info_map,json=svstInfoMap" json:"svst_info_map" form:"svst_info_map" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SvStatisticsInfoRes) Reset()                    { *m = SvStatisticsInfoRes{} }
func (*SvStatisticsInfoRes) ProtoMessage()               {}
func (*SvStatisticsInfoRes) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

type SvStInfo struct {
	Svid      int64 `protobuf:"varint,1,opt,name=svid,proto3" json:"svid" form:"svid"`
	Play      int64 `protobuf:"varint,2,opt,name=play,proto3" json:"play" form:"play"`
	Subtitles int64 `protobuf:"varint,3,opt,name=subtitles,proto3" json:"subtitles" form:"subtitles"`
	Like      int64 `protobuf:"varint,4,opt,name=like,proto3" json:"like" form:"like"`
	Share     int64 `protobuf:"varint,5,opt,name=share,proto3" json:"share" form:"share"`
	Report    int64 `protobuf:"varint,6,opt,name=report,proto3" json:"report" form:"report"`
	Reply     int64 `protobuf:"varint,7,opt,name=reply,proto3" json:"reply" form:"reply"`
}

func (m *SvStInfo) Reset()                    { *m = SvStInfo{} }
func (*SvStInfo) ProtoMessage()               {}
func (*SvStInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

type SyncMidRequset struct {
	MID int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid" form:"mid"`
}

func (m *SyncMidRequset) Reset()                    { *m = SyncMidRequset{} }
func (*SyncMidRequset) ProtoMessage()               {}
func (*SyncMidRequset) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

type SyncUserBaseResponse struct {
	Affc int64 `protobuf:"varint,1,opt,name=affc,proto3" json:"affc" form:"affc"`
}

func (m *SyncUserBaseResponse) Reset()                    { *m = SyncUserBaseResponse{} }
func (*SyncUserBaseResponse) ProtoMessage()               {}
func (*SyncUserBaseResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

type SyncMidsRequset struct {
	MIDS []int64 `protobuf:"varint,1,rep,packed,name=mids" json:"mids" form:"mids"`
}

func (m *SyncMidsRequset) Reset()                    { *m = SyncMidsRequset{} }
func (*SyncMidsRequset) ProtoMessage()               {}
func (*SyncMidsRequset) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

type BVideoTransRequset struct {
	SVID int64 `protobuf:"varint,1,opt,name=svid,proto3" json:"svid" form:"svid" validate:"min=0"`
	CID  int64 `protobuf:"varint,2,opt,name=cid,proto3" json:"cid" form:"cid" validate:"min=0"`
}

func (m *BVideoTransRequset) Reset()                    { *m = BVideoTransRequset{} }
func (*BVideoTransRequset) ProtoMessage()               {}
func (*BVideoTransRequset) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

type BVCTransBackRequset struct {
	FlowID   string          `protobuf:"bytes,1,opt,name=flow_id,json=flowId,proto3" json:"flow_id" form:"flow_id" validate:"min=0"`
	FlowType int8            `protobuf:"varint,2,opt,name=flow_type,json=flowType,proto3,casttype=int8" json:"flow_type" form:"flow_type" validate:"min=0"`
	SVID     int64           `protobuf:"varint,3,opt,name=svid,proto3" json:"svid" form:"svid" validate:"min=0"`
	TransRes []*BVCTransInfo `protobuf:"bytes,4,rep,name=trans_res,json=transRes" json:"trans_res" form:"trans_res"`
	PIC      *SvPic          `protobuf:"bytes,5,opt,name=pic" json:"pic" form:"pic" validate:"required"`
}

func (m *BVCTransBackRequset) Reset()                    { *m = BVCTransBackRequset{} }
func (*BVCTransBackRequset) ProtoMessage()               {}
func (*BVCTransBackRequset) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

type SvPic struct {
	PicURL    string `protobuf:"bytes,1,opt,name=pic_url,json=picUrl,proto3" json:"pic_url" form:"pic_url" validate:"required"`
	PicWidth  int64  `protobuf:"varint,2,opt,name=pic_width,json=picWidth,proto3" json:"pic_width" form:"pic_width" validate:"required"`
	PicHeight int64  `protobuf:"varint,3,opt,name=pic_height,json=picHeight,proto3" json:"pic_height" form:"pic_height" validate:"required"`
}

func (m *SvPic) Reset()                    { *m = SvPic{} }
func (*SvPic) ProtoMessage()               {}
func (*SvPic) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

type BVCTransInfo struct {
	Path      string `protobuf:"bytes,2,opt,name=path,proto3" json:"path" form:"path" validate:"required"`
	PPI       string `protobuf:"bytes,3,opt,name=ppi,proto3" json:"ppi" form:"ppi" validate:"required"`
	BPS       string `protobuf:"bytes,4,opt,name=bps,proto3" json:"bps" form:"bps" validate:"required"`
	VideoCode string `protobuf:"bytes,5,opt,name=video_code,json=videoCode,proto3" json:"video_code" form:"video_code" validate:"required"`
	Filesize  int64  `protobuf:"varint,6,opt,name=filesize,proto3" json:"filesize" form:"filesize" validate:"required"`
	Duration  int64  `protobuf:"varint,8,opt,name=duration,proto3" json:"duration" form:"duration" validate:"required"`
}

func (m *BVCTransInfo) Reset()                    { *m = BVCTransInfo{} }
func (*BVCTransInfo) ProtoMessage()               {}
func (*BVCTransInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{13} }

type CreateIDRequest struct {
	Mid  int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"required"`
	Time int64 `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty" form:"time"`
}

func (m *CreateIDRequest) Reset()                    { *m = CreateIDRequest{} }
func (*CreateIDRequest) ProtoMessage()               {}
func (*CreateIDRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{14} }

type CreateIDResponse struct {
	NewId int64 `protobuf:"varint,1,opt,name=new_id,json=newId,proto3" json:"new_id,omitempty"`
}

func (m *CreateIDResponse) Reset()                    { *m = CreateIDResponse{} }
func (*CreateIDResponse) ProtoMessage()               {}
func (*CreateIDResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{15} }

type VideoInfo struct {
	VideoBase *VideoBase `protobuf:"bytes,1,opt,name=video_base,json=videoBase" json:"vidoe_base"`
}

func (m *VideoInfo) Reset()                    { *m = VideoInfo{} }
func (*VideoInfo) ProtoMessage()               {}
func (*VideoInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{16} }

type ListVideoInfoRequest struct {
	SvIDs []int64 `protobuf:"varint,1,rep,packed,name=svIDs" json:"svIDs,omitempty" form:"svids" validate:"required"`
}

func (m *ListVideoInfoRequest) Reset()                    { *m = ListVideoInfoRequest{} }
func (*ListVideoInfoRequest) ProtoMessage()               {}
func (*ListVideoInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{17} }

type ListVideoInfoResponse struct {
	List []*VideoInfo `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *ListVideoInfoResponse) Reset()                    { *m = ListVideoInfoResponse{} }
func (*ListVideoInfoResponse) ProtoMessage()               {}
func (*ListVideoInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{18} }

type ModifyLimitsRequest struct {
	Svid      int64  `protobuf:"varint,1,opt,name=svid,proto3" json:"svid,omitempty" form:"svid" validate:"required"`
	LimitType uint64 `protobuf:"varint,2,opt,name=limit_type,json=limitType,proto3" json:"limit_type,omitempty" form:"limit_type" validate:"required"`
	LimitOp   uint64 `protobuf:"varint,3,opt,name=limit_op,json=limitOp,proto3" json:"limit_op,omitempty" form:"limit_op"`
}

func (m *ModifyLimitsRequest) Reset()                    { *m = ModifyLimitsRequest{} }
func (*ModifyLimitsRequest) ProtoMessage()               {}
func (*ModifyLimitsRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{19} }

type ModifyLimitsResponse struct {
}

func (m *ModifyLimitsResponse) Reset()                    { *m = ModifyLimitsResponse{} }
func (*ModifyLimitsResponse) ProtoMessage()               {}
func (*ModifyLimitsResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{20} }

type PreUploadRequest struct {
	Title     string `protobuf:"bytes,1,opt,name=title,proto3" json:"title" form:"title" validate:"required"`
	Mid       int64  `protobuf:"varint,2,opt,name=mid,proto3" json:"mid" form:"mid" validate:"required"`
	Topic     string `protobuf:"bytes,3,opt,name=topic,proto3" json:"topic" form:"topic"`
	From      int64  `protobuf:"varint,4,opt,name=from,proto3" json:"from" form:"from" validate:"required"`
	FileExt   string `protobuf:"bytes,5,opt,name=file_ext,json=fileExt,proto3" json:"file_ext" form:"file_ext" validate:"required"`
	Entension string `protobuf:"bytes,6,opt,name=entension,proto3" json:"entension" form:"entension"`
}

func (m *PreUploadRequest) Reset()                    { *m = PreUploadRequest{} }
func (*PreUploadRequest) ProtoMessage()               {}
func (*PreUploadRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{21} }

type PreUploadResponse struct {
	Svid      int64    `protobuf:"varint,1,opt,name=svid,proto3" json:"biz_id" form:"biz_id"`
	UposUri   string   `protobuf:"bytes,2,opt,name=upos_uri,json=uposUri,proto3" json:"upos_uri" form:"upos_uri"`
	EndPoint  string   `protobuf:"bytes,3,opt,name=end_point,json=endPoint,proto3" json:"endpoint" form:"endpoint"`
	EndPoints []string `protobuf:"bytes,4,rep,name=end_points,json=endPoints" json:"endpoints" form:"endpoints"`
	Auth      string   `protobuf:"bytes,5,opt,name=auth,proto3" json:"auth" form:"auth"`
}

func (m *PreUploadResponse) Reset()                    { *m = PreUploadResponse{} }
func (*PreUploadResponse) ProtoMessage()               {}
func (*PreUploadResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{22} }

type CallBackRequest struct {
	Svid int64 `protobuf:"varint,1,opt,name=svid,proto3" json:"svid" form:"svid" validate:"required"`
	Mid  int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid" form:"mid" validate:"required"`
}

func (m *CallBackRequest) Reset()                    { *m = CallBackRequest{} }
func (*CallBackRequest) ProtoMessage()               {}
func (*CallBackRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{23} }

type VideoUnshelfRequest struct {
	Svid int64 `protobuf:"varint,1,opt,name=svid,proto3" json:"svid" form:"svid" validate:"required"`
}

func (m *VideoUnshelfRequest) Reset()                    { *m = VideoUnshelfRequest{} }
func (*VideoUnshelfRequest) ProtoMessage()               {}
func (*VideoUnshelfRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{24} }

type VideoDeleteRequest struct {
	Svid  int64 `protobuf:"varint,1,opt,name=svid,proto3" json:"svid" form:"svid"`
	UpMid int64 `protobuf:"varint,2,opt,name=up_mid,json=upMid,proto3" json:"up_mid" form:"up_mid"`
}

func (m *VideoDeleteRequest) Reset()                    { *m = VideoDeleteRequest{} }
func (*VideoDeleteRequest) ProtoMessage()               {}
func (*VideoDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{25} }

type UploadingVideo struct {
	Svid          int64  `protobuf:"varint,1,opt,name=svid,proto3" json:"svid,omitempty"`
	Mid           int64  `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	Title         string `protobuf:"bytes,3,opt,name=title,proto3" json:"title"`
	UploadStatus  int64  `protobuf:"varint,4,opt,name=upload_status,json=uploadStatus,proto3" json:"upload_status"`
	RetryTime     int64  `protobuf:"varint,5,opt,name=retry_time,json=retryTime,proto3" json:"retry_time,omitempty"`
	HomeImgUrl    string `protobuf:"bytes,6,opt,name=home_img_url,json=homeImgUrl,proto3" json:"home_img_url"`
	HomeImgHeight int64  `protobuf:"varint,7,opt,name=home_img_height,json=homeImgHeight,proto3" json:"home_img_height"`
	HomeImgWidth  int64  `protobuf:"varint,8,opt,name=home_img_width,json=homeImgWidth,proto3" json:"home_img_width"`
}

func (m *UploadingVideo) Reset()                    { *m = UploadingVideo{} }
func (*UploadingVideo) ProtoMessage()               {}
func (*UploadingVideo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{26} }

type PrepareVideoRequest struct {
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
}

func (m *PrepareVideoRequest) Reset()                    { *m = PrepareVideoRequest{} }
func (*PrepareVideoRequest) ProtoMessage()               {}
func (*PrepareVideoRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{27} }

type PrepareVideoResponse struct {
	List []*UploadingVideo `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *PrepareVideoResponse) Reset()                    { *m = PrepareVideoResponse{} }
func (*PrepareVideoResponse) ProtoMessage()               {}
func (*PrepareVideoResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{28} }

type HomeImgCreateRequest struct {
	Svid   int64  `protobuf:"varint,1,opt,name=svid,proto3" json:"svid" form:"svid" validate:"required"`
	Mid    int64  `protobuf:"varint,2,opt,name=mid,proto3" json:"mid" form:"mid" validate:"required"`
	Width  int64  `protobuf:"varint,3,opt,name=width,proto3" json:"width" form:"width" validate:"required"`
	Url    string `protobuf:"bytes,4,opt,name=url,proto3" json:"url" form:"url" validate:"required"`
	Height int64  `protobuf:"varint,5,opt,name=height,proto3" json:"height" form:"height" validate:"required"`
}

func (m *HomeImgCreateRequest) Reset()                    { *m = HomeImgCreateRequest{} }
func (*HomeImgCreateRequest) ProtoMessage()               {}
func (*HomeImgCreateRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{29} }

type PlayInfoRequest struct {
	Svid []int64 `protobuf:"varint,1,rep,packed,name=svid" json:"svid" form:"svid" validate:"required"`
}

func (m *PlayInfoRequest) Reset()                    { *m = PlayInfoRequest{} }
func (*PlayInfoRequest) ProtoMessage()               {}
func (*PlayInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{30} }

type PlayInfoResponse struct {
	List map[int64]*PlayInfo `protobuf:"bytes,1,rep,name=list" json:"list" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PlayInfoResponse) Reset()                    { *m = PlayInfoResponse{} }
func (*PlayInfoResponse) ProtoMessage()               {}
func (*PlayInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{31} }

type PlayInfo struct {
	Svid           int64       `protobuf:"varint,1,opt,name=svid,proto3" json:""`
	ExpireTime     int64       `protobuf:"varint,2,opt,name=expire_time,json=expireTime,proto3" json:"expire_time"`
	Quality        int64       `protobuf:"varint,3,opt,name=quality,proto3" json:"quality"`
	Url            string      `protobuf:"bytes,4,opt,name=url,proto3" json:"url"`
	CurrentTime    int64       `protobuf:"varint,5,opt,name=current_time,json=currentTime,proto3" json:"current_time"`
	FileInfo       []*FileInfo `protobuf:"bytes,6,rep,name=file_info,json=fileInfo" json:"file_info"`
	SupportQuality []int64     `protobuf:"varint,7,rep,packed,name=support_quality,json=supportQuality" json:"support_quality"`
}

func (m *PlayInfo) Reset()                    { *m = PlayInfo{} }
func (*PlayInfo) ProtoMessage()               {}
func (*PlayInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{32} }

type FileInfo struct {
	Ahead      string `protobuf:"bytes,1,opt,name=ahead,proto3" json:"ahead"`
	Filesize   int64  `protobuf:"varint,2,opt,name=filesize,proto3" json:"filesize"`
	Timelength int64  `protobuf:"varint,3,opt,name=timelength,proto3" json:"timelength"`
	Vhead      string `protobuf:"bytes,4,opt,name=vhead,proto3" json:"vhead"`
	Path       string `protobuf:"bytes,5,opt,name=path,proto3" json:"path"`
	Url        string `protobuf:"bytes,6,opt,name=url,proto3" json:"url"`
	UrlBc      string `protobuf:"bytes,7,opt,name=url_bc,json=urlBc,proto3" json:"url_bc"`
}

func (m *FileInfo) Reset()                    { *m = FileInfo{} }
func (*FileInfo) ProtoMessage()               {}
func (*FileInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{33} }

func init() {
	proto.RegisterType((*ImportVideoInfo)(nil), "bbq.service.video.v1.ImportVideoInfo")
	proto.RegisterType((*VideoBase)(nil), "bbq.service.video.v1.VideoBase")
	proto.RegisterType((*SyncVideoTagRequest)(nil), "bbq.service.video.v1.SyncVideoTagRequest")
	proto.RegisterType((*TagInfo)(nil), "bbq.service.video.v1.TagInfo")
	proto.RegisterType((*SvStatisticsInfoReq)(nil), "bbq.service.video.v1.SvStatisticsInfoReq")
	proto.RegisterType((*SvStatisticsInfoRes)(nil), "bbq.service.video.v1.SvStatisticsInfoRes")
	proto.RegisterType((*SvStInfo)(nil), "bbq.service.video.v1.SvStInfo")
	proto.RegisterType((*SyncMidRequset)(nil), "bbq.service.video.v1.SyncMidRequset")
	proto.RegisterType((*SyncUserBaseResponse)(nil), "bbq.service.video.v1.SyncUserBaseResponse")
	proto.RegisterType((*SyncMidsRequset)(nil), "bbq.service.video.v1.SyncMidsRequset")
	proto.RegisterType((*BVideoTransRequset)(nil), "bbq.service.video.v1.BVideoTransRequset")
	proto.RegisterType((*BVCTransBackRequset)(nil), "bbq.service.video.v1.BVCTransBackRequset")
	proto.RegisterType((*SvPic)(nil), "bbq.service.video.v1.SvPic")
	proto.RegisterType((*BVCTransInfo)(nil), "bbq.service.video.v1.BVCTransInfo")
	proto.RegisterType((*CreateIDRequest)(nil), "bbq.service.video.v1.CreateIDRequest")
	proto.RegisterType((*CreateIDResponse)(nil), "bbq.service.video.v1.CreateIDResponse")
	proto.RegisterType((*VideoInfo)(nil), "bbq.service.video.v1.VideoInfo")
	proto.RegisterType((*ListVideoInfoRequest)(nil), "bbq.service.video.v1.ListVideoInfoRequest")
	proto.RegisterType((*ListVideoInfoResponse)(nil), "bbq.service.video.v1.ListVideoInfoResponse")
	proto.RegisterType((*ModifyLimitsRequest)(nil), "bbq.service.video.v1.ModifyLimitsRequest")
	proto.RegisterType((*ModifyLimitsResponse)(nil), "bbq.service.video.v1.ModifyLimitsResponse")
	proto.RegisterType((*PreUploadRequest)(nil), "bbq.service.video.v1.PreUploadRequest")
	proto.RegisterType((*PreUploadResponse)(nil), "bbq.service.video.v1.PreUploadResponse")
	proto.RegisterType((*CallBackRequest)(nil), "bbq.service.video.v1.CallBackRequest")
	proto.RegisterType((*VideoUnshelfRequest)(nil), "bbq.service.video.v1.VideoUnshelfRequest")
	proto.RegisterType((*VideoDeleteRequest)(nil), "bbq.service.video.v1.VideoDeleteRequest")
	proto.RegisterType((*UploadingVideo)(nil), "bbq.service.video.v1.UploadingVideo")
	proto.RegisterType((*PrepareVideoRequest)(nil), "bbq.service.video.v1.PrepareVideoRequest")
	proto.RegisterType((*PrepareVideoResponse)(nil), "bbq.service.video.v1.PrepareVideoResponse")
	proto.RegisterType((*HomeImgCreateRequest)(nil), "bbq.service.video.v1.HomeImgCreateRequest")
	proto.RegisterType((*PlayInfoRequest)(nil), "bbq.service.video.v1.PlayInfoRequest")
	proto.RegisterType((*PlayInfoResponse)(nil), "bbq.service.video.v1.PlayInfoResponse")
	proto.RegisterType((*PlayInfo)(nil), "bbq.service.video.v1.PlayInfo")
	proto.RegisterType((*FileInfo)(nil), "bbq.service.video.v1.FileInfo")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Video service

type VideoClient interface {
	ImportVideo(ctx context.Context, in *ImportVideoInfo, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	SyncTag(ctx context.Context, in *SyncVideoTagRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	SvStatisticsInfo(ctx context.Context, in *SvStatisticsInfoReq, opts ...grpc.CallOption) (*SvStatisticsInfoRes, error)
	SyncUserBase(ctx context.Context, in *SyncMidRequset, opts ...grpc.CallOption) (*SyncUserBaseResponse, error)
	SyncUserSta(ctx context.Context, in *SyncMidRequset, opts ...grpc.CallOption) (*SyncUserBaseResponse, error)
	SyncUserBases(ctx context.Context, in *SyncMidsRequset, opts ...grpc.CallOption) (*SyncUserBaseResponse, error)
	SyncUserStas(ctx context.Context, in *SyncMidsRequset, opts ...grpc.CallOption) (*SyncUserBaseResponse, error)
	CreateID(ctx context.Context, in *CreateIDRequest, opts ...grpc.CallOption) (*CreateIDResponse, error)
	BVCTransCommit(ctx context.Context, in *BVideoTransRequset, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	ListVideoInfo(ctx context.Context, in *ListVideoInfoRequest, opts ...grpc.CallOption) (*ListVideoInfoResponse, error)
	ModifyLimits(ctx context.Context, in *ModifyLimitsRequest, opts ...grpc.CallOption) (*ModifyLimitsResponse, error)
	PreUpload(ctx context.Context, in *PreUploadRequest, opts ...grpc.CallOption) (*PreUploadResponse, error)
	CallBack(ctx context.Context, in *CallBackRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	VideoUnshelf(ctx context.Context, in *VideoUnshelfRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	VideoDelete(ctx context.Context, in *VideoDeleteRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	ListPrepareVideo(ctx context.Context, in *PrepareVideoRequest, opts ...grpc.CallOption) (*PrepareVideoResponse, error)
	HomeImgCreate(ctx context.Context, in *HomeImgCreateRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	PlayInfo(ctx context.Context, in *PlayInfoRequest, opts ...grpc.CallOption) (*PlayInfoResponse, error)
}

type videoClient struct {
	cc *grpc.ClientConn
}

func NewVideoClient(cc *grpc.ClientConn) VideoClient {
	return &videoClient{cc}
}

func (c *videoClient) ImportVideo(ctx context.Context, in *ImportVideoInfo, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/ImportVideo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) SyncTag(ctx context.Context, in *SyncVideoTagRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/SyncTag", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) SvStatisticsInfo(ctx context.Context, in *SvStatisticsInfoReq, opts ...grpc.CallOption) (*SvStatisticsInfoRes, error) {
	out := new(SvStatisticsInfoRes)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/SvStatisticsInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) SyncUserBase(ctx context.Context, in *SyncMidRequset, opts ...grpc.CallOption) (*SyncUserBaseResponse, error) {
	out := new(SyncUserBaseResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/SyncUserBase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) SyncUserSta(ctx context.Context, in *SyncMidRequset, opts ...grpc.CallOption) (*SyncUserBaseResponse, error) {
	out := new(SyncUserBaseResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/SyncUserSta", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) SyncUserBases(ctx context.Context, in *SyncMidsRequset, opts ...grpc.CallOption) (*SyncUserBaseResponse, error) {
	out := new(SyncUserBaseResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/SyncUserBases", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) SyncUserStas(ctx context.Context, in *SyncMidsRequset, opts ...grpc.CallOption) (*SyncUserBaseResponse, error) {
	out := new(SyncUserBaseResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/SyncUserStas", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) CreateID(ctx context.Context, in *CreateIDRequest, opts ...grpc.CallOption) (*CreateIDResponse, error) {
	out := new(CreateIDResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/CreateID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) BVCTransCommit(ctx context.Context, in *BVideoTransRequset, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/BVCTransCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) ListVideoInfo(ctx context.Context, in *ListVideoInfoRequest, opts ...grpc.CallOption) (*ListVideoInfoResponse, error) {
	out := new(ListVideoInfoResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/ListVideoInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) ModifyLimits(ctx context.Context, in *ModifyLimitsRequest, opts ...grpc.CallOption) (*ModifyLimitsResponse, error) {
	out := new(ModifyLimitsResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/ModifyLimits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) PreUpload(ctx context.Context, in *PreUploadRequest, opts ...grpc.CallOption) (*PreUploadResponse, error) {
	out := new(PreUploadResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/PreUpload", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) CallBack(ctx context.Context, in *CallBackRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/CallBack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) VideoUnshelf(ctx context.Context, in *VideoUnshelfRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/VideoUnshelf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) VideoDelete(ctx context.Context, in *VideoDeleteRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/VideoDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) ListPrepareVideo(ctx context.Context, in *PrepareVideoRequest, opts ...grpc.CallOption) (*PrepareVideoResponse, error) {
	out := new(PrepareVideoResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/ListPrepareVideo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) HomeImgCreate(ctx context.Context, in *HomeImgCreateRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/HomeImgCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoClient) PlayInfo(ctx context.Context, in *PlayInfoRequest, opts ...grpc.CallOption) (*PlayInfoResponse, error) {
	out := new(PlayInfoResponse)
	err := grpc.Invoke(ctx, "/bbq.service.video.v1.Video/PlayInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Video service

type VideoServer interface {
	ImportVideo(context.Context, *ImportVideoInfo) (*google_protobuf1.Empty, error)
	SyncTag(context.Context, *SyncVideoTagRequest) (*google_protobuf1.Empty, error)
	SvStatisticsInfo(context.Context, *SvStatisticsInfoReq) (*SvStatisticsInfoRes, error)
	SyncUserBase(context.Context, *SyncMidRequset) (*SyncUserBaseResponse, error)
	SyncUserSta(context.Context, *SyncMidRequset) (*SyncUserBaseResponse, error)
	SyncUserBases(context.Context, *SyncMidsRequset) (*SyncUserBaseResponse, error)
	SyncUserStas(context.Context, *SyncMidsRequset) (*SyncUserBaseResponse, error)
	CreateID(context.Context, *CreateIDRequest) (*CreateIDResponse, error)
	BVCTransCommit(context.Context, *BVideoTransRequset) (*google_protobuf1.Empty, error)
	ListVideoInfo(context.Context, *ListVideoInfoRequest) (*ListVideoInfoResponse, error)
	ModifyLimits(context.Context, *ModifyLimitsRequest) (*ModifyLimitsResponse, error)
	PreUpload(context.Context, *PreUploadRequest) (*PreUploadResponse, error)
	CallBack(context.Context, *CallBackRequest) (*google_protobuf1.Empty, error)
	VideoUnshelf(context.Context, *VideoUnshelfRequest) (*google_protobuf1.Empty, error)
	VideoDelete(context.Context, *VideoDeleteRequest) (*google_protobuf1.Empty, error)
	ListPrepareVideo(context.Context, *PrepareVideoRequest) (*PrepareVideoResponse, error)
	HomeImgCreate(context.Context, *HomeImgCreateRequest) (*google_protobuf1.Empty, error)
	PlayInfo(context.Context, *PlayInfoRequest) (*PlayInfoResponse, error)
}

func RegisterVideoServer(s *grpc.Server, srv VideoServer) {
	s.RegisterService(&_Video_serviceDesc, srv)
}

func _Video_ImportVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportVideoInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).ImportVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/ImportVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).ImportVideo(ctx, req.(*ImportVideoInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_SyncTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncVideoTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).SyncTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/SyncTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).SyncTag(ctx, req.(*SyncVideoTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_SvStatisticsInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SvStatisticsInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).SvStatisticsInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/SvStatisticsInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).SvStatisticsInfo(ctx, req.(*SvStatisticsInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_SyncUserBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMidRequset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).SyncUserBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/SyncUserBase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).SyncUserBase(ctx, req.(*SyncMidRequset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_SyncUserSta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMidRequset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).SyncUserSta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/SyncUserSta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).SyncUserSta(ctx, req.(*SyncMidRequset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_SyncUserBases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMidsRequset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).SyncUserBases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/SyncUserBases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).SyncUserBases(ctx, req.(*SyncMidsRequset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_SyncUserStas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMidsRequset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).SyncUserStas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/SyncUserStas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).SyncUserStas(ctx, req.(*SyncMidsRequset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_CreateID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).CreateID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/CreateID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).CreateID(ctx, req.(*CreateIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_BVCTransCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BVideoTransRequset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).BVCTransCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/BVCTransCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).BVCTransCommit(ctx, req.(*BVideoTransRequset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_ListVideoInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVideoInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).ListVideoInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/ListVideoInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).ListVideoInfo(ctx, req.(*ListVideoInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_ModifyLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).ModifyLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/ModifyLimits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).ModifyLimits(ctx, req.(*ModifyLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_PreUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).PreUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/PreUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).PreUpload(ctx, req.(*PreUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_CallBack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallBackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).CallBack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/CallBack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).CallBack(ctx, req.(*CallBackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_VideoUnshelf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoUnshelfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).VideoUnshelf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/VideoUnshelf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).VideoUnshelf(ctx, req.(*VideoUnshelfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_VideoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).VideoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/VideoDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).VideoDelete(ctx, req.(*VideoDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_ListPrepareVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareVideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).ListPrepareVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/ListPrepareVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).ListPrepareVideo(ctx, req.(*PrepareVideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_HomeImgCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HomeImgCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).HomeImgCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/HomeImgCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).HomeImgCreate(ctx, req.(*HomeImgCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Video_PlayInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServer).PlayInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.video.v1.Video/PlayInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServer).PlayInfo(ctx, req.(*PlayInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Video_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bbq.service.video.v1.Video",
	HandlerType: (*VideoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportVideo",
			Handler:    _Video_ImportVideo_Handler,
		},
		{
			MethodName: "SyncTag",
			Handler:    _Video_SyncTag_Handler,
		},
		{
			MethodName: "SvStatisticsInfo",
			Handler:    _Video_SvStatisticsInfo_Handler,
		},
		{
			MethodName: "SyncUserBase",
			Handler:    _Video_SyncUserBase_Handler,
		},
		{
			MethodName: "SyncUserSta",
			Handler:    _Video_SyncUserSta_Handler,
		},
		{
			MethodName: "SyncUserBases",
			Handler:    _Video_SyncUserBases_Handler,
		},
		{
			MethodName: "SyncUserStas",
			Handler:    _Video_SyncUserStas_Handler,
		},
		{
			MethodName: "CreateID",
			Handler:    _Video_CreateID_Handler,
		},
		{
			MethodName: "BVCTransCommit",
			Handler:    _Video_BVCTransCommit_Handler,
		},
		{
			MethodName: "ListVideoInfo",
			Handler:    _Video_ListVideoInfo_Handler,
		},
		{
			MethodName: "ModifyLimits",
			Handler:    _Video_ModifyLimits_Handler,
		},
		{
			MethodName: "PreUpload",
			Handler:    _Video_PreUpload_Handler,
		},
		{
			MethodName: "CallBack",
			Handler:    _Video_CallBack_Handler,
		},
		{
			MethodName: "VideoUnshelf",
			Handler:    _Video_VideoUnshelf_Handler,
		},
		{
			MethodName: "VideoDelete",
			Handler:    _Video_VideoDelete_Handler,
		},
		{
			MethodName: "ListPrepareVideo",
			Handler:    _Video_ListPrepareVideo_Handler,
		},
		{
			MethodName: "HomeImgCreate",
			Handler:    _Video_HomeImgCreate_Handler,
		},
		{
			MethodName: "PlayInfo",
			Handler:    _Video_PlayInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/bbq/video/api/grpc/v1/api.proto",
}

func (m *ImportVideoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportVideoInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AVID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AVID))
	}
	if m.CID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CID))
	}
	if m.MID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MID))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Original != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Original))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Duration))
	}
	if m.State != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State))
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.Pubtime) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Pubtime)))
		i += copy(dAtA[i:], m.Pubtime)
	}
	if m.TID != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TID))
	}
	if m.SubTID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SubTID))
	}
	if m.IsFullScreen != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IsFullScreen))
	}
	if len(m.CoverUrl) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CoverUrl)))
		i += copy(dAtA[i:], m.CoverUrl)
	}
	if m.CoverWidth != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CoverWidth))
	}
	if m.CoverHeight != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CoverHeight))
	}
	if m.From != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.From))
	}
	if m.Svid != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if len(m.HomeImgUrl) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HomeImgUrl)))
		i += copy(dAtA[i:], m.HomeImgUrl)
	}
	if m.HomeImgWidth != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HomeImgWidth))
	}
	if m.HomeImgHeight != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HomeImgHeight))
	}
	return i, nil
}

func (m *VideoBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Avid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Avid))
	}
	if m.Cid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
	}
	if m.Mid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Original != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Original))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Duration))
	}
	if m.State != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State))
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if m.Pubtime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pubtime))
	}
	if m.Tid != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
	}
	if m.SubTid != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SubTid))
	}
	if m.IsFullScreen != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IsFullScreen))
	}
	if len(m.CoverUrl) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CoverUrl)))
		i += copy(dAtA[i:], m.CoverUrl)
	}
	if m.CoverWidth != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CoverWidth))
	}
	if m.CoverHeight != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CoverHeight))
	}
	if m.From != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.From))
	}
	if m.Svid != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.Limits != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Limits))
	}
	return i, nil
}

func (m *SyncVideoTagRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncVideoTagRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TagInfos) > 0 {
		for _, msg := range m.TagInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TagInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TagType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagType))
	}
	if len(m.TagName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TagName)))
		i += copy(dAtA[i:], m.TagName)
	}
	return i, nil
}

func (m *SvStatisticsInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SvStatisticsInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SvidList) > 0 {
		dAtA2 := make([]byte, len(m.SvidList)*10)
		var j1 int
		for _, num1 := range m.SvidList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *SvStatisticsInfoRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SvStatisticsInfoRes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SvstInfoMap) > 0 {
		for k, _ := range m.SvstInfoMap {
			dAtA[i] = 0xa
			i++
			v := m.SvstInfoMap[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *SvStInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SvStInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.Play != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Play))
	}
	if m.Subtitles != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Subtitles))
	}
	if m.Like != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Like))
	}
	if m.Share != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Share))
	}
	if m.Report != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Report))
	}
	if m.Reply != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Reply))
	}
	return i, nil
}

func (m *SyncMidRequset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncMidRequset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MID))
	}
	return i, nil
}

func (m *SyncUserBaseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncUserBaseResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Affc != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Affc))
	}
	return i, nil
}

func (m *SyncMidsRequset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncMidsRequset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MIDS) > 0 {
		dAtA5 := make([]byte, len(m.MIDS)*10)
		var j4 int
		for _, num1 := range m.MIDS {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *BVideoTransRequset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BVideoTransRequset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SVID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SVID))
	}
	if m.CID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CID))
	}
	return i, nil
}

func (m *BVCTransBackRequset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BVCTransBackRequset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FlowID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FlowID)))
		i += copy(dAtA[i:], m.FlowID)
	}
	if m.FlowType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FlowType))
	}
	if m.SVID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SVID))
	}
	if len(m.TransRes) > 0 {
		for _, msg := range m.TransRes {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PIC != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PIC.Size()))
		n6, err := m.PIC.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *SvPic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SvPic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PicURL) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PicURL)))
		i += copy(dAtA[i:], m.PicURL)
	}
	if m.PicWidth != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PicWidth))
	}
	if m.PicHeight != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PicHeight))
	}
	return i, nil
}

func (m *BVCTransInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BVCTransInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.PPI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PPI)))
		i += copy(dAtA[i:], m.PPI)
	}
	if len(m.BPS) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.BPS)))
		i += copy(dAtA[i:], m.BPS)
	}
	if len(m.VideoCode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.VideoCode)))
		i += copy(dAtA[i:], m.VideoCode)
	}
	if m.Filesize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Filesize))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *CreateIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIDRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Time))
	}
	return i, nil
}

func (m *CreateIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIDResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NewId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NewId))
	}
	return i, nil
}

func (m *VideoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VideoBase != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VideoBase.Size()))
		n7, err := m.VideoBase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *ListVideoInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVideoInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SvIDs) > 0 {
		dAtA9 := make([]byte, len(m.SvIDs)*10)
		var j8 int
		for _, num1 := range m.SvIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	return i, nil
}

func (m *ListVideoInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVideoInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ModifyLimitsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyLimitsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.LimitType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LimitType))
	}
	if m.LimitOp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LimitOp))
	}
	return i, nil
}

func (m *ModifyLimitsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyLimitsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PreUploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreUploadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Topic) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if m.From != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.From))
	}
	if len(m.FileExt) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FileExt)))
		i += copy(dAtA[i:], m.FileExt)
	}
	if len(m.Entension) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Entension)))
		i += copy(dAtA[i:], m.Entension)
	}
	return i, nil
}

func (m *PreUploadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreUploadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if len(m.UposUri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.UposUri)))
		i += copy(dAtA[i:], m.UposUri)
	}
	if len(m.EndPoint) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.EndPoint)))
		i += copy(dAtA[i:], m.EndPoint)
	}
	if len(m.EndPoints) > 0 {
		for _, s := range m.EndPoints {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Auth) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Auth)))
		i += copy(dAtA[i:], m.Auth)
	}
	return i, nil
}

func (m *CallBackRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallBackRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	return i, nil
}

func (m *VideoUnshelfRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoUnshelfRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	return i, nil
}

func (m *VideoDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.UpMid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UpMid))
	}
	return i, nil
}

func (m *UploadingVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadingVideo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.UploadStatus != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UploadStatus))
	}
	if m.RetryTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RetryTime))
	}
	if len(m.HomeImgUrl) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.HomeImgUrl)))
		i += copy(dAtA[i:], m.HomeImgUrl)
	}
	if m.HomeImgHeight != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HomeImgHeight))
	}
	if m.HomeImgWidth != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HomeImgWidth))
	}
	return i, nil
}

func (m *PrepareVideoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareVideoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	return i, nil
}

func (m *PrepareVideoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareVideoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HomeImgCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HomeImgCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Width != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Width))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.Height != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Height))
	}
	return i, nil
}

func (m *PlayInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Svid) > 0 {
		dAtA11 := make([]byte, len(m.Svid)*10)
		var j10 int
		for _, num1 := range m.Svid {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *PlayInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for k, _ := range m.List {
			dAtA[i] = 0xa
			i++
			v := m.List[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	return i, nil
}

func (m *PlayInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.ExpireTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ExpireTime))
	}
	if m.Quality != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Quality))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.CurrentTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CurrentTime))
	}
	if len(m.FileInfo) > 0 {
		for _, msg := range m.FileInfo {
			dAtA[i] = 0x32
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SupportQuality) > 0 {
		dAtA14 := make([]byte, len(m.SupportQuality)*10)
		var j13 int
		for _, num1 := range m.SupportQuality {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ahead) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ahead)))
		i += copy(dAtA[i:], m.Ahead)
	}
	if m.Filesize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Filesize))
	}
	if m.Timelength != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Timelength))
	}
	if len(m.Vhead) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Vhead)))
		i += copy(dAtA[i:], m.Vhead)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.UrlBc) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.UrlBc)))
		i += copy(dAtA[i:], m.UrlBc)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ImportVideoInfo) Size() (n int) {
	var l int
	_ = l
	if m.AVID != 0 {
		n += 1 + sovApi(uint64(m.AVID))
	}
	if m.CID != 0 {
		n += 1 + sovApi(uint64(m.CID))
	}
	if m.MID != 0 {
		n += 1 + sovApi(uint64(m.MID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Original != 0 {
		n += 1 + sovApi(uint64(m.Original))
	}
	if m.Duration != 0 {
		n += 1 + sovApi(uint64(m.Duration))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Pubtime)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TID != 0 {
		n += 1 + sovApi(uint64(m.TID))
	}
	if m.SubTID != 0 {
		n += 1 + sovApi(uint64(m.SubTID))
	}
	if m.IsFullScreen != 0 {
		n += 1 + sovApi(uint64(m.IsFullScreen))
	}
	l = len(m.CoverUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CoverWidth != 0 {
		n += 1 + sovApi(uint64(m.CoverWidth))
	}
	if m.CoverHeight != 0 {
		n += 2 + sovApi(uint64(m.CoverHeight))
	}
	if m.From != 0 {
		n += 2 + sovApi(uint64(m.From))
	}
	if m.Svid != 0 {
		n += 2 + sovApi(uint64(m.Svid))
	}
	l = len(m.HomeImgUrl)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.HomeImgWidth != 0 {
		n += 2 + sovApi(uint64(m.HomeImgWidth))
	}
	if m.HomeImgHeight != 0 {
		n += 2 + sovApi(uint64(m.HomeImgHeight))
	}
	return n
}

func (m *VideoBase) Size() (n int) {
	var l int
	_ = l
	if m.Avid != 0 {
		n += 1 + sovApi(uint64(m.Avid))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Original != 0 {
		n += 1 + sovApi(uint64(m.Original))
	}
	if m.Duration != 0 {
		n += 1 + sovApi(uint64(m.Duration))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Pubtime != 0 {
		n += 1 + sovApi(uint64(m.Pubtime))
	}
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	if m.SubTid != 0 {
		n += 1 + sovApi(uint64(m.SubTid))
	}
	if m.IsFullScreen != 0 {
		n += 1 + sovApi(uint64(m.IsFullScreen))
	}
	l = len(m.CoverUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CoverWidth != 0 {
		n += 1 + sovApi(uint64(m.CoverWidth))
	}
	if m.CoverHeight != 0 {
		n += 2 + sovApi(uint64(m.CoverHeight))
	}
	if m.From != 0 {
		n += 2 + sovApi(uint64(m.From))
	}
	if m.Svid != 0 {
		n += 2 + sovApi(uint64(m.Svid))
	}
	if m.Limits != 0 {
		n += 2 + sovApi(uint64(m.Limits))
	}
	return n
}

func (m *SyncVideoTagRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.TagInfos) > 0 {
		for _, e := range m.TagInfos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *TagInfo) Size() (n int) {
	var l int
	_ = l
	if m.TagType != 0 {
		n += 1 + sovApi(uint64(m.TagType))
	}
	l = len(m.TagName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SvStatisticsInfoReq) Size() (n int) {
	var l int
	_ = l
	if len(m.SvidList) > 0 {
		l = 0
		for _, e := range m.SvidList {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func (m *SvStatisticsInfoRes) Size() (n int) {
	var l int
	_ = l
	if len(m.SvstInfoMap) > 0 {
		for k, v := range m.SvstInfoMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SvStInfo) Size() (n int) {
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.Play != 0 {
		n += 1 + sovApi(uint64(m.Play))
	}
	if m.Subtitles != 0 {
		n += 1 + sovApi(uint64(m.Subtitles))
	}
	if m.Like != 0 {
		n += 1 + sovApi(uint64(m.Like))
	}
	if m.Share != 0 {
		n += 1 + sovApi(uint64(m.Share))
	}
	if m.Report != 0 {
		n += 1 + sovApi(uint64(m.Report))
	}
	if m.Reply != 0 {
		n += 1 + sovApi(uint64(m.Reply))
	}
	return n
}

func (m *SyncMidRequset) Size() (n int) {
	var l int
	_ = l
	if m.MID != 0 {
		n += 1 + sovApi(uint64(m.MID))
	}
	return n
}

func (m *SyncUserBaseResponse) Size() (n int) {
	var l int
	_ = l
	if m.Affc != 0 {
		n += 1 + sovApi(uint64(m.Affc))
	}
	return n
}

func (m *SyncMidsRequset) Size() (n int) {
	var l int
	_ = l
	if len(m.MIDS) > 0 {
		l = 0
		for _, e := range m.MIDS {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func (m *BVideoTransRequset) Size() (n int) {
	var l int
	_ = l
	if m.SVID != 0 {
		n += 1 + sovApi(uint64(m.SVID))
	}
	if m.CID != 0 {
		n += 1 + sovApi(uint64(m.CID))
	}
	return n
}

func (m *BVCTransBackRequset) Size() (n int) {
	var l int
	_ = l
	l = len(m.FlowID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.FlowType != 0 {
		n += 1 + sovApi(uint64(m.FlowType))
	}
	if m.SVID != 0 {
		n += 1 + sovApi(uint64(m.SVID))
	}
	if len(m.TransRes) > 0 {
		for _, e := range m.TransRes {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.PIC != nil {
		l = m.PIC.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SvPic) Size() (n int) {
	var l int
	_ = l
	l = len(m.PicURL)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PicWidth != 0 {
		n += 1 + sovApi(uint64(m.PicWidth))
	}
	if m.PicHeight != 0 {
		n += 1 + sovApi(uint64(m.PicHeight))
	}
	return n
}

func (m *BVCTransInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PPI)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.BPS)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.VideoCode)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Filesize != 0 {
		n += 1 + sovApi(uint64(m.Filesize))
	}
	if m.Duration != 0 {
		n += 1 + sovApi(uint64(m.Duration))
	}
	return n
}

func (m *CreateIDRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Time != 0 {
		n += 1 + sovApi(uint64(m.Time))
	}
	return n
}

func (m *CreateIDResponse) Size() (n int) {
	var l int
	_ = l
	if m.NewId != 0 {
		n += 1 + sovApi(uint64(m.NewId))
	}
	return n
}

func (m *VideoInfo) Size() (n int) {
	var l int
	_ = l
	if m.VideoBase != nil {
		l = m.VideoBase.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListVideoInfoRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.SvIDs) > 0 {
		l = 0
		for _, e := range m.SvIDs {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func (m *ListVideoInfoResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ModifyLimitsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.LimitType != 0 {
		n += 1 + sovApi(uint64(m.LimitType))
	}
	if m.LimitOp != 0 {
		n += 1 + sovApi(uint64(m.LimitOp))
	}
	return n
}

func (m *ModifyLimitsResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PreUploadRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovApi(uint64(m.From))
	}
	l = len(m.FileExt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Entension)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *PreUploadResponse) Size() (n int) {
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	l = len(m.UposUri)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.EndPoint)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.EndPoints) > 0 {
		for _, s := range m.EndPoints {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Auth)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CallBackRequest) Size() (n int) {
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	return n
}

func (m *VideoUnshelfRequest) Size() (n int) {
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	return n
}

func (m *VideoDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.UpMid != 0 {
		n += 1 + sovApi(uint64(m.UpMid))
	}
	return n
}

func (m *UploadingVideo) Size() (n int) {
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UploadStatus != 0 {
		n += 1 + sovApi(uint64(m.UploadStatus))
	}
	if m.RetryTime != 0 {
		n += 1 + sovApi(uint64(m.RetryTime))
	}
	l = len(m.HomeImgUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.HomeImgHeight != 0 {
		n += 1 + sovApi(uint64(m.HomeImgHeight))
	}
	if m.HomeImgWidth != 0 {
		n += 1 + sovApi(uint64(m.HomeImgWidth))
	}
	return n
}

func (m *PrepareVideoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	return n
}

func (m *PrepareVideoResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *HomeImgCreateRequest) Size() (n int) {
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Width != 0 {
		n += 1 + sovApi(uint64(m.Width))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovApi(uint64(m.Height))
	}
	return n
}

func (m *PlayInfoRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Svid) > 0 {
		l = 0
		for _, e := range m.Svid {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func (m *PlayInfoResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for k, v := range m.List {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PlayInfo) Size() (n int) {
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.ExpireTime != 0 {
		n += 1 + sovApi(uint64(m.ExpireTime))
	}
	if m.Quality != 0 {
		n += 1 + sovApi(uint64(m.Quality))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CurrentTime != 0 {
		n += 1 + sovApi(uint64(m.CurrentTime))
	}
	if len(m.FileInfo) > 0 {
		for _, e := range m.FileInfo {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.SupportQuality) > 0 {
		l = 0
		for _, e := range m.SupportQuality {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ahead)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Filesize != 0 {
		n += 1 + sovApi(uint64(m.Filesize))
	}
	if m.Timelength != 0 {
		n += 1 + sovApi(uint64(m.Timelength))
	}
	l = len(m.Vhead)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.UrlBc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ImportVideoInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImportVideoInfo{`,
		`AVID:` + fmt.Sprintf("%v", this.AVID) + `,`,
		`CID:` + fmt.Sprintf("%v", this.CID) + `,`,
		`MID:` + fmt.Sprintf("%v", this.MID) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`Original:` + fmt.Sprintf("%v", this.Original) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Tag:` + fmt.Sprintf("%v", this.Tag) + `,`,
		`Pubtime:` + fmt.Sprintf("%v", this.Pubtime) + `,`,
		`TID:` + fmt.Sprintf("%v", this.TID) + `,`,
		`SubTID:` + fmt.Sprintf("%v", this.SubTID) + `,`,
		`IsFullScreen:` + fmt.Sprintf("%v", this.IsFullScreen) + `,`,
		`CoverUrl:` + fmt.Sprintf("%v", this.CoverUrl) + `,`,
		`CoverWidth:` + fmt.Sprintf("%v", this.CoverWidth) + `,`,
		`CoverHeight:` + fmt.Sprintf("%v", this.CoverHeight) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`HomeImgUrl:` + fmt.Sprintf("%v", this.HomeImgUrl) + `,`,
		`HomeImgWidth:` + fmt.Sprintf("%v", this.HomeImgWidth) + `,`,
		`HomeImgHeight:` + fmt.Sprintf("%v", this.HomeImgHeight) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoBase) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoBase{`,
		`Avid:` + fmt.Sprintf("%v", this.Avid) + `,`,
		`Cid:` + fmt.Sprintf("%v", this.Cid) + `,`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`Original:` + fmt.Sprintf("%v", this.Original) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Tag:` + fmt.Sprintf("%v", this.Tag) + `,`,
		`Pubtime:` + fmt.Sprintf("%v", this.Pubtime) + `,`,
		`Tid:` + fmt.Sprintf("%v", this.Tid) + `,`,
		`SubTid:` + fmt.Sprintf("%v", this.SubTid) + `,`,
		`IsFullScreen:` + fmt.Sprintf("%v", this.IsFullScreen) + `,`,
		`CoverUrl:` + fmt.Sprintf("%v", this.CoverUrl) + `,`,
		`CoverWidth:` + fmt.Sprintf("%v", this.CoverWidth) + `,`,
		`CoverHeight:` + fmt.Sprintf("%v", this.CoverHeight) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`Limits:` + fmt.Sprintf("%v", this.Limits) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncVideoTagRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SyncVideoTagRequest{`,
		`TagInfos:` + strings.Replace(fmt.Sprintf("%v", this.TagInfos), "TagInfo", "TagInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TagInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TagInfo{`,
		`TagType:` + fmt.Sprintf("%v", this.TagType) + `,`,
		`TagName:` + fmt.Sprintf("%v", this.TagName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SvStatisticsInfoReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SvStatisticsInfoReq{`,
		`SvidList:` + fmt.Sprintf("%v", this.SvidList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SvStatisticsInfoRes) String() string {
	if this == nil {
		return "nil"
	}
	keysForSvstInfoMap := make([]int64, 0, len(this.SvstInfoMap))
	for k, _ := range this.SvstInfoMap {
		keysForSvstInfoMap = append(keysForSvstInfoMap, k)
	}
	sortkeys.Int64s(keysForSvstInfoMap)
	mapStringForSvstInfoMap := "map[int64]*SvStInfo{"
	for _, k := range keysForSvstInfoMap {
		mapStringForSvstInfoMap += fmt.Sprintf("%v: %v,", k, this.SvstInfoMap[k])
	}
	mapStringForSvstInfoMap += "}"
	s := strings.Join([]string{`&SvStatisticsInfoRes{`,
		`SvstInfoMap:` + mapStringForSvstInfoMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *SvStInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SvStInfo{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`Play:` + fmt.Sprintf("%v", this.Play) + `,`,
		`Subtitles:` + fmt.Sprintf("%v", this.Subtitles) + `,`,
		`Like:` + fmt.Sprintf("%v", this.Like) + `,`,
		`Share:` + fmt.Sprintf("%v", this.Share) + `,`,
		`Report:` + fmt.Sprintf("%v", this.Report) + `,`,
		`Reply:` + fmt.Sprintf("%v", this.Reply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncMidRequset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SyncMidRequset{`,
		`MID:` + fmt.Sprintf("%v", this.MID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncUserBaseResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SyncUserBaseResponse{`,
		`Affc:` + fmt.Sprintf("%v", this.Affc) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncMidsRequset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SyncMidsRequset{`,
		`MIDS:` + fmt.Sprintf("%v", this.MIDS) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BVideoTransRequset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BVideoTransRequset{`,
		`SVID:` + fmt.Sprintf("%v", this.SVID) + `,`,
		`CID:` + fmt.Sprintf("%v", this.CID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BVCTransBackRequset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BVCTransBackRequset{`,
		`FlowID:` + fmt.Sprintf("%v", this.FlowID) + `,`,
		`FlowType:` + fmt.Sprintf("%v", this.FlowType) + `,`,
		`SVID:` + fmt.Sprintf("%v", this.SVID) + `,`,
		`TransRes:` + strings.Replace(fmt.Sprintf("%v", this.TransRes), "BVCTransInfo", "BVCTransInfo", 1) + `,`,
		`PIC:` + strings.Replace(fmt.Sprintf("%v", this.PIC), "SvPic", "SvPic", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SvPic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SvPic{`,
		`PicURL:` + fmt.Sprintf("%v", this.PicURL) + `,`,
		`PicWidth:` + fmt.Sprintf("%v", this.PicWidth) + `,`,
		`PicHeight:` + fmt.Sprintf("%v", this.PicHeight) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BVCTransInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BVCTransInfo{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`PPI:` + fmt.Sprintf("%v", this.PPI) + `,`,
		`BPS:` + fmt.Sprintf("%v", this.BPS) + `,`,
		`VideoCode:` + fmt.Sprintf("%v", this.VideoCode) + `,`,
		`Filesize:` + fmt.Sprintf("%v", this.Filesize) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateIDRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateIDRequest{`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`Time:` + fmt.Sprintf("%v", this.Time) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateIDResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateIDResponse{`,
		`NewId:` + fmt.Sprintf("%v", this.NewId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoInfo{`,
		`VideoBase:` + strings.Replace(fmt.Sprintf("%v", this.VideoBase), "VideoBase", "VideoBase", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListVideoInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListVideoInfoRequest{`,
		`SvIDs:` + fmt.Sprintf("%v", this.SvIDs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListVideoInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListVideoInfoResponse{`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "VideoInfo", "VideoInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyLimitsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyLimitsRequest{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`LimitType:` + fmt.Sprintf("%v", this.LimitType) + `,`,
		`LimitOp:` + fmt.Sprintf("%v", this.LimitOp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ModifyLimitsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ModifyLimitsResponse{`,
		`}`,
	}, "")
	return s
}
func (this *PreUploadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PreUploadRequest{`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`FileExt:` + fmt.Sprintf("%v", this.FileExt) + `,`,
		`Entension:` + fmt.Sprintf("%v", this.Entension) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PreUploadResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PreUploadResponse{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`UposUri:` + fmt.Sprintf("%v", this.UposUri) + `,`,
		`EndPoint:` + fmt.Sprintf("%v", this.EndPoint) + `,`,
		`EndPoints:` + fmt.Sprintf("%v", this.EndPoints) + `,`,
		`Auth:` + fmt.Sprintf("%v", this.Auth) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CallBackRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CallBackRequest{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoUnshelfRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoUnshelfRequest{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoDeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoDeleteRequest{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`UpMid:` + fmt.Sprintf("%v", this.UpMid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadingVideo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadingVideo{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`UploadStatus:` + fmt.Sprintf("%v", this.UploadStatus) + `,`,
		`RetryTime:` + fmt.Sprintf("%v", this.RetryTime) + `,`,
		`HomeImgUrl:` + fmt.Sprintf("%v", this.HomeImgUrl) + `,`,
		`HomeImgHeight:` + fmt.Sprintf("%v", this.HomeImgHeight) + `,`,
		`HomeImgWidth:` + fmt.Sprintf("%v", this.HomeImgWidth) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrepareVideoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrepareVideoRequest{`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrepareVideoResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrepareVideoResponse{`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "UploadingVideo", "UploadingVideo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HomeImgCreateRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HomeImgCreateRequest{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayInfoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlayInfoRequest{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayInfoResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForList := make([]int64, 0, len(this.List))
	for k, _ := range this.List {
		keysForList = append(keysForList, k)
	}
	sortkeys.Int64s(keysForList)
	mapStringForList := "map[int64]*PlayInfo{"
	for _, k := range keysForList {
		mapStringForList += fmt.Sprintf("%v: %v,", k, this.List[k])
	}
	mapStringForList += "}"
	s := strings.Join([]string{`&PlayInfoResponse{`,
		`List:` + mapStringForList + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlayInfo{`,
		`Svid:` + fmt.Sprintf("%v", this.Svid) + `,`,
		`ExpireTime:` + fmt.Sprintf("%v", this.ExpireTime) + `,`,
		`Quality:` + fmt.Sprintf("%v", this.Quality) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`CurrentTime:` + fmt.Sprintf("%v", this.CurrentTime) + `,`,
		`FileInfo:` + strings.Replace(fmt.Sprintf("%v", this.FileInfo), "FileInfo", "FileInfo", 1) + `,`,
		`SupportQuality:` + fmt.Sprintf("%v", this.SupportQuality) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileInfo{`,
		`Ahead:` + fmt.Sprintf("%v", this.Ahead) + `,`,
		`Filesize:` + fmt.Sprintf("%v", this.Filesize) + `,`,
		`Timelength:` + fmt.Sprintf("%v", this.Timelength) + `,`,
		`Vhead:` + fmt.Sprintf("%v", this.Vhead) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`UrlBc:` + fmt.Sprintf("%v", this.UrlBc) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ImportVideoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportVideoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportVideoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AVID", wireType)
			}
			m.AVID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AVID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CID", wireType)
			}
			m.CID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MID", wireType)
			}
			m.MID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Original", wireType)
			}
			m.Original = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Original |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TID", wireType)
			}
			m.TID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTID", wireType)
			}
			m.SubTID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubTID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullScreen", wireType)
			}
			m.IsFullScreen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFullScreen |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverWidth", wireType)
			}
			m.CoverWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoverWidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverHeight", wireType)
			}
			m.CoverHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoverHeight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeImgWidth", wireType)
			}
			m.HomeImgWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeImgWidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeImgHeight", wireType)
			}
			m.HomeImgHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeImgHeight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avid", wireType)
			}
			m.Avid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Avid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Original", wireType)
			}
			m.Original = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Original |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubtime", wireType)
			}
			m.Pubtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pubtime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTid", wireType)
			}
			m.SubTid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubTid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFullScreen", wireType)
			}
			m.IsFullScreen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFullScreen |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverWidth", wireType)
			}
			m.CoverWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoverWidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverHeight", wireType)
			}
			m.CoverHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoverHeight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			m.Limits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limits |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncVideoTagRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncVideoTagRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncVideoTagRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagInfos = append(m.TagInfos, &TagInfo{})
			if err := m.TagInfos[len(m.TagInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagType", wireType)
			}
			m.TagType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SvStatisticsInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SvStatisticsInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SvStatisticsInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SvidList = append(m.SvidList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SvidList = append(m.SvidList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SvidList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SvStatisticsInfoRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SvStatisticsInfoRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SvStatisticsInfoRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SvstInfoMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SvstInfoMap == nil {
				m.SvstInfoMap = make(map[int64]*SvStInfo)
			}
			var mapkey int64
			var mapvalue *SvStInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SvStInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SvstInfoMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SvStInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SvStInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SvStInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Play", wireType)
			}
			m.Play = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Play |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitles", wireType)
			}
			m.Subtitles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtitles |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Like", wireType)
			}
			m.Like = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Like |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			m.Share = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Share |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			m.Report = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Report |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			m.Reply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reply |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncMidRequset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncMidRequset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncMidRequset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MID", wireType)
			}
			m.MID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncUserBaseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncUserBaseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncUserBaseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affc", wireType)
			}
			m.Affc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Affc |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncMidsRequset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncMidsRequset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncMidsRequset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MIDS = append(m.MIDS, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MIDS = append(m.MIDS, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MIDS", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BVideoTransRequset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BVideoTransRequset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BVideoTransRequset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SVID", wireType)
			}
			m.SVID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SVID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CID", wireType)
			}
			m.CID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BVCTransBackRequset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BVCTransBackRequset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BVCTransBackRequset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowType", wireType)
			}
			m.FlowType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowType |= (int8(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SVID", wireType)
			}
			m.SVID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SVID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransRes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransRes = append(m.TransRes, &BVCTransInfo{})
			if err := m.TransRes[len(m.TransRes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PIC == nil {
				m.PIC = &SvPic{}
			}
			if err := m.PIC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SvPic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SvPic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SvPic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PicURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicWidth", wireType)
			}
			m.PicWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicWidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicHeight", wireType)
			}
			m.PicHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicHeight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BVCTransInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BVCTransInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BVCTransInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PPI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PPI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BPS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filesize", wireType)
			}
			m.Filesize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filesize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewId", wireType)
			}
			m.NewId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoBase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VideoBase == nil {
				m.VideoBase = &VideoBase{}
			}
			if err := m.VideoBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVideoInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListVideoInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListVideoInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SvIDs = append(m.SvIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SvIDs = append(m.SvIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SvIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVideoInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListVideoInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListVideoInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &VideoInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyLimitsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyLimitsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyLimitsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitType", wireType)
			}
			m.LimitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitType |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitOp", wireType)
			}
			m.LimitOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitOp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyLimitsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyLimitsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyLimitsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreUploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreUploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreUploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileExt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileExt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entension", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entension = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreUploadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreUploadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreUploadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UposUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UposUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndPoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPoints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndPoints = append(m.EndPoints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallBackRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallBackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallBackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoUnshelfRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoUnshelfRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoUnshelfRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpMid", wireType)
			}
			m.UpMid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpMid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadingVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadingVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadingVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadStatus", wireType)
			}
			m.UploadStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryTime", wireType)
			}
			m.RetryTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeImgHeight", wireType)
			}
			m.HomeImgHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeImgHeight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeImgWidth", wireType)
			}
			m.HomeImgWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomeImgWidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareVideoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareVideoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareVideoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareVideoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareVideoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareVideoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &UploadingVideo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HomeImgCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HomeImgCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HomeImgCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Svid = append(m.Svid, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Svid = append(m.Svid, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = make(map[int64]*PlayInfo)
			}
			var mapkey int64
			var mapvalue *PlayInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PlayInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.List[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTime", wireType)
			}
			m.CurrentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileInfo = append(m.FileInfo, &FileInfo{})
			if err := m.FileInfo[len(m.FileInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportQuality = append(m.SupportQuality, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportQuality = append(m.SupportQuality, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportQuality", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ahead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ahead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filesize", wireType)
			}
			m.Filesize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filesize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timelength", wireType)
			}
			m.Timelength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timelength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vhead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vhead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlBc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlBc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app/service/bbq/video/api/grpc/v1/api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 3186 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x4d, 0x73, 0x1b, 0xc7,
	0xd1, 0x36, 0x08, 0x10, 0x04, 0x9a, 0x9f, 0x5e, 0x52, 0x32, 0x4c, 0x49, 0x5c, 0x79, 0x25, 0xbd,
	0x92, 0x5e, 0x45, 0xa0, 0x2c, 0x39, 0xb6, 0x4a, 0x72, 0x22, 0x07, 0x94, 0x65, 0xd3, 0x25, 0xc9,
	0xd4, 0x92, 0x94, 0xcb, 0xf9, 0x82, 0x17, 0xc0, 0x00, 0x9c, 0xf2, 0x02, 0xbb, 0xda, 0x1d, 0x40,
	0xa6, 0x4f, 0x71, 0x0e, 0xa9, 0xf2, 0x29, 0xc7, 0x1c, 0x72, 0xcc, 0x39, 0xbf, 0x20, 0x7f, 0xc0,
	0xc7, 0xe4, 0x14, 0xe7, 0xb2, 0x89, 0x79, 0x0b, 0x8f, 0x38, 0xfa, 0x92, 0x54, 0xf7, 0xcc, 0xec,
	0x2e, 0x40, 0x2c, 0x2d, 0xdb, 0x71, 0x55, 0x52, 0xe5, 0x13, 0x76, 0x9e, 0xe9, 0xee, 0x99, 0xe9,
	0xee, 0xe9, 0xe9, 0xee, 0x02, 0x5c, 0x71, 0x7c, 0x7f, 0x3d, 0x64, 0xc1, 0x80, 0x37, 0xd9, 0x7a,
	0xa3, 0xf1, 0x64, 0x7d, 0xc0, 0x5b, 0xcc, 0x5b, 0x77, 0x7c, 0xbe, 0xde, 0x09, 0xfc, 0xe6, 0xfa,
	0xe0, 0x65, 0xfc, 0xae, 0xfa, 0x81, 0x27, 0x3c, 0x63, 0xa5, 0xd1, 0x78, 0x52, 0x55, 0xc4, 0x55,
	0x22, 0xac, 0x0e, 0x5e, 0x5e, 0xbd, 0xda, 0xe1, 0x62, 0xaf, 0xdf, 0xa8, 0x36, 0xbd, 0xee, 0x7a,
	0xc7, 0xeb, 0x78, 0xeb, 0x44, 0xdc, 0xe8, 0xb7, 0x69, 0x44, 0x03, 0xfa, 0x92, 0x42, 0x56, 0x4f,
	0x75, 0x3c, 0xaf, 0xe3, 0xb2, 0x84, 0x8a, 0x75, 0x7d, 0xb1, 0x2f, 0x27, 0xad, 0xdf, 0x00, 0x2c,
	0x6e, 0x76, 0x7d, 0x2f, 0x10, 0x8f, 0x51, 0xfc, 0x66, 0xaf, 0xed, 0x19, 0x37, 0xa0, 0xe0, 0x0c,
	0x78, 0xab, 0x92, 0x3b, 0x9b, 0xbb, 0x94, 0xaf, 0x99, 0x07, 0x91, 0x59, 0xf8, 0xc9, 0xe3, 0xcd,
	0xbb, 0x87, 0x91, 0x49, 0xf8, 0x30, 0x32, 0x67, 0xdb, 0x5e, 0xd0, 0xbd, 0x65, 0xe1, 0xc8, 0xb2,
	0x09, 0x34, 0xd6, 0x21, 0xdf, 0xe4, 0xad, 0xca, 0x14, 0xf1, 0x9c, 0x39, 0x88, 0xcc, 0xfc, 0x06,
	0xb1, 0x20, 0x3a, 0xce, 0x81, 0x98, 0x51, 0x85, 0x7c, 0x97, 0xb7, 0x2a, 0x79, 0x62, 0x38, 0x8d,
	0x0c, 0x0f, 0x24, 0x43, 0x97, 0x18, 0x40, 0x32, 0x74, 0x89, 0xbe, 0x4b, 0x0b, 0x4c, 0x0b, 0x2e,
	0x5c, 0x56, 0x29, 0x9c, 0xcd, 0x5d, 0x2a, 0xd7, 0x5e, 0x3c, 0x8c, 0x4c, 0x09, 0x0c, 0x23, 0x73,
	0x4e, 0x12, 0xd3, 0xd0, 0xb2, 0x25, 0x6c, 0xbc, 0x06, 0x33, 0x4d, 0xaf, 0x27, 0x58, 0x4f, 0x54,
	0xa6, 0x89, 0xe5, 0xcc, 0x61, 0x64, 0x6a, 0x68, 0x18, 0x99, 0x0b, 0x92, 0x49, 0x01, 0x96, 0xad,
	0xa7, 0x8c, 0xdb, 0x50, 0xf2, 0x02, 0xde, 0xe1, 0x3d, 0xc7, 0xad, 0x14, 0xa5, 0x0e, 0x0e, 0x23,
	0x33, 0xc6, 0x86, 0x91, 0xb9, 0x28, 0x59, 0x35, 0x62, 0xd9, 0xf1, 0x24, 0x32, 0xb7, 0xfa, 0x81,
	0x23, 0xb8, 0xd7, 0xab, 0xcc, 0x24, 0xcc, 0x1a, 0x4b, 0x98, 0x35, 0x62, 0xd9, 0xf1, 0x24, 0x9e,
	0x31, 0x14, 0x8e, 0x60, 0x95, 0x12, 0x71, 0xd2, 0x19, 0x09, 0x48, 0xce, 0x48, 0x43, 0xcb, 0x96,
	0xb0, 0x71, 0x11, 0xf2, 0xc2, 0xe9, 0x54, 0xca, 0x74, 0xbe, 0x13, 0xa8, 0x3d, 0xe1, 0x74, 0x12,
	0xed, 0x09, 0xa7, 0x63, 0xd9, 0x08, 0xa1, 0x32, 0xfc, 0x7e, 0x43, 0xf0, 0x2e, 0xab, 0x40, 0xa2,
	0x0c, 0x05, 0x25, 0xca, 0x50, 0x80, 0x65, 0xeb, 0x29, 0x34, 0x93, 0xe0, 0xad, 0xca, 0x6c, 0x62,
	0xa6, 0x1d, 0x69, 0x26, 0x91, 0x36, 0x93, 0x20, 0x33, 0x09, 0xde, 0x32, 0xde, 0x80, 0x99, 0xb0,
	0xdf, 0xa8, 0x23, 0xcf, 0x1c, 0xf1, 0x5c, 0x3c, 0x88, 0xcc, 0xe2, 0x76, 0xbf, 0x21, 0xd9, 0xf4,
	0x64, 0xb2, 0xa4, 0x02, 0x2c, 0xbb, 0x18, 0xf6, 0x1b, 0x3b, 0xbc, 0x65, 0x3c, 0x82, 0x05, 0x1e,
	0xd6, 0xdb, 0x7d, 0xd7, 0xad, 0x87, 0xcd, 0x80, 0xb1, 0x5e, 0x65, 0x9e, 0x04, 0x5d, 0x39, 0x8c,
	0xcc, 0xb1, 0x99, 0x61, 0x64, 0x9e, 0x90, 0x52, 0x46, 0x71, 0xcb, 0x9e, 0xe3, 0xe1, 0xbd, 0xbe,
	0xeb, 0x6e, 0xd3, 0xd0, 0xf8, 0x31, 0x94, 0x9b, 0xde, 0x80, 0x05, 0xf5, 0x7e, 0xe0, 0x56, 0x16,
	0xe8, 0xfc, 0x2f, 0x1d, 0x46, 0x66, 0x02, 0x0e, 0x23, 0x73, 0x49, 0xbb, 0x83, 0x82, 0x2c, 0xbb,
	0x44, 0xdf, 0xbb, 0x81, 0x6b, 0xdc, 0x83, 0x59, 0x89, 0x3f, 0xe5, 0x2d, 0xb1, 0x57, 0x59, 0xa4,
	0xfd, 0x5c, 0x38, 0x8c, 0xcc, 0x34, 0x3c, 0x8c, 0x4c, 0x23, 0x2d, 0x83, 0x40, 0xcb, 0x06, 0x1a,
	0xbd, 0x87, 0x03, 0xe3, 0x1d, 0x98, 0x93, 0x73, 0x7b, 0x8c, 0x77, 0xf6, 0x44, 0x65, 0x49, 0x6a,
	0xe8, 0x30, 0x32, 0x47, 0xf0, 0x61, 0x64, 0x2e, 0xa7, 0x25, 0x49, 0xd4, 0xb2, 0xe5, 0x6a, 0x6f,
	0xd3, 0xc8, 0xb8, 0x02, 0x85, 0x76, 0xe0, 0x75, 0x2b, 0xcf, 0x93, 0x8c, 0x17, 0xf0, 0x76, 0xe2,
	0x38, 0xb9, 0x6b, 0x38, 0xb2, 0x6c, 0x02, 0x91, 0x38, 0xc4, 0x2b, 0x6d, 0x24, 0xc4, 0xe1, 0xc8,
	0x55, 0x0e, 0xe5, 0x55, 0xc6, 0x1f, 0x63, 0x13, 0xe6, 0xf6, 0xbc, 0x2e, 0xab, 0xf3, 0x6e, 0x87,
	0x14, 0xb6, 0x4c, 0x0a, 0xa3, 0x5d, 0xa6, 0xf1, 0x64, 0x97, 0x69, 0xd4, 0xb2, 0x01, 0x87, 0x9b,
	0xdd, 0x0e, 0x2a, 0xee, 0x11, 0x2c, 0xc4, 0x93, 0x52, 0x77, 0x2b, 0x89, 0x2d, 0x47, 0x67, 0x12,
	0x5b, 0x8e, 0xe2, 0x96, 0x3d, 0xa7, 0x04, 0x4a, 0x1d, 0xee, 0xc2, 0x62, 0x4c, 0xa0, 0xd4, 0x78,
	0x82, 0x64, 0x5e, 0x3d, 0x8c, 0xcc, 0xf1, 0xa9, 0x61, 0x64, 0x9e, 0x1c, 0x13, 0xaa, 0x95, 0x39,
	0xaf, 0xa4, 0x4a, 0x75, 0x5a, 0x7f, 0x28, 0x41, 0x99, 0x42, 0x60, 0xcd, 0x09, 0x19, 0xea, 0x2b,
	0x15, 0x02, 0x5f, 0x38, 0x3e, 0xf4, 0x5d, 0x4a, 0x87, 0xbe, 0x93, 0xc7, 0xc5, 0xbc, 0x8b, 0xe9,
	0x98, 0x77, 0xe2, 0xfb, 0x60, 0xf7, 0x1d, 0x05, 0x3b, 0x7b, 0x34, 0xd8, 0xe5, 0x6b, 0x37, 0x47,
	0x83, 0x5d, 0x8a, 0xe1, 0xcb, 0xc8, 0x3c, 0xd5, 0xf1, 0xae, 0x36, 0xbd, 0x6e, 0xd7, 0xeb, 0xad,
	0xbb, 0xbc, 0x11, 0x38, 0xc1, 0xfe, 0x3a, 0xd2, 0x55, 0x77, 0x78, 0x97, 0x25, 0x71, 0xf0, 0x62,
	0x3a, 0x0e, 0x9e, 0x38, 0x26, 0x00, 0xbe, 0x3a, 0x1e, 0x00, 0xcf, 0x7c, 0x1f, 0xf6, 0xfe, 0x27,
	0xc2, 0x9e, 0x05, 0x45, 0x97, 0x77, 0xb9, 0x08, 0x29, 0xe0, 0x15, 0x6a, 0x70, 0x18, 0x99, 0x0a,
	0xb1, 0xd5, 0xaf, 0x25, 0x60, 0x79, 0x7b, 0xbf, 0xd7, 0xa4, 0x40, 0xb1, 0xe3, 0x74, 0x6c, 0xf6,
	0xa4, 0xcf, 0x42, 0x61, 0xfc, 0x02, 0xca, 0xc2, 0xe9, 0xd4, 0x79, 0xaf, 0xed, 0x85, 0x95, 0xdc,
	0xd9, 0xfc, 0xa5, 0xd9, 0xeb, 0x67, 0xaa, 0x93, 0x72, 0xb7, 0xea, 0x8e, 0xd3, 0xc1, 0x1c, 0x4b,
	0xda, 0x21, 0xe6, 0x49, 0xec, 0x10, 0x43, 0x96, 0x5d, 0x12, 0x92, 0x36, 0xb4, 0x3e, 0xc9, 0xc1,
	0x8c, 0x62, 0x34, 0x6e, 0x01, 0xe2, 0x75, 0xb1, 0xef, 0x33, 0x8a, 0x4e, 0xd3, 0xf2, 0xca, 0x69,
	0x2c, 0xb9, 0x72, 0x1a, 0xb1, 0xec, 0x19, 0xe1, 0x74, 0x76, 0xf6, 0x7d, 0xa6, 0x79, 0x7b, 0x4e,
	0x97, 0x51, 0xb4, 0x2a, 0x27, 0xbc, 0x88, 0x8d, 0xf2, 0x22, 0x22, 0x79, 0x1f, 0xe2, 0xd7, 0x2e,
	0x2c, 0x6f, 0x0f, 0xb6, 0x85, 0x23, 0x78, 0x28, 0x78, 0x33, 0xc4, 0xbd, 0xd8, 0xec, 0x09, 0xba,
	0x18, 0x2a, 0xaf, 0xee, 0xf2, 0x50, 0xd0, 0xc9, 0xf3, 0xf2, 0x68, 0x31, 0x98, 0x1c, 0x2d, 0x86,
	0x2c, 0xbb, 0x84, 0xdf, 0xf7, 0xf1, 0xf3, 0x93, 0xa9, 0x49, 0x72, 0x43, 0xe3, 0xd3, 0x1c, 0xcc,
	0x87, 0x83, 0x50, 0x90, 0x32, 0xea, 0x5d, 0xc7, 0x57, 0x6a, 0xbd, 0x35, 0x59, 0xad, 0x13, 0x44,
	0x54, 0xb7, 0x07, 0xa1, 0xc0, 0xef, 0x07, 0x8e, 0xff, 0x66, 0x4f, 0x04, 0xfb, 0xb5, 0xcb, 0x87,
	0x91, 0x39, 0x2a, 0x74, 0x18, 0x99, 0x2b, 0x7a, 0x73, 0x29, 0xd8, 0xb2, 0x67, 0xc3, 0x84, 0x79,
	0xf5, 0x97, 0xb0, 0x34, 0x2e, 0xcb, 0x58, 0x82, 0xfc, 0x87, 0x6c, 0x5f, 0xbe, 0x0f, 0x36, 0x7e,
	0x1a, 0xaf, 0xc0, 0xf4, 0xc0, 0x71, 0xfb, 0x52, 0xb3, 0xb3, 0xd7, 0xd7, 0xb2, 0x37, 0x4a, 0x1b,
	0x94, 0xc4, 0xb7, 0xa6, 0x6e, 0xe6, 0xac, 0x7f, 0x4e, 0x41, 0x49, 0xe3, 0xb1, 0xcb, 0xe6, 0x9e,
	0xc5, 0x65, 0xaf, 0x40, 0xc1, 0x77, 0x9d, 0x7d, 0xf5, 0xf4, 0x10, 0x31, 0x8e, 0x13, 0x62, 0x1c,
	0x59, 0x36, 0x81, 0xc6, 0x1d, 0x28, 0x87, 0x18, 0xcc, 0x84, 0xcb, 0x42, 0xf5, 0x04, 0x49, 0x53,
	0x69, 0x30, 0x65, 0x2a, 0x0d, 0x59, 0x76, 0x32, 0x8d, 0xab, 0xb9, 0xfc, 0x43, 0xf9, 0x26, 0xa9,
	0xd5, 0x70, 0x9c, 0xac, 0x86, 0x23, 0xcb, 0x26, 0x90, 0xa2, 0xfb, 0x9e, 0x13, 0x30, 0x7a, 0x8e,
	0x74, 0x74, 0x47, 0x20, 0x15, 0xdd, 0x71, 0x88, 0xd1, 0x1d, 0x7f, 0x8d, 0x1b, 0x50, 0x0c, 0x18,
	0x16, 0x22, 0xea, 0x19, 0x3a, 0x85, 0xd7, 0x4f, 0x22, 0xc3, 0xc8, 0x9c, 0x97, 0x2c, 0x72, 0x6c,
	0xd9, 0x6a, 0x02, 0x57, 0x09, 0x98, 0xef, 0xee, 0xab, 0xd7, 0x87, 0x56, 0x21, 0x20, 0x59, 0x85,
	0x86, 0x96, 0x2d, 0x61, 0xeb, 0x0d, 0x58, 0xc0, 0x0b, 0xfc, 0x80, 0xb7, 0xf0, 0xee, 0x86, 0x4c,
	0xe8, 0x3a, 0x24, 0xf7, 0x8c, 0x75, 0x88, 0xb5, 0x01, 0x2b, 0x28, 0x61, 0x37, 0x64, 0x01, 0xa6,
	0x0a, 0x36, 0x0b, 0x7d, 0xaf, 0xa7, 0x52, 0x86, 0x76, 0xbb, 0x39, 0x92, 0x32, 0xb4, 0xdb, 0xcd,
	0x54, 0x1e, 0xd0, 0x6e, 0x37, 0x31, 0x65, 0xc0, 0x9f, 0x7b, 0xb0, 0xa8, 0xb6, 0x11, 0xea, 0x7d,
	0xdc, 0x80, 0x42, 0x97, 0xb7, 0x42, 0x75, 0x89, 0xa8, 0xea, 0x7a, 0xb0, 0x79, 0x77, 0x1b, 0xe5,
	0x20, 0x9e, 0xc8, 0xc1, 0x91, 0x65, 0x13, 0x68, 0xfd, 0x3e, 0x07, 0x46, 0x4d, 0x46, 0xa3, 0xc0,
	0xe9, 0xc5, 0xb2, 0xee, 0x8e, 0x38, 0xd1, 0x35, 0x94, 0xb5, 0xad, 0x2a, 0x38, 0xe5, 0x4c, 0xa7,
	0x53, 0xce, 0x74, 0x76, 0xe0, 0xb8, 0xbc, 0xe5, 0x08, 0x86, 0xb2, 0x7b, 0x3f, 0xba, 0xa6, 0xbd,
	0xeb, 0x4e, 0x3a, 0xaf, 0xb9, 0x7a, 0xa4, 0xa4, 0x3b, 0xa5, 0x62, 0xf5, 0x44, 0x09, 0x48, 0x63,
	0x7d, 0x9e, 0x87, 0xe5, 0xda, 0xe3, 0x0d, 0xda, 0x5a, 0xcd, 0x69, 0x7e, 0xa8, 0xb7, 0xf7, 0x08,
	0x66, 0xda, 0xae, 0xf7, 0xb4, 0xae, 0x76, 0x58, 0xae, 0xdd, 0xc4, 0x1a, 0xe1, 0x9e, 0xeb, 0x3d,
	0x95, 0x35, 0x82, 0x9a, 0x1c, 0x46, 0xa6, 0xa9, 0x62, 0xba, 0x04, 0x26, 0xac, 0x53, 0xc4, 0xa9,
	0xcd, 0x96, 0xd1, 0x84, 0x32, 0x11, 0x51, 0x5c, 0x94, 0x3b, 0xbe, 0x77, 0x10, 0x99, 0x25, 0x14,
	0x8a, 0xb1, 0x0f, 0x1d, 0x3d, 0x26, 0x18, 0x46, 0xe6, 0x4b, 0x29, 0xc1, 0x14, 0x25, 0x8f, 0x88,
	0xfe, 0x32, 0x32, 0x0b, 0xbc, 0x27, 0x6e, 0xda, 0xa5, 0xb6, 0x92, 0x11, 0xab, 0x35, 0xff, 0xad,
	0xd4, 0xda, 0x80, 0xb2, 0x40, 0x8d, 0xd4, 0x03, 0x16, 0x56, 0x0a, 0x14, 0xd5, 0xac, 0xc9, 0xc1,
	0x42, 0xeb, 0x2e, 0xf5, 0x62, 0x68, 0xc6, 0xd4, 0x8b, 0xa1, 0x21, 0x7c, 0x31, 0xa4, 0x13, 0x84,
	0x46, 0x1d, 0xf2, 0x3e, 0x6f, 0xd2, 0xdd, 0x9b, 0xbd, 0x7e, 0x2a, 0x2b, 0x14, 0x6d, 0xf1, 0x26,
	0x9d, 0x22, 0xbf, 0xb5, 0xb9, 0x81, 0x76, 0xf5, 0x39, 0xba, 0xeb, 0x9a, 0x0a, 0x1d, 0xbc, 0x99,
	0x3e, 0x42, 0xc0, 0x9e, 0xf4, 0x79, 0xc0, 0xf0, 0x16, 0xe0, 0xcc, 0xa7, 0x53, 0x30, 0x4d, 0x02,
	0x8c, 0x1d, 0x98, 0xf1, 0x79, 0x93, 0x52, 0x0c, 0x69, 0xcc, 0xdb, 0x68, 0xcc, 0x2d, 0xde, 0xdc,
	0xb5, 0xef, 0x53, 0xda, 0x25, 0x27, 0x87, 0x91, 0x69, 0xc5, 0x82, 0x29, 0xd1, 0x98, 0x28, 0xbc,
	0xe8, 0xf3, 0x26, 0xa6, 0x1e, 0x36, 0x94, 0x91, 0x4e, 0x26, 0x1e, 0xd2, 0x9e, 0x3f, 0x44, 0x05,
	0xc4, 0xe0, 0x30, 0x32, 0xcf, 0x27, 0xf2, 0x64, 0xd2, 0x31, 0x51, 0x62, 0xc9, 0xe7, 0x4d, 0x99,
	0x86, 0x3c, 0x06, 0x40, 0x5a, 0x95, 0x84, 0x48, 0x23, 0xbe, 0x76, 0x18, 0x99, 0x29, 0x74, 0x18,
	0x99, 0x17, 0x12, 0xa9, 0x2a, 0x01, 0x99, 0x28, 0x16, 0x77, 0xa2, 0x4a, 0x87, 0xbf, 0xe4, 0x61,
	0x2e, 0x6d, 0x2a, 0xe3, 0x0e, 0x14, 0x7c, 0x47, 0xed, 0xbb, 0x4c, 0x09, 0x1c, 0x8d, 0x13, 0x7f,
	0xc6, 0xd1, 0x64, 0xb1, 0x44, 0x68, 0xd4, 0x20, 0xef, 0xfb, 0x9c, 0xb6, 0x58, 0x56, 0x16, 0xda,
	0xda, 0x24, 0x0b, 0xf9, 0x3c, 0x65, 0x21, 0x9f, 0x67, 0x59, 0xc8, 0xe7, 0x28, 0xa3, 0xe1, 0x87,
	0xaa, 0x80, 0x20, 0x19, 0xb5, 0x2d, 0x8c, 0x26, 0x88, 0x26, 0x32, 0x1a, 0x7e, 0x98, 0x21, 0xa3,
	0xe1, 0x87, 0xa8, 0x31, 0x72, 0x97, 0x7a, 0xd3, 0x6b, 0x31, 0x55, 0x58, 0x90, 0xc6, 0x12, 0x34,
	0xd1, 0x58, 0x82, 0x65, 0x68, 0x8c, 0x08, 0x36, 0xbc, 0x16, 0x33, 0xde, 0x85, 0x52, 0x9b, 0xbb,
	0x2c, 0xe4, 0x1f, 0x33, 0x15, 0xed, 0x6f, 0x60, 0x22, 0xa2, 0xb1, 0x61, 0x64, 0x9e, 0x53, 0xf7,
	0x53, 0x21, 0x19, 0xa6, 0xd5, 0xd3, 0x28, 0x30, 0x2e, 0x44, 0x4a, 0x89, 0xc0, 0x54, 0x21, 0x72,
	0x6e, 0xac, 0x10, 0x99, 0x2c, 0x30, 0x9e, 0x76, 0x61, 0x71, 0x23, 0x60, 0x8e, 0x60, 0x9b, 0x77,
	0x75, 0x92, 0xf7, 0x4a, 0xfa, 0xa1, 0xb0, 0x12, 0x15, 0x76, 0x47, 0xef, 0x7a, 0x4a, 0x85, 0x58,
	0xc9, 0x9d, 0x83, 0x02, 0x15, 0x22, 0xd2, 0x87, 0x17, 0x93, 0x30, 0x2e, 0xfb, 0x2c, 0x34, 0x69,
	0x5d, 0x86, 0xa5, 0x64, 0x35, 0xf5, 0x9e, 0x9c, 0x80, 0x62, 0x8f, 0xc5, 0x31, 0x32, 0x6f, 0x4f,
	0xf7, 0xd8, 0xd3, 0xcd, 0x96, 0xf5, 0x33, 0x55, 0xa6, 0x92, 0xa3, 0x3d, 0xd4, 0xf6, 0x69, 0x38,
	0xa1, 0x4c, 0x07, 0x67, 0xaf, 0x9b, 0x93, 0x6f, 0x7b, 0x5c, 0xdb, 0xd6, 0x16, 0x94, 0x01, 0x3d,
	0x46, 0x6c, 0xca, 0x2e, 0x38, 0x65, 0xd9, 0xb0, 0x82, 0x59, 0x59, 0xbc, 0x80, 0x3e, 0xfa, 0x2d,
	0x98, 0x0e, 0x07, 0x9b, 0x77, 0xf5, 0xe3, 0x74, 0x7e, 0x18, 0x99, 0x67, 0x93, 0x48, 0x97, 0xe1,
	0x41, 0x92, 0xc5, 0xfa, 0x00, 0x4e, 0x8c, 0xc9, 0x54, 0x07, 0x7c, 0x0b, 0xd3, 0x09, 0x95, 0x35,
	0x1e, 0xbf, 0x6d, 0x8a, 0x7f, 0x06, 0xd6, 0x41, 0xc8, 0xf0, 0x03, 0xaf, 0xcb, 0x05, 0xf5, 0x30,
	0x6d, 0x12, 0x60, 0x7d, 0x96, 0x83, 0xe5, 0x07, 0x5e, 0x8b, 0xb7, 0xf7, 0xef, 0xcb, 0x6c, 0x5d,
	0xed, 0xfa, 0xb5, 0x91, 0x57, 0xf0, 0x5c, 0x72, 0xfd, 0xc6, 0xc3, 0x73, 0xea, 0xfa, 0x51, 0x84,
	0x7e, 0x1b, 0x80, 0xf2, 0xfd, 0xe4, 0x35, 0x29, 0xd4, 0x2e, 0x27, 0x8e, 0x9e, 0xcc, 0x65, 0x38,
	0x3a, 0x11, 0xd0, 0x8b, 0x51, 0x85, 0x92, 0xa4, 0xf6, 0x7c, 0xba, 0xcd, 0x85, 0xda, 0x72, 0x92,
	0x65, 0xeb, 0x19, 0xcb, 0x9e, 0xa1, 0xcf, 0x77, 0x7d, 0xeb, 0x24, 0xac, 0x8c, 0x9e, 0x44, 0xea,
	0xca, 0xfa, 0x5d, 0x1e, 0x96, 0xb6, 0x02, 0xb6, 0xeb, 0xbb, 0x9e, 0xd3, 0xd2, 0xe7, 0xdb, 0xd0,
	0x4d, 0x02, 0x19, 0x77, 0xaf, 0xa6, 0x9b, 0x04, 0x67, 0xd3, 0x4d, 0x82, 0xc9, 0xe6, 0x91, 0x8d,
	0x83, 0xdb, 0xd2, 0xab, 0xa5, 0x7b, 0x5e, 0x4e, 0xf2, 0x9e, 0x67, 0x72, 0xee, 0x75, 0x98, 0x16,
	0x1e, 0x3e, 0x34, 0xf9, 0x54, 0x9b, 0xc2, 0x93, 0xcf, 0x88, 0x6e, 0x53, 0xe0, 0x10, 0x57, 0xc3,
	0x5f, 0x8c, 0x8c, 0x54, 0xbd, 0x15, 0xe2, 0xd2, 0x56, 0x57, 0x6f, 0x66, 0xaa, 0x7a, 0x9b, 0x6c,
	0x1a, 0xaa, 0xe8, 0x1e, 0xca, 0xc8, 0x51, 0x67, 0x1f, 0xe9, 0x46, 0x47, 0x1c, 0x39, 0x10, 0x1b,
	0x8d, 0x1c, 0x88, 0x4c, 0x16, 0x36, 0x83, 0xd3, 0x6f, 0x7e, 0x24, 0x30, 0x29, 0x66, 0x3d, 0xc1,
	0x7a, 0x21, 0x46, 0x8e, 0x62, 0x52, 0x22, 0xc7, 0x60, 0xf2, 0xd0, 0xc6, 0x90, 0x65, 0x27, 0xd3,
	0xd6, 0x1f, 0xa7, 0xe0, 0xf9, 0x94, 0x65, 0x94, 0x6f, 0xaf, 0x8f, 0xb8, 0x1e, 0xa5, 0xb2, 0x0d,
	0xfe, 0xb1, 0xcc, 0x69, 0x54, 0x2a, 0x2b, 0xc7, 0xda, 0xe5, 0x6e, 0x41, 0xa9, 0xef, 0x7b, 0x61,
	0xbd, 0x1f, 0xf0, 0x74, 0x69, 0xa6, 0xb1, 0xc4, 0x69, 0x34, 0x62, 0xd9, 0x33, 0xf8, 0xb9, 0x1b,
	0x70, 0xe3, 0x75, 0x3c, 0x43, 0xab, 0xee, 0x7b, 0xbc, 0x27, 0x94, 0x25, 0x88, 0x99, 0xf5, 0x5a,
	0x84, 0x25, 0xcc, 0x1a, 0xb1, 0x6c, 0x9c, 0xdc, 0xc2, 0x4f, 0xe3, 0x0d, 0x80, 0x98, 0x5b, 0xe6,
	0x23, 0xb1, 0x0a, 0x24, 0x71, 0x98, 0x56, 0x81, 0x82, 0x48, 0x05, 0x52, 0x00, 0xd5, 0x05, 0x4e,
	0x5f, 0xec, 0x29, 0x7b, 0xc8, 0xcc, 0xb7, 0x4f, 0xcf, 0x9d, 0xce, 0x7c, 0xfb, 0x62, 0x0f, 0x33,
	0x5f, 0xfc, 0xf9, 0x6d, 0x0e, 0x16, 0x37, 0x1c, 0xd7, 0xd5, 0xf9, 0x20, 0x3a, 0xf2, 0x9d, 0x11,
	0x6d, 0x5d, 0x49, 0xe5, 0x53, 0xcf, 0x78, 0x61, 0xbf, 0x8d, 0x13, 0x5b, 0x8f, 0x61, 0x99, 0xa2,
	0xcc, 0x6e, 0x2f, 0xdc, 0x63, 0x6e, 0xfb, 0x3f, 0xb5, 0x29, 0xab, 0x0f, 0x06, 0xc9, 0xbd, 0xcb,
	0x5c, 0x26, 0x98, 0x16, 0xfb, 0xb5, 0xea, 0xbb, 0xeb, 0x50, 0xec, 0xfb, 0xf5, 0xe4, 0x68, 0xe4,
	0x48, 0x12, 0x49, 0x1c, 0x49, 0x8e, 0x2d, 0x7b, 0xba, 0xef, 0x3f, 0xe0, 0x2d, 0xeb, 0x6f, 0x53,
	0xb0, 0x20, 0xbd, 0x91, 0xf7, 0x3a, 0xb4, 0x01, 0xc3, 0x48, 0xaf, 0xa9, 0x44, 0x2f, 0xa5, 0x54,
	0x26, 0x2f, 0xb3, 0xa9, 0xc3, 0x89, 0x74, 0xa1, 0x72, 0x1c, 0x4e, 0x74, 0xa8, 0x78, 0x15, 0xe6,
	0xfb, 0x24, 0xb8, 0x1e, 0x0a, 0x47, 0xf4, 0x43, 0x75, 0x8b, 0x9f, 0xc7, 0xb2, 0x7a, 0x64, 0xc2,
	0x9e, 0x93, 0xc3, 0x6d, 0x1a, 0x19, 0x67, 0x00, 0x02, 0x26, 0x82, 0xfd, 0x3a, 0x3d, 0x84, 0x54,
	0x0f, 0xda, 0x65, 0x42, 0x76, 0x78, 0x97, 0x19, 0xd7, 0xc7, 0xda, 0xcd, 0xf2, 0x16, 0x2e, 0x8d,
	0xb7, 0x9b, 0x47, 0xfa, 0xca, 0xb7, 0x8f, 0x36, 0x81, 0x65, 0x05, 0xb8, 0x3c, 0xa1, 0x09, 0x3c,
	0xd6, 0xea, 0x35, 0x6e, 0x1e, 0x69, 0x4a, 0xcb, 0x94, 0xc1, 0x38, 0xda, 0x94, 0x1e, 0xed, 0x3d,
	0x5b, 0x17, 0x61, 0x79, 0x2b, 0x60, 0xbe, 0x13, 0x30, 0x52, 0xac, 0xb6, 0xe9, 0x52, 0x2a, 0x33,
	0x90, 0x3e, 0xb5, 0x05, 0x2b, 0xa3, 0x84, 0x2a, 0x2e, 0xdc, 0x1c, 0x79, 0xf3, 0xce, 0x4f, 0x7e,
	0xf3, 0x46, 0xad, 0xa7, 0x1e, 0xb9, 0xbf, 0x4f, 0xc1, 0xca, 0xdb, 0x72, 0x2f, 0x32, 0x55, 0xf8,
	0xaf, 0xb8, 0x3c, 0xf8, 0x06, 0x49, 0x15, 0xe6, 0xe3, 0x1e, 0xfc, 0xb4, 0xce, 0xcf, 0xd5, 0x1b,
	0x74, 0x4c, 0x6e, 0x2e, 0x49, 0x71, 0x07, 0x68, 0x78, 0x99, 0xaa, 0xd2, 0x0e, 0x64, 0xc1, 0xa0,
	0x76, 0x90, 0x59, 0x2c, 0x20, 0x99, 0xf1, 0x16, 0x14, 0x95, 0x07, 0xc8, 0x4e, 0xc3, 0x3a, 0xde,
	0x91, 0x38, 0x9b, 0x57, 0x75, 0xde, 0x71, 0x99, 0x7c, 0x51, 0xf7, 0x19, 0x61, 0x71, 0xcb, 0x75,
	0xf6, 0xd3, 0x79, 0x4f, 0xa2, 0xdb, 0xfc, 0x37, 0x8b, 0x01, 0x7f, 0xca, 0xc1, 0x52, 0x22, 0x54,
	0x39, 0xc1, 0xc3, 0x11, 0x27, 0xb8, 0x36, 0xd9, 0x09, 0xc6, 0xb9, 0xaa, 0x98, 0x44, 0xc9, 0x3e,
	0x56, 0x49, 0x76, 0x5e, 0x42, 0x21, 0x5d, 0x63, 0xf5, 0x3d, 0x28, 0xc7, 0x93, 0xdf, 0xb8, 0x31,
	0x15, 0xaf, 0x97, 0x6a, 0x4c, 0xfd, 0x75, 0x0a, 0x4a, 0x1a, 0x37, 0x2a, 0x23, 0x7e, 0x56, 0x38,
	0x8c, 0xcc, 0xe7, 0x94, 0x03, 0x5d, 0x83, 0x59, 0xf6, 0x91, 0xcf, 0x03, 0x56, 0x4f, 0x67, 0xba,
	0x87, 0x91, 0x99, 0x86, 0x6d, 0x90, 0x03, 0xba, 0xf2, 0x17, 0x60, 0xe6, 0x49, 0xdf, 0x71, 0xb9,
	0xd8, 0x57, 0x7e, 0x33, 0x8b, 0x95, 0xa2, 0x82, 0x6c, 0xfd, 0x61, 0xbc, 0x98, 0xf6, 0x8b, 0x19,
	0xe5, 0x17, 0xd2, 0xea, 0x37, 0x60, 0xae, 0xd9, 0x0f, 0x02, 0xd6, 0x13, 0xa9, 0xa8, 0x22, 0x83,
	0x46, 0x1a, 0xb7, 0x67, 0xd5, 0x88, 0x96, 0x7d, 0x07, 0xca, 0x94, 0x16, 0xf0, 0x5e, 0xdb, 0xab,
	0x14, 0x49, 0xfb, 0x19, 0xda, 0xb8, 0xc7, 0x5d, 0x46, 0x59, 0xe7, 0x3c, 0x35, 0x0e, 0x34, 0x93,
	0xac, 0x38, 0x48, 0x1d, 0xaf, 0xc3, 0x62, 0xd8, 0xf7, 0x7d, 0x2f, 0x10, 0x75, 0x7d, 0x94, 0x19,
	0xf2, 0x12, 0x8a, 0x40, 0x63, 0x53, 0xf6, 0x82, 0x02, 0x1e, 0xc9, 0xb1, 0xf5, 0xeb, 0x29, 0x28,
	0xe9, 0x35, 0x30, 0xf0, 0x3a, 0x7b, 0xcc, 0xd1, 0xcd, 0x10, 0x0a, 0xbc, 0x04, 0xd8, 0xf2, 0xc7,
	0xb8, 0x94, 0x2a, 0x97, 0xa4, 0x76, 0xe7, 0xd2, 0xe5, 0x52, 0xaa, 0x0e, 0xaa, 0x02, 0xe0, 0xb1,
	0x5d, 0xd6, 0xeb, 0xc4, 0x77, 0x92, 0xf2, 0xfd, 0x04, 0xb5, 0x53, 0xdf, 0xb8, 0xf4, 0x80, 0x96,
	0x2e, 0x24, 0x4b, 0x0f, 0xe4, 0xd2, 0xf4, 0x63, 0x9c, 0x56, 0xa5, 0xac, 0x7c, 0xdb, 0x4b, 0xba,
	0x94, 0x55, 0x75, 0xaa, 0x32, 0x50, 0x71, 0x82, 0x81, 0x5e, 0x82, 0x62, 0x3f, 0x70, 0xeb, 0x8d,
	0x26, 0x05, 0xe6, 0xb2, 0xec, 0xa6, 0x4b, 0xc4, 0x9e, 0xee, 0x07, 0x6e, 0xad, 0x79, 0xfd, 0x5f,
	0x73, 0x30, 0x2d, 0x1f, 0xa8, 0xfb, 0x30, 0x9b, 0xfa, 0x13, 0x82, 0x71, 0x61, 0xb2, 0x51, 0xc6,
	0xfe, 0xa7, 0xb0, 0x7a, 0xb2, 0x2a, 0xff, 0xd9, 0x50, 0xd5, 0xff, 0x6c, 0xa8, 0xbe, 0x89, 0x55,
	0x81, 0x71, 0x1f, 0x66, 0xb6, 0xf7, 0x7b, 0xcd, 0x1d, 0xa7, 0x63, 0x5c, 0xce, 0x68, 0x7d, 0x1c,
	0xed, 0xe1, 0x67, 0x4a, 0xdb, 0x83, 0xa5, 0xf1, 0xee, 0x72, 0xa6, 0xd8, 0xa3, 0x0d, 0xf2, 0xd5,
	0x67, 0x26, 0x0d, 0x8d, 0x0f, 0x60, 0x2e, 0xdd, 0x59, 0x34, 0xce, 0x67, 0x6f, 0x3e, 0xe9, 0x5f,
	0xae, 0xfe, 0x7f, 0x36, 0xd5, 0x91, 0x1e, 0x65, 0x1d, 0x66, 0x35, 0xbe, 0x2d, 0x9c, 0xef, 0x60,
	0x81, 0x06, 0xcc, 0xa7, 0xf1, 0x30, 0xcb, 0x94, 0x63, 0xcd, 0xcf, 0xaf, 0xb5, 0x86, 0x93, 0xa8,
	0x69, 0x5b, 0x38, 0xdf, 0xc9, 0x12, 0xef, 0x43, 0x49, 0xd7, 0xe3, 0x59, 0xe2, 0xc7, 0xba, 0x03,
	0xab, 0xff, 0xf7, 0x55, 0x64, 0x4a, 0xb4, 0x0d, 0x0b, 0xba, 0x57, 0xb4, 0xe1, 0x75, 0xbb, 0x5c,
	0x18, 0x97, 0xb2, 0x9a, 0x7f, 0xe3, 0x6d, 0xdd, 0x63, 0x5c, 0x74, 0x7e, 0xa4, 0xc4, 0x36, 0x32,
	0xce, 0x3a, 0xa9, 0xb6, 0x5f, 0xbd, 0xf2, 0x4c, 0xb4, 0x6a, 0xf7, 0x0c, 0xe6, 0xd2, 0xf5, 0x69,
	0xd6, 0x45, 0x98, 0x50, 0x8d, 0x67, 0xe9, 0x7f, 0x52, 0xb9, 0x6b, 0xfc, 0x1c, 0xca, 0x71, 0x4d,
	0x65, 0x64, 0x68, 0x76, 0xbc, 0x1c, 0x5e, 0xbd, 0xf8, 0x95, 0x74, 0x4a, 0xfa, 0x26, 0x94, 0x74,
	0x05, 0x92, 0x69, 0xdd, 0xd1, 0x0a, 0x25, 0x53, 0xf3, 0x8f, 0x60, 0x2e, 0x5d, 0x3b, 0x64, 0xe9,
	0x63, 0x42, 0x7d, 0x91, 0x29, 0xf2, 0x5d, 0x98, 0x4d, 0x95, 0x0d, 0x59, 0xde, 0x71, 0xb4, 0xb2,
	0xc8, 0x14, 0xc8, 0x61, 0x09, 0x8d, 0x99, 0xce, 0x47, 0xb3, 0xf6, 0x39, 0x21, 0xb9, 0xcd, 0xb2,
	0xdb, 0xc4, 0xf4, 0x76, 0x1b, 0xe6, 0x47, 0x72, 0xd4, 0x2c, 0x47, 0x9c, 0x94, 0xc8, 0x66, 0xee,
	0xff, 0xfd, 0x54, 0x12, 0x72, 0xe1, 0xab, 0x92, 0xa5, 0x63, 0x2f, 0xe3, 0x78, 0x4e, 0x55, 0x3b,
	0xfd, 0xd9, 0x17, 0x6b, 0xcf, 0x7d, 0xfe, 0xc5, 0xda, 0x73, 0xbf, 0x3a, 0x58, 0xcb, 0x7d, 0x76,
	0xb0, 0x96, 0xfb, 0xf3, 0xc1, 0x5a, 0xee, 0x1f, 0x07, 0x6b, 0xb9, 0x9f, 0x4e, 0x0d, 0x5e, 0x6e,
	0x14, 0x69, 0x23, 0x37, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xa8, 0xaa, 0xe7, 0xf4, 0xb3, 0x27,
	0x00, 0x00,
}
