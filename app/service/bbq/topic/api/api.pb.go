// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/bbq/topic/api/api.proto

package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import empty "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ListExtensionReq struct {
	Svids                []int64  `protobuf:"varint,1,rep,packed,name=svids" json:"svids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListExtensionReq) Reset()         { *m = ListExtensionReq{} }
func (m *ListExtensionReq) String() string { return proto.CompactTextString(m) }
func (*ListExtensionReq) ProtoMessage()    {}
func (*ListExtensionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{0}
}
func (m *ListExtensionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListExtensionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListExtensionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListExtensionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListExtensionReq.Merge(dst, src)
}
func (m *ListExtensionReq) XXX_Size() int {
	return m.Size()
}
func (m *ListExtensionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListExtensionReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListExtensionReq proto.InternalMessageInfo

type ListExtensionReply struct {
	List                 []*VideoExtension `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ListExtensionReply) Reset()         { *m = ListExtensionReply{} }
func (m *ListExtensionReply) String() string { return proto.CompactTextString(m) }
func (*ListExtensionReply) ProtoMessage()    {}
func (*ListExtensionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{1}
}
func (m *ListExtensionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListExtensionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListExtensionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListExtensionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListExtensionReply.Merge(dst, src)
}
func (m *ListExtensionReply) XXX_Size() int {
	return m.Size()
}
func (m *ListExtensionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ListExtensionReply.DiscardUnknown(m)
}

var xxx_messageInfo_ListExtensionReply proto.InternalMessageInfo

type UpdateVideoScoreReq struct {
	Svid                 int64    `protobuf:"varint,1,opt,name=svid,proto3" json:"svid,omitempty"`
	Score                float64  `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateVideoScoreReq) Reset()         { *m = UpdateVideoScoreReq{} }
func (m *UpdateVideoScoreReq) String() string { return proto.CompactTextString(m) }
func (*UpdateVideoScoreReq) ProtoMessage()    {}
func (*UpdateVideoScoreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{2}
}
func (m *UpdateVideoScoreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateVideoScoreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateVideoScoreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateVideoScoreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateVideoScoreReq.Merge(dst, src)
}
func (m *UpdateVideoScoreReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateVideoScoreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateVideoScoreReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateVideoScoreReq proto.InternalMessageInfo

type UpdateVideoStateReq struct {
	Svid                 int64    `protobuf:"varint,1,opt,name=svid,proto3" json:"svid,omitempty"`
	State                int32    `protobuf:"varint,2,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateVideoStateReq) Reset()         { *m = UpdateVideoStateReq{} }
func (m *UpdateVideoStateReq) String() string { return proto.CompactTextString(m) }
func (*UpdateVideoStateReq) ProtoMessage()    {}
func (*UpdateVideoStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{3}
}
func (m *UpdateVideoStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateVideoStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateVideoStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateVideoStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateVideoStateReq.Merge(dst, src)
}
func (m *UpdateVideoStateReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateVideoStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateVideoStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateVideoStateReq proto.InternalMessageInfo

type TopicVideosReq struct {
	TopicId              int64    `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty" form:"topic_id"`
	CursorPrev           string   `protobuf:"bytes,2,opt,name=cursor_prev,json=cursorPrev,proto3" json:"cursor_prev,omitempty" form:"cursor_prev"`
	CursorNext           string   `protobuf:"bytes,3,opt,name=cursor_next,json=cursorNext,proto3" json:"cursor_next,omitempty" form:"cursor_next"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicVideosReq) Reset()         { *m = TopicVideosReq{} }
func (m *TopicVideosReq) String() string { return proto.CompactTextString(m) }
func (*TopicVideosReq) ProtoMessage()    {}
func (*TopicVideosReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{4}
}
func (m *TopicVideosReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicVideosReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicVideosReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TopicVideosReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicVideosReq.Merge(dst, src)
}
func (m *TopicVideosReq) XXX_Size() int {
	return m.Size()
}
func (m *TopicVideosReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicVideosReq.DiscardUnknown(m)
}

var xxx_messageInfo_TopicVideosReq proto.InternalMessageInfo

type ListMultiTopicVideosReq struct {
	List                 []*TopicVideosReq `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ListMultiTopicVideosReq) Reset()         { *m = ListMultiTopicVideosReq{} }
func (m *ListMultiTopicVideosReq) String() string { return proto.CompactTextString(m) }
func (*ListMultiTopicVideosReq) ProtoMessage()    {}
func (*ListMultiTopicVideosReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{5}
}
func (m *ListMultiTopicVideosReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMultiTopicVideosReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMultiTopicVideosReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListMultiTopicVideosReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMultiTopicVideosReq.Merge(dst, src)
}
func (m *ListMultiTopicVideosReq) XXX_Size() int {
	return m.Size()
}
func (m *ListMultiTopicVideosReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMultiTopicVideosReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListMultiTopicVideosReq proto.InternalMessageInfo

type VideoItem struct {
	Svid                 int64    `protobuf:"varint,1,opt,name=svid,proto3" json:"svid,omitempty"`
	CursorValue          string   `protobuf:"bytes,2,opt,name=cursor_value,json=cursorValue,proto3" json:"cursor_value,omitempty"`
	HotType              int64    `protobuf:"varint,3,opt,name=hot_type,json=hotType,proto3" json:"hot_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VideoItem) Reset()         { *m = VideoItem{} }
func (m *VideoItem) String() string { return proto.CompactTextString(m) }
func (*VideoItem) ProtoMessage()    {}
func (*VideoItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{6}
}
func (m *VideoItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VideoItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoItem.Merge(dst, src)
}
func (m *VideoItem) XXX_Size() int {
	return m.Size()
}
func (m *VideoItem) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoItem.DiscardUnknown(m)
}

var xxx_messageInfo_VideoItem proto.InternalMessageInfo

type TopicDetail struct {
	TopicInfo            *TopicInfo   `protobuf:"bytes,1,opt,name=topic_info,json=topicInfo" json:"topic_info,omitempty"`
	List                 []*VideoItem `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
	HasMore              bool         `protobuf:"varint,3,opt,name=has_more,json=hasMore,proto3" json:"has_more"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TopicDetail) Reset()         { *m = TopicDetail{} }
func (m *TopicDetail) String() string { return proto.CompactTextString(m) }
func (*TopicDetail) ProtoMessage()    {}
func (*TopicDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{7}
}
func (m *TopicDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TopicDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicDetail.Merge(dst, src)
}
func (m *TopicDetail) XXX_Size() int {
	return m.Size()
}
func (m *TopicDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicDetail.DiscardUnknown(m)
}

var xxx_messageInfo_TopicDetail proto.InternalMessageInfo

type ListDiscoveryTopicReq struct {
	Page                 int32    `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty" form:"page" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDiscoveryTopicReq) Reset()         { *m = ListDiscoveryTopicReq{} }
func (m *ListDiscoveryTopicReq) String() string { return proto.CompactTextString(m) }
func (*ListDiscoveryTopicReq) ProtoMessage()    {}
func (*ListDiscoveryTopicReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{8}
}
func (m *ListDiscoveryTopicReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDiscoveryTopicReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDiscoveryTopicReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListDiscoveryTopicReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDiscoveryTopicReq.Merge(dst, src)
}
func (m *ListDiscoveryTopicReq) XXX_Size() int {
	return m.Size()
}
func (m *ListDiscoveryTopicReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDiscoveryTopicReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListDiscoveryTopicReq proto.InternalMessageInfo

type ListDiscoveryTopicReply struct {
	List                 []*TopicDetail `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	HasMore              bool           `protobuf:"varint,2,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListDiscoveryTopicReply) Reset()         { *m = ListDiscoveryTopicReply{} }
func (m *ListDiscoveryTopicReply) String() string { return proto.CompactTextString(m) }
func (*ListDiscoveryTopicReply) ProtoMessage()    {}
func (*ListDiscoveryTopicReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{9}
}
func (m *ListDiscoveryTopicReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDiscoveryTopicReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDiscoveryTopicReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListDiscoveryTopicReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDiscoveryTopicReply.Merge(dst, src)
}
func (m *ListDiscoveryTopicReply) XXX_Size() int {
	return m.Size()
}
func (m *ListDiscoveryTopicReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDiscoveryTopicReply.DiscardUnknown(m)
}

var xxx_messageInfo_ListDiscoveryTopicReply proto.InternalMessageInfo

type ListTopicsReq struct {
	Page                 int32    `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty" form:"page" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListTopicsReq) Reset()         { *m = ListTopicsReq{} }
func (m *ListTopicsReq) String() string { return proto.CompactTextString(m) }
func (*ListTopicsReq) ProtoMessage()    {}
func (*ListTopicsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{10}
}
func (m *ListTopicsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTopicsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTopicsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListTopicsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTopicsReq.Merge(dst, src)
}
func (m *ListTopicsReq) XXX_Size() int {
	return m.Size()
}
func (m *ListTopicsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTopicsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListTopicsReq proto.InternalMessageInfo

type ListTopicsReply struct {
	HasMore              bool         `protobuf:"varint,1,opt,name=has_more,json=hasMore,proto3" json:"has_more"`
	List                 []*TopicInfo `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ListTopicsReply) Reset()         { *m = ListTopicsReply{} }
func (m *ListTopicsReply) String() string { return proto.CompactTextString(m) }
func (*ListTopicsReply) ProtoMessage()    {}
func (*ListTopicsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{11}
}
func (m *ListTopicsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTopicsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTopicsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListTopicsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTopicsReply.Merge(dst, src)
}
func (m *ListTopicsReply) XXX_Size() int {
	return m.Size()
}
func (m *ListTopicsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTopicsReply.DiscardUnknown(m)
}

var xxx_messageInfo_ListTopicsReply proto.InternalMessageInfo

type StickTopicReq struct {
	TopicId              int64    `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty" form:"topic_id" validate:"required"`
	Op                   int64    `protobuf:"varint,2,opt,name=op,proto3" json:"op,omitempty" form:"op"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StickTopicReq) Reset()         { *m = StickTopicReq{} }
func (m *StickTopicReq) String() string { return proto.CompactTextString(m) }
func (*StickTopicReq) ProtoMessage()    {}
func (*StickTopicReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{12}
}
func (m *StickTopicReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StickTopicReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StickTopicReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StickTopicReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StickTopicReq.Merge(dst, src)
}
func (m *StickTopicReq) XXX_Size() int {
	return m.Size()
}
func (m *StickTopicReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StickTopicReq.DiscardUnknown(m)
}

var xxx_messageInfo_StickTopicReq proto.InternalMessageInfo

type StickTopicVideoReq struct {
	TopicId              int64    `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty" form:"topic_id" validate:"required"`
	Svid                 int64    `protobuf:"varint,2,opt,name=svid,proto3" json:"svid,omitempty" form:"svid" validate:"required"`
	Op                   int64    `protobuf:"varint,3,opt,name=op,proto3" json:"op,omitempty" form:"op"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StickTopicVideoReq) Reset()         { *m = StickTopicVideoReq{} }
func (m *StickTopicVideoReq) String() string { return proto.CompactTextString(m) }
func (*StickTopicVideoReq) ProtoMessage()    {}
func (*StickTopicVideoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{13}
}
func (m *StickTopicVideoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StickTopicVideoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StickTopicVideoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StickTopicVideoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StickTopicVideoReq.Merge(dst, src)
}
func (m *StickTopicVideoReq) XXX_Size() int {
	return m.Size()
}
func (m *StickTopicVideoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StickTopicVideoReq.DiscardUnknown(m)
}

var xxx_messageInfo_StickTopicVideoReq proto.InternalMessageInfo

type SetStickTopicVideoReq struct {
	TopicId              int64    `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty" form:"topic_id" validate:"required"`
	Svids                []int64  `protobuf:"varint,2,rep,packed,name=svids" json:"svids,omitempty" form:"svids"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetStickTopicVideoReq) Reset()         { *m = SetStickTopicVideoReq{} }
func (m *SetStickTopicVideoReq) String() string { return proto.CompactTextString(m) }
func (*SetStickTopicVideoReq) ProtoMessage()    {}
func (*SetStickTopicVideoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{14}
}
func (m *SetStickTopicVideoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetStickTopicVideoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetStickTopicVideoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetStickTopicVideoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetStickTopicVideoReq.Merge(dst, src)
}
func (m *SetStickTopicVideoReq) XXX_Size() int {
	return m.Size()
}
func (m *SetStickTopicVideoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetStickTopicVideoReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetStickTopicVideoReq proto.InternalMessageInfo

// 所有查找走同一个接口
type ListCmsTopicsReq struct {
	Page                 int32    `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty" form:"page" validate:"required"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	TopicId              int64    `protobuf:"varint,3,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty" form:"topic_id"`
	State                int32    `protobuf:"varint,4,opt,name=state,proto3" json:"state,omitempty" form:"state"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListCmsTopicsReq) Reset()         { *m = ListCmsTopicsReq{} }
func (m *ListCmsTopicsReq) String() string { return proto.CompactTextString(m) }
func (*ListCmsTopicsReq) ProtoMessage()    {}
func (*ListCmsTopicsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{15}
}
func (m *ListCmsTopicsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCmsTopicsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCmsTopicsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListCmsTopicsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCmsTopicsReq.Merge(dst, src)
}
func (m *ListCmsTopicsReq) XXX_Size() int {
	return m.Size()
}
func (m *ListCmsTopicsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCmsTopicsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListCmsTopicsReq proto.InternalMessageInfo

type ListCmsTopicsReply struct {
	HasMore              bool         `protobuf:"varint,1,opt,name=has_more,json=hasMore,proto3" json:"has_more"`
	List                 []*TopicInfo `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ListCmsTopicsReply) Reset()         { *m = ListCmsTopicsReply{} }
func (m *ListCmsTopicsReply) String() string { return proto.CompactTextString(m) }
func (*ListCmsTopicsReply) ProtoMessage()    {}
func (*ListCmsTopicsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{16}
}
func (m *ListCmsTopicsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCmsTopicsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCmsTopicsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListCmsTopicsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCmsTopicsReply.Merge(dst, src)
}
func (m *ListCmsTopicsReply) XXX_Size() int {
	return m.Size()
}
func (m *ListCmsTopicsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCmsTopicsReply.DiscardUnknown(m)
}

var xxx_messageInfo_ListCmsTopicsReply proto.InternalMessageInfo

type TopicVideoItem struct {
	TopicId              int64    `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	Svid                 int64    `protobuf:"varint,2,opt,name=svid,proto3" json:"svid,omitempty"`
	Score                float64  `protobuf:"fixed64,3,opt,name=score,proto3" json:"score,omitempty"`
	State                int32    `protobuf:"varint,4,opt,name=state,proto3" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicVideoItem) Reset()         { *m = TopicVideoItem{} }
func (m *TopicVideoItem) String() string { return proto.CompactTextString(m) }
func (*TopicVideoItem) ProtoMessage()    {}
func (*TopicVideoItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{17}
}
func (m *TopicVideoItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicVideoItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicVideoItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TopicVideoItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicVideoItem.Merge(dst, src)
}
func (m *TopicVideoItem) XXX_Size() int {
	return m.Size()
}
func (m *TopicVideoItem) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicVideoItem.DiscardUnknown(m)
}

var xxx_messageInfo_TopicVideoItem proto.InternalMessageInfo

type VideoTopicReq struct {
	Svid                 int64    `protobuf:"varint,1,opt,name=svid,proto3" json:"svid,omitempty" form:"svid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VideoTopicReq) Reset()         { *m = VideoTopicReq{} }
func (m *VideoTopicReq) String() string { return proto.CompactTextString(m) }
func (*VideoTopicReq) ProtoMessage()    {}
func (*VideoTopicReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{18}
}
func (m *VideoTopicReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoTopicReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoTopicReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VideoTopicReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoTopicReq.Merge(dst, src)
}
func (m *VideoTopicReq) XXX_Size() int {
	return m.Size()
}
func (m *VideoTopicReq) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoTopicReq.DiscardUnknown(m)
}

var xxx_messageInfo_VideoTopicReq proto.InternalMessageInfo

type VideoTopicReply struct {
	List                 []*TopicVideoItem `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *VideoTopicReply) Reset()         { *m = VideoTopicReply{} }
func (m *VideoTopicReply) String() string { return proto.CompactTextString(m) }
func (*VideoTopicReply) ProtoMessage()    {}
func (*VideoTopicReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{19}
}
func (m *VideoTopicReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoTopicReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoTopicReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VideoTopicReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoTopicReply.Merge(dst, src)
}
func (m *VideoTopicReply) XXX_Size() int {
	return m.Size()
}
func (m *VideoTopicReply) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoTopicReply.DiscardUnknown(m)
}

var xxx_messageInfo_VideoTopicReply proto.InternalMessageInfo

type UpdateTopicStateReq struct {
	TopicId              int64    `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty" form:"topic_id"`
	Op                   int32    `protobuf:"varint,2,opt,name=op,proto3" json:"op,omitempty" form:"op"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateTopicStateReq) Reset()         { *m = UpdateTopicStateReq{} }
func (m *UpdateTopicStateReq) String() string { return proto.CompactTextString(m) }
func (*UpdateTopicStateReq) ProtoMessage()    {}
func (*UpdateTopicStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{20}
}
func (m *UpdateTopicStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTopicStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTopicStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateTopicStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTopicStateReq.Merge(dst, src)
}
func (m *UpdateTopicStateReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTopicStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTopicStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTopicStateReq proto.InternalMessageInfo

type TopicInfo struct {
	TopicId              int64    `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty" form:"topic_id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Desc                 string   `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc,omitempty" form:"desc"`
	Score                float64  `protobuf:"fixed64,4,opt,name=score,proto3" json:"score,omitempty"`
	State                int32    `protobuf:"varint,5,opt,name=state,proto3" json:"state,omitempty" form:"state"`
	HotType              int32    `protobuf:"varint,6,opt,name=hot_type,json=hotType,proto3" json:"hot_type"`
	CoverUrl             string   `protobuf:"bytes,7,opt,name=cover_url,json=coverUrl,proto3" json:"cover_url,omitempty" form:"cover_url"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicInfo) Reset()         { *m = TopicInfo{} }
func (m *TopicInfo) String() string { return proto.CompactTextString(m) }
func (*TopicInfo) ProtoMessage()    {}
func (*TopicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{21}
}
func (m *TopicInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TopicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicInfo.Merge(dst, src)
}
func (m *TopicInfo) XXX_Size() int {
	return m.Size()
}
func (m *TopicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicInfo proto.InternalMessageInfo

type TitleExtraItem struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Type                 int64    `protobuf:"varint,2,opt,name=type,proto3" json:"type"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Start                int64    `protobuf:"varint,4,opt,name=start,proto3" json:"start"`
	End                  int64    `protobuf:"varint,5,opt,name=end,proto3" json:"end"`
	Scheme               string   `protobuf:"bytes,6,opt,name=scheme,proto3" json:"scheme"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TitleExtraItem) Reset()         { *m = TitleExtraItem{} }
func (m *TitleExtraItem) String() string { return proto.CompactTextString(m) }
func (*TitleExtraItem) ProtoMessage()    {}
func (*TitleExtraItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{22}
}
func (m *TitleExtraItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TitleExtraItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TitleExtraItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TitleExtraItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TitleExtraItem.Merge(dst, src)
}
func (m *TitleExtraItem) XXX_Size() int {
	return m.Size()
}
func (m *TitleExtraItem) XXX_DiscardUnknown() {
	xxx_messageInfo_TitleExtraItem.DiscardUnknown(m)
}

var xxx_messageInfo_TitleExtraItem proto.InternalMessageInfo

// 用于传递给上游的extension，通过序列化赋值给extension
type VideoExtension struct {
	Svid                 int64    `protobuf:"varint,1,opt,name=svid,proto3" json:"svid,omitempty"`
	Extension            string   `protobuf:"bytes,2,opt,name=extension,proto3" json:"extension,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VideoExtension) Reset()         { *m = VideoExtension{} }
func (m *VideoExtension) String() string { return proto.CompactTextString(m) }
func (*VideoExtension) ProtoMessage()    {}
func (*VideoExtension) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{23}
}
func (m *VideoExtension) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoExtension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoExtension.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VideoExtension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoExtension.Merge(dst, src)
}
func (m *VideoExtension) XXX_Size() int {
	return m.Size()
}
func (m *VideoExtension) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoExtension.DiscardUnknown(m)
}

var xxx_messageInfo_VideoExtension proto.InternalMessageInfo

// 结构化的extension，真正的extension
type Extension struct {
	TitleExtra           []*TitleExtraItem `protobuf:"bytes,1,rep,name=title_extra,json=titleExtra" json:"title_extra,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Extension) Reset()         { *m = Extension{} }
func (m *Extension) String() string { return proto.CompactTextString(m) }
func (*Extension) ProtoMessage()    {}
func (*Extension) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_328ca58160a5beb9, []int{24}
}
func (m *Extension) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Extension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Extension.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Extension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Extension.Merge(dst, src)
}
func (m *Extension) XXX_Size() int {
	return m.Size()
}
func (m *Extension) XXX_DiscardUnknown() {
	xxx_messageInfo_Extension.DiscardUnknown(m)
}

var xxx_messageInfo_Extension proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ListExtensionReq)(nil), "bbq.service.topic.v1.ListExtensionReq")
	proto.RegisterType((*ListExtensionReply)(nil), "bbq.service.topic.v1.ListExtensionReply")
	proto.RegisterType((*UpdateVideoScoreReq)(nil), "bbq.service.topic.v1.UpdateVideoScoreReq")
	proto.RegisterType((*UpdateVideoStateReq)(nil), "bbq.service.topic.v1.UpdateVideoStateReq")
	proto.RegisterType((*TopicVideosReq)(nil), "bbq.service.topic.v1.TopicVideosReq")
	proto.RegisterType((*ListMultiTopicVideosReq)(nil), "bbq.service.topic.v1.ListMultiTopicVideosReq")
	proto.RegisterType((*VideoItem)(nil), "bbq.service.topic.v1.VideoItem")
	proto.RegisterType((*TopicDetail)(nil), "bbq.service.topic.v1.TopicDetail")
	proto.RegisterType((*ListDiscoveryTopicReq)(nil), "bbq.service.topic.v1.ListDiscoveryTopicReq")
	proto.RegisterType((*ListDiscoveryTopicReply)(nil), "bbq.service.topic.v1.ListDiscoveryTopicReply")
	proto.RegisterType((*ListTopicsReq)(nil), "bbq.service.topic.v1.ListTopicsReq")
	proto.RegisterType((*ListTopicsReply)(nil), "bbq.service.topic.v1.ListTopicsReply")
	proto.RegisterType((*StickTopicReq)(nil), "bbq.service.topic.v1.StickTopicReq")
	proto.RegisterType((*StickTopicVideoReq)(nil), "bbq.service.topic.v1.StickTopicVideoReq")
	proto.RegisterType((*SetStickTopicVideoReq)(nil), "bbq.service.topic.v1.SetStickTopicVideoReq")
	proto.RegisterType((*ListCmsTopicsReq)(nil), "bbq.service.topic.v1.ListCmsTopicsReq")
	proto.RegisterType((*ListCmsTopicsReply)(nil), "bbq.service.topic.v1.ListCmsTopicsReply")
	proto.RegisterType((*TopicVideoItem)(nil), "bbq.service.topic.v1.TopicVideoItem")
	proto.RegisterType((*VideoTopicReq)(nil), "bbq.service.topic.v1.VideoTopicReq")
	proto.RegisterType((*VideoTopicReply)(nil), "bbq.service.topic.v1.VideoTopicReply")
	proto.RegisterType((*UpdateTopicStateReq)(nil), "bbq.service.topic.v1.UpdateTopicStateReq")
	proto.RegisterType((*TopicInfo)(nil), "bbq.service.topic.v1.TopicInfo")
	proto.RegisterType((*TitleExtraItem)(nil), "bbq.service.topic.v1.TitleExtraItem")
	proto.RegisterType((*VideoExtension)(nil), "bbq.service.topic.v1.VideoExtension")
	proto.RegisterType((*Extension)(nil), "bbq.service.topic.v1.Extension")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TopicClient is the client API for Topic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TopicClient interface {
	// //////////////extension////////////////
	Register(ctx context.Context, in *VideoExtension, opts ...grpc.CallOption) (*empty.Empty, error)
	ListExtension(ctx context.Context, in *ListExtensionReq, opts ...grpc.CallOption) (*ListExtensionReply, error)
	// ////////////////topic///////////////////
	UpdateVideoScore(ctx context.Context, in *UpdateVideoScoreReq, opts ...grpc.CallOption) (*empty.Empty, error)
	UpdateVideoState(ctx context.Context, in *UpdateVideoStateReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 获取话题下的视频
	ListTopicVideos(ctx context.Context, in *TopicVideosReq, opts ...grpc.CallOption) (*TopicDetail, error)
	// TODO: to deleted. 发现页分成先请求话题，再请求话题下视频
	// 获取发现页下的话题
	ListDiscoveryTopics(ctx context.Context, in *ListDiscoveryTopicReq, opts ...grpc.CallOption) (*ListDiscoveryTopicReply, error)
	// 推荐的话题，不会返回话题内的视频
	ListTopics(ctx context.Context, in *ListTopicsReq, opts ...grpc.CallOption) (*ListTopicsReply, error)
	// /// cms /////
	StickTopic(ctx context.Context, in *StickTopicReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 置顶、取消置顶话题下的视频（需要cms先去判断该视频是否可以放在话题中）
	StickTopicVideo(ctx context.Context, in *StickTopicVideoReq, opts ...grpc.CallOption) (*empty.Empty, error)
	SetStickTopicVideo(ctx context.Context, in *SetStickTopicVideoReq, opts ...grpc.CallOption) (*empty.Empty, error)
	// 注意：该接口不支持复杂条件，当以下三种同时请求的时候只会按顺序选择一种进行返回：
	//   话题name查找接口，不区分隐藏，返回数组，但是暂时只会完全匹配，
	//   话题隐藏列表接口，按照时间反向排序
	//   话题推荐列表接口，按照热度反向排序，其中第一页会包含置顶话题
	ListCmsTopics(ctx context.Context, in *ListCmsTopicsReq, opts ...grpc.CallOption) (*ListCmsTopicsReply, error)
	// 修改话题简介，topic_id必传传，直接放在http请求里
	UpdateTopicDesc(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*empty.Empty, error)
	UpdateTopicState(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*empty.Empty, error)
	// 根据svid返回topic_id列表
	VideoTopic(ctx context.Context, in *VideoTopicReq, opts ...grpc.CallOption) (*VideoTopicReply, error)
}

type topicClient struct {
	cc *grpc.ClientConn
}

func NewTopicClient(cc *grpc.ClientConn) TopicClient {
	return &topicClient{cc}
}

func (c *topicClient) Register(ctx context.Context, in *VideoExtension, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) ListExtension(ctx context.Context, in *ListExtensionReq, opts ...grpc.CallOption) (*ListExtensionReply, error) {
	out := new(ListExtensionReply)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/ListExtension", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) UpdateVideoScore(ctx context.Context, in *UpdateVideoScoreReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/UpdateVideoScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) UpdateVideoState(ctx context.Context, in *UpdateVideoStateReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/UpdateVideoState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) ListTopicVideos(ctx context.Context, in *TopicVideosReq, opts ...grpc.CallOption) (*TopicDetail, error) {
	out := new(TopicDetail)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/ListTopicVideos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) ListDiscoveryTopics(ctx context.Context, in *ListDiscoveryTopicReq, opts ...grpc.CallOption) (*ListDiscoveryTopicReply, error) {
	out := new(ListDiscoveryTopicReply)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/ListDiscoveryTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) ListTopics(ctx context.Context, in *ListTopicsReq, opts ...grpc.CallOption) (*ListTopicsReply, error) {
	out := new(ListTopicsReply)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/ListTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) StickTopic(ctx context.Context, in *StickTopicReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/StickTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) StickTopicVideo(ctx context.Context, in *StickTopicVideoReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/StickTopicVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) SetStickTopicVideo(ctx context.Context, in *SetStickTopicVideoReq, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/SetStickTopicVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) ListCmsTopics(ctx context.Context, in *ListCmsTopicsReq, opts ...grpc.CallOption) (*ListCmsTopicsReply, error) {
	out := new(ListCmsTopicsReply)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/ListCmsTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) UpdateTopicDesc(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/UpdateTopicDesc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) UpdateTopicState(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/UpdateTopicState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicClient) VideoTopic(ctx context.Context, in *VideoTopicReq, opts ...grpc.CallOption) (*VideoTopicReply, error) {
	out := new(VideoTopicReply)
	err := c.cc.Invoke(ctx, "/bbq.service.topic.v1.Topic/VideoTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TopicServer is the server API for Topic service.
type TopicServer interface {
	// //////////////extension////////////////
	Register(context.Context, *VideoExtension) (*empty.Empty, error)
	ListExtension(context.Context, *ListExtensionReq) (*ListExtensionReply, error)
	// ////////////////topic///////////////////
	UpdateVideoScore(context.Context, *UpdateVideoScoreReq) (*empty.Empty, error)
	UpdateVideoState(context.Context, *UpdateVideoStateReq) (*empty.Empty, error)
	// 获取话题下的视频
	ListTopicVideos(context.Context, *TopicVideosReq) (*TopicDetail, error)
	// TODO: to deleted. 发现页分成先请求话题，再请求话题下视频
	// 获取发现页下的话题
	ListDiscoveryTopics(context.Context, *ListDiscoveryTopicReq) (*ListDiscoveryTopicReply, error)
	// 推荐的话题，不会返回话题内的视频
	ListTopics(context.Context, *ListTopicsReq) (*ListTopicsReply, error)
	// /// cms /////
	StickTopic(context.Context, *StickTopicReq) (*empty.Empty, error)
	// 置顶、取消置顶话题下的视频（需要cms先去判断该视频是否可以放在话题中）
	StickTopicVideo(context.Context, *StickTopicVideoReq) (*empty.Empty, error)
	SetStickTopicVideo(context.Context, *SetStickTopicVideoReq) (*empty.Empty, error)
	// 注意：该接口不支持复杂条件，当以下三种同时请求的时候只会按顺序选择一种进行返回：
	//   话题name查找接口，不区分隐藏，返回数组，但是暂时只会完全匹配，
	//   话题隐藏列表接口，按照时间反向排序
	//   话题推荐列表接口，按照热度反向排序，其中第一页会包含置顶话题
	ListCmsTopics(context.Context, *ListCmsTopicsReq) (*ListCmsTopicsReply, error)
	// 修改话题简介，topic_id必传传，直接放在http请求里
	UpdateTopicDesc(context.Context, *TopicInfo) (*empty.Empty, error)
	UpdateTopicState(context.Context, *TopicInfo) (*empty.Empty, error)
	// 根据svid返回topic_id列表
	VideoTopic(context.Context, *VideoTopicReq) (*VideoTopicReply, error)
}

func RegisterTopicServer(s *grpc.Server, srv TopicServer) {
	s.RegisterService(&_Topic_serviceDesc, srv)
}

func _Topic_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoExtension)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).Register(ctx, req.(*VideoExtension))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_ListExtension_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExtensionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).ListExtension(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/ListExtension",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).ListExtension(ctx, req.(*ListExtensionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_UpdateVideoScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVideoScoreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).UpdateVideoScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/UpdateVideoScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).UpdateVideoScore(ctx, req.(*UpdateVideoScoreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_UpdateVideoState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVideoStateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).UpdateVideoState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/UpdateVideoState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).UpdateVideoState(ctx, req.(*UpdateVideoStateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_ListTopicVideos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicVideosReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).ListTopicVideos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/ListTopicVideos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).ListTopicVideos(ctx, req.(*TopicVideosReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_ListDiscoveryTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDiscoveryTopicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).ListDiscoveryTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/ListDiscoveryTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).ListDiscoveryTopics(ctx, req.(*ListDiscoveryTopicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/ListTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).ListTopics(ctx, req.(*ListTopicsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_StickTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StickTopicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).StickTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/StickTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).StickTopic(ctx, req.(*StickTopicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_StickTopicVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StickTopicVideoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).StickTopicVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/StickTopicVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).StickTopicVideo(ctx, req.(*StickTopicVideoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_SetStickTopicVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetStickTopicVideoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).SetStickTopicVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/SetStickTopicVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).SetStickTopicVideo(ctx, req.(*SetStickTopicVideoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_ListCmsTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCmsTopicsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).ListCmsTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/ListCmsTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).ListCmsTopics(ctx, req.(*ListCmsTopicsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_UpdateTopicDesc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).UpdateTopicDesc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/UpdateTopicDesc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).UpdateTopicDesc(ctx, req.(*TopicInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_UpdateTopicState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).UpdateTopicState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/UpdateTopicState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).UpdateTopicState(ctx, req.(*TopicInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topic_VideoTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoTopicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicServer).VideoTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.topic.v1.Topic/VideoTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicServer).VideoTopic(ctx, req.(*VideoTopicReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Topic_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bbq.service.topic.v1.Topic",
	HandlerType: (*TopicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Topic_Register_Handler,
		},
		{
			MethodName: "ListExtension",
			Handler:    _Topic_ListExtension_Handler,
		},
		{
			MethodName: "UpdateVideoScore",
			Handler:    _Topic_UpdateVideoScore_Handler,
		},
		{
			MethodName: "UpdateVideoState",
			Handler:    _Topic_UpdateVideoState_Handler,
		},
		{
			MethodName: "ListTopicVideos",
			Handler:    _Topic_ListTopicVideos_Handler,
		},
		{
			MethodName: "ListDiscoveryTopics",
			Handler:    _Topic_ListDiscoveryTopics_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _Topic_ListTopics_Handler,
		},
		{
			MethodName: "StickTopic",
			Handler:    _Topic_StickTopic_Handler,
		},
		{
			MethodName: "StickTopicVideo",
			Handler:    _Topic_StickTopicVideo_Handler,
		},
		{
			MethodName: "SetStickTopicVideo",
			Handler:    _Topic_SetStickTopicVideo_Handler,
		},
		{
			MethodName: "ListCmsTopics",
			Handler:    _Topic_ListCmsTopics_Handler,
		},
		{
			MethodName: "UpdateTopicDesc",
			Handler:    _Topic_UpdateTopicDesc_Handler,
		},
		{
			MethodName: "UpdateTopicState",
			Handler:    _Topic_UpdateTopicState_Handler,
		},
		{
			MethodName: "VideoTopic",
			Handler:    _Topic_VideoTopic_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/bbq/topic/api/api.proto",
}

func (m *ListExtensionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListExtensionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Svids) > 0 {
		dAtA2 := make([]byte, len(m.Svids)*10)
		var j1 int
		for _, num1 := range m.Svids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListExtensionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListExtensionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateVideoScoreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVideoScoreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.Score != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Score))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateVideoStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVideoStateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicVideosReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicVideosReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicId))
	}
	if len(m.CursorPrev) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CursorPrev)))
		i += copy(dAtA[i:], m.CursorPrev)
	}
	if len(m.CursorNext) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CursorNext)))
		i += copy(dAtA[i:], m.CursorNext)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListMultiTopicVideosReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMultiTopicVideosReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if len(m.CursorValue) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CursorValue)))
		i += copy(dAtA[i:], m.CursorValue)
	}
	if m.HotType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HotType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicInfo.Size()))
		n3, err := m.TopicInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HasMore {
		dAtA[i] = 0x18
		i++
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListDiscoveryTopicReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDiscoveryTopicReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListDiscoveryTopicReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDiscoveryTopicReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HasMore {
		dAtA[i] = 0x10
		i++
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListTopicsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTopicsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListTopicsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTopicsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HasMore {
		dAtA[i] = 0x8
		i++
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StickTopicReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickTopicReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicId))
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StickTopicVideoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickTopicVideoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicId))
	}
	if m.Svid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.Op != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetStickTopicVideoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetStickTopicVideoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicId))
	}
	if len(m.Svids) > 0 {
		dAtA5 := make([]byte, len(m.Svids)*10)
		var j4 int
		for _, num1 := range m.Svids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListCmsTopicsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCmsTopicsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Page))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.TopicId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicId))
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListCmsTopicsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCmsTopicsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HasMore {
		dAtA[i] = 0x8
		i++
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicVideoItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicVideoItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicId))
	}
	if m.Svid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.Score != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Score))))
		i += 8
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoTopicReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoTopicReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoTopicReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoTopicReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateTopicStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTopicStateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicId))
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopicInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopicId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TopicId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.Score != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Score))))
		i += 8
	}
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State))
	}
	if m.HotType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HotType))
	}
	if len(m.CoverUrl) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CoverUrl)))
		i += copy(dAtA[i:], m.CoverUrl)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TitleExtraItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TitleExtraItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Start != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.End))
	}
	if len(m.Scheme) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VideoExtension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoExtension) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Svid))
	}
	if len(m.Extension) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Extension)))
		i += copy(dAtA[i:], m.Extension)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Extension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Extension) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TitleExtra) > 0 {
		for _, msg := range m.TitleExtra {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ListExtensionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Svids) > 0 {
		l = 0
		for _, e := range m.Svids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListExtensionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateVideoScoreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.Score != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateVideoStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicVideosReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicId != 0 {
		n += 1 + sovApi(uint64(m.TopicId))
	}
	l = len(m.CursorPrev)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CursorNext)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListMultiTopicVideosReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	l = len(m.CursorValue)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.HotType != 0 {
		n += 1 + sovApi(uint64(m.HotType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicInfo != nil {
		l = m.TopicInfo.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.HasMore {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDiscoveryTopicReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovApi(uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDiscoveryTopicReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.HasMore {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTopicsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovApi(uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTopicsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasMore {
		n += 2
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StickTopicReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicId != 0 {
		n += 1 + sovApi(uint64(m.TopicId))
	}
	if m.Op != 0 {
		n += 1 + sovApi(uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StickTopicVideoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicId != 0 {
		n += 1 + sovApi(uint64(m.TopicId))
	}
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.Op != 0 {
		n += 1 + sovApi(uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetStickTopicVideoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicId != 0 {
		n += 1 + sovApi(uint64(m.TopicId))
	}
	if len(m.Svids) > 0 {
		l = 0
		for _, e := range m.Svids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCmsTopicsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovApi(uint64(m.Page))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TopicId != 0 {
		n += 1 + sovApi(uint64(m.TopicId))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCmsTopicsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasMore {
		n += 2
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicVideoItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicId != 0 {
		n += 1 + sovApi(uint64(m.TopicId))
	}
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.Score != 0 {
		n += 9
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoTopicReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoTopicReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTopicStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicId != 0 {
		n += 1 + sovApi(uint64(m.TopicId))
	}
	if m.Op != 0 {
		n += 1 + sovApi(uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopicInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicId != 0 {
		n += 1 + sovApi(uint64(m.TopicId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Score != 0 {
		n += 9
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.HotType != 0 {
		n += 1 + sovApi(uint64(m.HotType))
	}
	l = len(m.CoverUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TitleExtraItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovApi(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovApi(uint64(m.End))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoExtension) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Svid != 0 {
		n += 1 + sovApi(uint64(m.Svid))
	}
	l = len(m.Extension)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Extension) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TitleExtra) > 0 {
		for _, e := range m.TitleExtra {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ListExtensionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListExtensionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListExtensionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Svids = append(m.Svids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Svids) == 0 {
					m.Svids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Svids = append(m.Svids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Svids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListExtensionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListExtensionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListExtensionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &VideoExtension{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVideoScoreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVideoScoreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVideoScoreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Score = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVideoStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVideoStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVideoStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicVideosReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicVideosReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicVideosReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CursorPrev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CursorPrev = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CursorNext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CursorNext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMultiTopicVideosReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMultiTopicVideosReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMultiTopicVideosReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &TopicVideosReq{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CursorValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CursorValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotType", wireType)
			}
			m.HotType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HotType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicInfo == nil {
				m.TopicInfo = &TopicInfo{}
			}
			if err := m.TopicInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &VideoItem{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDiscoveryTopicReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDiscoveryTopicReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDiscoveryTopicReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDiscoveryTopicReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDiscoveryTopicReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDiscoveryTopicReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &TopicDetail{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTopicsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTopicsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTopicsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTopicsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTopicsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTopicsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &TopicInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickTopicReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickTopicReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickTopicReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickTopicVideoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickTopicVideoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickTopicVideoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetStickTopicVideoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetStickTopicVideoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetStickTopicVideoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Svids = append(m.Svids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Svids) == 0 {
					m.Svids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Svids = append(m.Svids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Svids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCmsTopicsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCmsTopicsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCmsTopicsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCmsTopicsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCmsTopicsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCmsTopicsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &TopicInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicVideoItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicVideoItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicVideoItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Score = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoTopicReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoTopicReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoTopicReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoTopicReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoTopicReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoTopicReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &TopicVideoItem{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTopicStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTopicStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTopicStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Score = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotType", wireType)
			}
			m.HotType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HotType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TitleExtraItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TitleExtraItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TitleExtraItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoExtension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoExtension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoExtension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			m.Svid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Svid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Extension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Extension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Extension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleExtra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TitleExtra = append(m.TitleExtra, &TitleExtraItem{})
			if err := m.TitleExtra[len(m.TitleExtra)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/bbq/topic/api/api.proto", fileDescriptor_api_328ca58160a5beb9)
}

var fileDescriptor_api_328ca58160a5beb9 = []byte{
	// 1303 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x6e, 0xdb, 0xc6,
	0x13, 0xff, 0x53, 0x94, 0x6d, 0x71, 0x1c, 0x47, 0xc6, 0xe6, 0xe3, 0x6f, 0xab, 0xa9, 0xe9, 0x50,
	0x6d, 0xa2, 0xa2, 0x88, 0x84, 0x24, 0x2d, 0x52, 0xe4, 0xd0, 0x02, 0x6c, 0x0c, 0xc4, 0x4d, 0x13,
	0x04, 0xeb, 0x24, 0x48, 0x03, 0x14, 0x02, 0x25, 0xad, 0x25, 0x22, 0x92, 0x48, 0x93, 0x2b, 0x21,
	0x3e, 0xf7, 0xde, 0x17, 0xe9, 0xa5, 0xe8, 0x33, 0xf4, 0x90, 0x63, 0x1f, 0xa0, 0x20, 0x5a, 0x1f,
	0x75, 0xd4, 0x13, 0x14, 0x3b, 0xcb, 0x2f, 0xd1, 0xa2, 0xa4, 0x34, 0xcd, 0xc1, 0x16, 0x77, 0x67,
	0x67, 0x76, 0xe6, 0x37, 0x33, 0xfb, 0x1b, 0xa8, 0x5a, 0xae, 0xdb, 0xf0, 0x99, 0x37, 0xb6, 0xdb,
	0xac, 0xd1, 0x6a, 0x9d, 0x34, 0xb8, 0xe3, 0xda, 0xed, 0x86, 0xe5, 0xda, 0xe2, 0xaf, 0xee, 0x7a,
	0x0e, 0x77, 0xc8, 0xe5, 0x56, 0xeb, 0xa4, 0x1e, 0x1e, 0xaa, 0xe3, 0x81, 0xfa, 0xf8, 0x76, 0xe5,
	0x56, 0xd7, 0xe6, 0xbd, 0x51, 0xab, 0xde, 0x76, 0x06, 0x8d, 0xae, 0xd3, 0x75, 0x1a, 0x78, 0xb8,
	0x35, 0x3a, 0xc6, 0x15, 0x2e, 0xf0, 0x4b, 0x1a, 0xa9, 0x7c, 0xd4, 0x75, 0x9c, 0x6e, 0x9f, 0x25,
	0xa7, 0xd8, 0xc0, 0xe5, 0xa7, 0x52, 0x68, 0xd4, 0x60, 0xfb, 0x7b, 0xdb, 0xe7, 0x07, 0x6f, 0x38,
	0x1b, 0xfa, 0xb6, 0x33, 0xa4, 0xec, 0x84, 0x5c, 0x86, 0x35, 0x7f, 0x6c, 0x77, 0xfc, 0x1d, 0x65,
	0x5f, 0xad, 0xa9, 0x54, 0x2e, 0x8c, 0x27, 0x40, 0x32, 0x27, 0xdd, 0xfe, 0x29, 0xf9, 0x0a, 0x8a,
	0x7d, 0xdb, 0xe7, 0x78, 0x74, 0xf3, 0xce, 0x27, 0xf5, 0x79, 0x0e, 0xd7, 0x5f, 0xd8, 0x1d, 0xe6,
	0x24, 0x8a, 0xa8, 0x61, 0x7c, 0x03, 0x97, 0x9e, 0xbb, 0x1d, 0x8b, 0x33, 0x94, 0x1e, 0xb5, 0x1d,
	0x8f, 0x89, 0xcb, 0x09, 0x14, 0xc5, 0x7d, 0x3b, 0xca, 0xbe, 0x52, 0x53, 0x29, 0x7e, 0xa3, 0x43,
	0x42, 0xbe, 0x53, 0xd8, 0x57, 0x6a, 0x0a, 0x95, 0x8b, 0xac, 0x01, 0x6e, 0xf1, 0x85, 0x06, 0x84,
	0x1c, 0x0d, 0xac, 0x51, 0xb9, 0x30, 0x7e, 0x53, 0xe0, 0xe2, 0x33, 0xe1, 0x23, 0x1a, 0xf0, 0x85,
	0x72, 0x1d, 0x4a, 0xe8, 0x75, 0x33, 0x32, 0x60, 0x5e, 0x9a, 0x06, 0x7a, 0xf9, 0xd8, 0xf1, 0x06,
	0xf7, 0x8d, 0x48, 0x62, 0xd0, 0x0d, 0xfc, 0x3c, 0xec, 0x90, 0x7b, 0xb0, 0xd9, 0x1e, 0x79, 0xbe,
	0xe3, 0x35, 0x5d, 0x8f, 0x8d, 0xd1, 0xbc, 0x66, 0x5e, 0x9d, 0x06, 0x3a, 0x91, 0x2a, 0x29, 0xa1,
	0x41, 0x41, 0xae, 0x9e, 0x7a, 0x6c, 0x9c, 0x52, 0x1c, 0xb2, 0x37, 0x7c, 0x47, 0xcd, 0x51, 0x14,
	0xc2, 0x58, 0xf1, 0x89, 0x58, 0x1c, 0xc1, 0xff, 0x45, 0x1a, 0x1e, 0x8f, 0xfa, 0xdc, 0xce, 0x38,
	0xbf, 0x52, 0x2e, 0x66, 0x75, 0xc2, 0x5c, 0xfc, 0x08, 0x1a, 0x6e, 0x1d, 0x72, 0x36, 0x98, 0x0b,
	0xe0, 0x75, 0xb8, 0x10, 0x7a, 0x34, 0xb6, 0xfa, 0x23, 0x89, 0xa3, 0x46, 0xc3, 0x10, 0x5e, 0x88,
	0x2d, 0xb2, 0x0b, 0xa5, 0x9e, 0xc3, 0x9b, 0xfc, 0xd4, 0x65, 0x18, 0x8e, 0x4a, 0x37, 0x7a, 0x0e,
	0x7f, 0x76, 0xea, 0x32, 0xe3, 0x17, 0x05, 0x36, 0xf1, 0xde, 0x07, 0x8c, 0x5b, 0x76, 0x9f, 0x7c,
	0x0d, 0x10, 0x62, 0x39, 0x3c, 0x76, 0xf0, 0x9e, 0xcd, 0x3b, 0xfa, 0x02, 0x77, 0x0f, 0x87, 0xc7,
	0x0e, 0xd5, 0x78, 0xf4, 0x49, 0xee, 0x86, 0x81, 0x16, 0x30, 0x50, 0x7d, 0x41, 0xd1, 0x89, 0x80,
	0x64, 0x8c, 0xe4, 0x26, 0x94, 0x7a, 0x96, 0xdf, 0x1c, 0x88, 0x3a, 0x12, 0xfe, 0x95, 0xcc, 0x0b,
	0x93, 0x40, 0x8f, 0xf7, 0xe8, 0x46, 0xcf, 0xf2, 0x1f, 0x8b, 0xba, 0x7a, 0x0a, 0x57, 0x04, 0xc2,
	0x0f, 0x6c, 0xbf, 0xed, 0x8c, 0x99, 0x77, 0x8a, 0x2e, 0x08, 0x7c, 0xef, 0x41, 0xd1, 0xb5, 0xba,
	0x0c, 0x1d, 0x5e, 0x33, 0xab, 0xd3, 0x40, 0xd7, 0x65, 0xb2, 0xc4, 0xae, 0xb1, 0x3f, 0xb6, 0xfa,
	0xb6, 0x28, 0xc7, 0xfb, 0x86, 0xc7, 0x4e, 0x46, 0xb6, 0xc7, 0x3a, 0x06, 0x45, 0x05, 0xe3, 0xb5,
	0xcc, 0x59, 0xd6, 0xa2, 0xe8, 0x9f, 0x2f, 0x67, 0x72, 0x76, 0x7d, 0x01, 0x08, 0x12, 0xbb, 0x30,
	0x98, 0xdd, 0x54, 0x30, 0x22, 0x17, 0xa5, 0xc4, 0xfd, 0x87, 0xb0, 0x25, 0x2e, 0x43, 0x1d, 0xff,
	0xbd, 0xdc, 0x76, 0xa0, 0x9c, 0xb6, 0x24, 0xdc, 0x4d, 0x83, 0xa8, 0x2c, 0x00, 0x71, 0xb5, 0x14,
	0x25, 0xc9, 0x95, 0x65, 0xe8, 0xc1, 0xd6, 0x11, 0xb7, 0xdb, 0xaf, 0x63, 0xc4, 0xcd, 0x73, 0xed,
	0x78, 0x73, 0x1a, 0xe8, 0xd5, 0x4c, 0x3b, 0xce, 0x0d, 0x21, 0x6e, 0xd1, 0x8f, 0xa1, 0xe0, 0xb8,
	0x08, 0x92, 0x6a, 0x6e, 0x4d, 0x03, 0x5d, 0x93, 0xda, 0x8e, 0x6b, 0xd0, 0x82, 0xe3, 0x1a, 0xbf,
	0x2a, 0x40, 0x92, 0x4b, 0xb1, 0x68, 0xfe, 0xab, 0x9b, 0xef, 0x85, 0x8d, 0x24, 0xef, 0x4e, 0x01,
	0x2f, 0x76, 0x73, 0x80, 0xc7, 0x6e, 0x93, 0x2e, 0xab, 0x79, 0x2e, 0xff, 0xa4, 0xc0, 0x95, 0x23,
	0xc6, 0x3f, 0x90, 0xd7, 0x37, 0xa2, 0xd7, 0x5f, 0xa4, 0x4e, 0x35, 0xb7, 0xa7, 0x81, 0x7e, 0x21,
	0x71, 0xdb, 0x37, 0x22, 0x3e, 0x78, 0xab, 0x48, 0xea, 0xf8, 0x76, 0xe0, 0xbf, 0x7f, 0xad, 0x91,
	0x2a, 0x14, 0x87, 0xd6, 0x20, 0x7c, 0x58, 0xcc, 0xf2, 0x34, 0xd0, 0x37, 0xa5, 0xa2, 0xd8, 0x35,
	0x28, 0x0a, 0x67, 0x5e, 0x67, 0x75, 0x85, 0xd7, 0xf9, 0x46, 0xf4, 0xec, 0x17, 0xd1, 0x9d, 0x74,
	0x28, 0x48, 0x00, 0x11, 0x11, 0x78, 0x92, 0xda, 0x52, 0x91, 0x7c, 0xf8, 0x5a, 0x7f, 0x9d, 0xe6,
	0x1e, 0x7c, 0x77, 0x77, 0xb3, 0xc9, 0x4b, 0x02, 0x21, 0xe9, 0x4a, 0xca, 0x92, 0xa2, 0x9a, 0x22,
	0xc5, 0x84, 0xe9, 0x8a, 0x69, 0xa6, 0xfb, 0x02, 0xb6, 0xf0, 0x9e, 0xb8, 0xb1, 0xaa, 0xe9, 0x37,
	0x3e, 0x0d, 0x37, 0x96, 0xa6, 0xbc, 0xc1, 0x78, 0x04, 0xe5, 0xb4, 0xd6, 0xca, 0x74, 0x3f, 0x1b,
	0x57, 0x18, 0x6f, 0x27, 0x62, 0x6b, 0x94, 0xc6, 0x6c, 0xfd, 0xae, 0x84, 0x9b, 0x74, 0xf3, 0xda,
	0xbc, 0xd6, 0xf8, 0xb9, 0x00, 0x5a, 0x8c, 0xf4, 0x3b, 0x1b, 0x27, 0xe9, 0x22, 0x0c, 0x6b, 0xae,
	0x0a, 0xc5, 0x0e, 0xf3, 0xdb, 0x21, 0x43, 0xa7, 0x90, 0x12, 0xbb, 0x06, 0x45, 0x61, 0x92, 0x8b,
	0x62, 0x3a, 0x17, 0x71, 0xf9, 0xad, 0x2d, 0x2c, 0x3f, 0x2c, 0xb4, 0x88, 0x39, 0xd7, 0xf1, 0xa8,
	0x2c, 0xb4, 0x70, 0x2f, 0xe6, 0x51, 0x72, 0x1b, 0x34, 0x24, 0x90, 0xe6, 0xc8, 0xeb, 0xef, 0x6c,
	0xa0, 0x43, 0x97, 0xa7, 0x81, 0xbe, 0x1d, 0x8e, 0x0c, 0x91, 0xc8, 0xa0, 0x25, 0xfc, 0x7e, 0xee,
	0xf5, 0x8d, 0xdf, 0xc5, 0x8c, 0x63, 0xf3, 0x3e, 0x3b, 0x78, 0xc3, 0x3d, 0x0b, 0xeb, 0xec, 0x2a,
	0x14, 0x62, 0x3c, 0xd6, 0x27, 0x81, 0x5e, 0xb0, 0x3b, 0xb4, 0x60, 0x77, 0xc8, 0x35, 0x28, 0xa2,
	0x0b, 0xf2, 0xb9, 0x2a, 0x4d, 0x02, 0x1d, 0xd7, 0x14, 0xff, 0x0b, 0x29, 0x62, 0x23, 0x71, 0x40,
	0xa9, 0x58, 0x87, 0x28, 0xe9, 0x18, 0xaa, 0xc7, 0x11, 0x00, 0xd5, 0xd4, 0x26, 0x81, 0x2e, 0x37,
	0xa8, 0xfc, 0x21, 0xbb, 0xa0, 0xb2, 0x61, 0x07, 0x91, 0x50, 0xcd, 0x8d, 0x49, 0xa0, 0x8b, 0x25,
	0x15, 0xff, 0x88, 0x01, 0xeb, 0x7e, 0xbb, 0xc7, 0x06, 0x32, 0x78, 0xcd, 0x84, 0x49, 0xa0, 0x87,
	0x3b, 0x34, 0xfc, 0x35, 0x4c, 0xb8, 0x38, 0x3b, 0x44, 0xce, 0x9d, 0x52, 0xae, 0x81, 0xc6, 0xa2,
	0x03, 0x61, 0x12, 0x93, 0x0d, 0x83, 0x82, 0x96, 0xa8, 0x1f, 0xc0, 0x26, 0x17, 0xb0, 0x34, 0x99,
	0xc0, 0x65, 0x49, 0x3d, 0xcf, 0xe0, 0x47, 0x81, 0xc7, 0xeb, 0x3b, 0x7f, 0x6a, 0xb0, 0x86, 0xf5,
	0x46, 0x1e, 0x42, 0x89, 0xb2, 0xae, 0xed, 0x73, 0xe6, 0x91, 0x95, 0xc6, 0xe0, 0xca, 0xd5, 0xba,
	0x1c, 0xcc, 0xeb, 0xd1, 0x60, 0x5e, 0x3f, 0x10, 0x83, 0x39, 0xb1, 0x24, 0x81, 0x27, 0xbe, 0xde,
	0x98, 0x6f, 0x2e, 0x3b, 0xb7, 0x57, 0x6a, 0x2b, 0x9d, 0x13, 0x6d, 0xfc, 0x1c, 0xb6, 0xb3, 0xb3,
	0x37, 0xf9, 0x6c, 0xbe, 0xf6, 0x9c, 0x19, 0x3d, 0xd7, 0xf3, 0x8c, 0x59, 0x2c, 0xee, 0x15, 0xcc,
	0x86, 0x6f, 0x41, 0xae, 0xd9, 0x57, 0xa9, 0x39, 0x44, 0x4e, 0xae, 0x64, 0xa5, 0xe1, 0xb6, 0xb2,
	0x7c, 0x9c, 0x22, 0x27, 0x70, 0xe9, 0xfc, 0x68, 0xe6, 0x93, 0xcf, 0xf3, 0xa1, 0x3c, 0x37, 0x17,
	0x56, 0x6e, 0xad, 0x7e, 0x58, 0x80, 0xff, 0x12, 0x20, 0x19, 0xab, 0x48, 0x35, 0x5f, 0x39, 0xa6,
	0xd5, 0xca, 0xa7, 0xcb, 0x0f, 0x09, 0xcb, 0x87, 0x00, 0xc9, 0x50, 0x90, 0x67, 0x79, 0x66, 0xc2,
	0xca, 0xc5, 0xfc, 0x08, 0xca, 0x99, 0xf9, 0x82, 0xd4, 0x96, 0xd9, 0x8b, 0xc6, 0x90, 0x5c, 0xa3,
	0x3f, 0x00, 0x39, 0x3f, 0xb7, 0xe4, 0x61, 0x3d, 0x77, 0xc2, 0x59, 0xd6, 0x34, 0x31, 0x85, 0x2f,
	0x6a, 0x9a, 0xf4, 0xc4, 0xb2, 0xa8, 0x69, 0x32, 0xf3, 0xc0, 0x77, 0x50, 0x4e, 0x31, 0xd8, 0x03,
	0xf1, 0xee, 0x2f, 0xe3, 0xfa, 0x5c, 0x77, 0x1f, 0x45, 0x9d, 0x92, 0xb0, 0xe1, 0xbf, 0x37, 0xf6,
	0x12, 0x20, 0xe1, 0xe9, 0xbc, 0xb4, 0xcf, 0xf0, 0x7f, 0x5e, 0x41, 0x65, 0xe8, 0xde, 0xbc, 0xf2,
	0xf6, 0xef, 0xbd, 0xff, 0xbd, 0x3d, 0xdb, 0x53, 0xfe, 0x38, 0xdb, 0x53, 0xfe, 0x3a, 0xdb, 0x53,
	0x5e, 0xa9, 0x96, 0x6b, 0xb7, 0xd6, 0xd1, 0x81, 0xbb, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x51,
	0x5d, 0x7d, 0x73, 0xc4, 0x10, 0x00, 0x00,
}
