// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/bbq/search/api/grpc/v1/api.proto

/*
	Package v1 is a generated protocol buffer package.

	It is generated from these files:
		app/service/bbq/search/api/grpc/v1/api.proto

	It has these top-level messages:
		SaveVideoRequest
		VideoESInfo
		VideoESTags
		SaveVideoResponse
		RecVideoInfo
		RecVideoDataRequest
		RecVideoDataResponse
		VideoDataRequest
		VideoDataResponse
		ESVideoDataRequest
		ESVideoDataResponse
		DelVideoBySVIDRequest
		DelVideoBySVIDResponse
*/
package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SaveVideoRequest struct {
	List []*VideoESInfo `protobuf:"bytes,1,rep,name=list" json:"list" form:"list" validate:"required"`
}

func (m *SaveVideoRequest) Reset()                    { *m = SaveVideoRequest{} }
func (*SaveVideoRequest) ProtoMessage()               {}
func (*SaveVideoRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

type VideoESInfo struct {
	SVID               int64          `protobuf:"varint,1,opt,name=svid,proto3" json:"svid" form:"svid"`
	Title              string         `protobuf:"bytes,2,opt,name=title,proto3" json:"title" form:"title"`
	Content            string         `protobuf:"bytes,3,opt,name=content,proto3" json:"content" form:"content"`
	MID                int64          `protobuf:"varint,4,opt,name=mid,proto3" json:"mid" form:"mid"`
	CID                int64          `protobuf:"varint,5,opt,name=cid,proto3" json:"cid" form:"cid"`
	Pubtime            int64          `protobuf:"varint,6,opt,name=pubtime,proto3" json:"pubtime" form:"pubtime"`
	Ctime              int64          `protobuf:"varint,7,opt,name=ctime,proto3" json:"ctime" form:"ctime"`
	Mtime              int64          `protobuf:"varint,8,opt,name=mtime,proto3" json:"mtime" form:"mtime"`
	Duration           int64          `protobuf:"varint,9,opt,name=duration,proto3" json:"duration" form:"duration"`
	Original           int64          `protobuf:"varint,10,opt,name=original,proto3" json:"original" form:"original"`
	State              int64          `protobuf:"varint,11,opt,name=state,proto3" json:"state" form:"state"`
	VerID              int64          `protobuf:"varint,12,opt,name=ver_id,json=verId,proto3" json:"ver_id" form:"ver_id"`
	Ver                string         `protobuf:"bytes,13,opt,name=ver,proto3" json:"ver" form:"ver"`
	From               int64          `protobuf:"varint,14,opt,name=from,proto3" json:"from" form:"from"`
	AVID               int64          `protobuf:"varint,15,opt,name=avid,proto3" json:"avid" form:"avid"`
	Tid                int64          `protobuf:"varint,16,opt,name=tid,proto3" json:"tid" form:"tid"`
	SubTid             int64          `protobuf:"varint,17,opt,name=sub_tid,json=subTid,proto3" json:"sub_tid" form:"sub_tid"`
	Score              int64          `protobuf:"varint,18,opt,name=score,proto3" json:"score" form:"score"`
	RoughScore         int64          `protobuf:"varint,19,opt,name=rough_score,json=roughScore,proto3" json:"rough_score" form:"rough_score"`
	Tags               []*VideoESTags `protobuf:"bytes,20,rep,name=tags" json:"tags" form:"tags"`
	PlayHive           int64          `protobuf:"varint,21,opt,name=play_hive,json=playHive,proto3" json:"play_hive" form:"play_hive"`
	FavHive            int64          `protobuf:"varint,22,opt,name=fav_hive,json=favHive,proto3" json:"fav_hive" form:"fav_hive"`
	CoinHive           int64          `protobuf:"varint,23,opt,name=coin_hive,json=coinHive,proto3" json:"coin_hive" form:"coin_hive"`
	SubtitlesHive      int64          `protobuf:"varint,24,opt,name=subtitles_hive,json=subtitlesHive,proto3" json:"subtitles_hive" form:"subtitles_hive"`
	LikesHive          int64          `protobuf:"varint,25,opt,name=likes_hive,json=likesHive,proto3" json:"likes_hive" form:"likes_hive"`
	ShareHive          int64          `protobuf:"varint,26,opt,name=share_hive,json=shareHive,proto3" json:"share_hive" form:"share_hive"`
	ReportHive         int64          `protobuf:"varint,27,opt,name=report_hive,json=reportHive,proto3" json:"report_hive" form:"report_hive"`
	DurationDailyHive  int64          `protobuf:"varint,28,opt,name=duration_daily_hive,json=durationDailyHive,proto3" json:"duration_daily_hive" form:"duration_daily_hive"`
	DurationAllHive    int64          `protobuf:"varint,29,opt,name=duration_all_hive,json=durationAllHive,proto3" json:"duration_all_hive" form:"duration_all_hive"`
	ReplyHive          int64          `protobuf:"varint,30,opt,name=reply_hive,json=replyHive,proto3" json:"reply_hive" form:"reply_hive"`
	ShareDailyHive     int64          `protobuf:"varint,31,opt,name=share_daily_hive,json=shareDailyHive,proto3" json:"share_daily_hive" form:"share_daily_hive"`
	PlayDailyHive      int64          `protobuf:"varint,32,opt,name=play_daily_hive,json=playDailyHive,proto3" json:"play_daily_hive" form:"play_daily_hive"`
	SubtitlesDailyHive int64          `protobuf:"varint,33,opt,name=subtitles_daily_hive,json=subtitlesDailyHive,proto3" json:"subtitles_daily_hive" form:"subtitles_daily_hive"`
	LikesDailyHive     int64          `protobuf:"varint,34,opt,name=likes_daily_hive,json=likesDailyHive,proto3" json:"likes_daily_hive" form:"likes_daily_hive"`
	FavDailyHive       int64          `protobuf:"varint,35,opt,name=fav_daily_hive,json=favDailyHive,proto3" json:"fav_daily_hive" form:"fav_daily_hive"`
	ReplyDailyHive     int64          `protobuf:"varint,36,opt,name=reply_daily_hive,json=replyDailyHive,proto3" json:"reply_daily_hive" form:"reply_daily_hive"`
	AccessHive         int64          `protobuf:"varint,37,opt,name=access_hive,json=accessHive,proto3" json:"access_hive" form:"access_hive"`
	Play               int64          `protobuf:"varint,38,opt,name=play,proto3" json:"play" form:"play"`
	Subtitles          int64          `protobuf:"varint,39,opt,name=subtitles,proto3" json:"subtitles" form:"subtitles"`
	Like               int64          `protobuf:"varint,40,opt,name=like,proto3" json:"like" form:"like"`
	Share              int64          `protobuf:"varint,41,opt,name=share,proto3" json:"share" form:"share"`
	Report             int64          `protobuf:"varint,42,opt,name=report,proto3" json:"report" form:"report"`
	SimilarID          []int64        `protobuf:"varint,43,rep,packed,name=similar_id,json=similarId" json:"similar_id" form:"similar_id"`
	ISFullScreen       int64          `protobuf:"varint,44,opt,name=is_full_screen,json=isFullScreen,proto3" json:"is_full_screen" form:"is_full_screen"`
}

func (m *VideoESInfo) Reset()                    { *m = VideoESInfo{} }
func (*VideoESInfo) ProtoMessage()               {}
func (*VideoESInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

type VideoESTags struct {
	ID   int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id" form:"id"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name" form:"name"`
	Type int64  `protobuf:"varint,3,opt,name=type,proto3" json:"type" form:"type"`
}

func (m *VideoESTags) Reset()                    { *m = VideoESTags{} }
func (*VideoESTags) ProtoMessage()               {}
func (*VideoESTags) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

type SaveVideoResponse struct {
}

func (m *SaveVideoResponse) Reset()                    { *m = SaveVideoResponse{} }
func (*SaveVideoResponse) ProtoMessage()               {}
func (*SaveVideoResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

type RecVideoInfo struct {
	SVID               int64          `protobuf:"varint,1,opt,name=svid,proto3" json:"svid" form:"svid"`
	Title              string         `protobuf:"bytes,2,opt,name=title,proto3" json:"title" form:"title"`
	Content            string         `protobuf:"bytes,3,opt,name=content,proto3" json:"content" form:"content"`
	MID                int64          `protobuf:"varint,4,opt,name=mid,proto3" json:"mid" form:"mid"`
	CID                int64          `protobuf:"varint,5,opt,name=cid,proto3" json:"cid" form:"cid"`
	Pubtime            int64          `protobuf:"varint,6,opt,name=pubtime,proto3" json:"pubtime" form:"pubtime"`
	Ctime              int64          `protobuf:"varint,7,opt,name=ctime,proto3" json:"ctime" form:"ctime"`
	Mtime              int64          `protobuf:"varint,8,opt,name=mtime,proto3" json:"mtime" form:"mtime"`
	Duration           int64          `protobuf:"varint,9,opt,name=duration,proto3" json:"duration" form:"duration"`
	Original           int64          `protobuf:"varint,10,opt,name=original,proto3" json:"original" form:"original"`
	State              int64          `protobuf:"varint,11,opt,name=state,proto3" json:"state" form:"state"`
	VerID              int64          `protobuf:"varint,12,opt,name=ver_id,json=verId,proto3" json:"ver_id" form:"ver_id"`
	Ver                string         `protobuf:"bytes,13,opt,name=ver,proto3" json:"ver" form:"ver"`
	From               int64          `protobuf:"varint,14,opt,name=from,proto3" json:"from" form:"from"`
	AVID               int64          `protobuf:"varint,15,opt,name=avid,proto3" json:"avid" form:"avid"`
	Tid                int64          `protobuf:"varint,16,opt,name=tid,proto3" json:"tid" form:"tid"`
	SubTid             int64          `protobuf:"varint,17,opt,name=sub_tid,json=subTid,proto3" json:"sub_tid" form:"sub_tid"`
	Score              int64          `protobuf:"varint,18,opt,name=score,proto3" json:"score" form:"score"`
	RoughScore         int64          `protobuf:"varint,19,opt,name=rough_score,json=roughScore,proto3" json:"rough_score" form:"rough_score"`
	Tags               []*VideoESTags `protobuf:"bytes,20,rep,name=tags" json:"tags" form:"tags"`
	PlayHive           int64          `protobuf:"varint,21,opt,name=play_hive,json=playHive,proto3" json:"play_hive" form:"play_hive"`
	FavHive            int64          `protobuf:"varint,22,opt,name=fav_hive,json=favHive,proto3" json:"fav_hive" form:"fav_hive"`
	CoinHive           int64          `protobuf:"varint,23,opt,name=coin_hive,json=coinHive,proto3" json:"coin_hive" form:"coin_hive"`
	SubtitlesHive      int64          `protobuf:"varint,24,opt,name=subtitles_hive,json=subtitlesHive,proto3" json:"subtitles_hive" form:"subtitles_hive"`
	LikesHive          int64          `protobuf:"varint,25,opt,name=likes_hive,json=likesHive,proto3" json:"likes_hive" form:"likes_hive"`
	ShareHive          int64          `protobuf:"varint,26,opt,name=share_hive,json=shareHive,proto3" json:"share_hive" form:"share_hive"`
	ReportHive         int64          `protobuf:"varint,27,opt,name=report_hive,json=reportHive,proto3" json:"report_hive" form:"report_hive"`
	DurationDailyHive  int64          `protobuf:"varint,28,opt,name=duration_daily_hive,json=durationDailyHive,proto3" json:"duration_daily_hive" form:"duration_daily_hive"`
	DurationAllHive    int64          `protobuf:"varint,29,opt,name=duration_all_hive,json=durationAllHive,proto3" json:"duration_all_hive" form:"duration_all_hive"`
	ReplyHive          int64          `protobuf:"varint,30,opt,name=reply_hive,json=replyHive,proto3" json:"reply_hive" form:"reply_hive"`
	ShareDailyHive     int64          `protobuf:"varint,31,opt,name=share_daily_hive,json=shareDailyHive,proto3" json:"share_daily_hive" form:"share_daily_hive"`
	PlayDailyHive      int64          `protobuf:"varint,32,opt,name=play_daily_hive,json=playDailyHive,proto3" json:"play_daily_hive" form:"play_daily_hive"`
	SubtitlesDailyHive int64          `protobuf:"varint,33,opt,name=subtitles_daily_hive,json=subtitlesDailyHive,proto3" json:"subtitles_daily_hive" form:"subtitles_daily_hive"`
	LikesDailyHive     int64          `protobuf:"varint,34,opt,name=likes_daily_hive,json=likesDailyHive,proto3" json:"likes_daily_hive" form:"likes_daily_hive"`
	FavDailyHive       int64          `protobuf:"varint,35,opt,name=fav_daily_hive,json=favDailyHive,proto3" json:"fav_daily_hive" form:"fav_daily_hive"`
	ReplyDailyHive     int64          `protobuf:"varint,36,opt,name=reply_daily_hive,json=replyDailyHive,proto3" json:"reply_daily_hive" form:"reply_daily_hive"`
	AccessHive         int64          `protobuf:"varint,37,opt,name=access_hive,json=accessHive,proto3" json:"access_hive" form:"access_hive"`
	Play               int64          `protobuf:"varint,38,opt,name=play,proto3" json:"play" form:"play"`
	Subtitles          int64          `protobuf:"varint,39,opt,name=subtitles,proto3" json:"subtitles" form:"subtitles"`
	Like               int64          `protobuf:"varint,40,opt,name=like,proto3" json:"like" form:"like"`
	Share              int64          `protobuf:"varint,41,opt,name=share,proto3" json:"share" form:"share"`
	Report             int64          `protobuf:"varint,42,opt,name=report,proto3" json:"report" form:"report"`
	SimilarID          []int64        `protobuf:"varint,43,rep,packed,name=similar_id,json=similarId" json:"similar_id" form:"similar_id"`
	ESScore            float64        `protobuf:"fixed32,44,opt,name=es_score,json=esScore,proto3,casttype=float64" json:"es_score" form:"es_score"`
	CustomScore        []float64      `protobuf:"fixed32,45,rep,packed,name=custom_score,json=customScore,casttype=float64" json:"custom_score" form:"custom_score"`
	ISFullScreen       int64          `protobuf:"varint,46,opt,name=is_full_screen,json=isFullScreen,proto3" json:"is_full_screen" form:"is_full_screen"`
}

func (m *RecVideoInfo) Reset()                    { *m = RecVideoInfo{} }
func (*RecVideoInfo) ProtoMessage()               {}
func (*RecVideoInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

type RecVideoDataRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query" form:"query" validate:"required"`
}

func (m *RecVideoDataRequest) Reset()                    { *m = RecVideoDataRequest{} }
func (*RecVideoDataRequest) ProtoMessage()               {}
func (*RecVideoDataRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

type RecVideoDataResponse struct {
	Total int64           `protobuf:"varint,1,opt,name=total,proto3" json:"total"`
	List  []*RecVideoInfo `protobuf:"bytes,2,rep,name=list" json:"list"`
}

func (m *RecVideoDataResponse) Reset()                    { *m = RecVideoDataResponse{} }
func (*RecVideoDataResponse) ProtoMessage()               {}
func (*RecVideoDataResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

type VideoDataRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query" form:"query" validate:"required"`
}

func (m *VideoDataRequest) Reset()                    { *m = VideoDataRequest{} }
func (*VideoDataRequest) ProtoMessage()               {}
func (*VideoDataRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

type VideoDataResponse struct {
	Total int64          `protobuf:"varint,1,opt,name=total,proto3" json:"total"`
	List  []*VideoESInfo `protobuf:"bytes,2,rep,name=list" json:"list"`
}

func (m *VideoDataResponse) Reset()                    { *m = VideoDataResponse{} }
func (*VideoDataResponse) ProtoMessage()               {}
func (*VideoDataResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

type ESVideoDataRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query" form:"query" validate:"required"`
}

func (m *ESVideoDataRequest) Reset()                    { *m = ESVideoDataRequest{} }
func (*ESVideoDataRequest) ProtoMessage()               {}
func (*ESVideoDataRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

type ESVideoDataResponse struct {
	Total int64           `protobuf:"varint,1,opt,name=total,proto3" json:"total"`
	List  []*RecVideoInfo `protobuf:"bytes,2,rep,name=list" json:"list"`
}

func (m *ESVideoDataResponse) Reset()                    { *m = ESVideoDataResponse{} }
func (*ESVideoDataResponse) ProtoMessage()               {}
func (*ESVideoDataResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

type DelVideoBySVIDRequest struct {
	SVIDs []int64 `protobuf:"varint,1,rep,packed,name=svids" json:"query" form:"svids" validate:"required"`
}

func (m *DelVideoBySVIDRequest) Reset()                    { *m = DelVideoBySVIDRequest{} }
func (*DelVideoBySVIDRequest) ProtoMessage()               {}
func (*DelVideoBySVIDRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

type DelVideoBySVIDResponse struct {
}

func (m *DelVideoBySVIDResponse) Reset()                    { *m = DelVideoBySVIDResponse{} }
func (*DelVideoBySVIDResponse) ProtoMessage()               {}
func (*DelVideoBySVIDResponse) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

func init() {
	proto.RegisterType((*SaveVideoRequest)(nil), "bbq.service.search.v1.SaveVideoRequest")
	proto.RegisterType((*VideoESInfo)(nil), "bbq.service.search.v1.VideoESInfo")
	proto.RegisterType((*VideoESTags)(nil), "bbq.service.search.v1.VideoESTags")
	proto.RegisterType((*SaveVideoResponse)(nil), "bbq.service.search.v1.SaveVideoResponse")
	proto.RegisterType((*RecVideoInfo)(nil), "bbq.service.search.v1.RecVideoInfo")
	proto.RegisterType((*RecVideoDataRequest)(nil), "bbq.service.search.v1.RecVideoDataRequest")
	proto.RegisterType((*RecVideoDataResponse)(nil), "bbq.service.search.v1.RecVideoDataResponse")
	proto.RegisterType((*VideoDataRequest)(nil), "bbq.service.search.v1.VideoDataRequest")
	proto.RegisterType((*VideoDataResponse)(nil), "bbq.service.search.v1.VideoDataResponse")
	proto.RegisterType((*ESVideoDataRequest)(nil), "bbq.service.search.v1.ESVideoDataRequest")
	proto.RegisterType((*ESVideoDataResponse)(nil), "bbq.service.search.v1.ESVideoDataResponse")
	proto.RegisterType((*DelVideoBySVIDRequest)(nil), "bbq.service.search.v1.DelVideoBySVIDRequest")
	proto.RegisterType((*DelVideoBySVIDResponse)(nil), "bbq.service.search.v1.DelVideoBySVIDResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Search service

type SearchClient interface {
	SaveVideo(ctx context.Context, in *SaveVideoRequest, opts ...grpc.CallOption) (*SaveVideoResponse, error)
	VideoData(ctx context.Context, in *VideoDataRequest, opts ...grpc.CallOption) (*VideoDataResponse, error)
	RecVideoData(ctx context.Context, in *RecVideoDataRequest, opts ...grpc.CallOption) (*RecVideoDataResponse, error)
	ESVideoData(ctx context.Context, in *ESVideoDataRequest, opts ...grpc.CallOption) (*ESVideoDataResponse, error)
	DelVideoBySVID(ctx context.Context, in *DelVideoBySVIDRequest, opts ...grpc.CallOption) (*DelVideoBySVIDResponse, error)
}

type searchClient struct {
	cc *grpc.ClientConn
}

func NewSearchClient(cc *grpc.ClientConn) SearchClient {
	return &searchClient{cc}
}

func (c *searchClient) SaveVideo(ctx context.Context, in *SaveVideoRequest, opts ...grpc.CallOption) (*SaveVideoResponse, error) {
	out := new(SaveVideoResponse)
	err := grpc.Invoke(ctx, "/bbq.service.search.v1.Search/SaveVideo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) VideoData(ctx context.Context, in *VideoDataRequest, opts ...grpc.CallOption) (*VideoDataResponse, error) {
	out := new(VideoDataResponse)
	err := grpc.Invoke(ctx, "/bbq.service.search.v1.Search/VideoData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) RecVideoData(ctx context.Context, in *RecVideoDataRequest, opts ...grpc.CallOption) (*RecVideoDataResponse, error) {
	out := new(RecVideoDataResponse)
	err := grpc.Invoke(ctx, "/bbq.service.search.v1.Search/RecVideoData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) ESVideoData(ctx context.Context, in *ESVideoDataRequest, opts ...grpc.CallOption) (*ESVideoDataResponse, error) {
	out := new(ESVideoDataResponse)
	err := grpc.Invoke(ctx, "/bbq.service.search.v1.Search/ESVideoData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) DelVideoBySVID(ctx context.Context, in *DelVideoBySVIDRequest, opts ...grpc.CallOption) (*DelVideoBySVIDResponse, error) {
	out := new(DelVideoBySVIDResponse)
	err := grpc.Invoke(ctx, "/bbq.service.search.v1.Search/DelVideoBySVID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Search service

type SearchServer interface {
	SaveVideo(context.Context, *SaveVideoRequest) (*SaveVideoResponse, error)
	VideoData(context.Context, *VideoDataRequest) (*VideoDataResponse, error)
	RecVideoData(context.Context, *RecVideoDataRequest) (*RecVideoDataResponse, error)
	ESVideoData(context.Context, *ESVideoDataRequest) (*ESVideoDataResponse, error)
	DelVideoBySVID(context.Context, *DelVideoBySVIDRequest) (*DelVideoBySVIDResponse, error)
}

func RegisterSearchServer(s *grpc.Server, srv SearchServer) {
	s.RegisterService(&_Search_serviceDesc, srv)
}

func _Search_SaveVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveVideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).SaveVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.search.v1.Search/SaveVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).SaveVideo(ctx, req.(*SaveVideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_VideoData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).VideoData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.search.v1.Search/VideoData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).VideoData(ctx, req.(*VideoDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_RecVideoData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecVideoDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).RecVideoData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.search.v1.Search/RecVideoData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).RecVideoData(ctx, req.(*RecVideoDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_ESVideoData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ESVideoDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).ESVideoData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.search.v1.Search/ESVideoData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).ESVideoData(ctx, req.(*ESVideoDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Search_DelVideoBySVID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelVideoBySVIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServer).DelVideoBySVID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bbq.service.search.v1.Search/DelVideoBySVID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServer).DelVideoBySVID(ctx, req.(*DelVideoBySVIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Search_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bbq.service.search.v1.Search",
	HandlerType: (*SearchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SaveVideo",
			Handler:    _Search_SaveVideo_Handler,
		},
		{
			MethodName: "VideoData",
			Handler:    _Search_VideoData_Handler,
		},
		{
			MethodName: "RecVideoData",
			Handler:    _Search_RecVideoData_Handler,
		},
		{
			MethodName: "ESVideoData",
			Handler:    _Search_ESVideoData_Handler,
		},
		{
			MethodName: "DelVideoBySVID",
			Handler:    _Search_DelVideoBySVID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/bbq/search/api/grpc/v1/api.proto",
}

func (m *SaveVideoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaveVideoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VideoESInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoESInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SVID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SVID))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.MID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MID))
	}
	if m.CID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CID))
	}
	if m.Pubtime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pubtime))
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mtime))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Duration))
	}
	if m.Original != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Original))
	}
	if m.State != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State))
	}
	if m.VerID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VerID))
	}
	if len(m.Ver) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ver)))
		i += copy(dAtA[i:], m.Ver)
	}
	if m.From != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.From))
	}
	if m.AVID != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AVID))
	}
	if m.Tid != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
	}
	if m.SubTid != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SubTid))
	}
	if m.Score != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
	}
	if m.RoughScore != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoughScore))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PlayHive != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayHive))
	}
	if m.FavHive != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FavHive))
	}
	if m.CoinHive != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CoinHive))
	}
	if m.SubtitlesHive != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SubtitlesHive))
	}
	if m.LikesHive != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LikesHive))
	}
	if m.ShareHive != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShareHive))
	}
	if m.ReportHive != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ReportHive))
	}
	if m.DurationDailyHive != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DurationDailyHive))
	}
	if m.DurationAllHive != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DurationAllHive))
	}
	if m.ReplyHive != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ReplyHive))
	}
	if m.ShareDailyHive != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShareDailyHive))
	}
	if m.PlayDailyHive != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayDailyHive))
	}
	if m.SubtitlesDailyHive != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SubtitlesDailyHive))
	}
	if m.LikesDailyHive != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LikesDailyHive))
	}
	if m.FavDailyHive != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FavDailyHive))
	}
	if m.ReplyDailyHive != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ReplyDailyHive))
	}
	if m.AccessHive != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AccessHive))
	}
	if m.Play != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Play))
	}
	if m.Subtitles != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Subtitles))
	}
	if m.Like != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Like))
	}
	if m.Share != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Share))
	}
	if m.Report != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Report))
	}
	if len(m.SimilarID) > 0 {
		dAtA2 := make([]byte, len(m.SimilarID)*10)
		var j1 int
		for _, num1 := range m.SimilarID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.ISFullScreen != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ISFullScreen))
	}
	return i, nil
}

func (m *VideoESTags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoESTags) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *SaveVideoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaveVideoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RecVideoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecVideoInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SVID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SVID))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.MID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MID))
	}
	if m.CID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CID))
	}
	if m.Pubtime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pubtime))
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mtime))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Duration))
	}
	if m.Original != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Original))
	}
	if m.State != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State))
	}
	if m.VerID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VerID))
	}
	if len(m.Ver) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ver)))
		i += copy(dAtA[i:], m.Ver)
	}
	if m.From != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.From))
	}
	if m.AVID != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AVID))
	}
	if m.Tid != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
	}
	if m.SubTid != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SubTid))
	}
	if m.Score != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
	}
	if m.RoughScore != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoughScore))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PlayHive != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayHive))
	}
	if m.FavHive != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FavHive))
	}
	if m.CoinHive != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CoinHive))
	}
	if m.SubtitlesHive != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SubtitlesHive))
	}
	if m.LikesHive != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LikesHive))
	}
	if m.ShareHive != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShareHive))
	}
	if m.ReportHive != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ReportHive))
	}
	if m.DurationDailyHive != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DurationDailyHive))
	}
	if m.DurationAllHive != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DurationAllHive))
	}
	if m.ReplyHive != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ReplyHive))
	}
	if m.ShareDailyHive != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShareDailyHive))
	}
	if m.PlayDailyHive != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlayDailyHive))
	}
	if m.SubtitlesDailyHive != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SubtitlesDailyHive))
	}
	if m.LikesDailyHive != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LikesDailyHive))
	}
	if m.FavDailyHive != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FavDailyHive))
	}
	if m.ReplyDailyHive != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ReplyDailyHive))
	}
	if m.AccessHive != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AccessHive))
	}
	if m.Play != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Play))
	}
	if m.Subtitles != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Subtitles))
	}
	if m.Like != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Like))
	}
	if m.Share != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Share))
	}
	if m.Report != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Report))
	}
	if len(m.SimilarID) > 0 {
		dAtA4 := make([]byte, len(m.SimilarID)*10)
		var j3 int
		for _, num1 := range m.SimilarID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.ESScore != 0 {
		dAtA[i] = 0xe5
		i++
		dAtA[i] = 0x2
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ESScore))))
		i += 4
	}
	if len(m.CustomScore) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CustomScore)*4))
		for _, num := range m.CustomScore {
			f5 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f5))
			i += 4
		}
	}
	if m.ISFullScreen != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ISFullScreen))
	}
	return i, nil
}

func (m *RecVideoDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecVideoDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	return i, nil
}

func (m *RecVideoDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecVideoDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VideoDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	return i, nil
}

func (m *VideoDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ESVideoDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ESVideoDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	return i, nil
}

func (m *ESVideoDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ESVideoDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DelVideoBySVIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelVideoBySVIDRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SVIDs) > 0 {
		dAtA7 := make([]byte, len(m.SVIDs)*10)
		var j6 int
		for _, num1 := range m.SVIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	return i, nil
}

func (m *DelVideoBySVIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelVideoBySVIDResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SaveVideoRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *VideoESInfo) Size() (n int) {
	var l int
	_ = l
	if m.SVID != 0 {
		n += 1 + sovApi(uint64(m.SVID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MID != 0 {
		n += 1 + sovApi(uint64(m.MID))
	}
	if m.CID != 0 {
		n += 1 + sovApi(uint64(m.CID))
	}
	if m.Pubtime != 0 {
		n += 1 + sovApi(uint64(m.Pubtime))
	}
	if m.Ctime != 0 {
		n += 1 + sovApi(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovApi(uint64(m.Mtime))
	}
	if m.Duration != 0 {
		n += 1 + sovApi(uint64(m.Duration))
	}
	if m.Original != 0 {
		n += 1 + sovApi(uint64(m.Original))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.VerID != 0 {
		n += 1 + sovApi(uint64(m.VerID))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovApi(uint64(m.From))
	}
	if m.AVID != 0 {
		n += 1 + sovApi(uint64(m.AVID))
	}
	if m.Tid != 0 {
		n += 2 + sovApi(uint64(m.Tid))
	}
	if m.SubTid != 0 {
		n += 2 + sovApi(uint64(m.SubTid))
	}
	if m.Score != 0 {
		n += 2 + sovApi(uint64(m.Score))
	}
	if m.RoughScore != 0 {
		n += 2 + sovApi(uint64(m.RoughScore))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.PlayHive != 0 {
		n += 2 + sovApi(uint64(m.PlayHive))
	}
	if m.FavHive != 0 {
		n += 2 + sovApi(uint64(m.FavHive))
	}
	if m.CoinHive != 0 {
		n += 2 + sovApi(uint64(m.CoinHive))
	}
	if m.SubtitlesHive != 0 {
		n += 2 + sovApi(uint64(m.SubtitlesHive))
	}
	if m.LikesHive != 0 {
		n += 2 + sovApi(uint64(m.LikesHive))
	}
	if m.ShareHive != 0 {
		n += 2 + sovApi(uint64(m.ShareHive))
	}
	if m.ReportHive != 0 {
		n += 2 + sovApi(uint64(m.ReportHive))
	}
	if m.DurationDailyHive != 0 {
		n += 2 + sovApi(uint64(m.DurationDailyHive))
	}
	if m.DurationAllHive != 0 {
		n += 2 + sovApi(uint64(m.DurationAllHive))
	}
	if m.ReplyHive != 0 {
		n += 2 + sovApi(uint64(m.ReplyHive))
	}
	if m.ShareDailyHive != 0 {
		n += 2 + sovApi(uint64(m.ShareDailyHive))
	}
	if m.PlayDailyHive != 0 {
		n += 2 + sovApi(uint64(m.PlayDailyHive))
	}
	if m.SubtitlesDailyHive != 0 {
		n += 2 + sovApi(uint64(m.SubtitlesDailyHive))
	}
	if m.LikesDailyHive != 0 {
		n += 2 + sovApi(uint64(m.LikesDailyHive))
	}
	if m.FavDailyHive != 0 {
		n += 2 + sovApi(uint64(m.FavDailyHive))
	}
	if m.ReplyDailyHive != 0 {
		n += 2 + sovApi(uint64(m.ReplyDailyHive))
	}
	if m.AccessHive != 0 {
		n += 2 + sovApi(uint64(m.AccessHive))
	}
	if m.Play != 0 {
		n += 2 + sovApi(uint64(m.Play))
	}
	if m.Subtitles != 0 {
		n += 2 + sovApi(uint64(m.Subtitles))
	}
	if m.Like != 0 {
		n += 2 + sovApi(uint64(m.Like))
	}
	if m.Share != 0 {
		n += 2 + sovApi(uint64(m.Share))
	}
	if m.Report != 0 {
		n += 2 + sovApi(uint64(m.Report))
	}
	if len(m.SimilarID) > 0 {
		l = 0
		for _, e := range m.SimilarID {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if m.ISFullScreen != 0 {
		n += 2 + sovApi(uint64(m.ISFullScreen))
	}
	return n
}

func (m *VideoESTags) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	return n
}

func (m *SaveVideoResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RecVideoInfo) Size() (n int) {
	var l int
	_ = l
	if m.SVID != 0 {
		n += 1 + sovApi(uint64(m.SVID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.MID != 0 {
		n += 1 + sovApi(uint64(m.MID))
	}
	if m.CID != 0 {
		n += 1 + sovApi(uint64(m.CID))
	}
	if m.Pubtime != 0 {
		n += 1 + sovApi(uint64(m.Pubtime))
	}
	if m.Ctime != 0 {
		n += 1 + sovApi(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovApi(uint64(m.Mtime))
	}
	if m.Duration != 0 {
		n += 1 + sovApi(uint64(m.Duration))
	}
	if m.Original != 0 {
		n += 1 + sovApi(uint64(m.Original))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.VerID != 0 {
		n += 1 + sovApi(uint64(m.VerID))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovApi(uint64(m.From))
	}
	if m.AVID != 0 {
		n += 1 + sovApi(uint64(m.AVID))
	}
	if m.Tid != 0 {
		n += 2 + sovApi(uint64(m.Tid))
	}
	if m.SubTid != 0 {
		n += 2 + sovApi(uint64(m.SubTid))
	}
	if m.Score != 0 {
		n += 2 + sovApi(uint64(m.Score))
	}
	if m.RoughScore != 0 {
		n += 2 + sovApi(uint64(m.RoughScore))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.PlayHive != 0 {
		n += 2 + sovApi(uint64(m.PlayHive))
	}
	if m.FavHive != 0 {
		n += 2 + sovApi(uint64(m.FavHive))
	}
	if m.CoinHive != 0 {
		n += 2 + sovApi(uint64(m.CoinHive))
	}
	if m.SubtitlesHive != 0 {
		n += 2 + sovApi(uint64(m.SubtitlesHive))
	}
	if m.LikesHive != 0 {
		n += 2 + sovApi(uint64(m.LikesHive))
	}
	if m.ShareHive != 0 {
		n += 2 + sovApi(uint64(m.ShareHive))
	}
	if m.ReportHive != 0 {
		n += 2 + sovApi(uint64(m.ReportHive))
	}
	if m.DurationDailyHive != 0 {
		n += 2 + sovApi(uint64(m.DurationDailyHive))
	}
	if m.DurationAllHive != 0 {
		n += 2 + sovApi(uint64(m.DurationAllHive))
	}
	if m.ReplyHive != 0 {
		n += 2 + sovApi(uint64(m.ReplyHive))
	}
	if m.ShareDailyHive != 0 {
		n += 2 + sovApi(uint64(m.ShareDailyHive))
	}
	if m.PlayDailyHive != 0 {
		n += 2 + sovApi(uint64(m.PlayDailyHive))
	}
	if m.SubtitlesDailyHive != 0 {
		n += 2 + sovApi(uint64(m.SubtitlesDailyHive))
	}
	if m.LikesDailyHive != 0 {
		n += 2 + sovApi(uint64(m.LikesDailyHive))
	}
	if m.FavDailyHive != 0 {
		n += 2 + sovApi(uint64(m.FavDailyHive))
	}
	if m.ReplyDailyHive != 0 {
		n += 2 + sovApi(uint64(m.ReplyDailyHive))
	}
	if m.AccessHive != 0 {
		n += 2 + sovApi(uint64(m.AccessHive))
	}
	if m.Play != 0 {
		n += 2 + sovApi(uint64(m.Play))
	}
	if m.Subtitles != 0 {
		n += 2 + sovApi(uint64(m.Subtitles))
	}
	if m.Like != 0 {
		n += 2 + sovApi(uint64(m.Like))
	}
	if m.Share != 0 {
		n += 2 + sovApi(uint64(m.Share))
	}
	if m.Report != 0 {
		n += 2 + sovApi(uint64(m.Report))
	}
	if len(m.SimilarID) > 0 {
		l = 0
		for _, e := range m.SimilarID {
			l += sovApi(uint64(e))
		}
		n += 2 + sovApi(uint64(l)) + l
	}
	if m.ESScore != 0 {
		n += 6
	}
	if len(m.CustomScore) > 0 {
		n += 2 + sovApi(uint64(len(m.CustomScore)*4)) + len(m.CustomScore)*4
	}
	if m.ISFullScreen != 0 {
		n += 2 + sovApi(uint64(m.ISFullScreen))
	}
	return n
}

func (m *RecVideoDataRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RecVideoDataResponse) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *VideoDataRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *VideoDataResponse) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ESVideoDataRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ESVideoDataResponse) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *DelVideoBySVIDRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.SVIDs) > 0 {
		l = 0
		for _, e := range m.SVIDs {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func (m *DelVideoBySVIDResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SaveVideoRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := ""
	return s
}
func (this *VideoESInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoESInfo{`,
		`SVID:` + fmt.Sprintf("%v", this.SVID) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`MID:` + fmt.Sprintf("%v", this.MID) + `,`,
		`CID:` + fmt.Sprintf("%v", this.CID) + `,`,
		`Pubtime:` + fmt.Sprintf("%v", this.Pubtime) + `,`,
		`Ctime:` + fmt.Sprintf("%v", this.Ctime) + `,`,
		`Mtime:` + fmt.Sprintf("%v", this.Mtime) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`Original:` + fmt.Sprintf("%v", this.Original) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`VerID:` + fmt.Sprintf("%v", this.VerID) + `,`,
		`Ver:` + fmt.Sprintf("%v", this.Ver) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`AVID:` + fmt.Sprintf("%v", this.AVID) + `,`,
		`Tid:` + fmt.Sprintf("%v", this.Tid) + `,`,
		`SubTid:` + fmt.Sprintf("%v", this.SubTid) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`RoughScore:` + fmt.Sprintf("%v", this.RoughScore) + `,`,
		`Tags:` + strings.Replace(fmt.Sprintf("%v", this.Tags), "VideoESTags", "VideoESTags", 1) + `,`,
		`PlayHive:` + fmt.Sprintf("%v", this.PlayHive) + `,`,
		`FavHive:` + fmt.Sprintf("%v", this.FavHive) + `,`,
		`CoinHive:` + fmt.Sprintf("%v", this.CoinHive) + `,`,
		`SubtitlesHive:` + fmt.Sprintf("%v", this.SubtitlesHive) + `,`,
		`LikesHive:` + fmt.Sprintf("%v", this.LikesHive) + `,`,
		`ShareHive:` + fmt.Sprintf("%v", this.ShareHive) + `,`,
		`ReportHive:` + fmt.Sprintf("%v", this.ReportHive) + `,`,
		`DurationDailyHive:` + fmt.Sprintf("%v", this.DurationDailyHive) + `,`,
		`DurationAllHive:` + fmt.Sprintf("%v", this.DurationAllHive) + `,`,
		`ReplyHive:` + fmt.Sprintf("%v", this.ReplyHive) + `,`,
		`ShareDailyHive:` + fmt.Sprintf("%v", this.ShareDailyHive) + `,`,
		`PlayDailyHive:` + fmt.Sprintf("%v", this.PlayDailyHive) + `,`,
		`SubtitlesDailyHive:` + fmt.Sprintf("%v", this.SubtitlesDailyHive) + `,`,
		`LikesDailyHive:` + fmt.Sprintf("%v", this.LikesDailyHive) + `,`,
		`FavDailyHive:` + fmt.Sprintf("%v", this.FavDailyHive) + `,`,
		`ReplyDailyHive:` + fmt.Sprintf("%v", this.ReplyDailyHive) + `,`,
		`AccessHive:` + fmt.Sprintf("%v", this.AccessHive) + `,`,
		`Play:` + fmt.Sprintf("%v", this.Play) + `,`,
		`Subtitles:` + fmt.Sprintf("%v", this.Subtitles) + `,`,
		`Like:` + fmt.Sprintf("%v", this.Like) + `,`,
		`Share:` + fmt.Sprintf("%v", this.Share) + `,`,
		`Report:` + fmt.Sprintf("%v", this.Report) + `,`,
		`SimilarID:` + fmt.Sprintf("%v", this.SimilarID) + `,`,
		`ISFullScreen:` + fmt.Sprintf("%v", this.ISFullScreen) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoESTags) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoESTags{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SaveVideoResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SaveVideoResponse{`,
		`}`,
	}, "")
	return s
}
func (this *RecVideoInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecVideoInfo{`,
		`SVID:` + fmt.Sprintf("%v", this.SVID) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`MID:` + fmt.Sprintf("%v", this.MID) + `,`,
		`CID:` + fmt.Sprintf("%v", this.CID) + `,`,
		`Pubtime:` + fmt.Sprintf("%v", this.Pubtime) + `,`,
		`Ctime:` + fmt.Sprintf("%v", this.Ctime) + `,`,
		`Mtime:` + fmt.Sprintf("%v", this.Mtime) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`Original:` + fmt.Sprintf("%v", this.Original) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`VerID:` + fmt.Sprintf("%v", this.VerID) + `,`,
		`Ver:` + fmt.Sprintf("%v", this.Ver) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`AVID:` + fmt.Sprintf("%v", this.AVID) + `,`,
		`Tid:` + fmt.Sprintf("%v", this.Tid) + `,`,
		`SubTid:` + fmt.Sprintf("%v", this.SubTid) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`RoughScore:` + fmt.Sprintf("%v", this.RoughScore) + `,`,
		`Tags:` + strings.Replace(fmt.Sprintf("%v", this.Tags), "VideoESTags", "VideoESTags", 1) + `,`,
		`PlayHive:` + fmt.Sprintf("%v", this.PlayHive) + `,`,
		`FavHive:` + fmt.Sprintf("%v", this.FavHive) + `,`,
		`CoinHive:` + fmt.Sprintf("%v", this.CoinHive) + `,`,
		`SubtitlesHive:` + fmt.Sprintf("%v", this.SubtitlesHive) + `,`,
		`LikesHive:` + fmt.Sprintf("%v", this.LikesHive) + `,`,
		`ShareHive:` + fmt.Sprintf("%v", this.ShareHive) + `,`,
		`ReportHive:` + fmt.Sprintf("%v", this.ReportHive) + `,`,
		`DurationDailyHive:` + fmt.Sprintf("%v", this.DurationDailyHive) + `,`,
		`DurationAllHive:` + fmt.Sprintf("%v", this.DurationAllHive) + `,`,
		`ReplyHive:` + fmt.Sprintf("%v", this.ReplyHive) + `,`,
		`ShareDailyHive:` + fmt.Sprintf("%v", this.ShareDailyHive) + `,`,
		`PlayDailyHive:` + fmt.Sprintf("%v", this.PlayDailyHive) + `,`,
		`SubtitlesDailyHive:` + fmt.Sprintf("%v", this.SubtitlesDailyHive) + `,`,
		`LikesDailyHive:` + fmt.Sprintf("%v", this.LikesDailyHive) + `,`,
		`FavDailyHive:` + fmt.Sprintf("%v", this.FavDailyHive) + `,`,
		`ReplyDailyHive:` + fmt.Sprintf("%v", this.ReplyDailyHive) + `,`,
		`AccessHive:` + fmt.Sprintf("%v", this.AccessHive) + `,`,
		`Play:` + fmt.Sprintf("%v", this.Play) + `,`,
		`Subtitles:` + fmt.Sprintf("%v", this.Subtitles) + `,`,
		`Like:` + fmt.Sprintf("%v", this.Like) + `,`,
		`Share:` + fmt.Sprintf("%v", this.Share) + `,`,
		`Report:` + fmt.Sprintf("%v", this.Report) + `,`,
		`SimilarID:` + fmt.Sprintf("%v", this.SimilarID) + `,`,
		`ESScore:` + fmt.Sprintf("%v", this.ESScore) + `,`,
		`CustomScore:` + fmt.Sprintf("%v", this.CustomScore) + `,`,
		`ISFullScreen:` + fmt.Sprintf("%v", this.ISFullScreen) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecVideoDataRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := ""
	return s
}
func (this *RecVideoDataResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecVideoDataResponse{`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`List:` + `,`,
		`}`,
	}, "")
	return s
}
func (this *VideoDataRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := ""
	return s
}
func (this *VideoDataResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VideoDataResponse{`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`List:` + `,`,
		`}`,
	}, "")
	return s
}
func (this *ESVideoDataRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := ""
	return s
}
func (this *ESVideoDataResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ESVideoDataResponse{`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`List:` + `,`,
		`}`,
	}, "")
	return s
}
func (this *DelVideoBySVIDRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DelVideoBySVIDRequest{`,
		`SVIDs:` + fmt.Sprintf("%v", this.SVIDs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DelVideoBySVIDResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DelVideoBySVIDResponse{`,
		`}`,
	}, "")
	return s
}
func valueToStringApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SaveVideoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaveVideoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaveVideoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &VideoESInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoESInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoESInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoESInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SVID", wireType)
			}
			m.SVID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SVID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MID", wireType)
			}
			m.MID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CID", wireType)
			}
			m.CID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubtime", wireType)
			}
			m.Pubtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pubtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Original", wireType)
			}
			m.Original = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Original |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerID", wireType)
			}
			m.VerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AVID", wireType)
			}
			m.AVID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AVID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTid", wireType)
			}
			m.SubTid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubTid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoughScore", wireType)
			}
			m.RoughScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoughScore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &VideoESTags{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayHive", wireType)
			}
			m.PlayHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FavHive", wireType)
			}
			m.FavHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FavHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinHive", wireType)
			}
			m.CoinHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtitlesHive", wireType)
			}
			m.SubtitlesHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubtitlesHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikesHive", wireType)
			}
			m.LikesHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LikesHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareHive", wireType)
			}
			m.ShareHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportHive", wireType)
			}
			m.ReportHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationDailyHive", wireType)
			}
			m.DurationDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationAllHive", wireType)
			}
			m.DurationAllHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationAllHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyHive", wireType)
			}
			m.ReplyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareDailyHive", wireType)
			}
			m.ShareDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayDailyHive", wireType)
			}
			m.PlayDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtitlesDailyHive", wireType)
			}
			m.SubtitlesDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubtitlesDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikesDailyHive", wireType)
			}
			m.LikesDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LikesDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FavDailyHive", wireType)
			}
			m.FavDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FavDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyDailyHive", wireType)
			}
			m.ReplyDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHive", wireType)
			}
			m.AccessHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Play", wireType)
			}
			m.Play = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Play |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitles", wireType)
			}
			m.Subtitles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtitles |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Like", wireType)
			}
			m.Like = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Like |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			m.Share = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Share |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			m.Report = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Report |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SimilarID = append(m.SimilarID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SimilarID = append(m.SimilarID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SimilarID", wireType)
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ISFullScreen", wireType)
			}
			m.ISFullScreen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ISFullScreen |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoESTags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoESTags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoESTags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SaveVideoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaveVideoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaveVideoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecVideoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecVideoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecVideoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SVID", wireType)
			}
			m.SVID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SVID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MID", wireType)
			}
			m.MID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CID", wireType)
			}
			m.CID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubtime", wireType)
			}
			m.Pubtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pubtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Original", wireType)
			}
			m.Original = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Original |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerID", wireType)
			}
			m.VerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AVID", wireType)
			}
			m.AVID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AVID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTid", wireType)
			}
			m.SubTid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubTid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoughScore", wireType)
			}
			m.RoughScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoughScore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &VideoESTags{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayHive", wireType)
			}
			m.PlayHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FavHive", wireType)
			}
			m.FavHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FavHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinHive", wireType)
			}
			m.CoinHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtitlesHive", wireType)
			}
			m.SubtitlesHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubtitlesHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikesHive", wireType)
			}
			m.LikesHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LikesHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareHive", wireType)
			}
			m.ShareHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportHive", wireType)
			}
			m.ReportHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationDailyHive", wireType)
			}
			m.DurationDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationAllHive", wireType)
			}
			m.DurationAllHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationAllHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyHive", wireType)
			}
			m.ReplyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareDailyHive", wireType)
			}
			m.ShareDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayDailyHive", wireType)
			}
			m.PlayDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtitlesDailyHive", wireType)
			}
			m.SubtitlesDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubtitlesDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikesDailyHive", wireType)
			}
			m.LikesDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LikesDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FavDailyHive", wireType)
			}
			m.FavDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FavDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyDailyHive", wireType)
			}
			m.ReplyDailyHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyDailyHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHive", wireType)
			}
			m.AccessHive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Play", wireType)
			}
			m.Play = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Play |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitles", wireType)
			}
			m.Subtitles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subtitles |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Like", wireType)
			}
			m.Like = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Like |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			m.Share = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Share |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			m.Report = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Report |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SimilarID = append(m.SimilarID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SimilarID = append(m.SimilarID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SimilarID", wireType)
			}
		case 44:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ESScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ESScore = float64(math.Float32frombits(v))
		case 45:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float64(math.Float32frombits(v))
				m.CustomScore = append(m.CustomScore, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float64(math.Float32frombits(v))
					m.CustomScore = append(m.CustomScore, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomScore", wireType)
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ISFullScreen", wireType)
			}
			m.ISFullScreen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ISFullScreen |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecVideoDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecVideoDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecVideoDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecVideoDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecVideoDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecVideoDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RecVideoInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &VideoESInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ESVideoDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ESVideoDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ESVideoDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ESVideoDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ESVideoDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ESVideoDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RecVideoInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelVideoBySVIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelVideoBySVIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelVideoBySVIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SVIDs = append(m.SVIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SVIDs = append(m.SVIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SVIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelVideoBySVIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelVideoBySVIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelVideoBySVIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app/service/bbq/search/api/grpc/v1/api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 1806 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0x37, 0x45, 0xea, 0x0f, 0x47, 0x32, 0x2d, 0xad, 0x2c, 0x7b, 0x2d, 0x3b, 0x1a, 0x65, 0x9c,
	0xd4, 0xb2, 0x65, 0x93, 0xb5, 0xdd, 0x38, 0x80, 0x0d, 0xa4, 0x35, 0x63, 0x1b, 0x35, 0xd0, 0x22,
	0xed, 0x30, 0x31, 0x90, 0x02, 0x09, 0xbb, 0x5c, 0x0e, 0xa9, 0x85, 0x97, 0x5c, 0x6a, 0x77, 0xb9,
	0x80, 0x80, 0x16, 0x0d, 0x7a, 0xe8, 0x07, 0xe8, 0xa9, 0xc7, 0x7e, 0x9c, 0x1c, 0x7b, 0xcc, 0x69,
	0xd0, 0xf0, 0xc8, 0xe3, 0x1e, 0x7b, 0x2a, 0xde, 0x9b, 0xdd, 0x9d, 0x21, 0x25, 0xc1, 0x42, 0x01,
	0xf7, 0x10, 0xf0, 0xb4, 0xfb, 0x7e, 0xef, 0xbd, 0xdf, 0x9b, 0x79, 0xf3, 0x76, 0x66, 0x1e, 0x96,
	0xdc, 0x77, 0x46, 0xa3, 0x46, 0x24, 0xc2, 0xc4, 0x73, 0x45, 0xa3, 0xd3, 0x39, 0x6e, 0x44, 0xc2,
	0x09, 0xdd, 0xa3, 0x86, 0x33, 0xf2, 0x1a, 0xfd, 0x70, 0xe4, 0x36, 0x92, 0x87, 0xf0, 0x5e, 0x1f,
	0x85, 0x41, 0x1c, 0x58, 0x3b, 0x9d, 0xce, 0x71, 0x3d, 0xb3, 0xae, 0x2b, 0xcb, 0x7a, 0xf2, 0x70,
	0xf7, 0x41, 0xdf, 0x8b, 0x8f, 0xc6, 0x9d, 0xba, 0x1b, 0x0c, 0x1a, 0xfd, 0xa0, 0x1f, 0x34, 0xd0,
	0xba, 0x33, 0xee, 0xa1, 0x84, 0x02, 0xbe, 0x29, 0x16, 0xf6, 0x67, 0xb2, 0xd9, 0x72, 0x12, 0xf1,
	0xc6, 0xeb, 0x8a, 0x80, 0x8b, 0xe3, 0xb1, 0x88, 0x62, 0xcb, 0x25, 0x15, 0xdf, 0x8b, 0x62, 0xbb,
	0xb4, 0x5f, 0x3e, 0x58, 0x7f, 0xc4, 0xea, 0x67, 0x06, 0xaa, 0xa3, 0xcb, 0xcb, 0xd6, 0xeb, 0x61,
	0x2f, 0x68, 0x1e, 0x4e, 0x25, 0x45, 0x9f, 0x54, 0x52, 0xda, 0x0b, 0xc2, 0xc1, 0x53, 0x06, 0x12,
	0xdb, 0x4f, 0x1c, 0xdf, 0xeb, 0x3a, 0xb1, 0x78, 0xca, 0x42, 0x71, 0x3c, 0xf6, 0x42, 0xd1, 0x65,
	0x1c, 0x0d, 0x9f, 0x56, 0xfe, 0xf1, 0x4f, 0x7a, 0x89, 0xfd, 0x70, 0x8d, 0xac, 0x1b, 0x44, 0xd6,
	0x63, 0x52, 0x89, 0x12, 0xaf, 0x6b, 0x97, 0xf6, 0x4b, 0x07, 0xe5, 0x26, 0x9d, 0x48, 0x5a, 0x69,
	0xbd, 0x79, 0xfd, 0x02, 0xe8, 0x01, 0x4f, 0x25, 0x5d, 0x57, 0xf4, 0x20, 0x31, 0x8e, 0xa0, 0xd5,
	0x20, 0xcb, 0xb1, 0x17, 0xfb, 0xc2, 0x5e, 0xda, 0x2f, 0x1d, 0x54, 0x9b, 0x37, 0xa6, 0x92, 0x2a,
	0x20, 0x95, 0x74, 0x43, 0x99, 0xa3, 0xc8, 0xb8, 0x82, 0xad, 0x4f, 0xc9, 0xaa, 0x1b, 0x0c, 0x63,
	0x31, 0x8c, 0xed, 0x32, 0xba, 0x7c, 0x30, 0x95, 0x34, 0x87, 0x52, 0x49, 0x6b, 0xca, 0x29, 0x03,
	0x18, 0xcf, 0x55, 0x56, 0x9d, 0x94, 0x07, 0x5e, 0xd7, 0xae, 0xe0, 0xe8, 0x6e, 0x4d, 0x24, 0x2d,
	0xff, 0x16, 0x07, 0x07, 0x68, 0x2a, 0x29, 0x51, 0x7e, 0x03, 0x18, 0x1a, 0x40, 0x60, 0xef, 0x7a,
	0x5d, 0x7b, 0x59, 0xdb, 0x7f, 0xae, 0xec, 0x5d, 0xd3, 0xde, 0x45, 0x7b, 0xd7, 0xeb, 0xc2, 0xc0,
	0x46, 0xe3, 0x4e, 0xec, 0x0d, 0x84, 0xbd, 0x82, 0x3e, 0x38, 0xb0, 0x0c, 0xd2, 0x03, 0xcb, 0x00,
	0xc6, 0x73, 0x15, 0xa4, 0xc0, 0x45, 0xb7, 0x55, 0x74, 0xc3, 0x14, 0xb8, 0x99, 0x53, 0x96, 0x02,
	0x57, 0xb9, 0x28, 0x18, 0x1c, 0x06, 0xe8, 0xb0, 0xa6, 0x1d, 0x06, 0xb3, 0x0e, 0x83, 0xcc, 0x01,
	0x9f, 0xd6, 0x33, 0xb2, 0xd6, 0x1d, 0x87, 0x4e, 0xec, 0x05, 0x43, 0xbb, 0xaa, 0x56, 0x67, 0x2a,
	0x69, 0x81, 0xa5, 0x92, 0x5e, 0x51, 0x6e, 0x39, 0xc2, 0x78, 0xa1, 0x04, 0xe7, 0x20, 0xf4, 0xfa,
	0xde, 0xd0, 0xf1, 0x6d, 0xa2, 0x9d, 0x73, 0x4c, 0x3b, 0xe7, 0x08, 0xe3, 0x85, 0x12, 0x86, 0x1a,
	0xc5, 0x4e, 0x2c, 0xec, 0x75, 0x3d, 0x54, 0x04, 0xf4, 0x50, 0x51, 0x64, 0x5c, 0xc1, 0xd6, 0x33,
	0xb2, 0x92, 0x88, 0xb0, 0xed, 0x75, 0xed, 0x0d, 0xf4, 0xf8, 0x68, 0x22, 0xe9, 0xf2, 0x1b, 0x11,
	0x62, 0xea, 0x33, 0x55, 0x2a, 0xe9, 0x65, 0xe5, 0xab, 0x64, 0xc6, 0x97, 0x13, 0x11, 0xbe, 0xee,
	0x5a, 0x77, 0x48, 0x39, 0x11, 0xa1, 0x7d, 0x19, 0xeb, 0x62, 0x07, 0xd6, 0x2a, 0x11, 0xa1, 0x5e,
	0xab, 0x44, 0x84, 0x8c, 0x03, 0x64, 0x1d, 0x92, 0x4a, 0x2f, 0x0c, 0x06, 0x76, 0x0d, 0x63, 0x5c,
	0x87, 0x12, 0x05, 0x59, 0x97, 0x28, 0x48, 0x8c, 0x23, 0x08, 0x75, 0xed, 0x40, 0x5d, 0x5f, 0xd1,
	0x75, 0xfd, 0x3c, 0xab, 0x6b, 0x67, 0xa6, 0xae, 0x1d, 0x55, 0xd7, 0xf0, 0x80, 0xa1, 0xc4, 0x5e,
	0xd7, 0xde, 0x44, 0x1f, 0x1c, 0x4a, 0x6c, 0x96, 0x4d, 0x8c, 0x65, 0x13, 0x7b, 0x5d, 0xeb, 0x09,
	0x59, 0x8d, 0xc6, 0x9d, 0x36, 0x18, 0x6f, 0xe9, 0xb2, 0xc9, 0x20, 0x5d, 0x36, 0x19, 0xc0, 0xf8,
	0x4a, 0x34, 0xee, 0x7c, 0xa9, 0x3e, 0x9c, 0xc8, 0x0d, 0x42, 0x61, 0x5b, 0x46, 0x66, 0x01, 0x30,
	0x32, 0x0b, 0x22, 0x64, 0x16, 0x9e, 0xd6, 0x2b, 0xb2, 0x1e, 0x06, 0xe3, 0xfe, 0x51, 0x5b, 0xb9,
	0x6d, 0xa3, 0xdb, 0xc7, 0x53, 0x49, 0x4d, 0x38, 0x95, 0xd4, 0x52, 0xce, 0x06, 0xc8, 0x38, 0x41,
	0xa9, 0x85, 0x3c, 0x5f, 0x90, 0x4a, 0xec, 0xf4, 0x23, 0xfb, 0xea, 0x45, 0x76, 0x98, 0x2f, 0x9d,
	0x7e, 0xa4, 0xf2, 0x0b, 0x3e, 0x3a, 0x55, 0x20, 0x31, 0x8e, 0xa0, 0xf5, 0x19, 0xa9, 0x8e, 0x7c,
	0xe7, 0xa4, 0x7d, 0xe4, 0x25, 0xc2, 0xde, 0xc1, 0x61, 0x7d, 0x38, 0x95, 0x54, 0x83, 0xa9, 0xa4,
	0x9b, 0xd9, 0xc7, 0x93, 0x43, 0x8c, 0xaf, 0xc1, 0xfb, 0xaf, 0xbd, 0x44, 0x58, 0x4f, 0xc9, 0x5a,
	0xcf, 0x49, 0x94, 0xfb, 0x35, 0x5d, 0xa0, 0x39, 0xa6, 0x0b, 0x34, 0x47, 0x18, 0x5f, 0xed, 0x39,
	0x09, 0xfa, 0x7e, 0x46, 0xaa, 0x6e, 0xe0, 0x0d, 0x95, 0xf3, 0x75, 0x1d, 0xbb, 0x00, 0x75, 0xec,
	0x02, 0x62, 0x7c, 0x0d, 0xde, 0xd1, 0x9f, 0x93, 0x5a, 0x04, 0x9f, 0x71, 0xec, 0x8b, 0x48, 0x91,
	0xd8, 0x48, 0x02, 0x9b, 0xea, 0x9c, 0x26, 0x95, 0x74, 0xa7, 0x58, 0x4b, 0x03, 0x67, 0xfc, 0x72,
	0x01, 0x20, 0x67, 0x93, 0x10, 0xdf, 0x7b, 0x9b, 0xf3, 0xdd, 0x40, 0xbe, 0xdb, 0x53, 0x49, 0x0d,
	0x34, 0x95, 0x74, 0x2b, 0xdf, 0xaa, 0xdf, 0x16, 0x3c, 0x55, 0x14, 0x72, 0x8e, 0xe8, 0xc8, 0x09,
	0x85, 0xe2, 0xd8, 0xd5, 0x1c, 0x1a, 0xd5, 0x1c, 0x1a, 0x63, 0xbc, 0x8a, 0x02, 0x72, 0x40, 0xc1,
	0x88, 0x51, 0x10, 0xc6, 0x8a, 0xe4, 0xa6, 0x51, 0x30, 0x1a, 0x36, 0x0a, 0x46, 0x83, 0x50, 0x30,
	0x28, 0x21, 0x8f, 0x20, 0xdb, 0xf9, 0x66, 0xd2, 0xee, 0x3a, 0x9e, 0x9f, 0xad, 0xf4, 0x2d, 0xe4,
	0xfb, 0x64, 0x2a, 0xe9, 0x59, 0xea, 0x54, 0xd2, 0xdd, 0xd9, 0x3d, 0xc9, 0x50, 0x32, 0xbe, 0x95,
	0xa3, 0x2f, 0x00, 0xc4, 0x30, 0xdf, 0x90, 0x02, 0x6c, 0x3b, 0xbe, 0xaf, 0x82, 0x7c, 0x80, 0x41,
	0x1e, 0x4e, 0x25, 0x3d, 0xad, 0x4c, 0x25, 0xb5, 0xe7, 0x42, 0xe4, 0x2a, 0xc6, 0xaf, 0xe4, 0xd8,
	0x73, 0xdf, 0xcf, 0x33, 0x1a, 0x8a, 0x51, 0x3e, 0xf8, 0x3d, 0x9d, 0x51, 0x8d, 0xea, 0x8c, 0x6a,
	0x8c, 0xf1, 0x2a, 0x0a, 0xc8, 0xf1, 0x35, 0xd9, 0x54, 0xb9, 0x36, 0xd2, 0x40, 0x91, 0xa9, 0x31,
	0x95, 0xf4, 0x94, 0x2e, 0x95, 0xf4, 0xba, 0xb9, 0x42, 0x66, 0x02, 0x6a, 0x08, 0xe9, 0xd9, 0x7f,
	0x45, 0xae, 0xe0, 0xc7, 0x61, 0x30, 0xef, 0x23, 0xf3, 0x83, 0xa9, 0xa4, 0xf3, 0xaa, 0x54, 0xd2,
	0x6b, 0xc6, 0x07, 0x65, 0xf2, 0x5e, 0x06, 0x44, 0xd3, 0x7a, 0xe4, 0xaa, 0xae, 0x56, 0x83, 0xfb,
	0x43, 0xe4, 0xfe, 0x74, 0x2a, 0xe9, 0x99, 0xfa, 0x54, 0xd2, 0x9b, 0xf3, 0xb5, 0x6e, 0x46, 0xb1,
	0x0a, 0x58, 0x87, 0xfa, 0x9a, 0x6c, 0xaa, 0x62, 0x36, 0xc2, 0x30, 0x9d, 0x9c, 0x79, 0x9d, 0x4e,
	0xce, 0xbc, 0x86, 0xf1, 0x1a, 0x42, 0x9a, 0xfa, 0xf7, 0xa4, 0x06, 0xdf, 0xbe, 0x41, 0x7c, 0x5b,
	0x7f, 0xa5, 0xb3, 0x1a, 0xfd, 0x95, 0xce, 0xe2, 0x8c, 0x6f, 0xf4, 0x9c, 0x64, 0x66, 0xb4, 0x6a,
	0x91, 0x0d, 0xd2, 0x8f, 0xf4, 0x68, 0xe7, 0x75, 0x7a, 0xb4, 0xf3, 0x1a, 0xc6, 0x6b, 0x08, 0x69,
	0xea, 0x57, 0x64, 0xdd, 0x71, 0x5d, 0x11, 0x65, 0x1b, 0xc0, 0xc7, 0xfa, 0xbb, 0x33, 0x60, 0xfd,
	0xdd, 0x19, 0x20, 0xe3, 0x44, 0x49, 0xc8, 0x73, 0x48, 0x2a, 0xb0, 0x98, 0xf6, 0xcf, 0xf4, 0x21,
	0x07, 0xb2, 0xde, 0x84, 0x41, 0x62, 0x1c, 0x41, 0xeb, 0x97, 0xa4, 0x5a, 0xac, 0x89, 0x7d, 0x47,
	0x6f, 0x84, 0x05, 0xa8, 0x37, 0xc2, 0x02, 0x82, 0xdd, 0x22, 0x7f, 0x87, 0x68, 0x90, 0x75, 0xfb,
	0x40, 0x47, 0x03, 0x59, 0x47, 0x03, 0x09, 0x2f, 0x90, 0x6f, 0xf1, 0x06, 0x83, 0xf5, 0x6b, 0xdf,
	0x35, 0x0e, 0x2f, 0x00, 0x8c, 0xc3, 0x0b, 0x44, 0x38, 0xbc, 0xe0, 0x69, 0x3d, 0x26, 0x2b, 0x6a,
	0x47, 0xb1, 0xef, 0xa1, 0xc7, 0x4d, 0xb8, 0x0d, 0x28, 0x44, 0xdf, 0x06, 0x94, 0xcc, 0x78, 0xa6,
	0xb0, 0xbe, 0x20, 0x24, 0xf2, 0x06, 0x9e, 0xef, 0xe0, 0x7d, 0xe2, 0x70, 0xbf, 0x7c, 0x50, 0x6e,
	0xfe, 0x7c, 0x22, 0x69, 0xb5, 0xa5, 0x50, 0x3c, 0xc3, 0x0d, 0x13, 0x63, 0x47, 0x2c, 0x30, 0x98,
	0x63, 0x66, 0xdd, 0xb5, 0x1c, 0x52, 0xf3, 0xa2, 0x76, 0x6f, 0xec, 0xfb, 0xed, 0xc8, 0x0d, 0x85,
	0x18, 0xda, 0xf7, 0x71, 0x34, 0xcf, 0x26, 0x92, 0x6e, 0xbc, 0x6e, 0xbd, 0x1a, 0xfb, 0x7e, 0x0b,
	0x71, 0xa8, 0xab, 0x59, 0x4b, 0x5d, 0x57, 0xb3, 0x38, 0xe3, 0x1b, 0x5e, 0xa4, 0x1d, 0xb3, 0xab,
	0xf5, 0xdf, 0x4b, 0xc5, 0xd5, 0x1a, 0x4e, 0x50, 0xeb, 0x2e, 0x59, 0x2a, 0x2e, 0xd6, 0x37, 0x26,
	0x92, 0x2e, 0xe1, 0xd0, 0x97, 0x70, 0xc8, 0xd5, 0x8c, 0xb6, 0xcb, 0xf8, 0x92, 0xd7, 0x85, 0x75,
	0x18, 0x3a, 0x83, 0xfc, 0x3e, 0x8d, 0xeb, 0x00, 0xb2, 0x5e, 0x07, 0x90, 0x18, 0x47, 0x10, 0x8c,
	0xe3, 0x93, 0x91, 0xc0, 0x9b, 0x74, 0xb6, 0x68, 0x20, 0x1b, 0xe7, 0xf4, 0xc9, 0x08, 0x8c, 0xf1,
	0xb1, 0x4d, 0xb6, 0x8c, 0x76, 0x23, 0x1a, 0x05, 0xc3, 0x48, 0xb0, 0xbf, 0xda, 0x64, 0x83, 0x0b,
	0x17, 0xc1, 0x45, 0x17, 0xb0, 0xe8, 0x02, 0x16, 0x5d, 0xc0, 0xa2, 0x0b, 0x58, 0x74, 0x01, 0x8b,
	0x2e, 0x60, 0xd1, 0x05, 0x2c, 0xba, 0x80, 0x45, 0x17, 0xb0, 0xe8, 0x02, 0x7e, 0x82, 0x5d, 0xc0,
	0xef, 0xc8, 0x9a, 0x88, 0xb2, 0xf3, 0x13, 0xee, 0xff, 0x4b, 0xcd, 0x4f, 0x26, 0x92, 0xae, 0xbe,
	0x6c, 0xe1, 0xc9, 0x08, 0x87, 0x4e, 0xae, 0xd6, 0x87, 0x4e, 0x8e, 0xb0, 0xff, 0x48, 0xba, 0xda,
	0xf3, 0x03, 0x27, 0x7e, 0xf2, 0x0b, 0xbe, 0x2a, 0x22, 0x75, 0x98, 0x7e, 0x45, 0x36, 0xdc, 0x71,
	0x14, 0x07, 0x83, 0x8c, 0xf5, 0xc1, 0x7e, 0xf9, 0x60, 0xa9, 0xf9, 0x68, 0x2a, 0xe9, 0x0c, 0x9e,
	0x4a, 0xba, 0x9d, 0x9d, 0x42, 0x06, 0x3a, 0x43, 0xb9, 0xae, 0x34, 0x8a, 0xf6, 0x74, 0xbb, 0x52,
	0x7f, 0x3f, 0xed, 0xca, 0x1f, 0xc9, 0x76, 0xde, 0x03, 0xbc, 0x70, 0x62, 0x27, 0xff, 0x17, 0xf1,
	0x39, 0x59, 0x3e, 0x1e, 0x8b, 0xf0, 0x04, 0x7b, 0x81, 0x2a, 0xee, 0x41, 0x0a, 0x48, 0x25, 0xdd,
	0x57, 0xec, 0x28, 0x9e, 0xfd, 0xab, 0x41, 0x99, 0x66, 0x11, 0xbe, 0x2b, 0x91, 0xab, 0xb3, 0x21,
	0x54, 0xff, 0x61, 0x51, 0xb2, 0x1c, 0x07, 0xb1, 0xe3, 0x67, 0xfd, 0x46, 0x15, 0x3b, 0x07, 0x00,
	0xb8, 0x7a, 0x58, 0xcf, 0xb3, 0x1f, 0x22, 0x4b, 0x78, 0x51, 0xb9, 0x7d, 0xce, 0x45, 0xc5, 0x6c,
	0x61, 0x9a, 0x6b, 0xf9, 0x1f, 0x91, 0x99, 0xdf, 0x1d, 0xdf, 0x90, 0xcd, 0xf7, 0x39, 0xc3, 0x3f,
	0x91, 0xad, 0xff, 0x61, 0x76, 0xbf, 0x9a, 0x99, 0xdd, 0x45, 0x7e, 0xf7, 0x9c, 0x3d, 0xb9, 0x36,
	0xb1, 0x5e, 0xb6, 0xde, 0xe7, 0xf4, 0xfe, 0x42, 0xb6, 0x67, 0x02, 0xfc, 0xdf, 0x97, 0xef, 0x2d,
	0xd9, 0x79, 0x21, 0x7c, 0xb4, 0x6a, 0x9e, 0x40, 0x47, 0x9a, 0x4f, 0xf2, 0x37, 0x64, 0x19, 0x7a,
	0xd0, 0x08, 0x7f, 0x99, 0x95, 0x9b, 0x4f, 0xa0, 0xd5, 0x00, 0x7d, 0x74, 0xc6, 0x6c, 0xd1, 0xf0,
	0x9c, 0xd9, 0xa2, 0x2e, 0x0b, 0x66, 0x93, 0x6b, 0xf3, 0xc1, 0xd4, 0x84, 0x1f, 0xfd, 0xad, 0x42,
	0x56, 0x5a, 0x38, 0x6e, 0xeb, 0x5b, 0x52, 0x2d, 0xfa, 0x69, 0xeb, 0xce, 0x39, 0x33, 0x9b, 0xff,
	0xc1, 0xb7, 0x7b, 0xf0, 0x6e, 0xc3, 0x2c, 0xb7, 0xdf, 0x92, 0x6a, 0x91, 0xf0, 0x73, 0xf9, 0xe7,
	0xd7, 0xfc, 0x5c, 0xfe, 0xd3, 0x6b, 0xd7, 0xd7, 0x9d, 0x3f, 0x86, 0xb8, 0xf7, 0x8e, 0xc5, 0x31,
	0xa3, 0x1c, 0x5e, 0xc8, 0x36, 0x0b, 0xd4, 0x25, 0xeb, 0x46, 0xed, 0x58, 0x77, 0xcf, 0xf1, 0x3d,
	0x5d, 0xc0, 0xbb, 0xf7, 0x2e, 0x62, 0x9a, 0x45, 0x19, 0x90, 0xda, 0xec, 0x9a, 0x59, 0xf7, 0xcf,
	0xf1, 0x3e, 0xb3, 0x8e, 0x76, 0x1f, 0x5c, 0xd0, 0x5a, 0x85, 0x6b, 0xde, 0xfa, 0xfe, 0xc7, 0xbd,
	0x4b, 0x3f, 0xfc, 0xb8, 0x77, 0xe9, 0xbb, 0xc9, 0x5e, 0xe9, 0xfb, 0xc9, 0x5e, 0xe9, 0x5f, 0x93,
	0xbd, 0xd2, 0xbf, 0x27, 0x7b, 0xa5, 0x3f, 0x2c, 0x25, 0x0f, 0x3b, 0x2b, 0xf8, 0x87, 0xf7, 0xf1,
	0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x0c, 0x70, 0x0a, 0x09, 0x57, 0x1e, 0x00, 0x00,
}
