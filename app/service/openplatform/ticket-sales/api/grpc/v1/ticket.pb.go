// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/ticket-sales/api/grpc/v1/ticket.proto

/*
	Package v1 is a generated protocol buffer package.

	It is generated from these files:
		app/service/openplatform/ticket-sales/api/grpc/v1/ticket.proto
		app/service/openplatform/ticket-sales/api/grpc/v1/promotion_mis.proto
		app/service/openplatform/ticket-sales/api/grpc/v1/order.proto
		app/service/openplatform/ticket-sales/api/grpc/v1/pay.proto
		app/service/openplatform/ticket-sales/api/grpc/v1/promotion.proto

	It has these top-level messages:
		TicketViewRequest
		TicketViewResponse
		TicketItem
		TicketSendRequest
		TicketSendResponse
		TicketSendItem
		PromoOrderMis
		GetGroupOrdersMisRequest
		GetGroupOrdersMisResponse
		ListOrdersRequest
		ListOrdersResponse
		OrderResponse
		OrderResponseMore
		CreateOrderSKU
		CreateOrderRequest
		CreateOrdersRequest
		CreateOrderResult
		CreateOrdersResponse
		UpBuyerRequest
		UpDeliveryRequest
		UpDetailResponse
		OrderLog
		ListOrderLogRequest
		ListOrderLogResponse
		AddOrderLogRequest
		AddOrderLogResponse
		PayNotifyRequest
		PayNotifyResponse
		Promo
		PromoGroup
		PromoOrder
		CreatePromoRequest
		OperatePromoRequest
		CheckCreatePromoOrderRequest
		RepeatOrder
		CheckCreatePromoOrderResponse
		CreatePromoOrderRequest
		CommonResponse
		PromoID
		OrderID
		GroupID
		GetPromoGroupInfoRequest
		GetPromoGroupInfoResponse
		CheckIssueResponse
		FinishIssueRequest
		GroupFailedRequest
		EditPromoRequest
*/
package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import go_common_library_time "go-common/library/time"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type TicketViewRequest struct {
	OrderID  int64   `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	UID      int64   `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	ScreenID int64   `protobuf:"varint,3,opt,name=screen_id,json=screenId,proto3" json:"screen_id,omitempty"`
	ID       []int64 `protobuf:"varint,4,rep,packed,name=id" json:"id,omitempty"`
}

func (m *TicketViewRequest) Reset()                    { *m = TicketViewRequest{} }
func (*TicketViewRequest) ProtoMessage()               {}
func (*TicketViewRequest) Descriptor() ([]byte, []int) { return fileDescriptorTicket, []int{0} }

type TicketViewResponse struct {
	Tickets []*TicketItem `protobuf:"bytes,1,rep,name=tickets" json:"tickets,omitempty"`
}

func (m *TicketViewResponse) Reset()                    { *m = TicketViewResponse{} }
func (*TicketViewResponse) ProtoMessage()               {}
func (*TicketViewResponse) Descriptor() ([]byte, []int) { return fileDescriptorTicket, []int{1} }

type TicketItem struct {
	ID              int64                       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	UID             int64                       `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	OID             int64                       `protobuf:"varint,3,opt,name=oid,proto3" json:"oid,omitempty"`
	SID             int64                       `protobuf:"varint,4,opt,name=sid,proto3" json:"sid,omitempty"`
	Price           int64                       `protobuf:"varint,5,opt,name=price,proto3" json:"price,omitempty"`
	Src             int16                       `protobuf:"varint,6,opt,name=src,proto3,casttype=int16" json:"src,omitempty"`
	Type            int16                       `protobuf:"varint,7,opt,name=type,proto3,casttype=int16" json:"type,omitempty"`
	Status          int16                       `protobuf:"varint,8,opt,name=status,proto3,casttype=int16" json:"status,omitempty"`
	Qr              string                      `protobuf:"bytes,9,opt,name=qr,proto3" json:"qr,omitempty"`
	RefID           int64                       `protobuf:"varint,10,opt,name=ref_id,json=refId,proto3" json:"ref_id,omitempty"`
	SkuID           int64                       `protobuf:"varint,11,opt,name=sku_id,json=skuId,proto3" json:"sku_id,omitempty"`
	SeatID          int64                       `protobuf:"varint,12,opt,name=seat_id,json=seatId,proto3" json:"seat_id,omitempty"`
	Seat            string                      `protobuf:"bytes,13,opt,name=seat,proto3" json:"seat,omitempty"`
	RefundApplyTime go_common_library_time.Time `protobuf:"varint,14,opt,name=refund_apply_time,json=refundApplyTime,proto3,casttype=go-common/library/time.Time" json:"refund_apply_time,omitempty"`
	ETime           go_common_library_time.Time `protobuf:"varint,15,opt,name=etime,proto3,casttype=go-common/library/time.Time" json:"etime,omitempty"`
	CTime           go_common_library_time.Time `protobuf:"varint,16,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime,omitempty"`
	MTime           go_common_library_time.Time `protobuf:"varint,17,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime,omitempty"`
}

func (m *TicketItem) Reset()                    { *m = TicketItem{} }
func (*TicketItem) ProtoMessage()               {}
func (*TicketItem) Descriptor() ([]byte, []int) { return fileDescriptorTicket, []int{2} }

type TicketSendRequest struct {
	SendTID []int64 `protobuf:"varint,1,rep,packed,name=send_tid,json=sendTid" json:"send_tid,omitempty"`
	RecvTID []int64 `protobuf:"varint,2,rep,packed,name=recv_tid,json=recvTid" json:"recv_tid,omitempty"`
}

func (m *TicketSendRequest) Reset()                    { *m = TicketSendRequest{} }
func (*TicketSendRequest) ProtoMessage()               {}
func (*TicketSendRequest) Descriptor() ([]byte, []int) { return fileDescriptorTicket, []int{3} }

type TicketSendResponse struct {
	TicketSends []*TicketSendItem `protobuf:"bytes,1,rep,name=ticket_sends,json=ticketSends" json:"ticket_sends,omitempty"`
}

func (m *TicketSendResponse) Reset()                    { *m = TicketSendResponse{} }
func (*TicketSendResponse) ProtoMessage()               {}
func (*TicketSendResponse) Descriptor() ([]byte, []int) { return fileDescriptorTicket, []int{4} }

type TicketSendItem struct {
	ID      int64                       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SID     int64                       `protobuf:"varint,2,opt,name=sid,proto3" json:"sid,omitempty"`
	SendTID int64                       `protobuf:"varint,3,opt,name=send_tid,json=sendTid,proto3" json:"send_tid,omitempty"`
	RecvTID int64                       `protobuf:"varint,4,opt,name=recv_tid,json=recvTid,proto3" json:"recv_tid,omitempty"`
	SendUID int64                       `protobuf:"varint,5,opt,name=send_uid,json=sendUid,proto3" json:"send_uid,omitempty"`
	RecvUID int64                       `protobuf:"varint,6,opt,name=recv_uid,json=recvUid,proto3" json:"recv_uid,omitempty"`
	RecvTel string                      `protobuf:"bytes,7,opt,name=recv_tel,json=recvTel,proto3" json:"recv_tel,omitempty"`
	Status  int16                       `protobuf:"varint,8,opt,name=status,proto3,casttype=int16" json:"status,omitempty"`
	CTime   go_common_library_time.Time `protobuf:"varint,9,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime,omitempty"`
	MTime   go_common_library_time.Time `protobuf:"varint,10,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime,omitempty"`
	OID     int64                       `protobuf:"varint,11,opt,name=oid,proto3" json:"oid,omitempty"`
}

func (m *TicketSendItem) Reset()                    { *m = TicketSendItem{} }
func (*TicketSendItem) ProtoMessage()               {}
func (*TicketSendItem) Descriptor() ([]byte, []int) { return fileDescriptorTicket, []int{5} }

func init() {
	proto.RegisterType((*TicketViewRequest)(nil), "ticket.service.sales.v1.TicketViewRequest")
	proto.RegisterType((*TicketViewResponse)(nil), "ticket.service.sales.v1.TicketViewResponse")
	proto.RegisterType((*TicketItem)(nil), "ticket.service.sales.v1.TicketItem")
	proto.RegisterType((*TicketSendRequest)(nil), "ticket.service.sales.v1.TicketSendRequest")
	proto.RegisterType((*TicketSendResponse)(nil), "ticket.service.sales.v1.TicketSendResponse")
	proto.RegisterType((*TicketSendItem)(nil), "ticket.service.sales.v1.TicketSendItem")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Ticket service

type TicketClient interface {
	// 查询电子票详情 - 支持根据订单号查询、场次 + uid 查询、票 id 查询
	TicketView(ctx context.Context, in *TicketViewRequest, opts ...grpc.CallOption) (*TicketViewResponse, error)
	// 查询赠票信息
	TicketSend(ctx context.Context, in *TicketSendRequest, opts ...grpc.CallOption) (*TicketSendResponse, error)
}

type ticketClient struct {
	cc *grpc.ClientConn
}

func NewTicketClient(cc *grpc.ClientConn) TicketClient {
	return &ticketClient{cc}
}

func (c *ticketClient) TicketView(ctx context.Context, in *TicketViewRequest, opts ...grpc.CallOption) (*TicketViewResponse, error) {
	out := new(TicketViewResponse)
	err := grpc.Invoke(ctx, "/ticket.service.sales.v1.Ticket/TicketView", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketClient) TicketSend(ctx context.Context, in *TicketSendRequest, opts ...grpc.CallOption) (*TicketSendResponse, error) {
	out := new(TicketSendResponse)
	err := grpc.Invoke(ctx, "/ticket.service.sales.v1.Ticket/TicketSend", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Ticket service

type TicketServer interface {
	// 查询电子票详情 - 支持根据订单号查询、场次 + uid 查询、票 id 查询
	TicketView(context.Context, *TicketViewRequest) (*TicketViewResponse, error)
	// 查询赠票信息
	TicketSend(context.Context, *TicketSendRequest) (*TicketSendResponse, error)
}

func RegisterTicketServer(s *grpc.Server, srv TicketServer) {
	s.RegisterService(&_Ticket_serviceDesc, srv)
}

func _Ticket_TicketView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketServer).TicketView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.sales.v1.Ticket/TicketView",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketServer).TicketView(ctx, req.(*TicketViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ticket_TicketSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketSendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketServer).TicketSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.sales.v1.Ticket/TicketSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketServer).TicketSend(ctx, req.(*TicketSendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ticket_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ticket.service.sales.v1.Ticket",
	HandlerType: (*TicketServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TicketView",
			Handler:    _Ticket_TicketView_Handler,
		},
		{
			MethodName: "TicketSend",
			Handler:    _Ticket_TicketSend_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/openplatform/ticket-sales/api/grpc/v1/ticket.proto",
}

func (m *TicketViewRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketViewRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.OrderID))
	}
	if m.UID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.UID))
	}
	if m.ScreenID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.ScreenID))
	}
	if len(m.ID) > 0 {
		dAtA2 := make([]byte, len(m.ID)*10)
		var j1 int
		for _, num1 := range m.ID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTicket(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *TicketViewResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketViewResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tickets) > 0 {
		for _, msg := range m.Tickets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTicket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TicketItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.ID))
	}
	if m.UID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.UID))
	}
	if m.OID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.OID))
	}
	if m.SID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.SID))
	}
	if m.Price != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.Price))
	}
	if m.Src != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.Src))
	}
	if m.Type != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.Type))
	}
	if m.Status != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.Status))
	}
	if len(m.Qr) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTicket(dAtA, i, uint64(len(m.Qr)))
		i += copy(dAtA[i:], m.Qr)
	}
	if m.RefID != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.RefID))
	}
	if m.SkuID != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.SkuID))
	}
	if m.SeatID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.SeatID))
	}
	if len(m.Seat) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTicket(dAtA, i, uint64(len(m.Seat)))
		i += copy(dAtA[i:], m.Seat)
	}
	if m.RefundApplyTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.RefundApplyTime))
	}
	if m.ETime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.ETime))
	}
	if m.CTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.CTime))
	}
	if m.MTime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.MTime))
	}
	return i, nil
}

func (m *TicketSendRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketSendRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SendTID) > 0 {
		dAtA4 := make([]byte, len(m.SendTID)*10)
		var j3 int
		for _, num1 := range m.SendTID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTicket(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.RecvTID) > 0 {
		dAtA6 := make([]byte, len(m.RecvTID)*10)
		var j5 int
		for _, num1 := range m.RecvTID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTicket(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *TicketSendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketSendResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TicketSends) > 0 {
		for _, msg := range m.TicketSends {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTicket(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TicketSendItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicketSendItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.ID))
	}
	if m.SID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.SID))
	}
	if m.SendTID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.SendTID))
	}
	if m.RecvTID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.RecvTID))
	}
	if m.SendUID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.SendUID))
	}
	if m.RecvUID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.RecvUID))
	}
	if len(m.RecvTel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTicket(dAtA, i, uint64(len(m.RecvTel)))
		i += copy(dAtA[i:], m.RecvTel)
	}
	if m.Status != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.Status))
	}
	if m.CTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.CTime))
	}
	if m.MTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.MTime))
	}
	if m.OID != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTicket(dAtA, i, uint64(m.OID))
	}
	return i, nil
}

func encodeVarintTicket(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TicketViewRequest) Size() (n int) {
	var l int
	_ = l
	if m.OrderID != 0 {
		n += 1 + sovTicket(uint64(m.OrderID))
	}
	if m.UID != 0 {
		n += 1 + sovTicket(uint64(m.UID))
	}
	if m.ScreenID != 0 {
		n += 1 + sovTicket(uint64(m.ScreenID))
	}
	if len(m.ID) > 0 {
		l = 0
		for _, e := range m.ID {
			l += sovTicket(uint64(e))
		}
		n += 1 + sovTicket(uint64(l)) + l
	}
	return n
}

func (m *TicketViewResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Tickets) > 0 {
		for _, e := range m.Tickets {
			l = e.Size()
			n += 1 + l + sovTicket(uint64(l))
		}
	}
	return n
}

func (m *TicketItem) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTicket(uint64(m.ID))
	}
	if m.UID != 0 {
		n += 1 + sovTicket(uint64(m.UID))
	}
	if m.OID != 0 {
		n += 1 + sovTicket(uint64(m.OID))
	}
	if m.SID != 0 {
		n += 1 + sovTicket(uint64(m.SID))
	}
	if m.Price != 0 {
		n += 1 + sovTicket(uint64(m.Price))
	}
	if m.Src != 0 {
		n += 1 + sovTicket(uint64(m.Src))
	}
	if m.Type != 0 {
		n += 1 + sovTicket(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovTicket(uint64(m.Status))
	}
	l = len(m.Qr)
	if l > 0 {
		n += 1 + l + sovTicket(uint64(l))
	}
	if m.RefID != 0 {
		n += 1 + sovTicket(uint64(m.RefID))
	}
	if m.SkuID != 0 {
		n += 1 + sovTicket(uint64(m.SkuID))
	}
	if m.SeatID != 0 {
		n += 1 + sovTicket(uint64(m.SeatID))
	}
	l = len(m.Seat)
	if l > 0 {
		n += 1 + l + sovTicket(uint64(l))
	}
	if m.RefundApplyTime != 0 {
		n += 1 + sovTicket(uint64(m.RefundApplyTime))
	}
	if m.ETime != 0 {
		n += 1 + sovTicket(uint64(m.ETime))
	}
	if m.CTime != 0 {
		n += 2 + sovTicket(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 2 + sovTicket(uint64(m.MTime))
	}
	return n
}

func (m *TicketSendRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.SendTID) > 0 {
		l = 0
		for _, e := range m.SendTID {
			l += sovTicket(uint64(e))
		}
		n += 1 + sovTicket(uint64(l)) + l
	}
	if len(m.RecvTID) > 0 {
		l = 0
		for _, e := range m.RecvTID {
			l += sovTicket(uint64(e))
		}
		n += 1 + sovTicket(uint64(l)) + l
	}
	return n
}

func (m *TicketSendResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.TicketSends) > 0 {
		for _, e := range m.TicketSends {
			l = e.Size()
			n += 1 + l + sovTicket(uint64(l))
		}
	}
	return n
}

func (m *TicketSendItem) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTicket(uint64(m.ID))
	}
	if m.SID != 0 {
		n += 1 + sovTicket(uint64(m.SID))
	}
	if m.SendTID != 0 {
		n += 1 + sovTicket(uint64(m.SendTID))
	}
	if m.RecvTID != 0 {
		n += 1 + sovTicket(uint64(m.RecvTID))
	}
	if m.SendUID != 0 {
		n += 1 + sovTicket(uint64(m.SendUID))
	}
	if m.RecvUID != 0 {
		n += 1 + sovTicket(uint64(m.RecvUID))
	}
	l = len(m.RecvTel)
	if l > 0 {
		n += 1 + l + sovTicket(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTicket(uint64(m.Status))
	}
	if m.CTime != 0 {
		n += 1 + sovTicket(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovTicket(uint64(m.MTime))
	}
	if m.OID != 0 {
		n += 1 + sovTicket(uint64(m.OID))
	}
	return n
}

func sovTicket(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTicket(x uint64) (n int) {
	return sovTicket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TicketViewRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TicketViewRequest{`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`UID:` + fmt.Sprintf("%v", this.UID) + `,`,
		`ScreenID:` + fmt.Sprintf("%v", this.ScreenID) + `,`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TicketViewResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TicketViewResponse{`,
		`Tickets:` + strings.Replace(fmt.Sprintf("%v", this.Tickets), "TicketItem", "TicketItem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TicketItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TicketItem{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`UID:` + fmt.Sprintf("%v", this.UID) + `,`,
		`OID:` + fmt.Sprintf("%v", this.OID) + `,`,
		`SID:` + fmt.Sprintf("%v", this.SID) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`Src:` + fmt.Sprintf("%v", this.Src) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Qr:` + fmt.Sprintf("%v", this.Qr) + `,`,
		`RefID:` + fmt.Sprintf("%v", this.RefID) + `,`,
		`SkuID:` + fmt.Sprintf("%v", this.SkuID) + `,`,
		`SeatID:` + fmt.Sprintf("%v", this.SeatID) + `,`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`RefundApplyTime:` + fmt.Sprintf("%v", this.RefundApplyTime) + `,`,
		`ETime:` + fmt.Sprintf("%v", this.ETime) + `,`,
		`CTime:` + fmt.Sprintf("%v", this.CTime) + `,`,
		`MTime:` + fmt.Sprintf("%v", this.MTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TicketSendRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TicketSendRequest{`,
		`SendTID:` + fmt.Sprintf("%v", this.SendTID) + `,`,
		`RecvTID:` + fmt.Sprintf("%v", this.RecvTID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TicketSendResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TicketSendResponse{`,
		`TicketSends:` + strings.Replace(fmt.Sprintf("%v", this.TicketSends), "TicketSendItem", "TicketSendItem", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TicketSendItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TicketSendItem{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`SID:` + fmt.Sprintf("%v", this.SID) + `,`,
		`SendTID:` + fmt.Sprintf("%v", this.SendTID) + `,`,
		`RecvTID:` + fmt.Sprintf("%v", this.RecvTID) + `,`,
		`SendUID:` + fmt.Sprintf("%v", this.SendUID) + `,`,
		`RecvUID:` + fmt.Sprintf("%v", this.RecvUID) + `,`,
		`RecvTel:` + fmt.Sprintf("%v", this.RecvTel) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`CTime:` + fmt.Sprintf("%v", this.CTime) + `,`,
		`MTime:` + fmt.Sprintf("%v", this.MTime) + `,`,
		`OID:` + fmt.Sprintf("%v", this.OID) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTicket(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TicketViewRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketViewRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketViewRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenID", wireType)
			}
			m.ScreenID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScreenID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTicket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ID = append(m.ID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTicket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTicket
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTicket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ID = append(m.ID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTicket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketViewResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketViewResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketViewResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tickets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTicket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tickets = append(m.Tickets, &TicketItem{})
			if err := m.Tickets[len(m.Tickets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTicket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OID", wireType)
			}
			m.OID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			m.SID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			m.Src = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Src |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefID", wireType)
			}
			m.RefID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkuID", wireType)
			}
			m.SkuID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkuID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatID", wireType)
			}
			m.SeatID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundApplyTime", wireType)
			}
			m.RefundApplyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundApplyTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ETime", wireType)
			}
			m.ETime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ETime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTicket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketSendRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketSendRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketSendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTicket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SendTID = append(m.SendTID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTicket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTicket
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTicket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SendTID = append(m.SendTID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTID", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTicket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RecvTID = append(m.RecvTID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTicket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTicket
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTicket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RecvTID = append(m.RecvTID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvTID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTicket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketSendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketSendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketSendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketSends", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTicket
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketSends = append(m.TicketSends, &TicketSendItem{})
			if err := m.TicketSends[len(m.TicketSends)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTicket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicketSendItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicketSendItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicketSendItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			m.SID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTID", wireType)
			}
			m.SendTID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendTID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvTID", wireType)
			}
			m.RecvTID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvTID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendUID", wireType)
			}
			m.SendUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendUID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvUID", wireType)
			}
			m.RecvUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvUID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvTel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicket
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecvTel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OID", wireType)
			}
			m.OID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTicket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTicket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTicket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTicket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTicket
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTicket
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTicket(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTicket = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTicket   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/ticket-sales/api/grpc/v1/ticket.proto", fileDescriptorTicket)
}

var fileDescriptorTicket = []byte{
	// 808 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0x5f, 0xdb, 0xb5, 0xd3, 0x4c, 0x4a, 0x97, 0x8e, 0x10, 0x78, 0x77, 0x21, 0x0e, 0x59, 0x09,
	0x02, 0xa8, 0xb1, 0xba, 0x48, 0xdc, 0x58, 0x89, 0x12, 0x0e, 0x06, 0xa1, 0x95, 0x9c, 0x94, 0x03,
	0x97, 0xe0, 0x78, 0x5e, 0xc2, 0x28, 0xf1, 0x9f, 0xce, 0x8c, 0x83, 0x7a, 0xe3, 0xc0, 0x97, 0xe0,
	0x1b, 0x2d, 0x37, 0x4e, 0x88, 0x93, 0xc5, 0xfa, 0x63, 0xf4, 0x84, 0x66, 0x6c, 0x27, 0x4e, 0x80,
	0xa6, 0x62, 0x6f, 0x9e, 0xf7, 0xfb, 0xf3, 0xf2, 0xe2, 0xf7, 0x1b, 0xa3, 0xe7, 0x41, 0x9a, 0xba,
	0x1c, 0xd8, 0x9a, 0x86, 0xe0, 0x26, 0x29, 0xc4, 0xe9, 0x2a, 0x10, 0xf3, 0x84, 0x45, 0xae, 0xa0,
	0xe1, 0x12, 0xc4, 0x39, 0x0f, 0x56, 0xc0, 0xdd, 0x20, 0xa5, 0xee, 0x82, 0xa5, 0xa1, 0xbb, 0xbe,
	0xa8, 0x80, 0x61, 0xca, 0x12, 0x91, 0xe0, 0x77, 0xaa, 0x53, 0x65, 0x31, 0x54, 0xf4, 0xe1, 0xfa,
	0xe2, 0xf1, 0xf9, 0x82, 0x8a, 0x1f, 0xb3, 0xd9, 0x30, 0x4c, 0x22, 0x77, 0x91, 0x2c, 0x12, 0x57,
	0xf1, 0x67, 0xd9, 0x5c, 0x9d, 0xd4, 0x41, 0x3d, 0x95, 0x3e, 0xfd, 0x5f, 0x35, 0x74, 0x36, 0x51,
	0x56, 0xdf, 0x51, 0xf8, 0xc9, 0x87, 0xeb, 0x0c, 0xb8, 0xc0, 0x1f, 0xa0, 0xe3, 0x84, 0x11, 0x60,
	0x53, 0x4a, 0x6c, 0xad, 0xa7, 0x0d, 0x8c, 0xcb, 0x4e, 0x91, 0x3b, 0xad, 0x17, 0xb2, 0xe6, 0x8d,
	0xfc, 0x96, 0x02, 0x3d, 0x82, 0x1f, 0x21, 0x23, 0xa3, 0xc4, 0xd6, 0x15, 0xa5, 0x55, 0xe4, 0x8e,
	0x71, 0xe5, 0x8d, 0x7c, 0x59, 0xc3, 0x1f, 0xa1, 0x36, 0x0f, 0x19, 0x40, 0x2c, 0x3d, 0x0c, 0x45,
	0x38, 0x29, 0x72, 0xe7, 0x78, 0xac, 0x8a, 0xde, 0xc8, 0x3f, 0x2e, 0x61, 0x8f, 0xe0, 0xb7, 0x91,
	0x4e, 0x89, 0x7d, 0xd4, 0x33, 0x06, 0xc6, 0xa5, 0x55, 0xe4, 0x8e, 0xee, 0x8d, 0x7c, 0x9d, 0x92,
	0xfe, 0x18, 0xe1, 0xe6, 0x4f, 0xe3, 0x69, 0x12, 0x73, 0xc0, 0x9f, 0xa3, 0x56, 0x39, 0x3b, 0xb7,
	0xb5, 0x9e, 0x31, 0xe8, 0x3c, 0x7b, 0x3a, 0xfc, 0x8f, 0xff, 0x62, 0x58, 0xaa, 0x3d, 0x01, 0x91,
	0x5f, 0x6b, 0xfa, 0xbf, 0x98, 0x08, 0x6d, 0xeb, 0x55, 0xef, 0x72, 0xc6, 0x46, 0xef, 0xbb, 0x26,
	0x7b, 0x84, 0x8c, 0x64, 0x33, 0x93, 0x82, 0x5e, 0x48, 0x28, 0x29, 0x21, 0xae, 0x46, 0xd9, 0x40,
	0x63, 0x09, 0x71, 0x4a, 0xf0, 0x5b, 0xc8, 0x4c, 0x19, 0x0d, 0xc1, 0x36, 0x25, 0xe8, 0x97, 0x07,
	0xfc, 0x04, 0x19, 0x9c, 0x85, 0xb6, 0xa5, 0x04, 0xed, 0xdb, 0xdc, 0x31, 0x69, 0x2c, 0x2e, 0x3e,
	0xf3, 0x65, 0x15, 0xbf, 0x87, 0x8e, 0xc4, 0x4d, 0x0a, 0x76, 0x6b, 0x1f, 0x55, 0x65, 0xfc, 0x3e,
	0xb2, 0xb8, 0x08, 0x44, 0xc6, 0xed, 0xe3, 0x7d, 0x42, 0x05, 0xe0, 0x53, 0xa4, 0x5f, 0x33, 0xbb,
	0xdd, 0xd3, 0x06, 0x6d, 0x5f, 0xbf, 0x66, 0xb8, 0x87, 0x2c, 0x06, 0x73, 0xf9, 0x46, 0x50, 0x29,
	0x29, 0x72, 0xc7, 0xf4, 0x61, 0xee, 0x8d, 0x7c, 0x93, 0xc1, 0xdc, 0x23, 0x92, 0xc1, 0x97, 0x99,
	0x64, 0x74, 0xb6, 0x8c, 0xf1, 0x32, 0x93, 0x0c, 0xbe, 0xcc, 0x3c, 0x82, 0x9f, 0xa2, 0x16, 0x87,
	0x40, 0x48, 0xca, 0x89, 0xa2, 0xa0, 0x22, 0x77, 0xac, 0x31, 0x04, 0xc2, 0x1b, 0xf9, 0x96, 0x84,
	0x3c, 0x82, 0x31, 0x3a, 0x92, 0x4f, 0xf6, 0x1b, 0xaa, 0xb5, 0x7a, 0xc6, 0xdf, 0xa0, 0x33, 0x06,
	0xf3, 0x2c, 0x26, 0xd3, 0x20, 0x4d, 0x57, 0x37, 0x53, 0x41, 0x23, 0xb0, 0x4f, 0x95, 0x85, 0x73,
	0x9b, 0x3b, 0x4f, 0x16, 0xc9, 0x79, 0x98, 0x44, 0x51, 0x12, 0xbb, 0x2b, 0x3a, 0x63, 0x01, 0xbb,
	0x71, 0x25, 0x63, 0x38, 0xa1, 0x11, 0xf8, 0x0f, 0x4b, 0xe5, 0x17, 0x52, 0x28, 0x0b, 0xf8, 0x39,
	0x32, 0x41, 0x19, 0x3c, 0x54, 0x06, 0x03, 0xf9, 0x33, 0xbf, 0x92, 0xc8, 0x21, 0xa7, 0x52, 0x26,
	0xf5, 0xa1, 0xd2, 0xbf, 0xb9, 0xd5, 0x7f, 0x79, 0x2f, 0x7d, 0x58, 0xeb, 0x23, 0xa5, 0x3f, 0xdb,
	0xea, 0xbf, 0xbd, 0x97, 0x5e, 0xc9, 0xfa, 0x61, 0x1d, 0xbb, 0x31, 0xc4, 0xa4, 0x11, 0x3b, 0x0e,
	0x31, 0x99, 0x0a, 0xb5, 0x92, 0x46, 0x1d, 0x3b, 0x49, 0x99, 0xc8, 0xd8, 0x49, 0x70, 0x42, 0x89,
	0xe4, 0x31, 0x08, 0xd7, 0x8a, 0xa7, 0x6f, 0x79, 0x3e, 0x84, 0x6b, 0xc5, 0x93, 0xe0, 0x84, 0x92,
	0xfe, 0x0f, 0x75, 0x80, 0xca, 0x26, 0x55, 0x80, 0xbe, 0x46, 0x27, 0x65, 0x18, 0xa6, 0xd2, 0xaf,
	0x4e, 0xd1, 0x87, 0x07, 0x52, 0x24, 0x2d, 0x54, 0x92, 0x3a, 0x62, 0x73, 0xe6, 0xfd, 0xdf, 0x0c,
	0x74, 0xba, 0x8b, 0xdf, 0x95, 0x28, 0xbe, 0x9b, 0xa8, 0x4d, 0x36, 0x9a, 0x73, 0x1b, 0xdb, 0xeb,
	0xe6, 0xce, 0xb9, 0x8f, 0xb6, 0xbc, 0xfd, 0xb9, 0x37, 0x7e, 0x32, 0xc1, 0xe6, 0xae, 0xdf, 0x55,
	0xed, 0x77, 0xd5, 0xf0, 0x93, 0x3c, 0x6b, 0xd7, 0xef, 0xaa, 0xf6, 0x6b, 0xf2, 0x04, 0xac, 0x54,
	0x18, 0xdb, 0x8d, 0xbe, 0xb0, 0xaa, 0xfa, 0xc2, 0x6a, 0x2f, 0x91, 0xe6, 0xbf, 0x25, 0x72, 0xb3,
	0x77, 0xed, 0xd7, 0xdc, 0x3b, 0xf4, 0xbf, 0xf6, 0xae, 0xbe, 0xbc, 0x3a, 0xff, 0xbc, 0xbc, 0x9e,
	0xfd, 0xa1, 0x21, 0xab, 0x7c, 0x97, 0x18, 0xea, 0x3b, 0x52, 0xde, 0xbc, 0xf8, 0xe3, 0x03, 0xab,
	0xd1, 0xf8, 0x72, 0x3c, 0xfe, 0xe4, 0x5e, 0xdc, 0x6a, 0x13, 0x37, 0x6d, 0xe4, 0x9b, 0x39, 0xd8,
	0xa6, 0x91, 0x94, 0x83, 0x6d, 0x9a, 0x0b, 0x7f, 0xf9, 0xee, 0xcb, 0x57, 0xdd, 0x07, 0x7f, 0xbe,
	0xea, 0x3e, 0xf8, 0xb9, 0xe8, 0x6a, 0x2f, 0x8b, 0xae, 0xf6, 0x7b, 0xd1, 0xd5, 0xfe, 0x2a, 0xba,
	0xda, 0xf7, 0xfa, 0xfa, 0x62, 0x66, 0xa9, 0x0f, 0xe1, 0xa7, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff,
	0x21, 0x74, 0x26, 0xf8, 0x92, 0x07, 0x00, 0x00,
}
