// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/ticket-sales/api/grpc/v1/order.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import ticket_service_sales_v1 "go-common/app/service/openplatform/ticket-sales/api/grpc/type"
import _ "github.com/gogo/protobuf/gogoproto"

import go_common_library_time "go-common/library/time"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ListOrdersRequest 用户订单列表请求参数
type ListOrdersRequest struct {
	UID          string  `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	OrderID      []int64 `protobuf:"varint,2,rep,packed,name=order_id,json=orderId" json:"order_id,omitempty"`
	ItemID       int64   `protobuf:"varint,3,opt,name=item_id,json=itemId,proto3" json:"item_id,omitempty"`
	Status       []int16 `protobuf:"varint,4,rep,packed,name=status,casttype=int16" json:"status,omitempty"`
	SubStatus    []int16 `protobuf:"varint,5,rep,packed,name=sub_status,json=subStatus,casttype=int16" json:"sub_status,omitempty"`
	RefundStatus []int16 `protobuf:"varint,6,rep,packed,name=refund_status,json=refundStatus,casttype=int16" json:"refund_status,omitempty"`
	Limit        int64   `protobuf:"varint,7,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset       int64   `protobuf:"varint,8,opt,name=offset,proto3" json:"offset,omitempty"`
	OrderBy      string  `protobuf:"bytes,9,opt,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
}

func (m *ListOrdersRequest) Reset()                    { *m = ListOrdersRequest{} }
func (*ListOrdersRequest) ProtoMessage()               {}
func (*ListOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{0} }

// ListOrdersResponse 用户订单列表返回
type ListOrdersResponse struct {
	List       []*OrderResponse `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	Count      int64            `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	NextOffset int64            `protobuf:"varint,3,opt,name=next_offset,json=nextOffset,proto3" json:"next_offset,omitempty"`
}

func (m *ListOrdersResponse) Reset()                    { *m = ListOrdersResponse{} }
func (*ListOrdersResponse) ProtoMessage()               {}
func (*ListOrdersResponse) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{1} }

// OrderResponse 单个订单响应
type OrderResponse struct {
	OrderID      int64                                   `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	UID          string                                  `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid"`
	OrderType    int16                                   `protobuf:"varint,3,opt,name=order_type,json=orderType,proto3,casttype=int16" json:"order_type"`
	ItemID       int64                                   `protobuf:"varint,4,opt,name=item_id,json=itemId,proto3" json:"item_id"`
	ItemInfo     *ticket_service_sales_v1.OrderItemInfo  `protobuf:"bytes,5,opt,name=item_info,json=itemInfo" json:"item_info"`
	Count        int64                                   `protobuf:"varint,6,opt,name=count,proto3" json:"count"`
	TotalMoney   int64                                   `protobuf:"varint,7,opt,name=total_money,json=totalMoney,proto3" json:"total_money"`
	PayMoney     int64                                   `protobuf:"varint,8,opt,name=pay_money,json=payMoney,proto3" json:"pay_money"`
	ExpressFee   int64                                   `protobuf:"varint,9,opt,name=express_fee,json=expressFee,proto3" json:"express_fee"`
	Status       int16                                   `protobuf:"varint,10,opt,name=status,proto3,casttype=int16" json:"status"`
	SubStatus    int16                                   `protobuf:"varint,11,opt,name=sub_status,json=subStatus,proto3,casttype=int16" json:"sub_status"`
	RefundStatus int16                                   `protobuf:"varint,12,opt,name=refund_status,json=refundStatus,proto3,casttype=int16" json:"refund_status"`
	Source       string                                  `protobuf:"bytes,13,opt,name=source,proto3" json:"source"`
	IsDeleted    int16                                   `protobuf:"varint,14,opt,name=is_deleted,json=isDeleted,proto3,casttype=int16" json:"is_deleted"`
	SKUs         []*ticket_service_sales_v1.OrderSKU     `protobuf:"bytes,15,rep,name=skus" json:"order_sku"`
	Detail       *OrderResponseMore                      `protobuf:"bytes,16,opt,name=detail" json:"detail"`
	PayCharge    *ticket_service_sales_v1.OrderPayCharge `protobuf:"bytes,17,opt,name=pay_charge,json=payCharge" json:"pay_charge"`
	CTime        go_common_library_time.Time             `protobuf:"varint,18,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	MTime        go_common_library_time.Time             `protobuf:"varint,19,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
}

func (m *OrderResponse) Reset()                    { *m = OrderResponse{} }
func (*OrderResponse) ProtoMessage()               {}
func (*OrderResponse) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{2} }

// OrderResponseMore 更详细的订单响应信息
type OrderResponseMore struct {
	Coupon      *ticket_service_sales_v1.OrderCoupon  `protobuf:"bytes,1,opt,name=coupon" json:"coupon"`
	Buyers      []*ticket_service_sales_v1.OrderBuyer `protobuf:"bytes,2,rep,name=buyers" json:"buyers"`
	Extra       *ticket_service_sales_v1.OrderExtra   `protobuf:"bytes,3,opt,name=extra" json:"extra"`
	Deliver     *ticket_service_sales_v1.OrderDeliver `protobuf:"bytes,4,opt,name=deliver" json:"deliver"`
	Remark      string                                `protobuf:"bytes,5,opt,name=remark,proto3" json:"remark"`
	DeviceType  int16                                 `protobuf:"varint,6,opt,name=device_type,json=deviceType,proto3,casttype=int16" json:"device_type"`
	IP          uint32                                `protobuf:"varint,7,opt,name=ip,proto3" json:"ip"`
	MSource     string                                `protobuf:"bytes,8,opt,name=msource,proto3" json:"msource"`
	ExpressCO   string                                `protobuf:"bytes,9,opt,name=express_co,json=expressCo,proto3" json:"-"`
	ExpressNO   string                                `protobuf:"bytes,10,opt,name=express_no,json=expressNo,proto3" json:"-"`
	ExpressType int16                                 `protobuf:"varint,11,opt,name=express_type,json=expressType,proto3,casttype=int16" json:"-"`
}

func (m *OrderResponseMore) Reset()                    { *m = OrderResponseMore{} }
func (*OrderResponseMore) ProtoMessage()               {}
func (*OrderResponseMore) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{3} }

// CreateOrderSKU 创建订单的sku请求
type CreateOrderSKU struct {
	SKUID int64 `protobuf:"varint,1,opt,name=sku_id,json=skuId,proto3" json:"sku_id,omitempty"`
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *CreateOrderSKU) Reset()                    { *m = CreateOrderSKU{} }
func (*CreateOrderSKU) ProtoMessage()               {}
func (*CreateOrderSKU) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{4} }

// CreateOrderRequest 单个订单创建请求
type CreateOrderRequest struct {
	ProjectID     int64                                 `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	ScreenID      int64                                 `protobuf:"varint,2,opt,name=screen_id,json=screenId,proto3" json:"screen_id,omitempty"`
	SKUs          []*CreateOrderSKU                     `protobuf:"bytes,3,rep,name=skus" json:"skus,omitempty"`
	UID           int64                                 `protobuf:"varint,4,opt,name=uid,proto3" json:"uid,omitempty"`
	PayMoney      int64                                 `protobuf:"varint,5,opt,name=pay_money,json=payMoney,proto3" json:"pay_money,omitempty"`
	OrderType     int16                                 `protobuf:"varint,6,opt,name=order_type,json=orderType,proto3,casttype=int16" json:"order_type,omitempty"`
	TS            int64                                 `protobuf:"varint,7,opt,name=ts,proto3" json:"ts,omitempty"`
	PromoID       int64                                 `protobuf:"varint,8,opt,name=promo_id,json=promoId,proto3" json:"promo_id,omitempty"`
	PromoGroupID  int64                                 `protobuf:"varint,9,opt,name=promo_group_id,json=promoGroupId,proto3" json:"promo_group_id,omitempty"`
	Buyers        []*ticket_service_sales_v1.OrderBuyer `protobuf:"bytes,10,rep,name=buyers" json:"buyers,omitempty"`
	DeliverDetail *ticket_service_sales_v1.OrderDeliver `protobuf:"bytes,11,opt,name=deliver_detail,json=deliverDetail" json:"deliver_detail,omitempty"`
	Seats         []uint64                              `protobuf:"varint,12,rep,packed,name=seats" json:"seats,omitempty"`
	Coupons       []string                              `protobuf:"bytes,13,rep,name=coupons" json:"coupons,omitempty"`
	LockID        int64                                 `protobuf:"varint,14,opt,name=lock_id,json=lockId,proto3" json:"lock_id,omitempty"`
	Source        string                                `protobuf:"bytes,15,opt,name=source,proto3" json:"source,omitempty"`
	IsDeleted     int16                                 `protobuf:"varint,16,opt,name=is_deleted,json=isDeleted,proto3,casttype=int16" json:"is_deleted,omitempty"`
	DeviceType    int16                                 `protobuf:"varint,17,opt,name=device_type,json=deviceType,proto3,casttype=int16" json:"device_type,omitempty"`
}

func (m *CreateOrderRequest) Reset()                    { *m = CreateOrderRequest{} }
func (*CreateOrderRequest) ProtoMessage()               {}
func (*CreateOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{5} }

// CreateOrdersRequest 创建订单请求
type CreateOrdersRequest struct {
	Orders []*CreateOrderRequest `protobuf:"bytes,1,rep,name=orders" json:"orders,omitempty"`
}

func (m *CreateOrdersRequest) Reset()                    { *m = CreateOrdersRequest{} }
func (*CreateOrdersRequest) ProtoMessage()               {}
func (*CreateOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{6} }

// CreateOrderResult 创建订单结果
type CreateOrderResult struct {
	OrderID int64  `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Code    int    `protobuf:"varint,2,opt,name=code,proto3,casttype=int" json:"code,omitempty"`
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *CreateOrderResult) Reset()                    { *m = CreateOrderResult{} }
func (*CreateOrderResult) ProtoMessage()               {}
func (*CreateOrderResult) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{7} }

// CreateOrdersResponse 创建订单响应
type CreateOrdersResponse struct {
	Count  uint32               `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	Result []*CreateOrderResult `protobuf:"bytes,2,rep,name=result" json:"result,omitempty"`
}

func (m *CreateOrdersResponse) Reset()                    { *m = CreateOrdersResponse{} }
func (*CreateOrdersResponse) ProtoMessage()               {}
func (*CreateOrdersResponse) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{8} }

// UpBuyerRequest 更新购买人信息
type UpBuyerRequest struct {
	OrderID int64                               `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Buyers  *ticket_service_sales_v1.OrderBuyer `protobuf:"bytes,2,opt,name=buyers" json:"buyers,omitempty"`
}

func (m *UpBuyerRequest) Reset()                    { *m = UpBuyerRequest{} }
func (*UpBuyerRequest) ProtoMessage()               {}
func (*UpBuyerRequest) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{9} }

// UpDeliveryRequest 更新配送信息
type UpDeliveryRequest struct {
	OrderID       int64                                 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	DeliverDetail *ticket_service_sales_v1.OrderDeliver `protobuf:"bytes,2,opt,name=deliver_detail,json=deliverDetail" json:"deliver_detail"`
}

func (m *UpDeliveryRequest) Reset()                    { *m = UpDeliveryRequest{} }
func (*UpDeliveryRequest) ProtoMessage()               {}
func (*UpDeliveryRequest) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{10} }

// UpDetailResponse 更新返回数据
type UpDetailResponse struct {
	OrderID  int64 `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	IsUpdate int16 `protobuf:"varint,2,opt,name=is_update,json=isUpdate,proto3,casttype=int16" json:"update"`
}

func (m *UpDetailResponse) Reset()                    { *m = UpDetailResponse{} }
func (*UpDetailResponse) ProtoMessage()               {}
func (*UpDetailResponse) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{11} }

// OrderLog 订单日志
type OrderLog struct {
	ID       int64                       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	UID      string                      `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	OID      int64                       `protobuf:"varint,3,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	IP       string                      `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	OpData   string                      `protobuf:"bytes,5,opt,name=op_data,json=opData,proto3" json:"op_data,omitempty"`
	Remark   string                      `protobuf:"bytes,6,opt,name=remark,proto3" json:"remark,omitempty"`
	OpObject string                      `protobuf:"bytes,7,opt,name=op_object,json=opObject,proto3" json:"op_object,omitempty"`
	OpName   string                      `protobuf:"bytes,8,opt,name=op_name,json=opName,proto3" json:"op_name,omitempty"`
	CTime    go_common_library_time.Time `protobuf:"varint,9,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"ctime,omitempty"`
	MTime    go_common_library_time.Time `protobuf:"varint,10,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"mtime,omitempty"`
}

func (m *OrderLog) Reset()                    { *m = OrderLog{} }
func (*OrderLog) ProtoMessage()               {}
func (*OrderLog) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{12} }

// ListOrdersLogRequest 订单日志
type ListOrderLogRequest struct {
	OrderID int64  `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Limit   int64  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset  int64  `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	OrderBy string `protobuf:"bytes,4,opt,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
}

func (m *ListOrderLogRequest) Reset()                    { *m = ListOrderLogRequest{} }
func (*ListOrderLogRequest) ProtoMessage()               {}
func (*ListOrderLogRequest) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{13} }

// ListOrderLogResponse 订单日志相应
type ListOrderLogResponse struct {
	List []*OrderLog `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	Cnt  int64       `protobuf:"varint,2,opt,name=cnt,proto3" json:"cnt,omitempty"`
}

func (m *ListOrderLogResponse) Reset()                    { *m = ListOrderLogResponse{} }
func (*ListOrderLogResponse) ProtoMessage()               {}
func (*ListOrderLogResponse) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{14} }

// AddOrderLogRequest 订单日志插入
type AddOrderLogRequest struct {
	Data *OrderLog `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *AddOrderLogRequest) Reset()                    { *m = AddOrderLogRequest{} }
func (*AddOrderLogRequest) ProtoMessage()               {}
func (*AddOrderLogRequest) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{15} }

// AddOrderLogResponse 订单日志插入相应
type AddOrderLogResponse struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *AddOrderLogResponse) Reset()                    { *m = AddOrderLogResponse{} }
func (*AddOrderLogResponse) ProtoMessage()               {}
func (*AddOrderLogResponse) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{16} }

func init() {
	proto.RegisterType((*ListOrdersRequest)(nil), "ticket.service.sales.v1.ListOrdersRequest")
	proto.RegisterType((*ListOrdersResponse)(nil), "ticket.service.sales.v1.ListOrdersResponse")
	proto.RegisterType((*OrderResponse)(nil), "ticket.service.sales.v1.OrderResponse")
	proto.RegisterType((*OrderResponseMore)(nil), "ticket.service.sales.v1.OrderResponseMore")
	proto.RegisterType((*CreateOrderSKU)(nil), "ticket.service.sales.v1.CreateOrderSKU")
	proto.RegisterType((*CreateOrderRequest)(nil), "ticket.service.sales.v1.CreateOrderRequest")
	proto.RegisterType((*CreateOrdersRequest)(nil), "ticket.service.sales.v1.CreateOrdersRequest")
	proto.RegisterType((*CreateOrderResult)(nil), "ticket.service.sales.v1.CreateOrderResult")
	proto.RegisterType((*CreateOrdersResponse)(nil), "ticket.service.sales.v1.CreateOrdersResponse")
	proto.RegisterType((*UpBuyerRequest)(nil), "ticket.service.sales.v1.UpBuyerRequest")
	proto.RegisterType((*UpDeliveryRequest)(nil), "ticket.service.sales.v1.UpDeliveryRequest")
	proto.RegisterType((*UpDetailResponse)(nil), "ticket.service.sales.v1.UpDetailResponse")
	proto.RegisterType((*OrderLog)(nil), "ticket.service.sales.v1.OrderLog")
	proto.RegisterType((*ListOrderLogRequest)(nil), "ticket.service.sales.v1.ListOrderLogRequest")
	proto.RegisterType((*ListOrderLogResponse)(nil), "ticket.service.sales.v1.ListOrderLogResponse")
	proto.RegisterType((*AddOrderLogRequest)(nil), "ticket.service.sales.v1.AddOrderLogRequest")
	proto.RegisterType((*AddOrderLogResponse)(nil), "ticket.service.sales.v1.AddOrderLogResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Trade service

type TradeClient interface {
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
	CreateOrders(ctx context.Context, in *CreateOrdersRequest, opts ...grpc.CallOption) (*CreateOrdersResponse, error)
	UpdateBuyer(ctx context.Context, in *UpBuyerRequest, opts ...grpc.CallOption) (*UpDetailResponse, error)
	UpdateDelivery(ctx context.Context, in *UpDeliveryRequest, opts ...grpc.CallOption) (*UpDetailResponse, error)
	ListOrderLogs(ctx context.Context, in *ListOrderLogRequest, opts ...grpc.CallOption) (*ListOrderLogResponse, error)
	AddOrderLogs(ctx context.Context, in *AddOrderLogRequest, opts ...grpc.CallOption) (*AddOrderLogResponse, error)
}

type tradeClient struct {
	cc *grpc.ClientConn
}

func NewTradeClient(cc *grpc.ClientConn) TradeClient {
	return &tradeClient{cc}
}

func (c *tradeClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	out := new(ListOrdersResponse)
	err := grpc.Invoke(ctx, "/ticket.service.sales.v1.Trade/ListOrders", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) CreateOrders(ctx context.Context, in *CreateOrdersRequest, opts ...grpc.CallOption) (*CreateOrdersResponse, error) {
	out := new(CreateOrdersResponse)
	err := grpc.Invoke(ctx, "/ticket.service.sales.v1.Trade/CreateOrders", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) UpdateBuyer(ctx context.Context, in *UpBuyerRequest, opts ...grpc.CallOption) (*UpDetailResponse, error) {
	out := new(UpDetailResponse)
	err := grpc.Invoke(ctx, "/ticket.service.sales.v1.Trade/UpdateBuyer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) UpdateDelivery(ctx context.Context, in *UpDeliveryRequest, opts ...grpc.CallOption) (*UpDetailResponse, error) {
	out := new(UpDetailResponse)
	err := grpc.Invoke(ctx, "/ticket.service.sales.v1.Trade/UpdateDelivery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) ListOrderLogs(ctx context.Context, in *ListOrderLogRequest, opts ...grpc.CallOption) (*ListOrderLogResponse, error) {
	out := new(ListOrderLogResponse)
	err := grpc.Invoke(ctx, "/ticket.service.sales.v1.Trade/ListOrderLogs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) AddOrderLogs(ctx context.Context, in *AddOrderLogRequest, opts ...grpc.CallOption) (*AddOrderLogResponse, error) {
	out := new(AddOrderLogResponse)
	err := grpc.Invoke(ctx, "/ticket.service.sales.v1.Trade/AddOrderLogs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Trade service

type TradeServer interface {
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	CreateOrders(context.Context, *CreateOrdersRequest) (*CreateOrdersResponse, error)
	UpdateBuyer(context.Context, *UpBuyerRequest) (*UpDetailResponse, error)
	UpdateDelivery(context.Context, *UpDeliveryRequest) (*UpDetailResponse, error)
	ListOrderLogs(context.Context, *ListOrderLogRequest) (*ListOrderLogResponse, error)
	AddOrderLogs(context.Context, *AddOrderLogRequest) (*AddOrderLogResponse, error)
}

func RegisterTradeServer(s *grpc.Server, srv TradeServer) {
	s.RegisterService(&_Trade_serviceDesc, srv)
}

func _Trade_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.sales.v1.Trade/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_CreateOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).CreateOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.sales.v1.Trade/CreateOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).CreateOrders(ctx, req.(*CreateOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_UpdateBuyer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpBuyerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).UpdateBuyer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.sales.v1.Trade/UpdateBuyer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).UpdateBuyer(ctx, req.(*UpBuyerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_UpdateDelivery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpDeliveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).UpdateDelivery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.sales.v1.Trade/UpdateDelivery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).UpdateDelivery(ctx, req.(*UpDeliveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_ListOrderLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrderLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).ListOrderLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.sales.v1.Trade/ListOrderLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).ListOrderLogs(ctx, req.(*ListOrderLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_AddOrderLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddOrderLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).AddOrderLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.sales.v1.Trade/AddOrderLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).AddOrderLogs(ctx, req.(*AddOrderLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Trade_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ticket.service.sales.v1.Trade",
	HandlerType: (*TradeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListOrders",
			Handler:    _Trade_ListOrders_Handler,
		},
		{
			MethodName: "CreateOrders",
			Handler:    _Trade_CreateOrders_Handler,
		},
		{
			MethodName: "UpdateBuyer",
			Handler:    _Trade_UpdateBuyer_Handler,
		},
		{
			MethodName: "UpdateDelivery",
			Handler:    _Trade_UpdateDelivery_Handler,
		},
		{
			MethodName: "ListOrderLogs",
			Handler:    _Trade_ListOrderLogs_Handler,
		},
		{
			MethodName: "AddOrderLogs",
			Handler:    _Trade_AddOrderLogs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/openplatform/ticket-sales/api/grpc/v1/order.proto",
}

func (m *ListOrdersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOrdersRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.UID)))
		i += copy(dAtA[i:], m.UID)
	}
	if len(m.OrderID) > 0 {
		dAtA2 := make([]byte, len(m.OrderID)*10)
		var j1 int
		for _, num1 := range m.OrderID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ItemID))
	}
	if len(m.Status) > 0 {
		dAtA4 := make([]byte, len(m.Status)*10)
		var j3 int
		for _, num1 := range m.Status {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrder(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.SubStatus) > 0 {
		dAtA6 := make([]byte, len(m.SubStatus)*10)
		var j5 int
		for _, num1 := range m.SubStatus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.RefundStatus) > 0 {
		dAtA8 := make([]byte, len(m.RefundStatus)*10)
		var j7 int
		for _, num1 := range m.RefundStatus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintOrder(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.Limit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Limit))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Offset))
	}
	if len(m.OrderBy) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OrderBy)))
		i += copy(dAtA[i:], m.OrderBy)
	}
	return i, nil
}

func (m *ListOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOrder(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Count))
	}
	if m.NextOffset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.NextOffset))
	}
	return i, nil
}

func (m *OrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderID))
	}
	if len(m.UID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.UID)))
		i += copy(dAtA[i:], m.UID)
	}
	if m.OrderType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderType))
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ItemID))
	}
	if m.ItemInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ItemInfo.Size()))
		n9, err := m.ItemInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Count != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Count))
	}
	if m.TotalMoney != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.TotalMoney))
	}
	if m.PayMoney != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.PayMoney))
	}
	if m.ExpressFee != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ExpressFee))
	}
	if m.Status != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Status))
	}
	if m.SubStatus != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.SubStatus))
	}
	if m.RefundStatus != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.RefundStatus))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if m.IsDeleted != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.IsDeleted))
	}
	if len(m.SKUs) > 0 {
		for _, msg := range m.SKUs {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintOrder(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Detail != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Detail.Size()))
		n10, err := m.Detail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.PayCharge != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.PayCharge.Size()))
		n11, err := m.PayCharge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.CTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.CTime))
	}
	if m.MTime != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.MTime))
	}
	return i, nil
}

func (m *OrderResponseMore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderResponseMore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Coupon != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Coupon.Size()))
		n12, err := m.Coupon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Buyers) > 0 {
		for _, msg := range m.Buyers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOrder(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Extra != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Extra.Size()))
		n13, err := m.Extra.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Deliver != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Deliver.Size()))
		n14, err := m.Deliver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Remark) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Remark)))
		i += copy(dAtA[i:], m.Remark)
	}
	if m.DeviceType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.DeviceType))
	}
	if m.IP != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.IP))
	}
	if len(m.MSource) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.MSource)))
		i += copy(dAtA[i:], m.MSource)
	}
	if len(m.ExpressCO) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.ExpressCO)))
		i += copy(dAtA[i:], m.ExpressCO)
	}
	if len(m.ExpressNO) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.ExpressNO)))
		i += copy(dAtA[i:], m.ExpressNO)
	}
	if m.ExpressType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ExpressType))
	}
	return i, nil
}

func (m *CreateOrderSKU) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOrderSKU) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SKUID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.SKUID))
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *CreateOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProjectID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ProjectID))
	}
	if m.ScreenID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ScreenID))
	}
	if len(m.SKUs) > 0 {
		for _, msg := range m.SKUs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOrder(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.UID))
	}
	if m.PayMoney != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.PayMoney))
	}
	if m.OrderType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderType))
	}
	if m.TS != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.TS))
	}
	if m.PromoID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.PromoID))
	}
	if m.PromoGroupID != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.PromoGroupID))
	}
	if len(m.Buyers) > 0 {
		for _, msg := range m.Buyers {
			dAtA[i] = 0x52
			i++
			i = encodeVarintOrder(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DeliverDetail != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.DeliverDetail.Size()))
		n15, err := m.DeliverDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Seats) > 0 {
		dAtA17 := make([]byte, len(m.Seats)*10)
		var j16 int
		for _, num := range m.Seats {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintOrder(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if len(m.Coupons) > 0 {
		for _, s := range m.Coupons {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.LockID != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.LockID))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if m.IsDeleted != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.IsDeleted))
	}
	if m.DeviceType != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.DeviceType))
	}
	return i, nil
}

func (m *CreateOrdersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOrdersRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for _, msg := range m.Orders {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOrder(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateOrderResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOrderResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderID))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *CreateOrdersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOrdersResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Count))
	}
	if len(m.Result) > 0 {
		for _, msg := range m.Result {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOrder(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpBuyerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpBuyerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderID))
	}
	if m.Buyers != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Buyers.Size()))
		n18, err := m.Buyers.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *UpDeliveryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpDeliveryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderID))
	}
	if m.DeliverDetail != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.DeliverDetail.Size()))
		n19, err := m.DeliverDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *UpDetailResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpDetailResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderID))
	}
	if m.IsUpdate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.IsUpdate))
	}
	return i, nil
}

func (m *OrderLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ID))
	}
	if len(m.UID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.UID)))
		i += copy(dAtA[i:], m.UID)
	}
	if m.OID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OID))
	}
	if len(m.IP) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if len(m.OpData) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OpData)))
		i += copy(dAtA[i:], m.OpData)
	}
	if len(m.Remark) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Remark)))
		i += copy(dAtA[i:], m.Remark)
	}
	if len(m.OpObject) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OpObject)))
		i += copy(dAtA[i:], m.OpObject)
	}
	if len(m.OpName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OpName)))
		i += copy(dAtA[i:], m.OpName)
	}
	if m.CTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.CTime))
	}
	if m.MTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.MTime))
	}
	return i, nil
}

func (m *ListOrderLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOrderLogRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderID))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Limit))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Offset))
	}
	if len(m.OrderBy) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.OrderBy)))
		i += copy(dAtA[i:], m.OrderBy)
	}
	return i, nil
}

func (m *ListOrderLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOrderLogResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOrder(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cnt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Cnt))
	}
	return i, nil
}

func (m *AddOrderLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddOrderLogRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Data.Size()))
		n20, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *AddOrderLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddOrderLogResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func encodeVarintOrder(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ListOrdersRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if len(m.OrderID) > 0 {
		l = 0
		for _, e := range m.OrderID {
			l += sovOrder(uint64(e))
		}
		n += 1 + sovOrder(uint64(l)) + l
	}
	if m.ItemID != 0 {
		n += 1 + sovOrder(uint64(m.ItemID))
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovOrder(uint64(e))
		}
		n += 1 + sovOrder(uint64(l)) + l
	}
	if len(m.SubStatus) > 0 {
		l = 0
		for _, e := range m.SubStatus {
			l += sovOrder(uint64(e))
		}
		n += 1 + sovOrder(uint64(l)) + l
	}
	if len(m.RefundStatus) > 0 {
		l = 0
		for _, e := range m.RefundStatus {
			l += sovOrder(uint64(e))
		}
		n += 1 + sovOrder(uint64(l)) + l
	}
	if m.Limit != 0 {
		n += 1 + sovOrder(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovOrder(uint64(m.Offset))
	}
	l = len(m.OrderBy)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *ListOrdersResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovOrder(uint64(m.Count))
	}
	if m.NextOffset != 0 {
		n += 1 + sovOrder(uint64(m.NextOffset))
	}
	return n
}

func (m *OrderResponse) Size() (n int) {
	var l int
	_ = l
	if m.OrderID != 0 {
		n += 1 + sovOrder(uint64(m.OrderID))
	}
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.OrderType != 0 {
		n += 1 + sovOrder(uint64(m.OrderType))
	}
	if m.ItemID != 0 {
		n += 1 + sovOrder(uint64(m.ItemID))
	}
	if m.ItemInfo != nil {
		l = m.ItemInfo.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovOrder(uint64(m.Count))
	}
	if m.TotalMoney != 0 {
		n += 1 + sovOrder(uint64(m.TotalMoney))
	}
	if m.PayMoney != 0 {
		n += 1 + sovOrder(uint64(m.PayMoney))
	}
	if m.ExpressFee != 0 {
		n += 1 + sovOrder(uint64(m.ExpressFee))
	}
	if m.Status != 0 {
		n += 1 + sovOrder(uint64(m.Status))
	}
	if m.SubStatus != 0 {
		n += 1 + sovOrder(uint64(m.SubStatus))
	}
	if m.RefundStatus != 0 {
		n += 1 + sovOrder(uint64(m.RefundStatus))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.IsDeleted != 0 {
		n += 1 + sovOrder(uint64(m.IsDeleted))
	}
	if len(m.SKUs) > 0 {
		for _, e := range m.SKUs {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 2 + l + sovOrder(uint64(l))
	}
	if m.PayCharge != nil {
		l = m.PayCharge.Size()
		n += 2 + l + sovOrder(uint64(l))
	}
	if m.CTime != 0 {
		n += 2 + sovOrder(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 2 + sovOrder(uint64(m.MTime))
	}
	return n
}

func (m *OrderResponseMore) Size() (n int) {
	var l int
	_ = l
	if m.Coupon != nil {
		l = m.Coupon.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if len(m.Buyers) > 0 {
		for _, e := range m.Buyers {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	if m.Extra != nil {
		l = m.Extra.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Deliver != nil {
		l = m.Deliver.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.DeviceType != 0 {
		n += 1 + sovOrder(uint64(m.DeviceType))
	}
	if m.IP != 0 {
		n += 1 + sovOrder(uint64(m.IP))
	}
	l = len(m.MSource)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.ExpressCO)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.ExpressNO)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.ExpressType != 0 {
		n += 1 + sovOrder(uint64(m.ExpressType))
	}
	return n
}

func (m *CreateOrderSKU) Size() (n int) {
	var l int
	_ = l
	if m.SKUID != 0 {
		n += 1 + sovOrder(uint64(m.SKUID))
	}
	if m.Count != 0 {
		n += 1 + sovOrder(uint64(m.Count))
	}
	return n
}

func (m *CreateOrderRequest) Size() (n int) {
	var l int
	_ = l
	if m.ProjectID != 0 {
		n += 1 + sovOrder(uint64(m.ProjectID))
	}
	if m.ScreenID != 0 {
		n += 1 + sovOrder(uint64(m.ScreenID))
	}
	if len(m.SKUs) > 0 {
		for _, e := range m.SKUs {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	if m.UID != 0 {
		n += 1 + sovOrder(uint64(m.UID))
	}
	if m.PayMoney != 0 {
		n += 1 + sovOrder(uint64(m.PayMoney))
	}
	if m.OrderType != 0 {
		n += 1 + sovOrder(uint64(m.OrderType))
	}
	if m.TS != 0 {
		n += 1 + sovOrder(uint64(m.TS))
	}
	if m.PromoID != 0 {
		n += 1 + sovOrder(uint64(m.PromoID))
	}
	if m.PromoGroupID != 0 {
		n += 1 + sovOrder(uint64(m.PromoGroupID))
	}
	if len(m.Buyers) > 0 {
		for _, e := range m.Buyers {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	if m.DeliverDetail != nil {
		l = m.DeliverDetail.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if len(m.Seats) > 0 {
		l = 0
		for _, e := range m.Seats {
			l += sovOrder(uint64(e))
		}
		n += 1 + sovOrder(uint64(l)) + l
	}
	if len(m.Coupons) > 0 {
		for _, s := range m.Coupons {
			l = len(s)
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	if m.LockID != 0 {
		n += 1 + sovOrder(uint64(m.LockID))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.IsDeleted != 0 {
		n += 2 + sovOrder(uint64(m.IsDeleted))
	}
	if m.DeviceType != 0 {
		n += 2 + sovOrder(uint64(m.DeviceType))
	}
	return n
}

func (m *CreateOrdersRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for _, e := range m.Orders {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	return n
}

func (m *CreateOrderResult) Size() (n int) {
	var l int
	_ = l
	if m.OrderID != 0 {
		n += 1 + sovOrder(uint64(m.OrderID))
	}
	if m.Code != 0 {
		n += 1 + sovOrder(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *CreateOrdersResponse) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovOrder(uint64(m.Count))
	}
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	return n
}

func (m *UpBuyerRequest) Size() (n int) {
	var l int
	_ = l
	if m.OrderID != 0 {
		n += 1 + sovOrder(uint64(m.OrderID))
	}
	if m.Buyers != nil {
		l = m.Buyers.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *UpDeliveryRequest) Size() (n int) {
	var l int
	_ = l
	if m.OrderID != 0 {
		n += 1 + sovOrder(uint64(m.OrderID))
	}
	if m.DeliverDetail != nil {
		l = m.DeliverDetail.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *UpDetailResponse) Size() (n int) {
	var l int
	_ = l
	if m.OrderID != 0 {
		n += 1 + sovOrder(uint64(m.OrderID))
	}
	if m.IsUpdate != 0 {
		n += 1 + sovOrder(uint64(m.IsUpdate))
	}
	return n
}

func (m *OrderLog) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovOrder(uint64(m.ID))
	}
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.OID != 0 {
		n += 1 + sovOrder(uint64(m.OID))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.OpData)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.OpObject)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.OpName)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.CTime != 0 {
		n += 1 + sovOrder(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovOrder(uint64(m.MTime))
	}
	return n
}

func (m *ListOrderLogRequest) Size() (n int) {
	var l int
	_ = l
	if m.OrderID != 0 {
		n += 1 + sovOrder(uint64(m.OrderID))
	}
	if m.Limit != 0 {
		n += 1 + sovOrder(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovOrder(uint64(m.Offset))
	}
	l = len(m.OrderBy)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *ListOrderLogResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovOrder(uint64(l))
		}
	}
	if m.Cnt != 0 {
		n += 1 + sovOrder(uint64(m.Cnt))
	}
	return n
}

func (m *AddOrderLogRequest) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *AddOrderLogResponse) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOrder(uint64(m.Id))
	}
	return n
}

func sovOrder(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOrder(x uint64) (n int) {
	return sovOrder(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ListOrdersRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListOrdersRequest{`,
		`UID:` + fmt.Sprintf("%v", this.UID) + `,`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`ItemID:` + fmt.Sprintf("%v", this.ItemID) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`SubStatus:` + fmt.Sprintf("%v", this.SubStatus) + `,`,
		`RefundStatus:` + fmt.Sprintf("%v", this.RefundStatus) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`OrderBy:` + fmt.Sprintf("%v", this.OrderBy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListOrdersResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListOrdersResponse{`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "OrderResponse", "OrderResponse", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`NextOffset:` + fmt.Sprintf("%v", this.NextOffset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderResponse{`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`UID:` + fmt.Sprintf("%v", this.UID) + `,`,
		`OrderType:` + fmt.Sprintf("%v", this.OrderType) + `,`,
		`ItemID:` + fmt.Sprintf("%v", this.ItemID) + `,`,
		`ItemInfo:` + strings.Replace(fmt.Sprintf("%v", this.ItemInfo), "OrderItemInfo", "ticket_service_sales_v1.OrderItemInfo", 1) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`TotalMoney:` + fmt.Sprintf("%v", this.TotalMoney) + `,`,
		`PayMoney:` + fmt.Sprintf("%v", this.PayMoney) + `,`,
		`ExpressFee:` + fmt.Sprintf("%v", this.ExpressFee) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`SubStatus:` + fmt.Sprintf("%v", this.SubStatus) + `,`,
		`RefundStatus:` + fmt.Sprintf("%v", this.RefundStatus) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`IsDeleted:` + fmt.Sprintf("%v", this.IsDeleted) + `,`,
		`SKUs:` + strings.Replace(fmt.Sprintf("%v", this.SKUs), "OrderSKU", "ticket_service_sales_v1.OrderSKU", 1) + `,`,
		`Detail:` + strings.Replace(fmt.Sprintf("%v", this.Detail), "OrderResponseMore", "OrderResponseMore", 1) + `,`,
		`PayCharge:` + strings.Replace(fmt.Sprintf("%v", this.PayCharge), "OrderPayCharge", "ticket_service_sales_v1.OrderPayCharge", 1) + `,`,
		`CTime:` + fmt.Sprintf("%v", this.CTime) + `,`,
		`MTime:` + fmt.Sprintf("%v", this.MTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderResponseMore) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderResponseMore{`,
		`Coupon:` + strings.Replace(fmt.Sprintf("%v", this.Coupon), "OrderCoupon", "ticket_service_sales_v1.OrderCoupon", 1) + `,`,
		`Buyers:` + strings.Replace(fmt.Sprintf("%v", this.Buyers), "OrderBuyer", "ticket_service_sales_v1.OrderBuyer", 1) + `,`,
		`Extra:` + strings.Replace(fmt.Sprintf("%v", this.Extra), "OrderExtra", "ticket_service_sales_v1.OrderExtra", 1) + `,`,
		`Deliver:` + strings.Replace(fmt.Sprintf("%v", this.Deliver), "OrderDeliver", "ticket_service_sales_v1.OrderDeliver", 1) + `,`,
		`Remark:` + fmt.Sprintf("%v", this.Remark) + `,`,
		`DeviceType:` + fmt.Sprintf("%v", this.DeviceType) + `,`,
		`IP:` + fmt.Sprintf("%v", this.IP) + `,`,
		`MSource:` + fmt.Sprintf("%v", this.MSource) + `,`,
		`ExpressCO:` + fmt.Sprintf("%v", this.ExpressCO) + `,`,
		`ExpressNO:` + fmt.Sprintf("%v", this.ExpressNO) + `,`,
		`ExpressType:` + fmt.Sprintf("%v", this.ExpressType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateOrderSKU) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateOrderSKU{`,
		`SKUID:` + fmt.Sprintf("%v", this.SKUID) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateOrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateOrderRequest{`,
		`ProjectID:` + fmt.Sprintf("%v", this.ProjectID) + `,`,
		`ScreenID:` + fmt.Sprintf("%v", this.ScreenID) + `,`,
		`SKUs:` + strings.Replace(fmt.Sprintf("%v", this.SKUs), "CreateOrderSKU", "CreateOrderSKU", 1) + `,`,
		`UID:` + fmt.Sprintf("%v", this.UID) + `,`,
		`PayMoney:` + fmt.Sprintf("%v", this.PayMoney) + `,`,
		`OrderType:` + fmt.Sprintf("%v", this.OrderType) + `,`,
		`TS:` + fmt.Sprintf("%v", this.TS) + `,`,
		`PromoID:` + fmt.Sprintf("%v", this.PromoID) + `,`,
		`PromoGroupID:` + fmt.Sprintf("%v", this.PromoGroupID) + `,`,
		`Buyers:` + strings.Replace(fmt.Sprintf("%v", this.Buyers), "OrderBuyer", "ticket_service_sales_v1.OrderBuyer", 1) + `,`,
		`DeliverDetail:` + strings.Replace(fmt.Sprintf("%v", this.DeliverDetail), "OrderDeliver", "ticket_service_sales_v1.OrderDeliver", 1) + `,`,
		`Seats:` + fmt.Sprintf("%v", this.Seats) + `,`,
		`Coupons:` + fmt.Sprintf("%v", this.Coupons) + `,`,
		`LockID:` + fmt.Sprintf("%v", this.LockID) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`IsDeleted:` + fmt.Sprintf("%v", this.IsDeleted) + `,`,
		`DeviceType:` + fmt.Sprintf("%v", this.DeviceType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateOrdersRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateOrdersRequest{`,
		`Orders:` + strings.Replace(fmt.Sprintf("%v", this.Orders), "CreateOrderRequest", "CreateOrderRequest", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateOrderResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateOrderResult{`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateOrdersResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateOrdersResponse{`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Result:` + strings.Replace(fmt.Sprintf("%v", this.Result), "CreateOrderResult", "CreateOrderResult", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpBuyerRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpBuyerRequest{`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`Buyers:` + strings.Replace(fmt.Sprintf("%v", this.Buyers), "OrderBuyer", "ticket_service_sales_v1.OrderBuyer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpDeliveryRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpDeliveryRequest{`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`DeliverDetail:` + strings.Replace(fmt.Sprintf("%v", this.DeliverDetail), "OrderDeliver", "ticket_service_sales_v1.OrderDeliver", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpDetailResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpDetailResponse{`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`IsUpdate:` + fmt.Sprintf("%v", this.IsUpdate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderLog) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderLog{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`UID:` + fmt.Sprintf("%v", this.UID) + `,`,
		`OID:` + fmt.Sprintf("%v", this.OID) + `,`,
		`IP:` + fmt.Sprintf("%v", this.IP) + `,`,
		`OpData:` + fmt.Sprintf("%v", this.OpData) + `,`,
		`Remark:` + fmt.Sprintf("%v", this.Remark) + `,`,
		`OpObject:` + fmt.Sprintf("%v", this.OpObject) + `,`,
		`OpName:` + fmt.Sprintf("%v", this.OpName) + `,`,
		`CTime:` + fmt.Sprintf("%v", this.CTime) + `,`,
		`MTime:` + fmt.Sprintf("%v", this.MTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListOrderLogRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListOrderLogRequest{`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`OrderBy:` + fmt.Sprintf("%v", this.OrderBy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListOrderLogResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListOrderLogResponse{`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "OrderLog", "OrderLog", 1) + `,`,
		`Cnt:` + fmt.Sprintf("%v", this.Cnt) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddOrderLogRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddOrderLogRequest{`,
		`Data:` + strings.Replace(fmt.Sprintf("%v", this.Data), "OrderLog", "OrderLog", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddOrderLogResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddOrderLogResponse{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringOrder(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ListOrdersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOrdersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOrdersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OrderID = append(m.OrderID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOrder
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OrderID = append(m.OrderID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int16
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int16(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOrder
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int16
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int16(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int16
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int16(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SubStatus = append(m.SubStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOrder
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int16
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int16(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SubStatus = append(m.SubStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubStatus", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int16
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int16(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RefundStatus = append(m.RefundStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOrder
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int16
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int16(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RefundStatus = append(m.RefundStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundStatus", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &OrderResponse{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextOffset", wireType)
			}
			m.NextOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextOffset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			m.OrderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderType |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemInfo == nil {
				m.ItemInfo = &ticket_service_sales_v1.OrderItemInfo{}
			}
			if err := m.ItemInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMoney", wireType)
			}
			m.TotalMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMoney |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayMoney", wireType)
			}
			m.PayMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayMoney |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressFee", wireType)
			}
			m.ExpressFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpressFee |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubStatus", wireType)
			}
			m.SubStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubStatus |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundStatus", wireType)
			}
			m.RefundStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundStatus |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			m.IsDeleted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsDeleted |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SKUs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SKUs = append(m.SKUs, &ticket_service_sales_v1.OrderSKU{})
			if err := m.SKUs[len(m.SKUs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &OrderResponseMore{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayCharge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PayCharge == nil {
				m.PayCharge = &ticket_service_sales_v1.OrderPayCharge{}
			}
			if err := m.PayCharge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderResponseMore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderResponseMore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderResponseMore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coupon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coupon == nil {
				m.Coupon = &ticket_service_sales_v1.OrderCoupon{}
			}
			if err := m.Coupon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyers = append(m.Buyers, &ticket_service_sales_v1.OrderBuyer{})
			if err := m.Buyers[len(m.Buyers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extra == nil {
				m.Extra = &ticket_service_sales_v1.OrderExtra{}
			}
			if err := m.Extra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deliver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deliver == nil {
				m.Deliver = &ticket_service_sales_v1.OrderDeliver{}
			}
			if err := m.Deliver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			m.IP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IP |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressCO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressCO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressNO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressNO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressType", wireType)
			}
			m.ExpressType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpressType |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOrderSKU) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOrderSKU: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOrderSKU: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SKUID", wireType)
			}
			m.SKUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SKUID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			m.ProjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenID", wireType)
			}
			m.ScreenID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScreenID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SKUs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SKUs = append(m.SKUs, &CreateOrderSKU{})
			if err := m.SKUs[len(m.SKUs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayMoney", wireType)
			}
			m.PayMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayMoney |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			m.OrderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderType |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TS", wireType)
			}
			m.TS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TS |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromoID", wireType)
			}
			m.PromoID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromoID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromoGroupID", wireType)
			}
			m.PromoGroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromoGroupID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyers = append(m.Buyers, &ticket_service_sales_v1.OrderBuyer{})
			if err := m.Buyers[len(m.Buyers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliverDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeliverDetail == nil {
				m.DeliverDetail = &ticket_service_sales_v1.OrderDeliver{}
			}
			if err := m.DeliverDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Seats = append(m.Seats, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOrder
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Seats = append(m.Seats, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Seats", wireType)
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coupons", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coupons = append(m.Coupons, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockID", wireType)
			}
			m.LockID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			m.IsDeleted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsDeleted |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOrdersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOrdersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOrdersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, &CreateOrderRequest{})
			if err := m.Orders[len(m.Orders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOrderResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOrderResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOrderResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOrdersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOrdersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOrdersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &CreateOrderResult{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpBuyerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpBuyerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpBuyerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Buyers == nil {
				m.Buyers = &ticket_service_sales_v1.OrderBuyer{}
			}
			if err := m.Buyers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpDeliveryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpDeliveryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpDeliveryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliverDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeliverDetail == nil {
				m.DeliverDetail = &ticket_service_sales_v1.OrderDeliver{}
			}
			if err := m.DeliverDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpDetailResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpDetailResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpDetailResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUpdate", wireType)
			}
			m.IsUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsUpdate |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OID", wireType)
			}
			m.OID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpObject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpObject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOrderLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOrderLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOrderLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOrderLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOrderLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOrderLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &OrderLog{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cnt", wireType)
			}
			m.Cnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddOrderLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddOrderLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddOrderLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &OrderLog{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddOrderLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddOrderLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddOrderLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrder(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOrder
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOrder(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOrder = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrder   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/ticket-sales/api/grpc/v1/order.proto", fileDescriptorOrder)
}

var fileDescriptorOrder = []byte{
	// 1945 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0x4b, 0x73, 0x1b, 0xc7,
	0x11, 0x36, 0xde, 0x40, 0x83, 0x80, 0xc8, 0xa1, 0x22, 0xc1, 0x94, 0x8b, 0x4b, 0x43, 0xb1, 0x03,
	0x3d, 0x08, 0x88, 0x4c, 0x59, 0x55, 0x89, 0x13, 0xbb, 0x02, 0x42, 0x91, 0x51, 0x22, 0x45, 0xd6,
	0x90, 0xcc, 0xc1, 0x17, 0x64, 0x89, 0x1d, 0xc2, 0x1b, 0x02, 0x98, 0xcd, 0xce, 0x2e, 0x4b, 0xb8,
	0xb9, 0x72, 0x48, 0xee, 0xb9, 0xe7, 0xc7, 0xe4, 0xe6, 0x63, 0x8e, 0x39, 0xb8, 0xb6, 0x22, 0x1c,
	0xf1, 0x13, 0x74, 0x4a, 0x4d, 0xcf, 0x2c, 0x76, 0x97, 0x0f, 0x08, 0x3c, 0x2d, 0xa6, 0xa7, 0xbb,
	0xa7, 0x67, 0xe6, 0xeb, 0xaf, 0x7b, 0x00, 0xbf, 0x37, 0x1d, 0xa7, 0x25, 0x98, 0x7b, 0x69, 0xf7,
	0x59, 0x8b, 0x3b, 0x6c, 0xec, 0x0c, 0x4d, 0xef, 0x9c, 0xbb, 0xa3, 0x96, 0x67, 0xf7, 0x2f, 0x98,
	0xb7, 0x2d, 0xcc, 0x21, 0x13, 0x2d, 0xd3, 0xb1, 0x5b, 0x03, 0xd7, 0xe9, 0xb7, 0x2e, 0x77, 0x5a,
	0xdc, 0xb5, 0x98, 0xdb, 0x74, 0x5c, 0xee, 0x71, 0xf2, 0x50, 0x69, 0x35, 0xb5, 0x87, 0x26, 0x6a,
	0x37, 0x2f, 0x77, 0x36, 0xbe, 0xbd, 0xa3, 0x5f, 0x6f, 0xe2, 0xb0, 0xb8, 0xe7, 0x8d, 0xed, 0x81,
	0xed, 0xfd, 0xe0, 0x9f, 0x35, 0xfb, 0x7c, 0xd4, 0x1a, 0xf0, 0x01, 0x6f, 0xa1, 0xf8, 0xcc, 0x3f,
	0xc7, 0x11, 0x0e, 0xf0, 0x97, 0x52, 0xaf, 0xff, 0x3b, 0x0d, 0x6b, 0xfb, 0xb6, 0xf0, 0x0e, 0xa5,
	0x0b, 0x41, 0xd9, 0x5f, 0x7d, 0x26, 0x3c, 0xf2, 0x29, 0x64, 0x7c, 0xdb, 0xaa, 0xa5, 0xb6, 0x52,
	0x8d, 0x52, 0xbb, 0x30, 0x0d, 0x8c, 0xcc, 0x69, 0xb7, 0x43, 0xa5, 0x8c, 0x7c, 0x09, 0x45, 0x5c,
	0xae, 0x67, 0x5b, 0xb5, 0xf4, 0x56, 0xa6, 0x91, 0x69, 0x97, 0xa7, 0x81, 0x51, 0x40, 0xfb, 0x6e,
	0x87, 0x16, 0x70, 0xb2, 0x6b, 0x91, 0xc7, 0x50, 0xb0, 0x3d, 0x36, 0x92, 0x6a, 0x99, 0xad, 0x54,
	0x23, 0xd3, 0x86, 0x69, 0x60, 0xe4, 0xbb, 0x1e, 0x1b, 0x75, 0x3b, 0x34, 0x2f, 0xa7, 0xba, 0x16,
	0xf9, 0x1c, 0xf2, 0xc2, 0x33, 0x3d, 0x5f, 0xd4, 0xb2, 0x5b, 0x99, 0x46, 0xae, 0x5d, 0xfa, 0x10,
	0x18, 0x39, 0x7b, 0xec, 0xed, 0xbc, 0xa4, 0x7a, 0x82, 0x34, 0x00, 0x84, 0x7f, 0xd6, 0xd3, 0x6a,
	0xb9, 0xab, 0x6a, 0x25, 0xe1, 0x9f, 0x1d, 0x2b, 0xcd, 0x26, 0x54, 0x5c, 0x76, 0xee, 0x8f, 0xad,
	0x50, 0x39, 0x7f, 0x55, 0x79, 0x45, 0xcd, 0x6b, 0xfd, 0xfb, 0x90, 0x1b, 0xda, 0x23, 0xdb, 0xab,
	0x15, 0x64, 0x7c, 0x54, 0x0d, 0xc8, 0x03, 0xc8, 0xf3, 0xf3, 0x73, 0xc1, 0xbc, 0x5a, 0x11, 0xc5,
	0x7a, 0x44, 0x3e, 0x0d, 0xf7, 0x7d, 0x36, 0xa9, 0x95, 0xe4, 0xb9, 0xe8, 0xad, 0xb6, 0x27, 0xf5,
	0x7f, 0xa4, 0x80, 0xc4, 0xcf, 0x50, 0x38, 0x7c, 0x2c, 0x18, 0xf9, 0x2d, 0x64, 0x87, 0xb6, 0xf0,
	0x6a, 0xa9, 0xad, 0x4c, 0xa3, 0xbc, 0xfb, 0x65, 0xf3, 0x96, 0x2b, 0x6f, 0xa2, 0x59, 0x68, 0x45,
	0xd1, 0x46, 0xc6, 0xd6, 0xe7, 0xfe, 0xd8, 0xab, 0xa5, 0x55, 0x6c, 0x38, 0x20, 0x06, 0x94, 0xc7,
	0xec, 0x9d, 0xd7, 0xd3, 0x01, 0xe2, 0xb9, 0x52, 0x90, 0xa2, 0x43, 0x94, 0xd4, 0x7f, 0x2e, 0x42,
	0x25, 0xe1, 0x8e, 0xec, 0xc6, 0xae, 0x2b, 0x85, 0xf7, 0xf0, 0x30, 0x76, 0x5d, 0xb3, 0xc0, 0x98,
	0x4f, 0x47, 0x57, 0xb7, 0xa5, 0x6e, 0x3f, 0x8d, 0xb7, 0x5f, 0xd5, 0xb7, 0x3f, 0x0b, 0x0c, 0x29,
	0x55, 0x20, 0x78, 0x09, 0xa0, 0xcc, 0x24, 0xfc, 0x30, 0x8e, 0x5c, 0xfb, 0xe1, 0x2c, 0x30, 0x62,
	0xd2, 0xd8, 0x15, 0xa1, 0xf0, 0x64, 0xe2, 0x30, 0xd2, 0x8c, 0x40, 0x91, 0xc5, 0x60, 0x7e, 0x11,
	0x81, 0x62, 0x16, 0x18, 0xe1, 0xe4, 0x1c, 0x1f, 0x14, 0x4a, 0x4a, 0x34, 0x3e, 0xe7, 0xb5, 0xdc,
	0x56, 0xea, 0xe3, 0xe7, 0x88, 0xbe, 0xc6, 0xe7, 0xbc, 0x5d, 0x99, 0x05, 0x46, 0x64, 0x4c, 0x8b,
	0xb6, 0x9e, 0x20, 0x46, 0x78, 0xb4, 0x79, 0x8c, 0xa0, 0x34, 0x0b, 0x0c, 0x25, 0x08, 0x4f, 0xf9,
	0x05, 0x94, 0x3d, 0xee, 0x99, 0xc3, 0xde, 0x88, 0x8f, 0xd9, 0x44, 0xa1, 0xa3, 0x7d, 0x6f, 0x16,
	0x18, 0x71, 0x31, 0x05, 0x1c, 0x1c, 0xc8, 0xdf, 0xe4, 0x29, 0x94, 0x1c, 0x73, 0xa2, 0xf5, 0x11,
	0x36, 0x6a, 0xf9, 0xb9, 0x90, 0x16, 0x1d, 0x73, 0xa2, 0x74, 0x5f, 0x40, 0x99, 0xbd, 0x73, 0x5c,
	0x26, 0x44, 0xef, 0x9c, 0x31, 0x84, 0x92, 0xf6, 0x1e, 0x13, 0x53, 0xd0, 0x83, 0x3f, 0x32, 0x46,
	0x9e, 0xcd, 0x93, 0x04, 0xf0, 0xa0, 0xd7, 0x67, 0x81, 0xa1, 0x25, 0xd7, 0xd3, 0xe5, 0x65, 0x22,
	0x5d, 0xca, 0xd1, 0xcd, 0x44, 0xd2, 0x1b, 0x93, 0xe7, 0xdb, 0xab, 0xc9, 0xb3, 0x82, 0xa6, 0x1b,
	0xb3, 0xc0, 0x48, 0x4e, 0xdc, 0x96, 0x4d, 0x75, 0xc8, 0x0b, 0xee, 0xbb, 0x7d, 0x56, 0xab, 0x20,
	0x6e, 0x00, 0xa3, 0x44, 0x09, 0xd5, 0x5f, 0x19, 0x9c, 0x2d, 0x7a, 0x16, 0x1b, 0x32, 0x8f, 0x59,
	0xb5, 0x6a, 0x14, 0x5c, 0x24, 0x8d, 0x05, 0x67, 0x8b, 0x8e, 0x92, 0x91, 0x7d, 0xc8, 0x8a, 0x0b,
	0x5f, 0xd4, 0xee, 0x61, 0x26, 0x7d, 0xbe, 0x18, 0x01, 0xc7, 0x6f, 0x4e, 0x11, 0x56, 0xd9, 0xe3,
	0x37, 0xa7, 0x42, 0xde, 0x82, 0xc2, 0xa4, 0xb8, 0xf0, 0x29, 0x7a, 0x21, 0x6f, 0x21, 0x6f, 0x31,
	0xcf, 0xb4, 0x87, 0xb5, 0x55, 0x44, 0xd4, 0xd3, 0xe5, 0x32, 0xf3, 0x80, 0xbb, 0x4c, 0xed, 0x4a,
	0x59, 0x53, 0xfd, 0x25, 0x7f, 0x02, 0x90, 0x17, 0xdd, 0xff, 0xc1, 0x74, 0x07, 0xac, 0xb6, 0x86,
	0x3e, 0x7f, 0xb5, 0xd8, 0xe7, 0x91, 0x39, 0xd9, 0x43, 0xf5, 0x76, 0x55, 0x6e, 0x3f, 0x32, 0xa7,
	0x12, 0x33, 0x6a, 0x8a, 0xbc, 0x86, 0x5c, 0xdf, 0xb3, 0x47, 0xac, 0x46, 0x10, 0x23, 0x3b, 0xd3,
	0xc0, 0xc8, 0xed, 0x9d, 0xd8, 0x23, 0x86, 0x88, 0x95, 0x33, 0x1f, 0x02, 0xe3, 0xd1, 0x80, 0x6f,
	0xf7, 0xf9, 0x68, 0xc4, 0xc7, 0xad, 0xa1, 0x7d, 0xe6, 0x9a, 0xee, 0xa4, 0x25, 0x67, 0x9a, 0x52,
	0x8f, 0x2a, 0x2d, 0xe9, 0x68, 0x84, 0x8e, 0xd6, 0x23, 0x47, 0x07, 0xa1, 0xa3, 0xd1, 0x52, 0x8e,
	0x50, 0xab, 0xfe, 0xb7, 0x1c, 0xac, 0x5d, 0x3b, 0x13, 0xf2, 0x1d, 0xe4, 0xfb, 0xdc, 0x77, 0xf8,
	0x18, 0x09, 0xa6, 0xbc, 0xfb, 0xcb, 0xc5, 0x7b, 0xdf, 0x43, 0x5d, 0x75, 0x92, 0xca, 0x8e, 0xea,
	0x2f, 0x79, 0x0d, 0xf9, 0x33, 0x7f, 0xc2, 0x5c, 0x81, 0x95, 0xa5, 0xbc, 0xfb, 0x78, 0xb1, 0xa7,
	0xb6, 0xd4, 0x55, 0x8e, 0x94, 0x19, 0xd5, 0x5f, 0xd2, 0x81, 0x1c, 0x7b, 0xe7, 0xb9, 0x26, 0x52,
	0xd3, 0x47, 0xfd, 0xbc, 0x92, 0xaa, 0x8a, 0x08, 0xd0, 0x8a, 0xaa, 0x0f, 0xd9, 0x87, 0x82, 0xc5,
	0x86, 0xf6, 0x25, 0x73, 0x91, 0xad, 0xca, 0xbb, 0x5f, 0x2c, 0xf6, 0xd3, 0x51, 0xca, 0xed, 0xb2,
	0xa4, 0x32, 0x6d, 0x49, 0xc3, 0x1f, 0x32, 0x41, 0x5c, 0x36, 0x32, 0xdd, 0x0b, 0x24, 0x32, 0x9d,
	0x20, 0x4a, 0x42, 0xf5, 0x97, 0xfc, 0x06, 0xca, 0x16, 0x93, 0x9e, 0x15, 0xb1, 0xe6, 0x31, 0x43,
	0x6a, 0x92, 0x1c, 0x62, 0xe2, 0x28, 0x45, 0x40, 0x49, 0x91, 0x5a, 0x3f, 0x83, 0xb4, 0xed, 0x20,
	0x59, 0x55, 0xda, 0x2b, 0xd3, 0xc0, 0x48, 0x77, 0x8f, 0x66, 0x81, 0x91, 0xb6, 0x1d, 0x9a, 0xb6,
	0x1d, 0xf2, 0x02, 0x0a, 0x23, 0x9d, 0x9e, 0x45, 0x5c, 0xfd, 0x81, 0xac, 0x02, 0x07, 0xc7, 0x28,
	0x92, 0xe1, 0xea, 0x59, 0x1a, 0xfe, 0x20, 0x3b, 0x10, 0x72, 0x50, 0xaf, 0xcf, 0x55, 0xc5, 0x6b,
	0x93, 0x69, 0x60, 0x94, 0x5e, 0x29, 0xe9, 0xde, 0xe1, 0x2c, 0x30, 0x52, 0xdb, 0xb4, 0xa4, 0xb5,
	0xf6, 0x78, 0xdc, 0x64, 0xcc, 0x91, 0xac, 0x92, 0x26, 0x6f, 0xaf, 0x98, 0xbc, 0x95, 0x26, 0x2b,
	0xa1, 0x09, 0xee, 0x58, 0x11, 0x56, 0x15, 0xf5, 0xa2, 0x7d, 0x86, 0xd4, 0x28, 0x37, 0x5a, 0xff,
	0x0e, 0xaa, 0x7b, 0x2e, 0x33, 0x3d, 0x16, 0x66, 0x3b, 0xd9, 0x82, 0xbc, 0xb8, 0xf0, 0xa3, 0x0a,
	0x57, 0x92, 0x00, 0x3f, 0x7e, 0x23, 0x5b, 0x96, 0x9c, 0xb8, 0xf0, 0xbb, 0xd6, 0xcd, 0xe5, 0xb4,
	0xfe, 0x73, 0x0e, 0x48, 0xcc, 0x55, 0xd8, 0xfc, 0x3c, 0x07, 0x70, 0x5c, 0xfe, 0x17, 0xd6, 0xf7,
	0x22, 0x97, 0x15, 0xb9, 0x8d, 0x23, 0x25, 0xed, 0x76, 0x68, 0x49, 0x2b, 0x74, 0x2d, 0xf2, 0x04,
	0x4a, 0xa2, 0xef, 0x32, 0x36, 0xee, 0xe9, 0x92, 0x99, 0xc1, 0xe3, 0x2f, 0x1e, 0xa3, 0xb0, 0xdb,
	0xa1, 0x45, 0x35, 0xdd, 0xb5, 0xc8, 0x2b, 0x4d, 0x63, 0x19, 0x04, 0xf7, 0xed, 0x14, 0x91, 0xdc,
	0x5e, 0xbb, 0x18, 0x92, 0x99, 0xe6, 0x2f, 0xdd, 0x9c, 0xa9, 0x02, 0x9a, 0x6c, 0xce, 0x1e, 0xc5,
	0x0b, 0x51, 0x0e, 0xf7, 0x1a, 0x55, 0x9e, 0x46, 0xa2, 0x68, 0x2b, 0x6c, 0x95, 0x6e, 0x2c, 0xd3,
	0x0f, 0x20, 0xed, 0x09, 0x5d, 0xf8, 0xf2, 0x12, 0x4b, 0x27, 0xc7, 0x34, 0xed, 0x09, 0xd9, 0xfb,
	0x39, 0x2e, 0x1f, 0x71, 0xb9, 0x55, 0x55, 0xe6, 0xb0, 0xf7, 0x3b, 0x92, 0x32, 0xd9, 0xfb, 0xe1,
	0x64, 0x57, 0xb6, 0x07, 0x55, 0xa5, 0x37, 0x70, 0xb9, 0xef, 0x48, 0x6d, 0x55, 0xe6, 0x56, 0xa7,
	0x81, 0xb1, 0x82, 0xda, 0xaf, 0xe5, 0x44, 0xb7, 0x43, 0x57, 0x9c, 0x68, 0x64, 0x91, 0xaf, 0xe7,
	0xf9, 0x0f, 0x4b, 0xe7, 0xff, 0x3c, 0xe7, 0xf7, 0xa1, 0xaa, 0x53, 0xad, 0xa7, 0xe9, 0xbd, 0x7c,
	0x87, 0xa4, 0xa5, 0x15, 0x6d, 0xdc, 0x51, 0xa4, 0x7e, 0x1f, 0x72, 0x82, 0x99, 0x9e, 0xac, 0x83,
	0x99, 0x46, 0x96, 0xaa, 0x01, 0xa9, 0x41, 0x41, 0x51, 0x95, 0xa8, 0x55, 0xb6, 0x32, 0xb2, 0x07,
	0xd4, 0x43, 0xd9, 0xee, 0x0e, 0x79, 0xff, 0x42, 0xee, 0xb5, 0x1a, 0xb5, 0xbb, 0xfb, 0xbc, 0x7f,
	0x21, 0xdb, 0x5d, 0x39, 0xd5, 0xb5, 0x64, 0x6f, 0xa9, 0x93, 0xf0, 0x1e, 0x76, 0x90, 0x61, 0x5d,
	0x6c, 0x24, 0xea, 0xe2, 0xea, 0xb5, 0x9b, 0x89, 0x2a, 0xe1, 0xd3, 0x24, 0x41, 0xac, 0x5d, 0x55,
	0x8d, 0x31, 0x42, 0xfd, 0x7b, 0x58, 0x8f, 0x21, 0x69, 0xde, 0xdb, 0xef, 0x41, 0x1e, 0x6f, 0x5a,
	0xe8, 0xc6, 0xf4, 0xd9, 0x32, 0x38, 0xd4, 0xc6, 0x54, 0x9b, 0xd6, 0x5d, 0x58, 0x4b, 0xcc, 0x0a,
	0x7f, 0xe8, 0x25, 0x9e, 0x06, 0xa9, 0x08, 0x1e, 0xd7, 0x9e, 0x06, 0x8f, 0x20, 0xdb, 0xe7, 0x16,
	0xc3, 0x6c, 0xc9, 0xb5, 0x0b, 0x1f, 0x02, 0x23, 0x63, 0x8f, 0x3d, 0x8a, 0x42, 0x79, 0xc4, 0x23,
	0x26, 0x84, 0x39, 0x50, 0x7d, 0x65, 0x89, 0x86, 0xc3, 0xba, 0x03, 0xf7, 0x93, 0xfb, 0xd1, 0x2d,
	0xee, 0x3c, 0xb9, 0xe5, 0x9a, 0x95, 0xb0, 0x8b, 0x6b, 0x4b, 0xba, 0x95, 0x61, 0xe9, 0x5a, 0xf2,
	0x74, 0xb9, 0x6d, 0x4a, 0x0b, 0xaa, 0x2d, 0xeb, 0x3e, 0x54, 0x4f, 0x1d, 0x85, 0x32, 0x7d, 0x78,
	0xcb, 0x6e, 0xf1, 0xeb, 0x58, 0x25, 0x4b, 0xdd, 0x11, 0xc9, 0xf5, 0x7f, 0xa5, 0x60, 0xed, 0xd4,
	0xd1, 0xc0, 0x9c, 0xdc, 0x75, 0xe9, 0x3f, 0x5f, 0xcb, 0x83, 0xf4, 0x5d, 0x8a, 0x17, 0x99, 0x05,
	0xc6, 0x15, 0x07, 0x57, 0x72, 0xa3, 0xfe, 0x0e, 0x56, 0x65, 0x78, 0x38, 0x15, 0x5e, 0xc2, 0xb2,
	0xd1, 0xfd, 0x0e, 0x4a, 0xb6, 0xe8, 0xf9, 0x8e, 0x65, 0x7a, 0x21, 0x00, 0x0c, 0x49, 0x97, 0x5d,
	0x71, 0x8a, 0x32, 0x59, 0x14, 0xd5, 0x6c, 0x04, 0xea, 0xa2, 0xad, 0x27, 0xeb, 0xff, 0xcc, 0x40,
	0x11, 0x5d, 0xee, 0xf3, 0x81, 0x64, 0xa9, 0xf9, 0x62, 0xc8, 0x52, 0xdd, 0x0e, 0x4d, 0xdb, 0x56,
	0xc8, 0x8f, 0xe9, 0x1b, 0x1e, 0xaf, 0xf5, 0x58, 0x94, 0x99, 0x88, 0x3f, 0x0f, 0xe3, 0x11, 0x3e,
	0xc0, 0x42, 0x9a, 0x45, 0x6b, 0xe5, 0xf6, 0x08, 0x4b, 0xe8, 0x63, 0x28, 0x70, 0xa7, 0x67, 0x99,
	0x9e, 0x19, 0x16, 0x70, 0x99, 0xe1, 0x87, 0x4e, 0xc7, 0xf4, 0x4c, 0x9a, 0xe7, 0xf8, 0x8d, 0x15,
	0xf9, 0x7c, 0xa4, 0x43, 0x93, 0x45, 0xfe, 0x09, 0x94, 0xb8, 0xd3, 0xe3, 0x67, 0xb2, 0x80, 0x20,
	0xc9, 0x96, 0x54, 0xc5, 0x38, 0x74, 0x0e, 0x51, 0x46, 0x8b, 0x5c, 0xff, 0xd2, 0x6b, 0x8e, 0xcd,
	0x51, 0x58, 0xb6, 0xf5, 0x9a, 0x6f, 0xcd, 0x11, 0x93, 0x6b, 0xca, 0x2f, 0xf9, 0x26, 0xec, 0x13,
	0x15, 0xc9, 0x36, 0xe6, 0x7d, 0xe2, 0x92, 0xed, 0xe1, 0x37, 0x61, 0x7b, 0x08, 0x91, 0xfd, 0xc1,
	0xc9, 0xf2, 0x5d, 0xe1, 0xdf, 0x53, 0xb0, 0x3e, 0x7f, 0xfe, 0xee, 0xf3, 0xc1, 0x5d, 0x01, 0x3b,
	0x7f, 0x87, 0xa7, 0x6f, 0x7e, 0x87, 0x67, 0x6e, 0x7d, 0x87, 0x67, 0x93, 0xef, 0xf0, 0x1e, 0xdc,
	0x4f, 0xc6, 0xa1, 0xb1, 0xf9, 0x55, 0xe2, 0x21, 0xfe, 0x91, 0xe7, 0x83, 0x34, 0x54, 0x6f, 0xf0,
	0x55, 0xc8, 0xf4, 0xe7, 0x2d, 0x83, 0xfc, 0x59, 0x7f, 0x03, 0xe4, 0x0f, 0x96, 0x75, 0x75, 0x9f,
	0x5f, 0x41, 0x16, 0x51, 0xa1, 0xba, 0xdf, 0x65, 0xdc, 0x4b, 0xf5, 0xfa, 0x17, 0xb0, 0x9e, 0x70,
	0xa6, 0x83, 0xad, 0x46, 0xa8, 0x96, 0x68, 0xde, 0xfd, 0x31, 0x07, 0xb9, 0x13, 0xd7, 0xb4, 0x18,
	0x61, 0x00, 0xd1, 0xbf, 0x0c, 0xe4, 0x76, 0x3e, 0xbb, 0xf6, 0x77, 0xce, 0xc6, 0xb3, 0xa5, 0x74,
	0x75, 0x00, 0x17, 0xb0, 0x12, 0xa7, 0x59, 0xf2, 0x7c, 0x19, 0xe2, 0x9c, 0x2f, 0xb5, 0xbd, 0xa4,
	0xb6, 0x5e, 0xcc, 0x84, 0xb2, 0x4a, 0x6d, 0x64, 0x40, 0x72, 0x7b, 0x4f, 0x94, 0xe4, 0xe1, 0x8d,
	0x27, 0x0b, 0x14, 0xaf, 0x30, 0xd3, 0x40, 0x92, 0xb8, 0x5c, 0x22, 0x24, 0xd4, 0x05, 0x47, 0x77,
	0x8d, 0x75, 0xef, 0xb2, 0xd0, 0x10, 0x2a, 0x71, 0xf8, 0x2d, 0x3a, 0xb9, 0x1b, 0xd2, 0x65, 0xc1,
	0xc9, 0xdd, 0x08, 0x6a, 0x1b, 0x56, 0x62, 0xf0, 0x11, 0xe4, 0xf6, 0x3b, 0xbe, 0x0e, 0xd9, 0x8d,
	0xe7, 0xcb, 0x29, 0xab, 0xa5, 0xda, 0x9f, 0xfd, 0xf4, 0x7e, 0xf3, 0x93, 0xff, 0xbe, 0xdf, 0xfc,
	0xe4, 0xc7, 0xe9, 0x66, 0xea, 0xa7, 0xe9, 0x66, 0xea, 0x3f, 0xd3, 0xcd, 0xd4, 0xff, 0xa6, 0x9b,
	0xa9, 0xef, 0xd3, 0x97, 0x3b, 0x67, 0x79, 0xfc, 0x23, 0xf1, 0xd7, 0xff, 0x0f, 0x00, 0x00, 0xff,
	0xff, 0x9c, 0x10, 0x21, 0xa1, 0x12, 0x15, 0x00, 0x00,
}
