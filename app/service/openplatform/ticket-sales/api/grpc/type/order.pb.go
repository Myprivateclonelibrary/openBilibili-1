// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/ticket-sales/api/grpc/type/order.proto

/*
	Package _type is a generated protocol buffer package.

	It is generated from these files:
		app/service/openplatform/ticket-sales/api/grpc/type/order.proto

	It has these top-level messages:
		OrderSKU
		OrderPayCharge
		OrderItemInfo
		OrderSKUDiscounts
		OrderBuyer
		OrderDeliver
		OrderExtra
		OrderCoupon
*/
package _type

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import go_common_library_time "go-common/library/time"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// OrderSKU 订单包含的sku信息
type OrderSKU struct {
	OrderID     int64                       `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	SKUID       int64                       `protobuf:"varint,2,opt,name=sku_id,json=skuId,proto3" json:"sku_id"`
	Count       int64                       `protobuf:"varint,3,opt,name=count,proto3" json:"count"`
	OriginPrice int64                       `protobuf:"varint,4,opt,name=origin_price,json=originPrice,proto3" json:"origin_price"`
	Price       int64                       `protobuf:"varint,5,opt,name=price,proto3" json:"price"`
	SeatIDs     []int64                     `protobuf:"varint,6,rep,packed,name=seat_ids,json=seatIds" json:"seat_ids"`
	TicketType  int16                       `protobuf:"varint,7,opt,name=ticket_type,json=ticketType,proto3,casttype=int16" json:"ticket_type"`
	Discounts   *OrderSKUDiscounts          `protobuf:"bytes,8,opt,name=discounts" json:"discounts"`
	CTime       go_common_library_time.Time `protobuf:"varint,9,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"-"`
	MTime       go_common_library_time.Time `protobuf:"varint,10,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"-"`
}

func (m *OrderSKU) Reset()                    { *m = OrderSKU{} }
func (*OrderSKU) ProtoMessage()               {}
func (*OrderSKU) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{0} }

// OrderPayCharge 订单支付信息
type OrderPayCharge struct {
	OrderID  int64                       `protobuf:"varint,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	ChargeID string                      `protobuf:"bytes,2,opt,name=charge_id,json=chargeId,proto3" json:"charge_id"`
	Channel  int16                       `protobuf:"varint,3,opt,name=channel,proto3,casttype=int16" json:"channel"`
	Paid     int16                       `protobuf:"varint,4,opt,name=paid,proto3,casttype=int16" json:"paid"`
	Refunded int16                       `protobuf:"varint,5,opt,name=refunded,proto3,casttype=int16" json:"refunded"`
	PayTime  int64                       `protobuf:"varint,6,opt,name=pay_time,json=payTime,proto3" json:"-"`
	CTime    go_common_library_time.Time `protobuf:"varint,7,opt,name=ctime,proto3,casttype=go-common/library/time.Time" json:"-"`
	MTime    go_common_library_time.Time `protobuf:"varint,8,opt,name=mtime,proto3,casttype=go-common/library/time.Time" json:"-"`
}

func (m *OrderPayCharge) Reset()                    { *m = OrderPayCharge{} }
func (*OrderPayCharge) ProtoMessage()               {}
func (*OrderPayCharge) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{1} }

// OrderItemInfo 订单中的商品快照
type OrderItemInfo struct {
	Name           string `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Img            string `protobuf:"bytes,2,opt,name=img,proto3" json:"img"`
	ScreenID       int64  `protobuf:"varint,3,opt,name=screen_id,json=screenId,proto3" json:"screen_id"`
	ScreenName     string `protobuf:"bytes,4,opt,name=screen_name,json=screenName,proto3" json:"screen_name"`
	ScreenType     int16  `protobuf:"varint,5,opt,name=screen_type,json=screenType,proto3,casttype=int16" json:"screen_type"`
	DeliverType    int16  `protobuf:"varint,6,opt,name=deliver_type,json=deliverType,proto3,casttype=int16" json:"deliver_type"`
	ExpressFee     int64  `protobuf:"varint,7,opt,name=express_fee,json=expressFee,proto3" json:"express_fee"`
	VIPExpressFree int16  `protobuf:"varint,8,opt,name=vip_express_free,json=vipExpressFree,proto3,casttype=int16" json:"express_free_flag"`
	VerID          int64  `protobuf:"varint,9,opt,name=ver_id,json=verId,proto3" json:"project_ver_id"`
}

func (m *OrderItemInfo) Reset()                    { *m = OrderItemInfo{} }
func (*OrderItemInfo) ProtoMessage()               {}
func (*OrderItemInfo) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{2} }

// OrderSKUDiscounts 订单分摊到sku上的折扣信息
type OrderSKUDiscounts struct {
	Platform map[int32]int64 `protobuf:"bytes,1,rep,name=platform" json:"1" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Merchant map[int32]int64 `protobuf:"bytes,2,rep,name=merchant" json:"2" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *OrderSKUDiscounts) Reset()                    { *m = OrderSKUDiscounts{} }
func (*OrderSKUDiscounts) ProtoMessage()               {}
func (*OrderSKUDiscounts) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{3} }

// OrderBuyer 订单购买人快照
type OrderBuyer struct {
	ID         int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Name       string `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Tel        string `protobuf:"bytes,3,opt,name=tel,proto3" json:"tel"`
	PersonalID string `protobuf:"bytes,4,opt,name=personal_id,json=personalId,proto3" json:"personal_id"`
}

func (m *OrderBuyer) Reset()                    { *m = OrderBuyer{} }
func (*OrderBuyer) ProtoMessage()               {}
func (*OrderBuyer) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{4} }

// OrderDeliver 订单配送信息快照
type OrderDeliver struct {
	AddrID int64  `protobuf:"varint,1,opt,name=addr_id,json=addrId,proto3" json:"addr_id"`
	Name   string `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Tel    string `protobuf:"bytes,3,opt,name=tel,proto3" json:"tel"`
	Addr   string `protobuf:"bytes,4,opt,name=addr,proto3" json:"addr"`
}

func (m *OrderDeliver) Reset()                    { *m = OrderDeliver{} }
func (*OrderDeliver) ProtoMessage()               {}
func (*OrderDeliver) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{5} }

// OrderExtra 订单额外信息
type OrderExtra struct {
	AutoRecvTime   int64 `protobuf:"varint,1,opt,name=auto_recv_time,json=autoRecvTime,proto3" json:"AutoRecvTime"`
	DelayRecvTimes int64 `protobuf:"varint,2,opt,name=delay_recv_times,json=delayRecvTimes,proto3" json:"DelayRecvTimes"`
}

func (m *OrderExtra) Reset()                    { *m = OrderExtra{} }
func (*OrderExtra) ProtoMessage()               {}
func (*OrderExtra) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{6} }

// OrderCoupon 订单优惠券信息
type OrderCoupon struct {
	Code  string `protobuf:"bytes,1,opt,name=code,proto3" json:"code"`
	Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Money int64  `protobuf:"varint,3,opt,name=money,proto3" json:"money"`
}

func (m *OrderCoupon) Reset()                    { *m = OrderCoupon{} }
func (*OrderCoupon) ProtoMessage()               {}
func (*OrderCoupon) Descriptor() ([]byte, []int) { return fileDescriptorOrder, []int{7} }

func init() {
	proto.RegisterType((*OrderSKU)(nil), "ticket.service.sales.v1.OrderSKU")
	proto.RegisterType((*OrderPayCharge)(nil), "ticket.service.sales.v1.OrderPayCharge")
	proto.RegisterType((*OrderItemInfo)(nil), "ticket.service.sales.v1.OrderItemInfo")
	proto.RegisterType((*OrderSKUDiscounts)(nil), "ticket.service.sales.v1.OrderSKUDiscounts")
	proto.RegisterType((*OrderBuyer)(nil), "ticket.service.sales.v1.OrderBuyer")
	proto.RegisterType((*OrderDeliver)(nil), "ticket.service.sales.v1.OrderDeliver")
	proto.RegisterType((*OrderExtra)(nil), "ticket.service.sales.v1.OrderExtra")
	proto.RegisterType((*OrderCoupon)(nil), "ticket.service.sales.v1.OrderCoupon")
}
func (m *OrderSKU) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderSKU) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderID))
	}
	if m.SKUID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.SKUID))
	}
	if m.Count != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Count))
	}
	if m.OriginPrice != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OriginPrice))
	}
	if m.Price != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Price))
	}
	if len(m.SeatIDs) > 0 {
		dAtA2 := make([]byte, len(m.SeatIDs)*10)
		var j1 int
		for _, num1 := range m.SeatIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintOrder(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.TicketType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.TicketType))
	}
	if m.Discounts != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Discounts.Size()))
		n3, err := m.Discounts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.CTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.CTime))
	}
	if m.MTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.MTime))
	}
	return i, nil
}

func (m *OrderPayCharge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderPayCharge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrderID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.OrderID))
	}
	if len(m.ChargeID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.ChargeID)))
		i += copy(dAtA[i:], m.ChargeID)
	}
	if m.Channel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Channel))
	}
	if m.Paid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Paid))
	}
	if m.Refunded != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Refunded))
	}
	if m.PayTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.PayTime))
	}
	if m.CTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.CTime))
	}
	if m.MTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.MTime))
	}
	return i, nil
}

func (m *OrderItemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderItemInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Img) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Img)))
		i += copy(dAtA[i:], m.Img)
	}
	if m.ScreenID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ScreenID))
	}
	if len(m.ScreenName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.ScreenName)))
		i += copy(dAtA[i:], m.ScreenName)
	}
	if m.ScreenType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ScreenType))
	}
	if m.DeliverType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.DeliverType))
	}
	if m.ExpressFee != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ExpressFee))
	}
	if m.VIPExpressFree != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.VIPExpressFree))
	}
	if m.VerID != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.VerID))
	}
	return i, nil
}

func (m *OrderSKUDiscounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderSKUDiscounts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Platform) > 0 {
		for k, _ := range m.Platform {
			dAtA[i] = 0xa
			i++
			v := m.Platform[k]
			mapSize := 1 + sovOrder(uint64(k)) + 1 + sovOrder(uint64(v))
			i = encodeVarintOrder(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintOrder(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintOrder(dAtA, i, uint64(v))
		}
	}
	if len(m.Merchant) > 0 {
		for k, _ := range m.Merchant {
			dAtA[i] = 0x12
			i++
			v := m.Merchant[k]
			mapSize := 1 + sovOrder(uint64(k)) + 1 + sovOrder(uint64(v))
			i = encodeVarintOrder(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintOrder(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintOrder(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *OrderBuyer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBuyer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Tel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Tel)))
		i += copy(dAtA[i:], m.Tel)
	}
	if len(m.PersonalID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.PersonalID)))
		i += copy(dAtA[i:], m.PersonalID)
	}
	return i, nil
}

func (m *OrderDeliver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderDeliver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AddrID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.AddrID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Tel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Tel)))
		i += copy(dAtA[i:], m.Tel)
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	return i, nil
}

func (m *OrderExtra) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderExtra) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AutoRecvTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.AutoRecvTime))
	}
	if m.DelayRecvTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.DelayRecvTimes))
	}
	return i, nil
}

func (m *OrderCoupon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderCoupon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrder(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Money != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrder(dAtA, i, uint64(m.Money))
	}
	return i, nil
}

func encodeVarintOrder(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *OrderSKU) Size() (n int) {
	var l int
	_ = l
	if m.OrderID != 0 {
		n += 1 + sovOrder(uint64(m.OrderID))
	}
	if m.SKUID != 0 {
		n += 1 + sovOrder(uint64(m.SKUID))
	}
	if m.Count != 0 {
		n += 1 + sovOrder(uint64(m.Count))
	}
	if m.OriginPrice != 0 {
		n += 1 + sovOrder(uint64(m.OriginPrice))
	}
	if m.Price != 0 {
		n += 1 + sovOrder(uint64(m.Price))
	}
	if len(m.SeatIDs) > 0 {
		l = 0
		for _, e := range m.SeatIDs {
			l += sovOrder(uint64(e))
		}
		n += 1 + sovOrder(uint64(l)) + l
	}
	if m.TicketType != 0 {
		n += 1 + sovOrder(uint64(m.TicketType))
	}
	if m.Discounts != nil {
		l = m.Discounts.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.CTime != 0 {
		n += 1 + sovOrder(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovOrder(uint64(m.MTime))
	}
	return n
}

func (m *OrderPayCharge) Size() (n int) {
	var l int
	_ = l
	if m.OrderID != 0 {
		n += 1 + sovOrder(uint64(m.OrderID))
	}
	l = len(m.ChargeID)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Channel != 0 {
		n += 1 + sovOrder(uint64(m.Channel))
	}
	if m.Paid != 0 {
		n += 1 + sovOrder(uint64(m.Paid))
	}
	if m.Refunded != 0 {
		n += 1 + sovOrder(uint64(m.Refunded))
	}
	if m.PayTime != 0 {
		n += 1 + sovOrder(uint64(m.PayTime))
	}
	if m.CTime != 0 {
		n += 1 + sovOrder(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovOrder(uint64(m.MTime))
	}
	return n
}

func (m *OrderItemInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Img)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.ScreenID != 0 {
		n += 1 + sovOrder(uint64(m.ScreenID))
	}
	l = len(m.ScreenName)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.ScreenType != 0 {
		n += 1 + sovOrder(uint64(m.ScreenType))
	}
	if m.DeliverType != 0 {
		n += 1 + sovOrder(uint64(m.DeliverType))
	}
	if m.ExpressFee != 0 {
		n += 1 + sovOrder(uint64(m.ExpressFee))
	}
	if m.VIPExpressFree != 0 {
		n += 1 + sovOrder(uint64(m.VIPExpressFree))
	}
	if m.VerID != 0 {
		n += 1 + sovOrder(uint64(m.VerID))
	}
	return n
}

func (m *OrderSKUDiscounts) Size() (n int) {
	var l int
	_ = l
	if len(m.Platform) > 0 {
		for k, v := range m.Platform {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOrder(uint64(k)) + 1 + sovOrder(uint64(v))
			n += mapEntrySize + 1 + sovOrder(uint64(mapEntrySize))
		}
	}
	if len(m.Merchant) > 0 {
		for k, v := range m.Merchant {
			_ = k
			_ = v
			mapEntrySize := 1 + sovOrder(uint64(k)) + 1 + sovOrder(uint64(v))
			n += mapEntrySize + 1 + sovOrder(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OrderBuyer) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovOrder(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Tel)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.PersonalID)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *OrderDeliver) Size() (n int) {
	var l int
	_ = l
	if m.AddrID != 0 {
		n += 1 + sovOrder(uint64(m.AddrID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Tel)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	return n
}

func (m *OrderExtra) Size() (n int) {
	var l int
	_ = l
	if m.AutoRecvTime != 0 {
		n += 1 + sovOrder(uint64(m.AutoRecvTime))
	}
	if m.DelayRecvTimes != 0 {
		n += 1 + sovOrder(uint64(m.DelayRecvTimes))
	}
	return n
}

func (m *OrderCoupon) Size() (n int) {
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Money != 0 {
		n += 1 + sovOrder(uint64(m.Money))
	}
	return n
}

func sovOrder(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOrder(x uint64) (n int) {
	return sovOrder(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *OrderSKU) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderSKU{`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`SKUID:` + fmt.Sprintf("%v", this.SKUID) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`OriginPrice:` + fmt.Sprintf("%v", this.OriginPrice) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`SeatIDs:` + fmt.Sprintf("%v", this.SeatIDs) + `,`,
		`TicketType:` + fmt.Sprintf("%v", this.TicketType) + `,`,
		`Discounts:` + strings.Replace(fmt.Sprintf("%v", this.Discounts), "OrderSKUDiscounts", "OrderSKUDiscounts", 1) + `,`,
		`CTime:` + fmt.Sprintf("%v", this.CTime) + `,`,
		`MTime:` + fmt.Sprintf("%v", this.MTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderPayCharge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderPayCharge{`,
		`OrderID:` + fmt.Sprintf("%v", this.OrderID) + `,`,
		`ChargeID:` + fmt.Sprintf("%v", this.ChargeID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Paid:` + fmt.Sprintf("%v", this.Paid) + `,`,
		`Refunded:` + fmt.Sprintf("%v", this.Refunded) + `,`,
		`PayTime:` + fmt.Sprintf("%v", this.PayTime) + `,`,
		`CTime:` + fmt.Sprintf("%v", this.CTime) + `,`,
		`MTime:` + fmt.Sprintf("%v", this.MTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderItemInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderItemInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Img:` + fmt.Sprintf("%v", this.Img) + `,`,
		`ScreenID:` + fmt.Sprintf("%v", this.ScreenID) + `,`,
		`ScreenName:` + fmt.Sprintf("%v", this.ScreenName) + `,`,
		`ScreenType:` + fmt.Sprintf("%v", this.ScreenType) + `,`,
		`DeliverType:` + fmt.Sprintf("%v", this.DeliverType) + `,`,
		`ExpressFee:` + fmt.Sprintf("%v", this.ExpressFee) + `,`,
		`VIPExpressFree:` + fmt.Sprintf("%v", this.VIPExpressFree) + `,`,
		`VerID:` + fmt.Sprintf("%v", this.VerID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderSKUDiscounts) String() string {
	if this == nil {
		return "nil"
	}
	keysForPlatform := make([]int32, 0, len(this.Platform))
	for k, _ := range this.Platform {
		keysForPlatform = append(keysForPlatform, k)
	}
	sortkeys.Int32s(keysForPlatform)
	mapStringForPlatform := "map[int32]int64{"
	for _, k := range keysForPlatform {
		mapStringForPlatform += fmt.Sprintf("%v: %v,", k, this.Platform[k])
	}
	mapStringForPlatform += "}"
	keysForMerchant := make([]int32, 0, len(this.Merchant))
	for k, _ := range this.Merchant {
		keysForMerchant = append(keysForMerchant, k)
	}
	sortkeys.Int32s(keysForMerchant)
	mapStringForMerchant := "map[int32]int64{"
	for _, k := range keysForMerchant {
		mapStringForMerchant += fmt.Sprintf("%v: %v,", k, this.Merchant[k])
	}
	mapStringForMerchant += "}"
	s := strings.Join([]string{`&OrderSKUDiscounts{`,
		`Platform:` + mapStringForPlatform + `,`,
		`Merchant:` + mapStringForMerchant + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderBuyer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderBuyer{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Tel:` + fmt.Sprintf("%v", this.Tel) + `,`,
		`PersonalID:` + fmt.Sprintf("%v", this.PersonalID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderDeliver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderDeliver{`,
		`AddrID:` + fmt.Sprintf("%v", this.AddrID) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Tel:` + fmt.Sprintf("%v", this.Tel) + `,`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderExtra) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderExtra{`,
		`AutoRecvTime:` + fmt.Sprintf("%v", this.AutoRecvTime) + `,`,
		`DelayRecvTimes:` + fmt.Sprintf("%v", this.DelayRecvTimes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderCoupon) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderCoupon{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringOrder(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *OrderSKU) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderSKU: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderSKU: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SKUID", wireType)
			}
			m.SKUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SKUID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginPrice", wireType)
			}
			m.OriginPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginPrice |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SeatIDs = append(m.SeatIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOrder
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SeatIDs = append(m.SeatIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIDs", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketType", wireType)
			}
			m.TicketType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TicketType |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Discounts == nil {
				m.Discounts = &OrderSKUDiscounts{}
			}
			if err := m.Discounts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderPayCharge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderPayCharge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderPayCharge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChargeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			m.Paid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Paid |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refunded", wireType)
			}
			m.Refunded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Refunded |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayTime", wireType)
			}
			m.PayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderItemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderItemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderItemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Img = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenID", wireType)
			}
			m.ScreenID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScreenID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScreenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenType", wireType)
			}
			m.ScreenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScreenType |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliverType", wireType)
			}
			m.DeliverType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliverType |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressFee", wireType)
			}
			m.ExpressFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpressFee |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VIPExpressFree", wireType)
			}
			m.VIPExpressFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VIPExpressFree |= (int16(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerID", wireType)
			}
			m.VerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderSKUDiscounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderSKUDiscounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderSKUDiscounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Platform == nil {
				m.Platform = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOrder(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthOrder
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Platform[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merchant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merchant == nil {
				m.Merchant = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrder
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOrder(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthOrder
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Merchant[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBuyer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBuyer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBuyer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderDeliver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderDeliver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderDeliver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrID", wireType)
			}
			m.AddrID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderExtra) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderExtra: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderExtra: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRecvTime", wireType)
			}
			m.AutoRecvTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRecvTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayRecvTimes", wireType)
			}
			m.DelayRecvTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayRecvTimes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderCoupon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderCoupon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderCoupon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrder(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrder
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOrder
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOrder
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOrder(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOrder = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrder   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/ticket-sales/api/grpc/type/order.proto", fileDescriptorOrder)
}

var fileDescriptorOrder = []byte{
	// 1144 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0xdb, 0xc6,
	0x13, 0x0f, 0x25, 0x51, 0x1f, 0x23, 0x5b, 0x7f, 0x7b, 0xff, 0x09, 0x22, 0x27, 0xae, 0x28, 0x08,
	0x28, 0x60, 0x04, 0xb0, 0x64, 0x3b, 0x80, 0x91, 0xb4, 0x41, 0x8b, 0xd0, 0x76, 0x01, 0x21, 0x48,
	0x6b, 0xac, 0x9d, 0x14, 0x48, 0x0f, 0x02, 0xcd, 0x5d, 0xc9, 0x8c, 0xc5, 0x0f, 0x2c, 0x29, 0x21,
	0xba, 0x15, 0x7d, 0x87, 0x3e, 0x41, 0xdf, 0xa0, 0x7d, 0x88, 0xe6, 0xd8, 0x63, 0x4f, 0x44, 0xc3,
	0xa3, 0x80, 0xbe, 0x40, 0x4e, 0xc5, 0xce, 0x92, 0x22, 0x8d, 0x22, 0x68, 0xd2, 0xf4, 0xb2, 0xdc,
	0x99, 0xfd, 0xcd, 0x8f, 0xb3, 0xf3, 0x45, 0xc2, 0x97, 0x56, 0x10, 0x0c, 0x42, 0x2e, 0xe6, 0x8e,
	0xcd, 0x07, 0x7e, 0xc0, 0xbd, 0x60, 0x6a, 0x45, 0x63, 0x5f, 0xb8, 0x83, 0xc8, 0xb1, 0xaf, 0x78,
	0xb4, 0x1b, 0x5a, 0x53, 0x1e, 0x0e, 0xac, 0xc0, 0x19, 0x4c, 0x44, 0x60, 0x0f, 0xa2, 0x45, 0xc0,
	0x07, 0xbe, 0x60, 0x5c, 0xf4, 0x03, 0xe1, 0x47, 0x3e, 0xb9, 0xad, 0x70, 0xfd, 0x94, 0xa3, 0x8f,
	0xf8, 0xfe, 0x7c, 0xff, 0xce, 0xee, 0xc4, 0x89, 0x2e, 0x67, 0x17, 0x7d, 0xdb, 0x77, 0x07, 0x13,
	0x7f, 0xe2, 0x0f, 0x10, 0x7f, 0x31, 0x1b, 0xa3, 0x84, 0x02, 0xee, 0x14, 0x4f, 0xef, 0x97, 0x0a,
	0xd4, 0xbf, 0x91, 0xbc, 0x67, 0x4f, 0x9e, 0x91, 0x03, 0xa8, 0xe3, 0x3b, 0x46, 0x0e, 0x6b, 0x6b,
	0x5d, 0x6d, 0xa7, 0x6c, 0xde, 0x4e, 0x62, 0xa3, 0x86, 0xe7, 0xc3, 0xe3, 0x65, 0x6c, 0xac, 0x8e,
	0x69, 0x0d, 0x77, 0x43, 0x46, 0xee, 0x41, 0x35, 0xbc, 0x9a, 0x49, 0x8b, 0x12, 0x5a, 0xfc, 0x3f,
	0x89, 0x0d, 0xfd, 0xec, 0xc9, 0x33, 0xc4, 0xa7, 0x47, 0x54, 0x0f, 0xaf, 0x66, 0x43, 0x46, 0x0c,
	0xd0, 0x6d, 0x7f, 0xe6, 0x45, 0xed, 0x32, 0x42, 0x1b, 0xcb, 0xd8, 0x50, 0x0a, 0xaa, 0x1e, 0xe4,
	0x3e, 0xac, 0xf9, 0xc2, 0x99, 0x38, 0xde, 0x28, 0x10, 0x8e, 0xcd, 0xdb, 0x15, 0xc4, 0x6d, 0x2c,
	0x63, 0xe3, 0x9a, 0x9e, 0x36, 0x95, 0x74, 0x2a, 0x05, 0xc9, 0xaa, 0xd0, 0x7a, 0xce, 0xaa, 0x60,
	0xea, 0x21, 0xaf, 0x15, 0x72, 0x2b, 0x1a, 0x39, 0x2c, 0x6c, 0x57, 0xbb, 0xe5, 0xec, 0x5a, 0x67,
	0xdc, 0x8a, 0x86, 0xc7, 0xa1, 0xbc, 0x56, 0x76, 0x4c, 0x6b, 0x72, 0x37, 0x64, 0x21, 0x79, 0x08,
	0x4d, 0x15, 0xe1, 0x91, 0x0c, 0x7d, 0xbb, 0xd6, 0xd5, 0x76, 0x74, 0xb3, 0xbd, 0x8c, 0x8d, 0xa2,
	0xfa, 0x6d, 0x6c, 0xe8, 0x8e, 0x17, 0xed, 0x1f, 0x52, 0x50, 0xda, 0xf3, 0x45, 0xc0, 0xc9, 0xb7,
	0xd0, 0x60, 0x4e, 0x88, 0x17, 0x0a, 0xdb, 0xf5, 0xae, 0xb6, 0xd3, 0x3c, 0xb8, 0xd7, 0x7f, 0x47,
	0xba, 0xfa, 0x59, 0xec, 0x8f, 0x33, 0x0b, 0x73, 0x7d, 0x19, 0x1b, 0x39, 0x01, 0xcd, 0xb7, 0xe4,
	0x08, 0x74, 0x3b, 0x72, 0x5c, 0xde, 0x6e, 0xe0, 0x45, 0x77, 0x65, 0xa4, 0x8f, 0xce, 0x1d, 0x97,
	0x2f, 0x63, 0x43, 0xdb, 0x7d, 0x1b, 0x1b, 0x77, 0x27, 0xfe, 0xae, 0xed, 0xbb, 0xae, 0xef, 0x0d,
	0xa6, 0xce, 0x85, 0xb0, 0xc4, 0x62, 0x20, 0xf1, 0x7d, 0x89, 0xa1, 0xca, 0x56, 0x92, 0xb8, 0x48,
	0x02, 0x39, 0xc9, 0xd3, 0xf7, 0x27, 0x41, 0xdb, 0xde, 0xcf, 0x65, 0x68, 0xa1, 0xe7, 0xa7, 0xd6,
	0xe2, 0xe8, 0xd2, 0x12, 0x13, 0xfe, 0xaf, 0x6a, 0xe7, 0x10, 0x1a, 0x36, 0x5a, 0x67, 0xe5, 0xd3,
	0x30, 0xb7, 0x92, 0xd8, 0xa8, 0x2b, 0x4a, 0xb4, 0xca, 0x01, 0xb4, 0xae, 0xb6, 0x43, 0x46, 0xfa,
	0x50, 0xb3, 0x2f, 0x2d, 0xcf, 0xe3, 0x53, 0xac, 0x24, 0xdd, 0xbc, 0xb9, 0x8c, 0x8d, 0x4c, 0x95,
	0x27, 0x25, 0xd3, 0x90, 0x4f, 0xa1, 0x12, 0x58, 0x0e, 0xc3, 0x72, 0xd2, 0xcd, 0xcd, 0x65, 0x6c,
	0xa0, 0x9c, 0x23, 0x51, 0x24, 0xfb, 0x50, 0x17, 0x7c, 0x3c, 0xf3, 0x18, 0x67, 0x58, 0x4b, 0xba,
	0x79, 0x4b, 0xfa, 0x9d, 0xe9, 0x72, 0xf8, 0x4a, 0x45, 0xba, 0x50, 0x0f, 0xac, 0xc5, 0x08, 0x03,
	0x5a, 0xc5, 0x5b, 0xeb, 0x18, 0x47, 0x5a, 0x0b, 0xac, 0xc5, 0x79, 0x1a, 0x6f, 0x95, 0xb4, 0xda,
	0x7f, 0x91, 0xb4, 0xfa, 0x47, 0x24, 0xed, 0xcf, 0x32, 0xac, 0xab, 0x74, 0x44, 0xdc, 0x1d, 0x7a,
	0x63, 0x9f, 0x6c, 0x43, 0xc5, 0xb3, 0x5c, 0x8e, 0xf9, 0x6a, 0x98, 0x75, 0x19, 0x17, 0x29, 0x53,
	0x5c, 0xc9, 0x16, 0x94, 0x1d, 0x77, 0x92, 0xe6, 0xa5, 0xb6, 0x8c, 0x0d, 0x29, 0x52, 0xb9, 0xc8,
	0xc4, 0x85, 0xb6, 0xe0, 0xdc, 0x93, 0x89, 0x53, 0xcd, 0x8c, 0x89, 0x3b, 0x43, 0xa5, 0x4a, 0xdc,
	0x0a, 0x40, 0xeb, 0x6a, 0x3b, 0x64, 0x64, 0x0f, 0x9a, 0xa9, 0x1a, 0xdf, 0x5b, 0x41, 0xea, 0xff,
	0xc9, 0xae, 0x2a, 0xa8, 0x29, 0x28, 0xe1, 0x6b, 0xe9, 0xc4, 0xc3, 0x95, 0x05, 0xf6, 0xa1, 0x9e,
	0xf7, 0x61, 0x41, 0x5d, 0xe8, 0x43, 0xa5, 0xc5, 0x3e, 0x7c, 0x04, 0x6b, 0x8c, 0x4f, 0x9d, 0x39,
	0x17, 0xca, 0xb6, 0x8a, 0xb6, 0x5b, 0x72, 0x98, 0x14, 0xf5, 0xb9, 0x71, 0x33, 0x55, 0xa3, 0xf5,
	0x1e, 0x34, 0xf9, 0xab, 0x40, 0xf0, 0x30, 0x1c, 0x8d, 0x79, 0x96, 0x3d, 0x74, 0xb5, 0xa0, 0xa6,
	0x90, 0x0a, 0x5f, 0x71, 0x4e, 0x5e, 0xc0, 0xc6, 0xdc, 0x09, 0x46, 0xab, 0x63, 0xc1, 0x55, 0xbe,
	0x74, 0x73, 0x2f, 0x89, 0x8d, 0xd6, 0xf3, 0xe1, 0xe9, 0x49, 0x0a, 0x16, 0x5c, 0x26, 0x6e, 0xb3,
	0x88, 0x1c, 0x8d, 0xa7, 0xd6, 0x24, 0x77, 0xa5, 0x35, 0x77, 0x82, 0x02, 0x9a, 0x1c, 0x40, 0x75,
	0xae, 0x7a, 0x4b, 0xf5, 0xfe, 0x5d, 0x59, 0x01, 0xcf, 0xd3, 0xce, 0x6a, 0x05, 0xc2, 0x7f, 0xc9,
	0xed, 0x68, 0xa4, 0x20, 0x54, 0x9f, 0xcb, 0xee, 0xea, 0xfd, 0x5a, 0x82, 0xcd, 0xbf, 0x8d, 0x17,
	0xf2, 0x1d, 0xd4, 0xb3, 0x6f, 0x4d, 0x5b, 0xeb, 0x96, 0x77, 0x9a, 0x07, 0x0f, 0xde, 0x7f, 0x38,
	0xf5, 0x4f, 0x53, 0xd3, 0x13, 0x2f, 0x12, 0x0b, 0x55, 0xeb, 0xfb, 0x74, 0x45, 0x28, 0xc9, 0x5d,
	0x2e, 0x64, 0xdb, 0x45, 0xed, 0xd2, 0x07, 0x93, 0x3f, 0x4d, 0x4d, 0x0b, 0xe4, 0x07, 0x74, 0x45,
	0x78, 0xe7, 0x73, 0x58, 0xbf, 0xf6, 0x7a, 0xb2, 0x01, 0xe5, 0x2b, 0xbe, 0xc0, 0xea, 0xd5, 0xa9,
	0xdc, 0x92, 0x9b, 0xa0, 0xcf, 0xad, 0xe9, 0x8c, 0xab, 0x6f, 0x11, 0x55, 0xc2, 0x67, 0xa5, 0x07,
	0x9a, 0x34, 0xbe, 0x46, 0xff, 0x21, 0xc6, 0xbd, 0x9f, 0x34, 0x00, 0x74, 0xd7, 0x9c, 0x2d, 0xb8,
	0x20, 0xdb, 0x50, 0x5a, 0x0d, 0xb9, 0xb5, 0x24, 0x36, 0x4a, 0x98, 0x85, 0x92, 0xc3, 0x68, 0xc9,
	0x61, 0xab, 0xa6, 0x2a, 0xbd, 0xab, 0xa9, 0xa2, 0x74, 0x6c, 0xa5, 0x4d, 0x15, 0xf1, 0x29, 0x95,
	0x0b, 0xf9, 0x02, 0x9a, 0x01, 0x17, 0xa1, 0xef, 0x59, 0xd3, 0x51, 0x3a, 0xac, 0x1a, 0xe6, 0x27,
	0x49, 0x6c, 0xc0, 0x69, 0xaa, 0xc6, 0xf7, 0x14, 0x41, 0x14, 0x32, 0x61, 0xc8, 0x7a, 0x3f, 0x6a,
	0xb0, 0x86, 0x5e, 0x1e, 0xab, 0x32, 0x96, 0x63, 0xd2, 0x62, 0xac, 0x30, 0x91, 0x6f, 0x25, 0xb1,
	0x51, 0x7d, 0xcc, 0x98, 0x2a, 0x9b, 0xec, 0x90, 0x56, 0xe5, 0x66, 0xf8, 0x11, 0x9e, 0x6f, 0x43,
	0x45, 0x52, 0xa4, 0x2e, 0xa3, 0xa1, 0x94, 0x29, 0xae, 0xbd, 0x1f, 0xb2, 0xe8, 0x9d, 0xbc, 0x8a,
	0x84, 0x45, 0x0e, 0xa1, 0x65, 0xcd, 0x22, 0x7f, 0x24, 0xb8, 0x3d, 0x57, 0x83, 0x53, 0xcb, 0xbf,
	0xf2, 0x8f, 0x67, 0x91, 0x4f, 0xb9, 0x3d, 0xc7, 0xb9, 0xb5, 0x66, 0x15, 0x24, 0xf2, 0x08, 0x36,
	0x18, 0x9f, 0x5a, 0x8b, 0xdc, 0x30, 0x4c, 0x7f, 0x39, 0x88, 0xec, 0x81, 0x63, 0x79, 0x96, 0x81,
	0x43, 0xda, 0x62, 0xd7, 0xe4, 0xde, 0x4b, 0x68, 0xa2, 0x0f, 0x47, 0xfe, 0x2c, 0xf0, 0x3d, 0xe9,
	0xb1, 0xed, 0xb3, 0x6b, 0x93, 0x4f, 0xca, 0x14, 0xd7, 0x7f, 0x08, 0x84, 0x01, 0xba, 0xeb, 0x7b,
	0x7c, 0x51, 0xfc, 0x8b, 0x41, 0x05, 0x55, 0x0f, 0xd3, 0x78, 0xfd, 0xa6, 0x73, 0xe3, 0xf7, 0x37,
	0x9d, 0x1b, 0xdf, 0x27, 0x1d, 0xed, 0x75, 0xd2, 0xd1, 0x7e, 0x4b, 0x3a, 0xda, 0x1f, 0x49, 0x47,
	0x7b, 0xa1, 0xe3, 0xc4, 0xb9, 0xa8, 0xe2, 0xbf, 0xd7, 0xfd, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x9e, 0xa7, 0x94, 0x32, 0x06, 0x0a, 0x00, 0x00,
}
