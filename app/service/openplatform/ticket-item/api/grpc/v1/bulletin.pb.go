// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/ticket-item/api/grpc/v1/bulletin.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The response message containing the bulletin info
type BulletinInfo struct {
	ID      int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id" validate:"min=1"`
	Title   string `protobuf:"bytes,2,opt,name=title,proto3" json:"title"`
	Content string `protobuf:"bytes,3,opt,name=content,proto3" json:"content"`
	Detail  string `protobuf:"bytes,4,opt,name=detail,proto3" json:"detail"`
	Ctime   string `protobuf:"bytes,5,opt,name=ctime,proto3" json:"ctime" validate:"min=0"`
	Mtime   string `protobuf:"bytes,6,opt,name=mtime,proto3" json:"mtime" validate:"min=0"`
	VerID   uint64 `protobuf:"varint,7,opt,name=ver_id,json=verId,proto3" json:"ver_id" validate:"min=0"`
}

func (m *BulletinInfo) Reset()                    { *m = BulletinInfo{} }
func (m *BulletinInfo) String() string            { return proto.CompactTextString(m) }
func (*BulletinInfo) ProtoMessage()               {}
func (*BulletinInfo) Descriptor() ([]byte, []int) { return fileDescriptorBulletin, []int{0} }

func (m *BulletinInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *BulletinInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BulletinInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *BulletinInfo) GetDetail() string {
	if m != nil {
		return m.Detail
	}
	return ""
}

func (m *BulletinInfo) GetCtime() string {
	if m != nil {
		return m.Ctime
	}
	return ""
}

func (m *BulletinInfo) GetMtime() string {
	if m != nil {
		return m.Mtime
	}
	return ""
}

func (m *BulletinInfo) GetVerID() uint64 {
	if m != nil {
		return m.VerID
	}
	return 0
}

// The request message containing the bulletin info to update
type BulletinInfoRequest struct {
	VerID      uint64 `protobuf:"varint,1,opt,name=ver_id,json=verId,proto3" json:"ver_id"`
	Title      string `protobuf:"bytes,2,opt,name=title,proto3" json:"title" validate:"required,max=32"`
	Content    string `protobuf:"bytes,3,opt,name=content,proto3" json:"content" validate:"max=128"`
	Detail     string `protobuf:"bytes,4,opt,name=detail,proto3" json:"detail"`
	TargetItem int64  `protobuf:"varint,5,opt,name=target_item,json=targetItem,proto3" json:"target_item"`
	ParentID   int64  `protobuf:"varint,6,opt,name=parent_id,json=parentId,proto3" json:"parent_id" validate:"required,min=1"`
}

func (m *BulletinInfoRequest) Reset()                    { *m = BulletinInfoRequest{} }
func (m *BulletinInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*BulletinInfoRequest) ProtoMessage()               {}
func (*BulletinInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorBulletin, []int{1} }

func (m *BulletinInfoRequest) GetVerID() uint64 {
	if m != nil {
		return m.VerID
	}
	return 0
}

func (m *BulletinInfoRequest) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BulletinInfoRequest) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *BulletinInfoRequest) GetDetail() string {
	if m != nil {
		return m.Detail
	}
	return ""
}

func (m *BulletinInfoRequest) GetTargetItem() int64 {
	if m != nil {
		return m.TargetItem
	}
	return 0
}

func (m *BulletinInfoRequest) GetParentID() int64 {
	if m != nil {
		return m.ParentID
	}
	return 0
}

// The request message containing the required version info to review the bulletin
type BulletinCheckRequest struct {
	VerID    uint64 `protobuf:"varint,1,opt,name=ver_id,json=verId,proto3" json:"ver_id" validate:"required,min=1"`
	OpType   int32  `protobuf:"varint,2,opt,name=op_type,json=opType,proto3" json:"op_type" validate:"min=0,max=1"`
	Comment  string `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment"`
	Reviewer string `protobuf:"bytes,4,opt,name=reviewer,proto3" json:"reviewer" validate:"required"`
}

func (m *BulletinCheckRequest) Reset()                    { *m = BulletinCheckRequest{} }
func (m *BulletinCheckRequest) String() string            { return proto.CompactTextString(m) }
func (*BulletinCheckRequest) ProtoMessage()               {}
func (*BulletinCheckRequest) Descriptor() ([]byte, []int) { return fileDescriptorBulletin, []int{2} }

func (m *BulletinCheckRequest) GetVerID() uint64 {
	if m != nil {
		return m.VerID
	}
	return 0
}

func (m *BulletinCheckRequest) GetOpType() int32 {
	if m != nil {
		return m.OpType
	}
	return 0
}

func (m *BulletinCheckRequest) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *BulletinCheckRequest) GetReviewer() string {
	if m != nil {
		return m.Reviewer
	}
	return ""
}

// The request message containing the required version info to change the bulletin's status
type BulletinStateRequest struct {
	VerID  uint64 `protobuf:"varint,1,opt,name=ver_id,json=verId,proto3" json:"ver_id" validate:"required,min=1"`
	OpType int32  `protobuf:"varint,2,opt,name=op_type,json=opType,proto3" json:"op_type" validate:"min=0,max=1"`
	Source int32  `protobuf:"varint,3,opt,name=source,proto3" json:"source" validate:"min=1,max=2"`
}

func (m *BulletinStateRequest) Reset()                    { *m = BulletinStateRequest{} }
func (m *BulletinStateRequest) String() string            { return proto.CompactTextString(m) }
func (*BulletinStateRequest) ProtoMessage()               {}
func (*BulletinStateRequest) Descriptor() ([]byte, []int) { return fileDescriptorBulletin, []int{3} }

func (m *BulletinStateRequest) GetVerID() uint64 {
	if m != nil {
		return m.VerID
	}
	return 0
}

func (m *BulletinStateRequest) GetOpType() int32 {
	if m != nil {
		return m.OpType
	}
	return 0
}

func (m *BulletinStateRequest) GetSource() int32 {
	if m != nil {
		return m.Source
	}
	return 0
}

// The general response message containing the result after updating/inserting the bulletin info
type BulletinReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success"`
}

func (m *BulletinReply) Reset()                    { *m = BulletinReply{} }
func (m *BulletinReply) String() string            { return proto.CompactTextString(m) }
func (*BulletinReply) ProtoMessage()               {}
func (*BulletinReply) Descriptor() ([]byte, []int) { return fileDescriptorBulletin, []int{4} }

func (m *BulletinReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func init() {
	proto.RegisterType((*BulletinInfo)(nil), "ticket.service.item.v1.BulletinInfo")
	proto.RegisterType((*BulletinInfoRequest)(nil), "ticket.service.item.v1.BulletinInfoRequest")
	proto.RegisterType((*BulletinCheckRequest)(nil), "ticket.service.item.v1.BulletinCheckRequest")
	proto.RegisterType((*BulletinStateRequest)(nil), "ticket.service.item.v1.BulletinStateRequest")
	proto.RegisterType((*BulletinReply)(nil), "ticket.service.item.v1.BulletinReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Bulletin service

type BulletinClient interface {
	BulletinInfo(ctx context.Context, in *BulletinInfoRequest, opts ...grpc.CallOption) (*BulletinReply, error)
	BulletinCheck(ctx context.Context, in *BulletinCheckRequest, opts ...grpc.CallOption) (*BulletinReply, error)
	BulletinState(ctx context.Context, in *BulletinStateRequest, opts ...grpc.CallOption) (*BulletinReply, error)
}

type bulletinClient struct {
	cc *grpc.ClientConn
}

func NewBulletinClient(cc *grpc.ClientConn) BulletinClient {
	return &bulletinClient{cc}
}

func (c *bulletinClient) BulletinInfo(ctx context.Context, in *BulletinInfoRequest, opts ...grpc.CallOption) (*BulletinReply, error) {
	out := new(BulletinReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Bulletin/BulletinInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bulletinClient) BulletinCheck(ctx context.Context, in *BulletinCheckRequest, opts ...grpc.CallOption) (*BulletinReply, error) {
	out := new(BulletinReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Bulletin/BulletinCheck", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bulletinClient) BulletinState(ctx context.Context, in *BulletinStateRequest, opts ...grpc.CallOption) (*BulletinReply, error) {
	out := new(BulletinReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Bulletin/BulletinState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Bulletin service

type BulletinServer interface {
	BulletinInfo(context.Context, *BulletinInfoRequest) (*BulletinReply, error)
	BulletinCheck(context.Context, *BulletinCheckRequest) (*BulletinReply, error)
	BulletinState(context.Context, *BulletinStateRequest) (*BulletinReply, error)
}

func RegisterBulletinServer(s *grpc.Server, srv BulletinServer) {
	s.RegisterService(&_Bulletin_serviceDesc, srv)
}

func _Bulletin_BulletinInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulletinInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BulletinServer).BulletinInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Bulletin/BulletinInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BulletinServer).BulletinInfo(ctx, req.(*BulletinInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bulletin_BulletinCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulletinCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BulletinServer).BulletinCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Bulletin/BulletinCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BulletinServer).BulletinCheck(ctx, req.(*BulletinCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bulletin_BulletinState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulletinStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BulletinServer).BulletinState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Bulletin/BulletinState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BulletinServer).BulletinState(ctx, req.(*BulletinStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Bulletin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ticket.service.item.v1.Bulletin",
	HandlerType: (*BulletinServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BulletinInfo",
			Handler:    _Bulletin_BulletinInfo_Handler,
		},
		{
			MethodName: "BulletinCheck",
			Handler:    _Bulletin_BulletinCheck_Handler,
		},
		{
			MethodName: "BulletinState",
			Handler:    _Bulletin_BulletinState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/openplatform/ticket-item/api/grpc/v1/bulletin.proto",
}

func (m *BulletinInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulletinInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.ID))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Detail) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Detail)))
		i += copy(dAtA[i:], m.Detail)
	}
	if len(m.Ctime) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Ctime)))
		i += copy(dAtA[i:], m.Ctime)
	}
	if len(m.Mtime) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Mtime)))
		i += copy(dAtA[i:], m.Mtime)
	}
	if m.VerID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.VerID))
	}
	return i, nil
}

func (m *BulletinInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulletinInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.VerID))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Detail) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Detail)))
		i += copy(dAtA[i:], m.Detail)
	}
	if m.TargetItem != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.TargetItem))
	}
	if m.ParentID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.ParentID))
	}
	return i, nil
}

func (m *BulletinCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulletinCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.VerID))
	}
	if m.OpType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.OpType))
	}
	if len(m.Comment) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Comment)))
		i += copy(dAtA[i:], m.Comment)
	}
	if len(m.Reviewer) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(len(m.Reviewer)))
		i += copy(dAtA[i:], m.Reviewer)
	}
	return i, nil
}

func (m *BulletinStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulletinStateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.VerID))
	}
	if m.OpType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.OpType))
	}
	if m.Source != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBulletin(dAtA, i, uint64(m.Source))
	}
	return i, nil
}

func (m *BulletinReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulletinReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintBulletin(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BulletinInfo) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBulletin(uint64(m.ID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	l = len(m.Ctime)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	l = len(m.Mtime)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	if m.VerID != 0 {
		n += 1 + sovBulletin(uint64(m.VerID))
	}
	return n
}

func (m *BulletinInfoRequest) Size() (n int) {
	var l int
	_ = l
	if m.VerID != 0 {
		n += 1 + sovBulletin(uint64(m.VerID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	if m.TargetItem != 0 {
		n += 1 + sovBulletin(uint64(m.TargetItem))
	}
	if m.ParentID != 0 {
		n += 1 + sovBulletin(uint64(m.ParentID))
	}
	return n
}

func (m *BulletinCheckRequest) Size() (n int) {
	var l int
	_ = l
	if m.VerID != 0 {
		n += 1 + sovBulletin(uint64(m.VerID))
	}
	if m.OpType != 0 {
		n += 1 + sovBulletin(uint64(m.OpType))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	l = len(m.Reviewer)
	if l > 0 {
		n += 1 + l + sovBulletin(uint64(l))
	}
	return n
}

func (m *BulletinStateRequest) Size() (n int) {
	var l int
	_ = l
	if m.VerID != 0 {
		n += 1 + sovBulletin(uint64(m.VerID))
	}
	if m.OpType != 0 {
		n += 1 + sovBulletin(uint64(m.OpType))
	}
	if m.Source != 0 {
		n += 1 + sovBulletin(uint64(m.Source))
	}
	return n
}

func (m *BulletinReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func sovBulletin(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBulletin(x uint64) (n int) {
	return sovBulletin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BulletinInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBulletin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulletinInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulletinInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ctime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerID", wireType)
			}
			m.VerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBulletin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBulletin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulletinInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBulletin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulletinInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulletinInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerID", wireType)
			}
			m.VerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetItem", wireType)
			}
			m.TargetItem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetItem |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBulletin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBulletin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulletinCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBulletin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulletinCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulletinCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerID", wireType)
			}
			m.VerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reviewer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBulletin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reviewer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBulletin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBulletin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulletinStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBulletin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulletinStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulletinStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerID", wireType)
			}
			m.VerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBulletin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBulletin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulletinReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBulletin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulletinReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulletinReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBulletin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBulletin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBulletin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBulletin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBulletin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBulletin
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBulletin
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBulletin(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBulletin = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBulletin   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/ticket-item/api/grpc/v1/bulletin.proto", fileDescriptorBulletin)
}

var fileDescriptorBulletin = []byte{
	// 703 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x55, 0x4d, 0x6f, 0xd3, 0x4a,
	0x14, 0x7d, 0x76, 0x9b, 0x34, 0x9d, 0xbe, 0xa7, 0x57, 0x4d, 0x51, 0x15, 0x2a, 0xd1, 0x09, 0x03,
	0x55, 0x2b, 0x68, 0xe3, 0x24, 0x95, 0x2a, 0x04, 0xa4, 0x95, 0x0c, 0x12, 0xca, 0x0e, 0xb9, 0x88,
	0x05, 0x9b, 0xca, 0xb1, 0x6f, 0xd2, 0x51, 0xe3, 0x8f, 0x4e, 0xc6, 0xa6, 0xfd, 0x05, 0xfc, 0x2d,
	0x96, 0x2c, 0x59, 0xb1, 0x63, 0x84, 0xb2, 0x42, 0x59, 0xe6, 0x17, 0x20, 0x8f, 0xed, 0x24, 0x24,
	0x81, 0x02, 0x2b, 0x56, 0x99, 0x39, 0x73, 0xce, 0xbd, 0x77, 0xce, 0xbd, 0xe3, 0xa0, 0x13, 0x3b,
	0x0c, 0x8d, 0x3e, 0xf0, 0x98, 0x39, 0x60, 0x04, 0x21, 0xf8, 0x61, 0xcf, 0x16, 0x9d, 0x80, 0x7b,
	0x86, 0x60, 0xce, 0x05, 0x88, 0x03, 0x26, 0xc0, 0x33, 0xec, 0x90, 0x19, 0x5d, 0x1e, 0x3a, 0x46,
	0x5c, 0x37, 0xda, 0x51, 0xaf, 0x07, 0x82, 0xf9, 0xd5, 0x90, 0x07, 0x22, 0xc0, 0x9b, 0x29, 0xaf,
	0x9a, 0xc5, 0xa8, 0x26, 0xfc, 0x6a, 0x5c, 0xdf, 0x3a, 0xe8, 0x32, 0x71, 0x1e, 0xb5, 0xab, 0x4e,
	0xe0, 0x19, 0xdd, 0xa0, 0x1b, 0x18, 0x8a, 0xde, 0x8e, 0x3a, 0x6a, 0xa7, 0x36, 0x6a, 0x95, 0x86,
	0xa1, 0x9f, 0x74, 0xf4, 0xaf, 0x99, 0x45, 0x6e, 0xf9, 0x9d, 0x00, 0xd7, 0x90, 0xce, 0xdc, 0xb2,
	0x56, 0xd1, 0xf6, 0x96, 0xcc, 0xca, 0x40, 0x12, 0xbd, 0xf5, 0x7c, 0x28, 0x89, 0xce, 0xdc, 0x91,
	0x24, 0xeb, 0xb1, 0xdd, 0x63, 0xae, 0x2d, 0xe0, 0x31, 0xf5, 0x98, 0xdf, 0xac, 0x53, 0x4b, 0x67,
	0x2e, 0x26, 0xa8, 0x20, 0x98, 0xe8, 0x41, 0x59, 0xaf, 0x68, 0x7b, 0xab, 0xe6, 0xea, 0x50, 0x92,
	0x14, 0xb0, 0xd2, 0x1f, 0xbc, 0x83, 0x56, 0x9c, 0xc0, 0x17, 0xe0, 0x8b, 0xf2, 0x92, 0xa2, 0xac,
	0x0d, 0x25, 0xc9, 0x21, 0x2b, 0x5f, 0x60, 0x8a, 0x8a, 0x2e, 0x08, 0x9b, 0xf5, 0xca, 0xcb, 0x8a,
	0x85, 0x86, 0x92, 0x64, 0x88, 0x95, 0xfd, 0xe2, 0x43, 0x54, 0x70, 0x04, 0xf3, 0xa0, 0x5c, 0x50,
	0x94, 0x3b, 0x49, 0x2e, 0x05, 0xcc, 0x57, 0x57, 0xa3, 0x56, 0x7a, 0x94, 0x88, 0x3c, 0x25, 0x2a,
	0x4e, 0x44, 0xde, 0x8f, 0x45, 0xea, 0x08, 0x1f, 0xa3, 0x62, 0x0c, 0xfc, 0x8c, 0xb9, 0xe5, 0x95,
	0x8a, 0xb6, 0xb7, 0x6c, 0xee, 0x0e, 0x24, 0x29, 0xbc, 0x06, 0xae, 0xec, 0xc8, 0x8e, 0x16, 0xeb,
	0x63, 0xe0, 0x2d, 0x97, 0x7e, 0xd5, 0xd1, 0xc6, 0xb4, 0xb1, 0x16, 0x5c, 0x46, 0xd0, 0x17, 0xf8,
	0xc1, 0x38, 0xae, 0xa6, 0xe2, 0x6e, 0x2c, 0x88, 0x9b, 0xc5, 0xc0, 0xcd, 0xef, 0x9d, 0xdd, 0x1d,
	0x3b, 0x3b, 0x92, 0x64, 0x6b, 0x92, 0x98, 0xc3, 0x65, 0xc4, 0x38, 0xb8, 0xfb, 0x9e, 0x7d, 0xd5,
	0x3c, 0x6c, 0xd0, 0xdc, 0xf7, 0x27, 0xb3, 0xbe, 0xdf, 0x9d, 0xf2, 0x7d, 0x24, 0x09, 0x9e, 0xaa,
	0xdd, 0xbe, 0x6a, 0xd6, 0x1b, 0x8f, 0xe8, 0xef, 0x75, 0xa3, 0x86, 0xd6, 0x84, 0xcd, 0xbb, 0x20,
	0xce, 0x92, 0xe9, 0x53, 0x3d, 0x59, 0x32, 0xff, 0x1f, 0x4a, 0x32, 0x0d, 0x5b, 0x28, 0xdd, 0xb4,
	0x04, 0x78, 0xf8, 0x14, 0xad, 0x86, 0x36, 0x07, 0x5f, 0x24, 0x06, 0x14, 0x15, 0xff, 0x68, 0x20,
	0x49, 0xe9, 0xa5, 0x02, 0x95, 0x07, 0x13, 0xc2, 0x48, 0x92, 0xdb, 0x8b, 0x6e, 0x99, 0x8e, 0x5e,
	0x29, 0xe5, 0xb5, 0x5c, 0xfa, 0x4e, 0x47, 0xb7, 0x72, 0xab, 0x9f, 0x9d, 0x83, 0x73, 0x91, 0x7b,
	0xfd, 0x62, 0xc6, 0xeb, 0xda, 0xe2, 0x1e, 0xfe, 0x24, 0x49, 0xd6, 0x88, 0x63, 0xb4, 0x12, 0x84,
	0x67, 0xe2, 0x3a, 0x4c, 0x5b, 0x51, 0x30, 0x77, 0x12, 0x27, 0x33, 0x68, 0x24, 0xc9, 0xe6, 0xcc,
	0x14, 0xa8, 0x4e, 0xd4, 0xa9, 0x55, 0x0c, 0xc2, 0x57, 0xd7, 0x61, 0xf6, 0x02, 0x3c, 0x6f, 0xee,
	0x05, 0x28, 0xc8, 0xca, 0x17, 0xf8, 0x04, 0x95, 0x38, 0xc4, 0x0c, 0xde, 0x02, 0xcf, 0x5c, 0xbf,
	0x37, 0x94, 0x64, 0x8c, 0x8d, 0x24, 0xd9, 0x98, 0x2f, 0x95, 0x5a, 0x63, 0x02, 0xfd, 0xac, 0x4d,
	0x9c, 0x38, 0x15, 0xb6, 0x80, 0xbf, 0xce, 0x89, 0xa7, 0xa8, 0xd8, 0x0f, 0x22, 0xee, 0x80, 0x32,
	0xa2, 0x60, 0xde, 0x4f, 0xf2, 0xa7, 0xc8, 0xbc, 0xba, 0xae, 0xd4, 0x0d, 0x6a, 0x65, 0x0c, 0x7a,
	0x84, 0xfe, 0xcb, 0xaf, 0x67, 0x41, 0xd8, 0xbb, 0x4e, 0x8c, 0xed, 0x47, 0x8e, 0x03, 0xfd, 0xbe,
	0xba, 0x58, 0x29, 0x35, 0x36, 0x83, 0xac, 0x7c, 0xd1, 0x78, 0xaf, 0xa3, 0x52, 0x2e, 0xc4, 0xee,
	0xcc, 0x17, 0xef, 0x61, 0x75, 0xf1, 0xa7, 0xb4, 0xba, 0xe0, 0xf9, 0x6e, 0xed, 0xdc, 0x44, 0x56,
	0x75, 0xd1, 0x7f, 0x70, 0x67, 0x52, 0xaa, 0x9a, 0x49, 0xbc, 0x7f, 0x93, 0x72, 0x7a, 0x74, 0xff,
	0x28, 0x8f, 0xea, 0xf8, 0xcd, 0x79, 0xa6, 0x07, 0xe3, 0x97, 0xf3, 0x98, 0xeb, 0x1f, 0x06, 0xdb,
	0xda, 0xc7, 0xc1, 0xb6, 0xf6, 0x65, 0xb0, 0xad, 0xbd, 0xd1, 0xe3, 0x7a, 0xbb, 0xa8, 0xfe, 0x41,
	0x0e, 0xbf, 0x05, 0x00, 0x00, 0xff, 0xff, 0x2f, 0xbb, 0xfb, 0xd9, 0xcb, 0x06, 0x00, 0x00,
}
