// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/ticket-item/api/grpc/v1/item.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The request message containing the itemID.
type InfoRequest struct {
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id" validate:"required"`
}

func (m *InfoRequest) Reset()                    { *m = InfoRequest{} }
func (m *InfoRequest) String() string            { return proto.CompactTextString(m) }
func (*InfoRequest) ProtoMessage()               {}
func (*InfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{0} }

// The request message containing the itemIDs.
type CardsRequest struct {
	IDs []int64 `protobuf:"varint,1,rep,packed,name=ids" json:"ids" validate:"required"`
}

func (m *CardsRequest) Reset()                    { *m = CardsRequest{} }
func (m *CardsRequest) String() string            { return proto.CompactTextString(m) }
func (*CardsRequest) ProtoMessage()               {}
func (*CardsRequest) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{1} }

// The request message containing the itemIDs ScIDs TicketIDs.
type BillRequest struct {
	IDs   []int64 `protobuf:"varint,1,rep,packed,name=ids" json:"ids" validate:"required"`
	ScIDs []int64 `protobuf:"varint,2,rep,packed,name=tk_ids,json=tkIds" json:"sc_ids" validate:"required"`
	TkIDs []int64 `protobuf:"varint,3,rep,packed,name=sc_ids,json=scIds" json:"tk_ids" validate:"required"`
}

func (m *BillRequest) Reset()                    { *m = BillRequest{} }
func (m *BillRequest) String() string            { return proto.CompactTextString(m) }
func (*BillRequest) ProtoMessage()               {}
func (*BillRequest) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{2} }

// The response message containing the itembaseinfo and related screeninfo,ticketinfo
type InfoReply struct {
	ID         int64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id" validate:"min=1"`
	Name       string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Status     int32                 `protobuf:"varint,3,opt,name=status,proto3" json:"status" validate:"min=1"`
	Type       int32                 `protobuf:"varint,4,opt,name=type,proto3" json:"type" validate:"min=0"`
	Rec        int32                 `protobuf:"varint,5,opt,name=rec,proto3" json:"rec" validate:"min=0"`
	IsSale     int32                 `protobuf:"varint,6,opt,name=is_sale,json=isSale,proto3" json:"is_sale" validate:"min=0"`
	TicketDesc string                `protobuf:"bytes,7,opt,name=ticket_desc,json=ticketDesc,proto3" json:"desc"`
	SaleFlag   int32                 `protobuf:"varint,8,opt,name=sale_flag,json=saleFlag,proto3" json:"sale_flag" validate:"min=1"`
	PromTag    string                `protobuf:"bytes,9,opt,name=prom_tag,json=promTag,proto3" json:"promo_tags"`
	Img        *ImgList              `protobuf:"bytes,10,opt,name=img" json:"img"`
	Time       *ItemTime             `protobuf:"bytes,11,opt,name=time" json:"time"`
	Screen     map[int64]*ScreenInfo `protobuf:"bytes,12,rep,name=screen" json:"screen" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Ext        *ItemExt              `protobuf:"bytes,13,opt,name=ext" json:"ext"`
	BillOpt    *BillOpt              `protobuf:"bytes,14,opt,name=bill_opt,json=billOpt" json:"bill_opt"`
}

func (m *InfoReply) Reset()                    { *m = InfoReply{} }
func (m *InfoReply) String() string            { return proto.CompactTextString(m) }
func (*InfoReply) ProtoMessage()               {}
func (*InfoReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{3} }

// The response message containing the map type cardinfo
type CardsReply struct {
	Cards map[int64]*CardReply `protobuf:"bytes,1,rep,name=cards" json:"list" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CardsReply) Reset()                    { *m = CardsReply{} }
func (m *CardsReply) String() string            { return proto.CompactTextString(m) }
func (*CardsReply) ProtoMessage()               {}
func (*CardsReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{4} }

// The response message containing the itembaseInfo
type CardReply struct {
	ID         int64      `protobuf:"varint,1,opt,name=id,proto3" json:"id" validate:"min=1"`
	Name       string     `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Status     int32      `protobuf:"varint,3,opt,name=status,proto3" json:"status" validate:"min=1"`
	Type       int32      `protobuf:"varint,4,opt,name=type,proto3" json:"type" validate:"min=0"`
	Rec        int32      `protobuf:"varint,5,opt,name=rec,proto3" json:"rec" validate:"min=0"`
	IsSale     int32      `protobuf:"varint,6,opt,name=is_sale,json=isSale,proto3" json:"is_sale" validate:"min=0"`
	TicketDesc string     `protobuf:"bytes,7,opt,name=ticket_desc,json=ticketDesc,proto3" json:"desc"`
	SaleFlag   int32      `protobuf:"varint,8,opt,name=sale_flag,json=saleFlag,proto3" json:"sale_flag" validate:"min=1"`
	PromTag    string     `protobuf:"bytes,9,opt,name=prom_tag,json=promTag,proto3" json:"promo_tags"`
	Img        *ImgList   `protobuf:"bytes,10,opt,name=img" json:"img"`
	Time       *ItemTime  `protobuf:"bytes,11,opt,name=time" json:"time"`
	Venue      *VenueInfo `protobuf:"bytes,12,opt,name=venue" json:"venue"`
}

func (m *CardReply) Reset()                    { *m = CardReply{} }
func (m *CardReply) String() string            { return proto.CompactTextString(m) }
func (*CardReply) ProtoMessage()               {}
func (*CardReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{5} }

// The response message containing billinfo
type BillReply struct {
	BaseInfo map[int64]*ItemBase `protobuf:"bytes,1,rep,name=base_info,json=baseInfo" json:"base_info" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	BillOpt  map[int64]*BillOpt  `protobuf:"bytes,2,rep,name=bill_opt,json=billOpt" json:"bill_opt" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BillReply) Reset()                    { *m = BillReply{} }
func (m *BillReply) String() string            { return proto.CompactTextString(m) }
func (*BillReply) ProtoMessage()               {}
func (*BillReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{6} }

// The response message containing the itembaseinfo and map type screeninfo
type ItemBase struct {
	ID      int64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id" validate:"min=1"`
	Status  int32                 `protobuf:"varint,2,opt,name=status,proto3" json:"status" validate:"min=0"`
	Name    string                `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Type    int32                 `protobuf:"varint,4,opt,name=type,proto3" json:"type" validate:"min=0"`
	IsSale  int32                 `protobuf:"varint,5,opt,name=is_sale,json=isSale,proto3" json:"is_sale" validate:"min=0"`
	PromTag string                `protobuf:"bytes,6,opt,name=prom_tag,json=promTag,proto3" json:"promo_tags"`
	VerID   uint64                `protobuf:"varint,7,opt,name=ver_id,json=verId,proto3" json:"ver_id" validate:"min=0"`
	Time    *ItemTime             `protobuf:"bytes,8,opt,name=time" json:"time"`
	Img     *ImgList              `protobuf:"bytes,9,opt,name=img" json:"img"`
	Screen  map[int64]*ScreenInfo `protobuf:"bytes,10,rep,name=screen" json:"screen" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ItemBase) Reset()                    { *m = ItemBase{} }
func (m *ItemBase) String() string            { return proto.CompactTextString(m) }
func (*ItemBase) ProtoMessage()               {}
func (*ItemBase) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{7} }

// The response message containing the ItemExtinfo
type ItemExt struct {
	Label    string              `protobuf:"bytes,1,opt,name=label,proto3" json:"label"`
	SpType   int32               `protobuf:"varint,2,opt,name=sp_type,json=spType,proto3" json:"sponsor_type" validate:"min=0"`
	VerID    uint64              `protobuf:"varint,3,opt,name=ver_id,json=verId,proto3" json:"ver_id" validate:"min=0"`
	Detail   string              `protobuf:"bytes,4,opt,name=detail,proto3" json:"detail"`
	Venue    *VenueInfo          `protobuf:"bytes,5,opt,name=venue" json:"venue"`
	Bulletin []*BulletinInfo     `protobuf:"bytes,6,rep,name=bulletin" json:"bulletin"`
	Guest    []*GuestInfoRequest `protobuf:"bytes,7,rep,name=guest" json:"guest"`
}

func (m *ItemExt) Reset()                    { *m = ItemExt{} }
func (m *ItemExt) String() string            { return proto.CompactTextString(m) }
func (*ItemExt) ProtoMessage()               {}
func (*ItemExt) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{8} }

// The response message containing the ImgList
type ImgList struct {
	First  string `protobuf:"bytes,1,opt,name=first,proto3" json:"first"`
	Banner string `protobuf:"bytes,2,opt,name=banner,proto3" json:"banner"`
}

func (m *ImgList) Reset()                    { *m = ImgList{} }
func (m *ImgList) String() string            { return proto.CompactTextString(m) }
func (*ImgList) ProtoMessage()               {}
func (*ImgList) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{9} }

// The response message containing the ItemBillOption
type BillOpt struct {
	BuyerInfo  string       `protobuf:"bytes,1,opt,name=buyerInfo,proto3" json:"buyer_info"`
	ExpTip     int32        `protobuf:"varint,2,opt,name=exp_tip,json=expTip,proto3" json:"exptip"`
	ExpFree    int32        `protobuf:"varint,3,opt,name=exp_free,json=expFree,proto3" json:"expfree"`
	VipExpFree int32        `protobuf:"varint,4,opt,name=vip_exp_free,json=vipExpFree,proto3" json:"vip_exp_free"`
	BuyLimit   *BuyNumLimit `protobuf:"bytes,5,opt,name=buy_limit,json=buyLimit" json:"buy_num_limit"`
}

func (m *BillOpt) Reset()                    { *m = BillOpt{} }
func (m *BillOpt) String() string            { return proto.CompactTextString(m) }
func (*BillOpt) ProtoMessage()               {}
func (*BillOpt) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{10} }

// 项目限购结构
type BuyNumLimit struct {
	Level []*BnlLevel         `protobuf:"bytes,1,rep,name=level" json:"level"`
	Per   int32               `protobuf:"varint,2,opt,name=per,proto3" json:"per"`
	VIP   map[int32]*BnlLevel `protobuf:"bytes,3,rep,name=vip" json:"vip" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BuyNumLimit) Reset()                    { *m = BuyNumLimit{} }
func (m *BuyNumLimit) String() string            { return proto.CompactTextString(m) }
func (*BuyNumLimit) ProtoMessage()               {}
func (*BuyNumLimit) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{11} }

type BnlLevel struct {
	ApplyToVip int32 `protobuf:"varint,1,opt,name=apply_to_vip,json=applyToVip,proto3" json:"apply_to_vip"`
	Max        int32 `protobuf:"varint,2,opt,name=max,proto3" json:"max"`
	Min        int32 `protobuf:"varint,3,opt,name=min,proto3" json:"min"`
}

func (m *BnlLevel) Reset()                    { *m = BnlLevel{} }
func (m *BnlLevel) String() string            { return proto.CompactTextString(m) }
func (*BnlLevel) ProtoMessage()               {}
func (*BnlLevel) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{12} }

// The request message containing ItemID MID Face.
type WishRequest struct {
	ItemID int64  `protobuf:"varint,1,opt,name=item_id,json=itemId,proto3" json:"item_id" validate:"required"`
	MID    int64  `protobuf:"varint,2,opt,name=mid,proto3" json:"mid" validate:"required"`
	Face   string `protobuf:"bytes,3,opt,name=face,proto3" json:"face"`
}

func (m *WishRequest) Reset()                    { *m = WishRequest{} }
func (m *WishRequest) String() string            { return proto.CompactTextString(m) }
func (*WishRequest) ProtoMessage()               {}
func (*WishRequest) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{13} }

// The response message containing the ITEMID MID
type WishReply struct {
	ItemID int64 `protobuf:"varint,1,opt,name=item_id,json=itemId,proto3" json:"item_id" validate:"required"`
	MID    int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid" validate:"required"`
}

func (m *WishReply) Reset()                    { *m = WishReply{} }
func (m *WishReply) String() string            { return proto.CompactTextString(m) }
func (*WishReply) ProtoMessage()               {}
func (*WishReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{14} }

// FavRequest 收藏
type FavRequest struct {
	ItemID int64 `protobuf:"varint,1,opt,name=item_id,json=itemId,proto3" json:"item_id" validate:"required"`
	MID    int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid" validate:"required"`
	Type   int32 `protobuf:"varint,3,opt,name=type,proto3" json:"type" validate:"required,min=1,max=3"`
	Status int32 `protobuf:"varint,4,opt,name=Status,proto3" json:"status" validate:"required,min=0,max=1"`
}

func (m *FavRequest) Reset()                    { *m = FavRequest{} }
func (m *FavRequest) String() string            { return proto.CompactTextString(m) }
func (*FavRequest) ProtoMessage()               {}
func (*FavRequest) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{15} }

// FavReply 收藏
type FavReply struct {
	ItemID int64 `protobuf:"varint,1,opt,name=item_id,json=itemId,proto3" json:"item_id" validate:"required"`
	MID    int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid" validate:"required"`
	Type   int32 `protobuf:"varint,3,opt,name=type,proto3" json:"type" validate:"required,min=0,max=1"`
	Status int32 `protobuf:"varint,4,opt,name=Status,proto3" json:"status" validate:"required,min=0,max=1"`
}

func (m *FavReply) Reset()                    { *m = FavReply{} }
func (m *FavReply) String() string            { return proto.CompactTextString(m) }
func (*FavReply) ProtoMessage()               {}
func (*FavReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{16} }

// The request message containing the version info to update/insert project
type VersionRequest struct {
	VerId  uint64 `protobuf:"varint,1,opt,name=ver_id,json=verId,proto3" json:"ver_id" validate:"required,min=0"`
	OpType uint32 `protobuf:"varint,2,opt,name=op_type,json=opType,proto3" json:"op_type" validate:"max=1"`
}

func (m *VersionRequest) Reset()                    { *m = VersionRequest{} }
func (m *VersionRequest) String() string            { return proto.CompactTextString(m) }
func (*VersionRequest) ProtoMessage()               {}
func (*VersionRequest) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{17} }

// The general response message containing the result after updating/inserting the project info
type VersionReply struct {
	ProjectId int64 `protobuf:"varint,1,opt,name=project_id,json=projectId,proto3" json:"project_id"`
}

func (m *VersionReply) Reset()                    { *m = VersionReply{} }
func (m *VersionReply) String() string            { return proto.CompactTextString(m) }
func (*VersionReply) ProtoMessage()               {}
func (*VersionReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{18} }

// The request message containing the info to add/edit a banner
type BannerEditRequest struct {
	VerId       uint64 `protobuf:"varint,1,opt,name=ver_id,json=verId,proto3" json:"ver_id"`
	OpType      int32  `protobuf:"varint,2,opt,name=op_type,json=opType,proto3" json:"op_type"`
	Name        string `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Position    int32  `protobuf:"varint,4,opt,name=position,proto3" json:"position"`
	SubPosition int32  `protobuf:"varint,5,opt,name=sub_position,json=subPosition,proto3" json:"sub_position"`
	Order       int32  `protobuf:"varint,6,opt,name=order,proto3" json:"order"`
	PubStart    int64  `protobuf:"varint,7,opt,name=pub_start,json=pubStart,proto3" json:"pub_start"`
	PubEnd      int64  `protobuf:"varint,8,opt,name=pub_end,json=pubEnd,proto3" json:"pub_end"`
	Pic         string `protobuf:"bytes,9,opt,name=pic,proto3" json:"pic"`
	Url         string `protobuf:"bytes,10,opt,name=url,proto3" json:"url"`
	From        string `protobuf:"bytes,11,opt,name=from,proto3" json:"from"`
	Location    string `protobuf:"bytes,12,opt,name=location,proto3" json:"location"`
	Uname       string `protobuf:"bytes,13,opt,name=uname,proto3" json:"uname"`
	TargetUser  int32  `protobuf:"varint,14,opt,name=target_user,json=targetUser,proto3" json:"target_user"`
}

func (m *BannerEditRequest) Reset()                    { *m = BannerEditRequest{} }
func (m *BannerEditRequest) String() string            { return proto.CompactTextString(m) }
func (*BannerEditRequest) ProtoMessage()               {}
func (*BannerEditRequest) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{19} }

// The response message containing the result after adding/editing a banner
type BannerEditReply struct {
	BannerId int64 `protobuf:"varint,1,opt,name=banner_id,json=bannerId,proto3" json:"banner_id"`
}

func (m *BannerEditReply) Reset()                    { *m = BannerEditReply{} }
func (m *BannerEditReply) String() string            { return proto.CompactTextString(m) }
func (*BannerEditReply) ProtoMessage()               {}
func (*BannerEditReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{20} }

// The request message containing the info to pass/reject a version
type VersionReviewRequest struct {
	VerId   uint64 `protobuf:"varint,1,opt,name=ver_id,json=verId,proto3" json:"ver_id"`
	OpType  int32  `protobuf:"varint,2,opt,name=op_type,json=opType,proto3" json:"op_type"`
	VerType int32  `protobuf:"varint,3,opt,name=ver_type,json=verType,proto3" json:"ver_type"`
	Msg     string `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg"`
	Uname   string `protobuf:"bytes,5,opt,name=uname,proto3" json:"uname"`
}

func (m *VersionReviewRequest) Reset()                    { *m = VersionReviewRequest{} }
func (m *VersionReviewRequest) String() string            { return proto.CompactTextString(m) }
func (*VersionReviewRequest) ProtoMessage()               {}
func (*VersionReviewRequest) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{21} }

// The response message containing the result after passing/rejecting a version
type VersionReviewReply struct {
	VerId uint64 `protobuf:"varint,1,opt,name=ver_id,json=verId,proto3" json:"ver_id"`
}

func (m *VersionReviewReply) Reset()                    { *m = VersionReviewReply{} }
func (m *VersionReviewReply) String() string            { return proto.CompactTextString(m) }
func (*VersionReviewReply) ProtoMessage()               {}
func (*VersionReviewReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{22} }

// The request message containing the info to change a version's status
type VersionStatusRequest struct {
	VerId   uint64 `protobuf:"varint,1,opt,name=ver_id,json=verId,proto3" json:"ver_id"`
	OpType  int32  `protobuf:"varint,2,opt,name=op_type,json=opType,proto3" json:"op_type"`
	VerType int32  `protobuf:"varint,3,opt,name=ver_type,json=verType,proto3" json:"ver_type"`
	Uname   string `protobuf:"bytes,4,opt,name=uname,proto3" json:"uname"`
}

func (m *VersionStatusRequest) Reset()                    { *m = VersionStatusRequest{} }
func (m *VersionStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*VersionStatusRequest) ProtoMessage()               {}
func (*VersionStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{23} }

// The response message containing the result after changing a version's status
type VersionStatusReply struct {
	VerId uint64 `protobuf:"varint,1,opt,name=ver_id,json=verId,proto3" json:"ver_id"`
}

func (m *VersionStatusReply) Reset()                    { *m = VersionStatusReply{} }
func (m *VersionStatusReply) String() string            { return proto.CompactTextString(m) }
func (*VersionStatusReply) ProtoMessage()               {}
func (*VersionStatusReply) Descriptor() ([]byte, []int) { return fileDescriptorItem, []int{24} }

func init() {
	proto.RegisterType((*InfoRequest)(nil), "ticket.service.item.v1.InfoRequest")
	proto.RegisterType((*CardsRequest)(nil), "ticket.service.item.v1.CardsRequest")
	proto.RegisterType((*BillRequest)(nil), "ticket.service.item.v1.BillRequest")
	proto.RegisterType((*InfoReply)(nil), "ticket.service.item.v1.InfoReply")
	proto.RegisterType((*CardsReply)(nil), "ticket.service.item.v1.CardsReply")
	proto.RegisterType((*CardReply)(nil), "ticket.service.item.v1.CardReply")
	proto.RegisterType((*BillReply)(nil), "ticket.service.item.v1.BillReply")
	proto.RegisterType((*ItemBase)(nil), "ticket.service.item.v1.ItemBase")
	proto.RegisterType((*ItemExt)(nil), "ticket.service.item.v1.ItemExt")
	proto.RegisterType((*ImgList)(nil), "ticket.service.item.v1.ImgList")
	proto.RegisterType((*BillOpt)(nil), "ticket.service.item.v1.BillOpt")
	proto.RegisterType((*BuyNumLimit)(nil), "ticket.service.item.v1.BuyNumLimit")
	proto.RegisterType((*BnlLevel)(nil), "ticket.service.item.v1.BnlLevel")
	proto.RegisterType((*WishRequest)(nil), "ticket.service.item.v1.WishRequest")
	proto.RegisterType((*WishReply)(nil), "ticket.service.item.v1.WishReply")
	proto.RegisterType((*FavRequest)(nil), "ticket.service.item.v1.FavRequest")
	proto.RegisterType((*FavReply)(nil), "ticket.service.item.v1.FavReply")
	proto.RegisterType((*VersionRequest)(nil), "ticket.service.item.v1.VersionRequest")
	proto.RegisterType((*VersionReply)(nil), "ticket.service.item.v1.VersionReply")
	proto.RegisterType((*BannerEditRequest)(nil), "ticket.service.item.v1.BannerEditRequest")
	proto.RegisterType((*BannerEditReply)(nil), "ticket.service.item.v1.BannerEditReply")
	proto.RegisterType((*VersionReviewRequest)(nil), "ticket.service.item.v1.VersionReviewRequest")
	proto.RegisterType((*VersionReviewReply)(nil), "ticket.service.item.v1.VersionReviewReply")
	proto.RegisterType((*VersionStatusRequest)(nil), "ticket.service.item.v1.VersionStatusRequest")
	proto.RegisterType((*VersionStatusReply)(nil), "ticket.service.item.v1.VersionStatusReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Item service

type ItemClient interface {
	// Info Servcie
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoReply, error)
	// cards Servcie
	Cards(ctx context.Context, in *CardsRequest, opts ...grpc.CallOption) (*CardsReply, error)
	// BillInfo Servcie
	BillInfo(ctx context.Context, in *BillRequest, opts ...grpc.CallOption) (*BillReply, error)
	// Wish Service
	Wish(ctx context.Context, in *WishRequest, opts ...grpc.CallOption) (*WishReply, error)
	// Version Service
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionReply, error)
	// VersionReview Service
	VersionReview(ctx context.Context, in *VersionReviewRequest, opts ...grpc.CallOption) (*VersionReviewReply, error)
	// VersionStatus Service
	VersionStatus(ctx context.Context, in *VersionStatusRequest, opts ...grpc.CallOption) (*VersionStatusReply, error)
	// BannerEdit Service
	BannerEdit(ctx context.Context, in *BannerEditRequest, opts ...grpc.CallOption) (*BannerEditReply, error)
}

type itemClient struct {
	cc *grpc.ClientConn
}

func NewItemClient(cc *grpc.ClientConn) ItemClient {
	return &itemClient{cc}
}

func (c *itemClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoReply, error) {
	out := new(InfoReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Item/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) Cards(ctx context.Context, in *CardsRequest, opts ...grpc.CallOption) (*CardsReply, error) {
	out := new(CardsReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Item/Cards", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) BillInfo(ctx context.Context, in *BillRequest, opts ...grpc.CallOption) (*BillReply, error) {
	out := new(BillReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Item/BillInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) Wish(ctx context.Context, in *WishRequest, opts ...grpc.CallOption) (*WishReply, error) {
	out := new(WishReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Item/Wish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionReply, error) {
	out := new(VersionReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Item/Version", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) VersionReview(ctx context.Context, in *VersionReviewRequest, opts ...grpc.CallOption) (*VersionReviewReply, error) {
	out := new(VersionReviewReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Item/VersionReview", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) VersionStatus(ctx context.Context, in *VersionStatusRequest, opts ...grpc.CallOption) (*VersionStatusReply, error) {
	out := new(VersionStatusReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Item/VersionStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *itemClient) BannerEdit(ctx context.Context, in *BannerEditRequest, opts ...grpc.CallOption) (*BannerEditReply, error) {
	out := new(BannerEditReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Item/BannerEdit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Item service

type ItemServer interface {
	// Info Servcie
	Info(context.Context, *InfoRequest) (*InfoReply, error)
	// cards Servcie
	Cards(context.Context, *CardsRequest) (*CardsReply, error)
	// BillInfo Servcie
	BillInfo(context.Context, *BillRequest) (*BillReply, error)
	// Wish Service
	Wish(context.Context, *WishRequest) (*WishReply, error)
	// Version Service
	Version(context.Context, *VersionRequest) (*VersionReply, error)
	// VersionReview Service
	VersionReview(context.Context, *VersionReviewRequest) (*VersionReviewReply, error)
	// VersionStatus Service
	VersionStatus(context.Context, *VersionStatusRequest) (*VersionStatusReply, error)
	// BannerEdit Service
	BannerEdit(context.Context, *BannerEditRequest) (*BannerEditReply, error)
}

func RegisterItemServer(s *grpc.Server, srv ItemServer) {
	s.RegisterService(&_Item_serviceDesc, srv)
}

func _Item_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Item/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).Info(ctx, req.(*InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_Cards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).Cards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Item/Cards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).Cards(ctx, req.(*CardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_BillInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).BillInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Item/BillInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).BillInfo(ctx, req.(*BillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_Wish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).Wish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Item/Wish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).Wish(ctx, req.(*WishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Item/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_VersionReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionReviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).VersionReview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Item/VersionReview",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).VersionReview(ctx, req.(*VersionReviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_VersionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).VersionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Item/VersionStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).VersionStatus(ctx, req.(*VersionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Item_BannerEdit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BannerEditRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ItemServer).BannerEdit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Item/BannerEdit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ItemServer).BannerEdit(ctx, req.(*BannerEditRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Item_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ticket.service.item.v1.Item",
	HandlerType: (*ItemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _Item_Info_Handler,
		},
		{
			MethodName: "Cards",
			Handler:    _Item_Cards_Handler,
		},
		{
			MethodName: "BillInfo",
			Handler:    _Item_BillInfo_Handler,
		},
		{
			MethodName: "Wish",
			Handler:    _Item_Wish_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _Item_Version_Handler,
		},
		{
			MethodName: "VersionReview",
			Handler:    _Item_VersionReview_Handler,
		},
		{
			MethodName: "VersionStatus",
			Handler:    _Item_VersionStatus_Handler,
		},
		{
			MethodName: "BannerEdit",
			Handler:    _Item_BannerEdit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/openplatform/ticket-item/api/grpc/v1/item.proto",
}

func (m *InfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ID))
	}
	return i, nil
}

func (m *CardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		dAtA2 := make([]byte, len(m.IDs)*10)
		var j1 int
		for _, num1 := range m.IDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintItem(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *BillRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BillRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		dAtA4 := make([]byte, len(m.IDs)*10)
		var j3 int
		for _, num1 := range m.IDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintItem(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.ScIDs) > 0 {
		dAtA6 := make([]byte, len(m.ScIDs)*10)
		var j5 int
		for _, num1 := range m.ScIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintItem(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.TkIDs) > 0 {
		dAtA8 := make([]byte, len(m.TkIDs)*10)
		var j7 int
		for _, num1 := range m.TkIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintItem(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *InfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Status))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Type))
	}
	if m.Rec != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Rec))
	}
	if m.IsSale != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.IsSale))
	}
	if len(m.TicketDesc) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.TicketDesc)))
		i += copy(dAtA[i:], m.TicketDesc)
	}
	if m.SaleFlag != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.SaleFlag))
	}
	if len(m.PromTag) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.PromTag)))
		i += copy(dAtA[i:], m.PromTag)
	}
	if m.Img != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Img.Size()))
		n9, err := m.Img.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Time != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Time.Size()))
		n10, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Screen) > 0 {
		for k, _ := range m.Screen {
			dAtA[i] = 0x62
			i++
			v := m.Screen[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovItem(uint64(msgSize))
			}
			mapSize := 1 + sovItem(uint64(k)) + msgSize
			i = encodeVarintItem(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintItem(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintItem(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	if m.Ext != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Ext.Size()))
		n12, err := m.Ext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.BillOpt != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.BillOpt.Size()))
		n13, err := m.BillOpt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *CardsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for k, _ := range m.Cards {
			dAtA[i] = 0xa
			i++
			v := m.Cards[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovItem(uint64(msgSize))
			}
			mapSize := 1 + sovItem(uint64(k)) + msgSize
			i = encodeVarintItem(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintItem(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintItem(dAtA, i, uint64(v.Size()))
				n14, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n14
			}
		}
	}
	return i, nil
}

func (m *CardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Status))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Type))
	}
	if m.Rec != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Rec))
	}
	if m.IsSale != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.IsSale))
	}
	if len(m.TicketDesc) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.TicketDesc)))
		i += copy(dAtA[i:], m.TicketDesc)
	}
	if m.SaleFlag != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.SaleFlag))
	}
	if len(m.PromTag) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.PromTag)))
		i += copy(dAtA[i:], m.PromTag)
	}
	if m.Img != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Img.Size()))
		n15, err := m.Img.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Time != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Time.Size()))
		n16, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Venue != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Venue.Size()))
		n17, err := m.Venue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *BillReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BillReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BaseInfo) > 0 {
		for k, _ := range m.BaseInfo {
			dAtA[i] = 0xa
			i++
			v := m.BaseInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovItem(uint64(msgSize))
			}
			mapSize := 1 + sovItem(uint64(k)) + msgSize
			i = encodeVarintItem(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintItem(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintItem(dAtA, i, uint64(v.Size()))
				n18, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n18
			}
		}
	}
	if len(m.BillOpt) > 0 {
		for k, _ := range m.BillOpt {
			dAtA[i] = 0x12
			i++
			v := m.BillOpt[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovItem(uint64(msgSize))
			}
			mapSize := 1 + sovItem(uint64(k)) + msgSize
			i = encodeVarintItem(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintItem(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintItem(dAtA, i, uint64(v.Size()))
				n19, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n19
			}
		}
	}
	return i, nil
}

func (m *ItemBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Status))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Type))
	}
	if m.IsSale != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.IsSale))
	}
	if len(m.PromTag) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.PromTag)))
		i += copy(dAtA[i:], m.PromTag)
	}
	if m.VerID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerID))
	}
	if m.Time != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Time.Size()))
		n20, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Img != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Img.Size()))
		n21, err := m.Img.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Screen) > 0 {
		for k, _ := range m.Screen {
			dAtA[i] = 0x52
			i++
			v := m.Screen[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovItem(uint64(msgSize))
			}
			mapSize := 1 + sovItem(uint64(k)) + msgSize
			i = encodeVarintItem(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintItem(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintItem(dAtA, i, uint64(v.Size()))
				n22, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n22
			}
		}
	}
	return i, nil
}

func (m *ItemExt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemExt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if m.SpType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.SpType))
	}
	if m.VerID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerID))
	}
	if len(m.Detail) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Detail)))
		i += copy(dAtA[i:], m.Detail)
	}
	if m.Venue != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Venue.Size()))
		n23, err := m.Venue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.Bulletin) > 0 {
		for _, msg := range m.Bulletin {
			dAtA[i] = 0x32
			i++
			i = encodeVarintItem(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Guest) > 0 {
		for _, msg := range m.Guest {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintItem(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ImgList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImgList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.First) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.First)))
		i += copy(dAtA[i:], m.First)
	}
	if len(m.Banner) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Banner)))
		i += copy(dAtA[i:], m.Banner)
	}
	return i, nil
}

func (m *BillOpt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BillOpt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuyerInfo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.BuyerInfo)))
		i += copy(dAtA[i:], m.BuyerInfo)
	}
	if m.ExpTip != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ExpTip))
	}
	if m.ExpFree != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ExpFree))
	}
	if m.VipExpFree != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VipExpFree))
	}
	if m.BuyLimit != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.BuyLimit.Size()))
		n24, err := m.BuyLimit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *BuyNumLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyNumLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Level) > 0 {
		for _, msg := range m.Level {
			dAtA[i] = 0xa
			i++
			i = encodeVarintItem(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Per != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Per))
	}
	if len(m.VIP) > 0 {
		for k, _ := range m.VIP {
			dAtA[i] = 0x1a
			i++
			v := m.VIP[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovItem(uint64(msgSize))
			}
			mapSize := 1 + sovItem(uint64(k)) + msgSize
			i = encodeVarintItem(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintItem(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintItem(dAtA, i, uint64(v.Size()))
				n25, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n25
			}
		}
	}
	return i, nil
}

func (m *BnlLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BnlLevel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApplyToVip != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ApplyToVip))
	}
	if m.Max != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Max))
	}
	if m.Min != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Min))
	}
	return i, nil
}

func (m *WishRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WishRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ItemID))
	}
	if m.MID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.MID))
	}
	if len(m.Face) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Face)))
		i += copy(dAtA[i:], m.Face)
	}
	return i, nil
}

func (m *WishReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WishReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ItemID))
	}
	if m.MID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.MID))
	}
	return i, nil
}

func (m *FavRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FavRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ItemID))
	}
	if m.MID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.MID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Type))
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *FavReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FavReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ItemID))
	}
	if m.MID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.MID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Type))
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *VersionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerId))
	}
	if m.OpType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.OpType))
	}
	return i, nil
}

func (m *VersionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProjectId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.ProjectId))
	}
	return i, nil
}

func (m *BannerEditRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BannerEditRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerId))
	}
	if m.OpType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.OpType))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Position != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Position))
	}
	if m.SubPosition != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.SubPosition))
	}
	if m.Order != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.Order))
	}
	if m.PubStart != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.PubStart))
	}
	if m.PubEnd != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.PubEnd))
	}
	if len(m.Pic) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Pic)))
		i += copy(dAtA[i:], m.Pic)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.Location) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Location)))
		i += copy(dAtA[i:], m.Location)
	}
	if len(m.Uname) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Uname)))
		i += copy(dAtA[i:], m.Uname)
	}
	if m.TargetUser != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.TargetUser))
	}
	return i, nil
}

func (m *BannerEditReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BannerEditReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BannerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.BannerId))
	}
	return i, nil
}

func (m *VersionReviewRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionReviewRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerId))
	}
	if m.OpType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.OpType))
	}
	if m.VerType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerType))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Uname) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Uname)))
		i += copy(dAtA[i:], m.Uname)
	}
	return i, nil
}

func (m *VersionReviewReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionReviewReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerId))
	}
	return i, nil
}

func (m *VersionStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerId))
	}
	if m.OpType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.OpType))
	}
	if m.VerType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerType))
	}
	if len(m.Uname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintItem(dAtA, i, uint64(len(m.Uname)))
		i += copy(dAtA[i:], m.Uname)
	}
	return i, nil
}

func (m *VersionStatusReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionStatusReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintItem(dAtA, i, uint64(m.VerId))
	}
	return i, nil
}

func encodeVarintItem(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *InfoRequest) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovItem(uint64(m.ID))
	}
	return n
}

func (m *CardsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.IDs) > 0 {
		l = 0
		for _, e := range m.IDs {
			l += sovItem(uint64(e))
		}
		n += 1 + sovItem(uint64(l)) + l
	}
	return n
}

func (m *BillRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.IDs) > 0 {
		l = 0
		for _, e := range m.IDs {
			l += sovItem(uint64(e))
		}
		n += 1 + sovItem(uint64(l)) + l
	}
	if len(m.ScIDs) > 0 {
		l = 0
		for _, e := range m.ScIDs {
			l += sovItem(uint64(e))
		}
		n += 1 + sovItem(uint64(l)) + l
	}
	if len(m.TkIDs) > 0 {
		l = 0
		for _, e := range m.TkIDs {
			l += sovItem(uint64(e))
		}
		n += 1 + sovItem(uint64(l)) + l
	}
	return n
}

func (m *InfoReply) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovItem(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovItem(uint64(m.Status))
	}
	if m.Type != 0 {
		n += 1 + sovItem(uint64(m.Type))
	}
	if m.Rec != 0 {
		n += 1 + sovItem(uint64(m.Rec))
	}
	if m.IsSale != 0 {
		n += 1 + sovItem(uint64(m.IsSale))
	}
	l = len(m.TicketDesc)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.SaleFlag != 0 {
		n += 1 + sovItem(uint64(m.SaleFlag))
	}
	l = len(m.PromTag)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Img != nil {
		l = m.Img.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if len(m.Screen) > 0 {
		for k, v := range m.Screen {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovItem(uint64(l))
			}
			mapEntrySize := 1 + sovItem(uint64(k)) + l
			n += mapEntrySize + 1 + sovItem(uint64(mapEntrySize))
		}
	}
	if m.Ext != nil {
		l = m.Ext.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if m.BillOpt != nil {
		l = m.BillOpt.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	return n
}

func (m *CardsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for k, v := range m.Cards {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovItem(uint64(l))
			}
			mapEntrySize := 1 + sovItem(uint64(k)) + l
			n += mapEntrySize + 1 + sovItem(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CardReply) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovItem(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovItem(uint64(m.Status))
	}
	if m.Type != 0 {
		n += 1 + sovItem(uint64(m.Type))
	}
	if m.Rec != 0 {
		n += 1 + sovItem(uint64(m.Rec))
	}
	if m.IsSale != 0 {
		n += 1 + sovItem(uint64(m.IsSale))
	}
	l = len(m.TicketDesc)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.SaleFlag != 0 {
		n += 1 + sovItem(uint64(m.SaleFlag))
	}
	l = len(m.PromTag)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Img != nil {
		l = m.Img.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Venue != nil {
		l = m.Venue.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	return n
}

func (m *BillReply) Size() (n int) {
	var l int
	_ = l
	if len(m.BaseInfo) > 0 {
		for k, v := range m.BaseInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovItem(uint64(l))
			}
			mapEntrySize := 1 + sovItem(uint64(k)) + l
			n += mapEntrySize + 1 + sovItem(uint64(mapEntrySize))
		}
	}
	if len(m.BillOpt) > 0 {
		for k, v := range m.BillOpt {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovItem(uint64(l))
			}
			mapEntrySize := 1 + sovItem(uint64(k)) + l
			n += mapEntrySize + 1 + sovItem(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ItemBase) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovItem(uint64(m.ID))
	}
	if m.Status != 0 {
		n += 1 + sovItem(uint64(m.Status))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovItem(uint64(m.Type))
	}
	if m.IsSale != 0 {
		n += 1 + sovItem(uint64(m.IsSale))
	}
	l = len(m.PromTag)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.VerID != 0 {
		n += 1 + sovItem(uint64(m.VerID))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Img != nil {
		l = m.Img.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if len(m.Screen) > 0 {
		for k, v := range m.Screen {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovItem(uint64(l))
			}
			mapEntrySize := 1 + sovItem(uint64(k)) + l
			n += mapEntrySize + 1 + sovItem(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ItemExt) Size() (n int) {
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.SpType != 0 {
		n += 1 + sovItem(uint64(m.SpType))
	}
	if m.VerID != 0 {
		n += 1 + sovItem(uint64(m.VerID))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Venue != nil {
		l = m.Venue.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	if len(m.Bulletin) > 0 {
		for _, e := range m.Bulletin {
			l = e.Size()
			n += 1 + l + sovItem(uint64(l))
		}
	}
	if len(m.Guest) > 0 {
		for _, e := range m.Guest {
			l = e.Size()
			n += 1 + l + sovItem(uint64(l))
		}
	}
	return n
}

func (m *ImgList) Size() (n int) {
	var l int
	_ = l
	l = len(m.First)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.Banner)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	return n
}

func (m *BillOpt) Size() (n int) {
	var l int
	_ = l
	l = len(m.BuyerInfo)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.ExpTip != 0 {
		n += 1 + sovItem(uint64(m.ExpTip))
	}
	if m.ExpFree != 0 {
		n += 1 + sovItem(uint64(m.ExpFree))
	}
	if m.VipExpFree != 0 {
		n += 1 + sovItem(uint64(m.VipExpFree))
	}
	if m.BuyLimit != nil {
		l = m.BuyLimit.Size()
		n += 1 + l + sovItem(uint64(l))
	}
	return n
}

func (m *BuyNumLimit) Size() (n int) {
	var l int
	_ = l
	if len(m.Level) > 0 {
		for _, e := range m.Level {
			l = e.Size()
			n += 1 + l + sovItem(uint64(l))
		}
	}
	if m.Per != 0 {
		n += 1 + sovItem(uint64(m.Per))
	}
	if len(m.VIP) > 0 {
		for k, v := range m.VIP {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovItem(uint64(l))
			}
			mapEntrySize := 1 + sovItem(uint64(k)) + l
			n += mapEntrySize + 1 + sovItem(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BnlLevel) Size() (n int) {
	var l int
	_ = l
	if m.ApplyToVip != 0 {
		n += 1 + sovItem(uint64(m.ApplyToVip))
	}
	if m.Max != 0 {
		n += 1 + sovItem(uint64(m.Max))
	}
	if m.Min != 0 {
		n += 1 + sovItem(uint64(m.Min))
	}
	return n
}

func (m *WishRequest) Size() (n int) {
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovItem(uint64(m.ItemID))
	}
	if m.MID != 0 {
		n += 1 + sovItem(uint64(m.MID))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	return n
}

func (m *WishReply) Size() (n int) {
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovItem(uint64(m.ItemID))
	}
	if m.MID != 0 {
		n += 1 + sovItem(uint64(m.MID))
	}
	return n
}

func (m *FavRequest) Size() (n int) {
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovItem(uint64(m.ItemID))
	}
	if m.MID != 0 {
		n += 1 + sovItem(uint64(m.MID))
	}
	if m.Type != 0 {
		n += 1 + sovItem(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovItem(uint64(m.Status))
	}
	return n
}

func (m *FavReply) Size() (n int) {
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovItem(uint64(m.ItemID))
	}
	if m.MID != 0 {
		n += 1 + sovItem(uint64(m.MID))
	}
	if m.Type != 0 {
		n += 1 + sovItem(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovItem(uint64(m.Status))
	}
	return n
}

func (m *VersionRequest) Size() (n int) {
	var l int
	_ = l
	if m.VerId != 0 {
		n += 1 + sovItem(uint64(m.VerId))
	}
	if m.OpType != 0 {
		n += 1 + sovItem(uint64(m.OpType))
	}
	return n
}

func (m *VersionReply) Size() (n int) {
	var l int
	_ = l
	if m.ProjectId != 0 {
		n += 1 + sovItem(uint64(m.ProjectId))
	}
	return n
}

func (m *BannerEditRequest) Size() (n int) {
	var l int
	_ = l
	if m.VerId != 0 {
		n += 1 + sovItem(uint64(m.VerId))
	}
	if m.OpType != 0 {
		n += 1 + sovItem(uint64(m.OpType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovItem(uint64(m.Position))
	}
	if m.SubPosition != 0 {
		n += 1 + sovItem(uint64(m.SubPosition))
	}
	if m.Order != 0 {
		n += 1 + sovItem(uint64(m.Order))
	}
	if m.PubStart != 0 {
		n += 1 + sovItem(uint64(m.PubStart))
	}
	if m.PubEnd != 0 {
		n += 1 + sovItem(uint64(m.PubEnd))
	}
	l = len(m.Pic)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	if m.TargetUser != 0 {
		n += 1 + sovItem(uint64(m.TargetUser))
	}
	return n
}

func (m *BannerEditReply) Size() (n int) {
	var l int
	_ = l
	if m.BannerId != 0 {
		n += 1 + sovItem(uint64(m.BannerId))
	}
	return n
}

func (m *VersionReviewRequest) Size() (n int) {
	var l int
	_ = l
	if m.VerId != 0 {
		n += 1 + sovItem(uint64(m.VerId))
	}
	if m.OpType != 0 {
		n += 1 + sovItem(uint64(m.OpType))
	}
	if m.VerType != 0 {
		n += 1 + sovItem(uint64(m.VerType))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	return n
}

func (m *VersionReviewReply) Size() (n int) {
	var l int
	_ = l
	if m.VerId != 0 {
		n += 1 + sovItem(uint64(m.VerId))
	}
	return n
}

func (m *VersionStatusRequest) Size() (n int) {
	var l int
	_ = l
	if m.VerId != 0 {
		n += 1 + sovItem(uint64(m.VerId))
	}
	if m.OpType != 0 {
		n += 1 + sovItem(uint64(m.OpType))
	}
	if m.VerType != 0 {
		n += 1 + sovItem(uint64(m.VerType))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 1 + l + sovItem(uint64(l))
	}
	return n
}

func (m *VersionStatusReply) Size() (n int) {
	var l int
	_ = l
	if m.VerId != 0 {
		n += 1 + sovItem(uint64(m.VerId))
	}
	return n
}

func sovItem(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozItem(x uint64) (n int) {
	return sovItem(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDs = append(m.IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthItem
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDs = append(m.IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BillRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BillRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BillRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDs = append(m.IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthItem
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDs = append(m.IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ScIDs = append(m.ScIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthItem
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ScIDs = append(m.ScIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ScIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TkIDs = append(m.TkIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthItem
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TkIDs = append(m.TkIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TkIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rec", wireType)
			}
			m.Rec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rec |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSale", wireType)
			}
			m.IsSale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsSale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaleFlag", wireType)
			}
			m.SaleFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaleFlag |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Img == nil {
				m.Img = &ImgList{}
			}
			if err := m.Img.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &ItemTime{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Screen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Screen == nil {
				m.Screen = make(map[int64]*ScreenInfo)
			}
			var mapkey int64
			var mapvalue *ScreenInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ScreenInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Screen[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ext == nil {
				m.Ext = &ItemExt{}
			}
			if err := m.Ext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillOpt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BillOpt == nil {
				m.BillOpt = &BillOpt{}
			}
			if err := m.BillOpt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cards == nil {
				m.Cards = make(map[int64]*CardReply)
			}
			var mapkey int64
			var mapvalue *CardReply
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CardReply{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Cards[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rec", wireType)
			}
			m.Rec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rec |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSale", wireType)
			}
			m.IsSale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsSale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaleFlag", wireType)
			}
			m.SaleFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaleFlag |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Img == nil {
				m.Img = &ImgList{}
			}
			if err := m.Img.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &ItemTime{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Venue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Venue == nil {
				m.Venue = &VenueInfo{}
			}
			if err := m.Venue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BillReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BillReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BillReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseInfo == nil {
				m.BaseInfo = make(map[int64]*ItemBase)
			}
			var mapkey int64
			var mapvalue *ItemBase
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemBase{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BaseInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillOpt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BillOpt == nil {
				m.BillOpt = make(map[int64]*BillOpt)
			}
			var mapkey int64
			var mapvalue *BillOpt
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BillOpt{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BillOpt[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSale", wireType)
			}
			m.IsSale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsSale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PromTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerID", wireType)
			}
			m.VerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &ItemTime{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Img == nil {
				m.Img = &ImgList{}
			}
			if err := m.Img.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Screen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Screen == nil {
				m.Screen = make(map[int64]*ScreenInfo)
			}
			var mapkey int64
			var mapvalue *ScreenInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ScreenInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Screen[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemExt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemExt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemExt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpType", wireType)
			}
			m.SpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerID", wireType)
			}
			m.VerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Venue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Venue == nil {
				m.Venue = &VenueInfo{}
			}
			if err := m.Venue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bulletin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bulletin = append(m.Bulletin, &BulletinInfo{})
			if err := m.Bulletin[len(m.Bulletin)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Guest = append(m.Guest, &GuestInfoRequest{})
			if err := m.Guest[len(m.Guest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImgList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImgList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImgList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.First = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Banner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Banner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BillOpt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BillOpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BillOpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyerInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuyerInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpTip", wireType)
			}
			m.ExpTip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpTip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpFree", wireType)
			}
			m.ExpFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpFree |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipExpFree", wireType)
			}
			m.VipExpFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipExpFree |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuyLimit == nil {
				m.BuyLimit = &BuyNumLimit{}
			}
			if err := m.BuyLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyNumLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyNumLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyNumLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = append(m.Level, &BnlLevel{})
			if err := m.Level[len(m.Level)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Per", wireType)
			}
			m.Per = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Per |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VIP == nil {
				m.VIP = make(map[int32]*BnlLevel)
			}
			var mapkey int32
			var mapvalue *BnlLevel
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowItem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowItem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthItem
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BnlLevel{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipItem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthItem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VIP[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BnlLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BnlLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BnlLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyToVip", wireType)
			}
			m.ApplyToVip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyToVip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			m.Min = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Min |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WishRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WishRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MID", wireType)
			}
			m.MID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WishReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WishReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WishReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MID", wireType)
			}
			m.MID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FavRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FavRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FavRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MID", wireType)
			}
			m.MID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FavReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FavReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FavReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MID", wireType)
			}
			m.MID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerId", wireType)
			}
			m.VerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			m.ProjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BannerEditRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BannerEditRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BannerEditRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerId", wireType)
			}
			m.VerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPosition", wireType)
			}
			m.SubPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubPosition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubStart", wireType)
			}
			m.PubStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubEnd", wireType)
			}
			m.PubEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubEnd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUser", wireType)
			}
			m.TargetUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetUser |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BannerEditReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BannerEditReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BannerEditReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BannerId", wireType)
			}
			m.BannerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BannerId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionReviewRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionReviewRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionReviewRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerId", wireType)
			}
			m.VerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerType", wireType)
			}
			m.VerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionReviewReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionReviewReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionReviewReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerId", wireType)
			}
			m.VerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerId", wireType)
			}
			m.VerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerType", wireType)
			}
			m.VerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthItem
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionStatusReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowItem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionStatusReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionStatusReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerId", wireType)
			}
			m.VerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowItem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipItem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthItem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipItem(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowItem
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowItem
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowItem
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthItem
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowItem
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipItem(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthItem = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowItem   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/ticket-item/api/grpc/v1/item.proto", fileDescriptorItem)
}

var fileDescriptorItem = []byte{
	// 2179 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x19, 0x4d, 0x6f, 0x1b, 0xc7,
	0x55, 0x24, 0xb5, 0xfc, 0x78, 0x94, 0x1c, 0x67, 0x5a, 0x14, 0x8c, 0x1a, 0x68, 0xe5, 0xb5, 0x1b,
	0xcb, 0x86, 0x2c, 0xc9, 0x36, 0x1a, 0x19, 0x6e, 0xe5, 0x22, 0xac, 0x65, 0x97, 0x80, 0xe3, 0xb8,
	0x23, 0x55, 0x69, 0x6b, 0x14, 0xc4, 0x92, 0x1c, 0x31, 0x53, 0xed, 0x72, 0x37, 0xbb, 0x4b, 0x56,
	0xba, 0xf7, 0xd4, 0xa2, 0xc7, 0xf6, 0xd6, 0x5b, 0x51, 0xa0, 0x68, 0x7f, 0x40, 0x7f, 0x40, 0x0f,
	0x39, 0xf4, 0x90, 0x5f, 0x40, 0x34, 0x3a, 0xf2, 0xd0, 0x43, 0x4f, 0xbd, 0x14, 0x28, 0xde, 0x9b,
	0xd9, 0x0f, 0x29, 0x5a, 0xd2, 0x52, 0x12, 0x24, 0x87, 0x5c, 0x66, 0x86, 0x6f, 0xde, 0x7b, 0xf3,
	0xde, 0x9b, 0xf7, 0x35, 0x4b, 0xf8, 0x9e, 0xed, 0xfb, 0x1b, 0xa1, 0x08, 0x46, 0xb2, 0x2b, 0x36,
	0x3c, 0x5f, 0x0c, 0x7c, 0xc7, 0x8e, 0x0e, 0xbc, 0xc0, 0xdd, 0x88, 0x64, 0xf7, 0x50, 0x44, 0x77,
	0x64, 0x24, 0xdc, 0x0d, 0xdb, 0x97, 0x1b, 0xfd, 0xc0, 0xef, 0x6e, 0x8c, 0xee, 0x6e, 0x20, 0x60,
	0xdd, 0x0f, 0xbc, 0xc8, 0x63, 0xdf, 0x52, 0x38, 0xeb, 0x9a, 0x7e, 0x9d, 0xb6, 0x46, 0x77, 0x97,
	0xee, 0xf4, 0x65, 0xf4, 0xc1, 0xb0, 0xb3, 0xde, 0xf5, 0xdc, 0x8d, 0xbe, 0xd7, 0xf7, 0x36, 0x08,
	0xbd, 0x33, 0x3c, 0xa0, 0x5f, 0xf4, 0x83, 0x56, 0x8a, 0xcd, 0xd2, 0xf6, 0x85, 0x65, 0x08, 0xbb,
	0x81, 0x10, 0x03, 0x4d, 0xfe, 0x83, 0x0b, 0x93, 0x77, 0x86, 0x8e, 0x23, 0x22, 0x19, 0x33, 0xf8,
	0xfe, 0x85, 0x19, 0xf4, 0x87, 0x22, 0x8c, 0x34, 0xf5, 0xc5, 0x2d, 0x18, 0x49, 0x57, 0x5c, 0xfa,
	0xe8, 0x91, 0x18, 0x0c, 0x35, 0xb5, 0xd5, 0x84, 0x7a, 0x6b, 0x70, 0xe0, 0x71, 0xf1, 0x21, 0xca,
	0xc3, 0xee, 0x43, 0x51, 0xf6, 0x1a, 0x85, 0x95, 0xc2, 0x6a, 0xa9, 0x79, 0xfd, 0x64, 0x6c, 0x16,
	0x5b, 0x8f, 0x27, 0x63, 0xb3, 0x28, 0x7b, 0xff, 0x19, 0x9b, 0xdf, 0x18, 0xd9, 0x8e, 0xec, 0xd9,
	0x91, 0x78, 0x68, 0x05, 0xe2, 0xc3, 0xa1, 0x0c, 0x44, 0xcf, 0xe2, 0x45, 0xd9, 0xb3, 0x9e, 0xc2,
	0xc2, 0x0f, 0xed, 0xa0, 0x17, 0xc6, 0x4c, 0xb6, 0xa0, 0x24, 0x7b, 0x61, 0xa3, 0xb0, 0x52, 0x5a,
	0x2d, 0x35, 0xbf, 0x73, 0x32, 0x36, 0x4b, 0xad, 0xc7, 0xe1, 0x64, 0x6c, 0x22, 0x34, 0x8f, 0x0f,
	0xee, 0x59, 0xff, 0x2c, 0x40, 0xbd, 0x29, 0x1d, 0xe7, 0xb3, 0x32, 0x62, 0xef, 0x40, 0x39, 0x3a,
	0x6c, 0x23, 0x6d, 0x91, 0x68, 0x6f, 0x9f, 0x8c, 0x4d, 0x63, 0xb7, 0xab, 0xa8, 0xcb, 0x61, 0xb7,
	0x3d, 0x85, 0x81, 0x11, 0x1d, 0xb6, 0x14, 0x0b, 0x85, 0xd7, 0x28, 0xa5, 0x2c, 0xf6, 0x0e, 0x35,
	0x0b, 0xc5, 0x3d, 0x97, 0x45, 0xd8, 0x6d, 0xf5, 0x42, 0xeb, 0xbf, 0x65, 0xa8, 0x29, 0xe3, 0xfa,
	0xce, 0x31, 0xdb, 0xcc, 0x98, 0x76, 0xe5, 0x8c, 0x69, 0xaf, 0xa6, 0x5c, 0x5c, 0x39, 0xd8, 0xbe,
	0x4b, 0x76, 0x65, 0x6f, 0xc2, 0xfc, 0xc0, 0x76, 0x45, 0xa3, 0xb8, 0x52, 0x58, 0xad, 0x35, 0xab,
	0x93, 0xb1, 0x49, 0xbf, 0x39, 0x8d, 0xec, 0x6d, 0x28, 0x87, 0x91, 0x1d, 0x0d, 0x51, 0xc0, 0xc2,
	0xaa, 0xd1, 0x5c, 0x26, 0xd5, 0x08, 0x72, 0x2e, 0x47, 0xbd, 0xc7, 0x36, 0x61, 0x3e, 0x3a, 0xf6,
	0x45, 0x63, 0x9e, 0xa8, 0xde, 0x44, 0xae, 0xf8, 0xfb, 0xd3, 0x34, 0x9b, 0x16, 0xa7, 0x1d, 0x76,
	0x07, 0x4a, 0x81, 0xe8, 0x36, 0x0c, 0x22, 0xf8, 0x36, 0xda, 0x3f, 0x10, 0xdd, 0x73, 0xf1, 0x71,
	0x83, 0x3d, 0x80, 0x8a, 0x0c, 0xdb, 0xa1, 0xed, 0x88, 0x46, 0x99, 0x48, 0xcc, 0xc9, 0xd8, 0x8c,
	0x41, 0xe7, 0x92, 0x95, 0x65, 0xb8, 0x6b, 0x3b, 0x82, 0xdd, 0x82, 0xba, 0xf2, 0xd9, 0x76, 0x4f,
	0x84, 0xdd, 0x46, 0x25, 0xd5, 0x1b, 0x7f, 0x73, 0x50, 0x9b, 0x8f, 0x45, 0xd8, 0x65, 0x8f, 0xa0,
	0x86, 0xec, 0xda, 0x07, 0x8e, 0xdd, 0x6f, 0x54, 0xe9, 0x98, 0x6b, 0x93, 0xb1, 0x99, 0x02, 0xcf,
	0xb5, 0x41, 0x15, 0xb7, 0x9f, 0x38, 0x76, 0x9f, 0xdd, 0x82, 0xaa, 0x1f, 0x78, 0x6e, 0x3b, 0xb2,
	0xfb, 0x8d, 0x1a, 0x9d, 0x73, 0x65, 0x32, 0x36, 0x01, 0x61, 0x1e, 0x02, 0x43, 0x5e, 0xc1, 0xf5,
	0x9e, 0xdd, 0x67, 0x0f, 0xa1, 0x24, 0xdd, 0x7e, 0x03, 0x56, 0x0a, 0xab, 0xf5, 0x7b, 0xe6, 0xfa,
	0xf9, 0x09, 0x6b, 0xbd, 0xe5, 0xf6, 0x9f, 0xc9, 0x30, 0x6a, 0x56, 0xc8, 0x3f, 0xdd, 0x3e, 0xc7,
	0x81, 0x3d, 0x82, 0x79, 0x0c, 0xd5, 0x46, 0x9d, 0x88, 0x57, 0x72, 0x89, 0x23, 0xe1, 0xee, 0x49,
	0x57, 0x28, 0x65, 0x91, 0x82, 0xd3, 0xc8, 0x7e, 0x8c, 0x5e, 0x88, 0x89, 0xaa, 0xb1, 0xb0, 0x52,
	0x5a, 0xad, 0xdf, 0xbb, 0x93, 0xcb, 0x21, 0xf6, 0xb3, 0xf5, 0x5d, 0xc2, 0xdf, 0x19, 0x44, 0xc1,
	0x71, 0x13, 0x94, 0xbb, 0x23, 0x80, 0xeb, 0x19, 0xd5, 0x11, 0x47, 0x51, 0x63, 0x71, 0x86, 0x3a,
	0x91, 0x70, 0x77, 0x8e, 0xb4, 0x3a, 0xe2, 0x28, 0xe2, 0x38, 0xb0, 0x1f, 0x41, 0xb5, 0x23, 0x1d,
	0xa7, 0xed, 0xf9, 0x51, 0xe3, 0xca, 0x74, 0x06, 0x18, 0xc7, 0xef, 0xf9, 0x51, 0x73, 0x61, 0x32,
	0x36, 0x13, 0x22, 0x5e, 0xe9, 0x28, 0xf0, 0xd2, 0x2f, 0xa0, 0x9e, 0x11, 0x94, 0x5d, 0x85, 0xd2,
	0xa1, 0x38, 0x56, 0xd1, 0xc1, 0x71, 0xc9, 0x1e, 0x80, 0x31, 0xb2, 0x9d, 0xa1, 0xf2, 0xfe, 0xfa,
	0x3d, 0x2b, 0xef, 0x1c, 0xc5, 0x85, 0xd4, 0x57, 0x04, 0x0f, 0x8b, 0x0f, 0x0a, 0xd6, 0xdf, 0x0b,
	0x00, 0x3a, 0x27, 0x61, 0xec, 0xbd, 0x0b, 0x46, 0x17, 0x7f, 0x51, 0x2a, 0x99, 0x62, 0xc5, 0x94,
	0x44, 0x2d, 0x95, 0x15, 0xe9, 0x52, 0x1c, 0x19, 0x46, 0x5c, 0x71, 0x59, 0x7a, 0xa9, 0x99, 0xe7,
	0xc9, 0xbe, 0x75, 0x5a, 0xf6, 0x6b, 0xd3, 0x8e, 0xa3, 0xd3, 0xb2, 0xa2, 0xff, 0xda, 0x80, 0x5a,
	0xb2, 0xf1, 0x75, 0xd6, 0xf8, 0x3a, 0x6b, 0x5c, 0x3c, 0x6b, 0x34, 0xc1, 0xa0, 0x1a, 0xdf, 0x58,
	0x98, 0xee, 0x7f, 0xfb, 0x88, 0x84, 0xa1, 0xd3, 0xac, 0x4d, 0xc6, 0xa6, 0xa2, 0xe1, 0x6a, 0xb2,
	0xfe, 0x57, 0x84, 0x9a, 0xaa, 0xc5, 0xe8, 0x86, 0x2f, 0xa1, 0xd6, 0xb1, 0x43, 0xd1, 0x96, 0x83,
	0x03, 0x4f, 0x07, 0xd1, 0xc6, 0xb4, 0xc8, 0x57, 0x31, 0xd4, 0xb4, 0x43, 0x62, 0xaf, 0xc2, 0x68,
	0x11, 0x2d, 0x9d, 0x70, 0xe1, 0xd5, 0x8e, 0xde, 0x65, 0xef, 0x67, 0xb2, 0x4a, 0x91, 0x78, 0xaf,
	0xbf, 0x02, 0x6f, 0x95, 0x48, 0x14, 0xeb, 0xdc, 0x24, 0xb3, 0x78, 0x4a, 0x84, 0x73, 0x42, 0xf5,
	0xed, 0xd3, 0xa1, 0x3a, 0xd5, 0xd6, 0xc8, 0x2b, 0x13, 0xa9, 0x4b, 0x2f, 0x61, 0x21, 0x2b, 0xc5,
	0x39, 0xdc, 0xbf, 0x7b, 0x9a, 0xfb, 0xac, 0x64, 0x99, 0x4d, 0x03, 0x7f, 0x30, 0xa0, 0x1a, 0x1f,
	0x7a, 0x89, 0x2c, 0x90, 0xc6, 0x79, 0x71, 0x76, 0x9c, 0x6f, 0xa6, 0x71, 0x1e, 0x67, 0x8f, 0xd2,
	0xb9, 0xd9, 0xe3, 0xe2, 0x59, 0x20, 0x13, 0xd6, 0xc6, 0x45, 0xc3, 0x3a, 0x8d, 0xb5, 0xf2, 0xf4,
	0x58, 0x7b, 0x04, 0xe5, 0x91, 0x08, 0xda, 0xb2, 0x47, 0xc1, 0x3f, 0xdf, 0xbc, 0x89, 0xbd, 0xda,
	0xbe, 0x08, 0xc8, 0x4a, 0x7a, 0xeb, 0xdc, 0xb3, 0x8c, 0x91, 0x08, 0x5a, 0xbd, 0x24, 0xde, 0xaa,
	0x97, 0x8c, 0x37, 0x1d, 0xeb, 0xb5, 0xcb, 0xc4, 0xfa, 0x8b, 0xa4, 0xc2, 0x03, 0xb9, 0xfe, 0xda,
	0x2c, 0x0f, 0x9c, 0x55, 0xe0, 0xbf, 0xe8, 0xd2, 0xfa, 0xb7, 0x12, 0x54, 0x74, 0x77, 0xc0, 0x4c,
	0x30, 0x1c, 0xbb, 0x23, 0x1c, 0xe2, 0x5e, 0x53, 0x59, 0x84, 0x00, 0x5c, 0x4d, 0x6c, 0x1b, 0x2a,
	0xa1, 0xdf, 0x26, 0x9f, 0x51, 0x7e, 0x78, 0x63, 0x32, 0x36, 0x17, 0x42, 0xdf, 0x1b, 0x84, 0x5e,
	0xd0, 0xce, 0xf5, 0x9d, 0x72, 0xe8, 0xef, 0xa1, 0xf7, 0xa4, 0x17, 0x5b, 0xba, 0xd4, 0xc5, 0x5a,
	0x50, 0xee, 0x89, 0xc8, 0x96, 0x0e, 0x79, 0x6c, 0x4d, 0x99, 0x4b, 0x41, 0xb8, 0x9e, 0xd3, 0x64,
	0x69, 0x5c, 0x3a, 0x59, 0xb2, 0xe7, 0x50, 0x8d, 0x1f, 0x84, 0x8d, 0x32, 0x5d, 0xe3, 0x8d, 0xdc,
	0x50, 0xd7, 0x78, 0xc4, 0x49, 0xe5, 0x2d, 0x0d, 0xe1, 0xc9, 0x8a, 0xb5, 0xc0, 0xa0, 0xf7, 0x61,
	0xa3, 0x42, 0xcc, 0x56, 0xf3, 0x98, 0x3d, 0x45, 0xa4, 0xcc, 0xfb, 0x4d, 0x89, 0x46, 0xa4, 0x5c,
	0x4d, 0xd6, 0x73, 0xa8, 0x68, 0xc7, 0xc3, 0xdb, 0x3a, 0x90, 0x41, 0x18, 0x65, 0x6f, 0x8b, 0x00,
	0x5c, 0x4d, 0x68, 0xae, 0x8e, 0x3d, 0x18, 0x88, 0x40, 0x37, 0x0f, 0x64, 0x2e, 0x05, 0xe1, 0x7a,
	0xb6, 0x7e, 0x57, 0x84, 0x8a, 0x4e, 0x57, 0x6c, 0x0d, 0x6a, 0x9d, 0xe1, 0xb1, 0x08, 0x5a, 0xaa,
	0x2a, 0x24, 0x31, 0x4a, 0x40, 0x95, 0xe5, 0x53, 0x04, 0x76, 0x1d, 0x2a, 0xe2, 0xc8, 0x6f, 0x47,
	0xd2, 0xd7, 0xbe, 0x40, 0xec, 0xc5, 0x91, 0x1f, 0x49, 0x9f, 0xe3, 0xbc, 0x27, 0x7d, 0xf6, 0x16,
	0x54, 0x11, 0xe9, 0x20, 0x10, 0x42, 0x77, 0x28, 0x75, 0x4c, 0x18, 0xe2, 0xc8, 0x47, 0x10, 0xc7,
	0xc5, 0x93, 0x40, 0x08, 0x76, 0x0f, 0x16, 0x46, 0xd2, 0x6f, 0x27, 0xb8, 0x2a, 0x23, 0x5d, 0x45,
	0xef, 0xca, 0xc2, 0x39, 0x8c, 0xa4, 0xbf, 0xa3, 0x69, 0x76, 0x49, 0xdc, 0xb6, 0x23, 0x5d, 0x19,
	0xe9, 0xdb, 0xbe, 0x9e, 0x7f, 0x4d, 0xc7, 0xcf, 0x87, 0xee, 0x33, 0x44, 0x6d, 0xbe, 0x3e, 0x19,
	0x9b, 0x8b, 0x48, 0x39, 0x18, 0xba, 0x8a, 0x1a, 0xaf, 0xea, 0x98, 0x36, 0xad, 0xdf, 0x17, 0xa1,
	0x9e, 0x41, 0x66, 0xef, 0x80, 0xe1, 0x88, 0x11, 0x85, 0x44, 0x69, 0x5a, 0x32, 0x69, 0x0e, 0x9c,
	0x67, 0x88, 0xa7, 0x83, 0x06, 0x97, 0x5c, 0x4d, 0xec, 0x0d, 0x28, 0xf9, 0xfa, 0x0e, 0x0c, 0x95,
	0x2d, 0x7c, 0x11, 0x70, 0x1c, 0xd8, 0x73, 0x28, 0x8d, 0xa4, 0x4f, 0x4f, 0xd2, 0x29, 0xa9, 0x22,
	0x23, 0xcf, 0xfa, 0xbe, 0xf4, 0x55, 0xaa, 0xb8, 0x82, 0xef, 0xe7, 0xfd, 0xd6, 0x0b, 0xe4, 0x37,
	0x92, 0x3e, 0xc7, 0x61, 0xe9, 0xa7, 0x50, 0x8d, 0x11, 0xb2, 0x89, 0xc2, 0xb8, 0x58, 0x71, 0x8c,
	0x75, 0xc9, 0xa6, 0x89, 0x08, 0xaa, 0x31, 0x18, 0x2f, 0xcb, 0xf6, 0x7d, 0xe7, 0xb8, 0x1d, 0x79,
	0x6d, 0x14, 0xbf, 0x90, 0x5e, 0x56, 0x16, 0xce, 0x81, 0x7e, 0xed, 0x79, 0xfb, 0xd2, 0x47, 0x23,
	0xb8, 0xf6, 0x51, 0xd6, 0x08, 0xae, 0x7d, 0xc4, 0x71, 0xa0, 0x2d, 0x39, 0xd0, 0xee, 0xa1, 0xb6,
	0xe4, 0x80, 0xe3, 0x60, 0xfd, 0xb5, 0x00, 0xf5, 0xf7, 0x65, 0xf8, 0x41, 0xfc, 0x05, 0x61, 0x07,
	0x2a, 0x28, 0x64, 0x3b, 0xa9, 0x9e, 0x6b, 0x27, 0x63, 0xb3, 0x8c, 0xe9, 0x8b, 0x52, 0x48, 0xbc,
	0x99, 0xf7, 0x90, 0x2f, 0xe3, 0x7e, 0xab, 0xc7, 0xb6, 0xf0, 0xc4, 0x1e, 0x09, 0xa3, 0x3f, 0x44,
	0xbc, 0x4b, 0xf4, 0x08, 0xcd, 0xfd, 0x10, 0xe1, 0xaa, 0x66, 0xfc, 0xc0, 0xee, 0x9e, 0x2a, 0xa7,
	0xf8, 0x9b, 0xd3, 0x68, 0xfd, 0xb6, 0x00, 0x35, 0x25, 0x2d, 0xf6, 0x58, 0x5f, 0xb2, 0xac, 0xd6,
	0x9f, 0x8b, 0x00, 0x4f, 0xec, 0xd1, 0x57, 0xc5, 0x74, 0x4f, 0x75, 0xaf, 0xa1, 0xae, 0xf9, 0xfe,
	0xc9, 0xd8, 0x9c, 0xc7, 0x9a, 0x90, 0xe9, 0x39, 0xcc, 0x4f, 0xd3, 0xae, 0x51, 0x0b, 0xb4, 0xe6,
	0xda, 0x47, 0xdb, 0xf7, 0xe3, 0x16, 0xe4, 0x3d, 0x28, 0xef, 0xaa, 0x56, 0x48, 0x25, 0x89, 0x2d,
	0xd4, 0x43, 0x41, 0x4e, 0x35, 0x45, 0x79, 0xec, 0x36, 0x89, 0x1d, 0xbe, 0x85, 0x14, 0x91, 0xf5,
	0xa7, 0x22, 0x54, 0xc9, 0x50, 0x5f, 0x81, 0x5b, 0xfb, 0x0c, 0x66, 0x4a, 0xf4, 0xfa, 0x82, 0xcc,
	0xf4, 0x9b, 0x02, 0x5c, 0xd9, 0x17, 0x41, 0x28, 0xbd, 0x41, 0xec, 0x53, 0x69, 0x3d, 0x2f, 0xa8,
	0x7a, 0x7e, 0xaa, 0x8c, 0xbf, 0x91, 0xc7, 0x39, 0xa9, 0xe7, 0x0f, 0xa0, 0xe2, 0x65, 0xda, 0x89,
	0x45, 0xd5, 0x4d, 0x6a, 0xd0, 0x99, 0x46, 0x40, 0x0b, 0xe3, 0x51, 0x27, 0x61, 0x6d, 0xc3, 0x42,
	0x22, 0x0b, 0x5e, 0xdb, 0x1d, 0xc0, 0x4e, 0xf2, 0x97, 0xa2, 0x1b, 0xa5, 0x37, 0x17, 0xf7, 0x97,
	0x1a, 0xca, 0x6b, 0x7a, 0xdd, 0xea, 0x59, 0x7f, 0x9c, 0x87, 0xd7, 0x9b, 0x54, 0x00, 0x77, 0x7a,
	0x32, 0x8a, 0xd5, 0xb9, 0x76, 0x46, 0x1d, 0x48, 0xd5, 0x89, 0x25, 0xbe, 0x71, 0x5a, 0x62, 0x5d,
	0xce, 0x34, 0x28, 0x96, 0x6e, 0x46, 0xd7, 0xbd, 0x0a, 0x55, 0xdf, 0x0b, 0x65, 0x24, 0xbd, 0x81,
	0xbe, 0x1b, 0xea, 0x1b, 0x62, 0x18, 0x4f, 0x56, 0xec, 0x3e, 0x2c, 0x84, 0xc3, 0x4e, 0x3b, 0xc1,
	0x36, 0xd2, 0x44, 0x9b, 0x85, 0xf3, 0x7a, 0x38, 0xec, 0xbc, 0x88, 0x89, 0x4c, 0x30, 0xbc, 0xa0,
	0x27, 0x02, 0xfd, 0xee, 0xa6, 0x7a, 0x44, 0x00, 0xae, 0x26, 0x76, 0x1b, 0x6a, 0xfe, 0xb0, 0xd3,
	0x0e, 0x23, 0x3b, 0x88, 0xa8, 0xc3, 0x2e, 0xa9, 0xb7, 0x5c, 0x02, 0xe4, 0x55, 0x7f, 0xd8, 0xd9,
	0xc5, 0x15, 0xea, 0x8b, 0x60, 0x31, 0xe8, 0x51, 0x37, 0x5d, 0x52, 0xfa, 0x6a, 0x10, 0x2f, 0xfb,
	0xc3, 0xce, 0xce, 0xa0, 0x47, 0x15, 0x4e, 0x76, 0xf5, 0x13, 0x5a, 0x55, 0x38, 0xd9, 0xe5, 0x38,
	0xe0, 0xd6, 0x30, 0x70, 0xe8, 0xdd, 0xac, 0xb7, 0x86, 0x81, 0xc3, 0x71, 0xa0, 0x64, 0x1a, 0x78,
	0x2e, 0x3d, 0x8b, 0xe3, 0x64, 0x1a, 0x78, 0x2e, 0xa7, 0x11, 0xad, 0xe4, 0x78, 0x5d, 0x9b, 0xf4,
	0x5e, 0x20, 0x0c, 0xb2, 0x52, 0x0c, 0xe3, 0xc9, 0x0a, 0x15, 0x1e, 0x92, 0xb9, 0x17, 0xd3, 0x3e,
	0x88, 0x00, 0x5c, 0x4d, 0x6c, 0x13, 0xea, 0x91, 0x1d, 0xf4, 0x45, 0xd4, 0x1e, 0x86, 0x22, 0xa0,
	0x2f, 0x5d, 0x46, 0xf3, 0xb5, 0xc9, 0xd8, 0xcc, 0x82, 0x39, 0xa8, 0x1f, 0x3f, 0x09, 0x45, 0x60,
	0x6d, 0xc3, 0x6b, 0x59, 0xf7, 0x40, 0x0f, 0xbb, 0x8d, 0x4f, 0x66, 0x04, 0xa5, 0x0e, 0xa6, 0x5f,
	0xc0, 0x1a, 0x88, 0x2f, 0x60, 0x5c, 0xb6, 0x7a, 0xd6, 0x3f, 0x0a, 0xf0, 0xcd, 0xc4, 0x3d, 0x47,
	0x52, 0xfc, 0xea, 0x73, 0xf7, 0xb0, 0x9b, 0x50, 0x45, 0xb2, 0x4c, 0xaa, 0x20, 0xeb, 0xc4, 0x30,
	0x5e, 0x19, 0x89, 0x80, 0x10, 0xb1, 0xb8, 0x86, 0x7d, 0xdd, 0x2f, 0xab, 0xe2, 0x1a, 0xf6, 0x39,
	0x0e, 0xa9, 0xdd, 0x8c, 0xf3, 0xed, 0x66, 0x6d, 0x01, 0x3b, 0xa3, 0x05, 0x1a, 0x62, 0xb6, 0x0e,
	0xd6, 0x5f, 0x52, 0xfd, 0x55, 0xf2, 0xf8, 0xf2, 0xf4, 0x4f, 0x94, 0x9c, 0x9f, 0xa9, 0x64, 0x2c,
	0xea, 0xab, 0x29, 0x79, 0xef, 0xdf, 0x06, 0xcc, 0x63, 0x5d, 0x60, 0x2f, 0x60, 0x5e, 0x35, 0xc4,
	0xd3, 0x3f, 0xe6, 0x92, 0x05, 0x96, 0xae, 0xcd, 0xfc, 0xe2, 0x6b, 0xcd, 0xb1, 0x5d, 0x30, 0xe8,
	0x83, 0x24, 0xbb, 0x31, 0xe3, 0xcb, 0xa6, 0xe2, 0x69, 0xcd, 0xfe, 0xfe, 0x69, 0xcd, 0xb1, 0x3d,
	0xa8, 0x62, 0xa3, 0x3f, 0x5d, 0xd4, 0xcc, 0xdf, 0x35, 0xf9, 0xa2, 0x26, 0x5f, 0x6d, 0xac, 0x39,
	0x54, 0x1e, 0x5b, 0x9e, 0x7c, 0x8e, 0x99, 0xf6, 0x2d, 0x9f, 0x63, 0xd2, 0x35, 0x59, 0x73, 0xec,
	0x67, 0x50, 0xd1, 0x17, 0xc2, 0xde, 0xca, 0x7f, 0xbc, 0x65, 0xeb, 0xd0, 0xd2, 0x8d, 0x99, 0x78,
	0x8a, 0xf5, 0x21, 0x2c, 0x9e, 0x72, 0x68, 0xb6, 0x36, 0x93, 0x30, 0x13, 0xbd, 0x4b, 0xb7, 0x5f,
	0x11, 0xfb, 0xec, 0x61, 0xca, 0xb1, 0x66, 0x1e, 0x76, 0x2a, 0x54, 0x66, 0x1e, 0x96, 0xf1, 0x56,
	0x6b, 0x8e, 0x75, 0x00, 0xd2, 0x84, 0xc5, 0x6e, 0xe5, 0xde, 0xdc, 0xd9, 0x9a, 0xb7, 0x74, 0xf3,
	0x55, 0x50, 0xe9, 0x8c, 0x66, 0xe3, 0xa3, 0x4f, 0x96, 0xe7, 0x3e, 0xfe, 0x64, 0x79, 0xee, 0xa3,
	0x93, 0xe5, 0xc2, 0xc7, 0x27, 0xcb, 0x85, 0x7f, 0x9d, 0x2c, 0x17, 0x7e, 0x5e, 0x1c, 0xdd, 0xed,
	0x94, 0xe9, 0xcf, 0xc7, 0xfb, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xfa, 0xc9, 0xf7, 0xa3, 0x3b,
	0x1e, 0x00, 0x00,
}
