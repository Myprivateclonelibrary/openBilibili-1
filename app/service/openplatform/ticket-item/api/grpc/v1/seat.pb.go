// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/ticket-item/api/grpc/v1/seat.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 单个座位信息
type AreaSeatInfo struct {
	// 座位图x
	X int32 `protobuf:"varint,1,opt,name=X,proto3" json:"x" validate:"min=0"`
	// 座位图y
	Y int32 `protobuf:"varint,2,opt,name=Y,proto3" json:"y" validate:"min=0"`
	// 座位号
	Label string `protobuf:"bytes,3,opt,name=Label,proto3" json:"label" validate:"min=1"`
	// 背景色
	Bgcolor string `protobuf:"bytes,4,opt,name=Bgcolor,proto3" json:"bgcolor" validate:"min=1"`
	// 区域ID
	Area int64 `protobuf:"varint,5,opt,name=Area,proto3" json:"area" validate:"min=1"`
}

func (m *AreaSeatInfo) Reset()                    { *m = AreaSeatInfo{} }
func (m *AreaSeatInfo) String() string            { return proto.CompactTextString(m) }
func (*AreaSeatInfo) ProtoMessage()               {}
func (*AreaSeatInfo) Descriptor() ([]byte, []int) { return fileDescriptorSeat, []int{0} }

// seatInfo接口请求
type SeatInfoRequest struct {
	// 区域ID
	Area int64 `protobuf:"varint,1,opt,name=Area,proto3" json:"area" validate:"min=1"`
	// 座位数
	SeatsNum int32 `protobuf:"varint,2,opt,name=SeatsNum,proto3" json:"seats_num" validate:"min=1"`
	// 座位图
	SeatMap string `protobuf:"bytes,3,opt,name=SeatMap,proto3" json:"seat_map" validate:"min=1"`
	// 座位数组
	Seats []*AreaSeatInfo `protobuf:"bytes,4,rep,name=Seats" json:"seats" validate:"min=1"`
	// 坐区宽度
	Width int32 `protobuf:"varint,5,opt,name=Width,proto3" json:"width" validate:"min=1"`
	// 坐区高度
	Height int32 `protobuf:"varint,6,opt,name=Height,proto3" json:"height" validate:"min=1"`
	// 行号序列
	RowList string `protobuf:"bytes,7,opt,name=RowList,proto3" json:"row_list" validate:"min=1"`
	// 座位起始坐标
	SeatStart string `protobuf:"bytes,8,opt,name=SeatStart,proto3" json:"seat_start" validate:"min=1"`
}

func (m *SeatInfoRequest) Reset()                    { *m = SeatInfoRequest{} }
func (m *SeatInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*SeatInfoRequest) ProtoMessage()               {}
func (*SeatInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorSeat, []int{1} }

// seatInfo接口返回
type SeatInfoReply struct {
	// 操作结果
	Success bool `protobuf:"varint,1,opt,name=Success,proto3" json:"success"`
}

func (m *SeatInfoReply) Reset()                    { *m = SeatInfoReply{} }
func (m *SeatInfoReply) String() string            { return proto.CompactTextString(m) }
func (*SeatInfoReply) ProtoMessage()               {}
func (*SeatInfoReply) Descriptor() ([]byte, []int) { return fileDescriptorSeat, []int{2} }

// 座位票种
type SeatPrice struct {
	// 座位图x
	X int32 `protobuf:"varint,1,opt,name=X,proto3" json:"x" validate:"min=0"`
	// 座位图y
	Y int32 `protobuf:"varint,2,opt,name=Y,proto3" json:"y" validate:"min=0"`
	// 票种ID
	Price int64 `protobuf:"varint,3,opt,name=Price,proto3" json:"price" validate:"min=1"`
}

func (m *SeatPrice) Reset()                    { *m = SeatPrice{} }
func (m *SeatPrice) String() string            { return proto.CompactTextString(m) }
func (*SeatPrice) ProtoMessage()               {}
func (*SeatPrice) Descriptor() ([]byte, []int) { return fileDescriptorSeat, []int{3} }

// seatStock接口请求
type SeatStockRequest struct {
	// 场次ID
	Screen int64 `protobuf:"varint,1,opt,name=Screen,proto3" json:"screen" validate:"min=1"`
	// 区域ID
	Area int64 `protobuf:"varint,2,opt,name=Area,proto3" json:"area" validate:"min=1"`
	// 座位票种定义数组
	SeatInfo []*SeatPrice `protobuf:"bytes,3,rep,name=SeatInfo" json:"seatInfo" validate:"min=1"`
}

func (m *SeatStockRequest) Reset()                    { *m = SeatStockRequest{} }
func (m *SeatStockRequest) String() string            { return proto.CompactTextString(m) }
func (*SeatStockRequest) ProtoMessage()               {}
func (*SeatStockRequest) Descriptor() ([]byte, []int) { return fileDescriptorSeat, []int{4} }

// seatStock接口返回
type SeatStockReply struct {
	// 操作结果
	Success bool `protobuf:"varint,1,opt,name=Success,proto3" json:"success"`
}

func (m *SeatStockReply) Reset()                    { *m = SeatStockReply{} }
func (m *SeatStockReply) String() string            { return proto.CompactTextString(m) }
func (*SeatStockReply) ProtoMessage()               {}
func (*SeatStockReply) Descriptor() ([]byte, []int) { return fileDescriptorSeat, []int{5} }

// removeSeatOrders接口请求
type RemoveSeatOrdersRequest struct {
	// 票价ID
	Price int64 `protobuf:"varint,1,opt,name=Price,proto3" json:"price" validate:"min=1"`
}

func (m *RemoveSeatOrdersRequest) Reset()                    { *m = RemoveSeatOrdersRequest{} }
func (m *RemoveSeatOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveSeatOrdersRequest) ProtoMessage()               {}
func (*RemoveSeatOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptorSeat, []int{6} }

// removeSeatOrders接口返回
type RemoveSeatOrdersReply struct {
	// 影响的区域
	Areas []int64 `protobuf:"varint,1,rep,packed,name=Areas" json:"areas"`
}

func (m *RemoveSeatOrdersReply) Reset()                    { *m = RemoveSeatOrdersReply{} }
func (m *RemoveSeatOrdersReply) String() string            { return proto.CompactTextString(m) }
func (*RemoveSeatOrdersReply) ProtoMessage()               {}
func (*RemoveSeatOrdersReply) Descriptor() ([]byte, []int) { return fileDescriptorSeat, []int{7} }

func init() {
	proto.RegisterType((*AreaSeatInfo)(nil), "ticket.service.item.v1.AreaSeatInfo")
	proto.RegisterType((*SeatInfoRequest)(nil), "ticket.service.item.v1.SeatInfoRequest")
	proto.RegisterType((*SeatInfoReply)(nil), "ticket.service.item.v1.SeatInfoReply")
	proto.RegisterType((*SeatPrice)(nil), "ticket.service.item.v1.SeatPrice")
	proto.RegisterType((*SeatStockRequest)(nil), "ticket.service.item.v1.SeatStockRequest")
	proto.RegisterType((*SeatStockReply)(nil), "ticket.service.item.v1.SeatStockReply")
	proto.RegisterType((*RemoveSeatOrdersRequest)(nil), "ticket.service.item.v1.RemoveSeatOrdersRequest")
	proto.RegisterType((*RemoveSeatOrdersReply)(nil), "ticket.service.item.v1.RemoveSeatOrdersReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Seat service

type SeatClient interface {
	SeatInfo(ctx context.Context, in *SeatInfoRequest, opts ...grpc.CallOption) (*SeatInfoReply, error)
	SeatStock(ctx context.Context, in *SeatStockRequest, opts ...grpc.CallOption) (*SeatStockReply, error)
	RemoveSeatOrders(ctx context.Context, in *RemoveSeatOrdersRequest, opts ...grpc.CallOption) (*RemoveSeatOrdersReply, error)
}

type seatClient struct {
	cc *grpc.ClientConn
}

func NewSeatClient(cc *grpc.ClientConn) SeatClient {
	return &seatClient{cc}
}

func (c *seatClient) SeatInfo(ctx context.Context, in *SeatInfoRequest, opts ...grpc.CallOption) (*SeatInfoReply, error) {
	out := new(SeatInfoReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Seat/SeatInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatClient) SeatStock(ctx context.Context, in *SeatStockRequest, opts ...grpc.CallOption) (*SeatStockReply, error) {
	out := new(SeatStockReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Seat/SeatStock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatClient) RemoveSeatOrders(ctx context.Context, in *RemoveSeatOrdersRequest, opts ...grpc.CallOption) (*RemoveSeatOrdersReply, error) {
	out := new(RemoveSeatOrdersReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Seat/RemoveSeatOrders", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Seat service

type SeatServer interface {
	SeatInfo(context.Context, *SeatInfoRequest) (*SeatInfoReply, error)
	SeatStock(context.Context, *SeatStockRequest) (*SeatStockReply, error)
	RemoveSeatOrders(context.Context, *RemoveSeatOrdersRequest) (*RemoveSeatOrdersReply, error)
}

func RegisterSeatServer(s *grpc.Server, srv SeatServer) {
	s.RegisterService(&_Seat_serviceDesc, srv)
}

func _Seat_SeatInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeatInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServer).SeatInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Seat/SeatInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServer).SeatInfo(ctx, req.(*SeatInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seat_SeatStock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeatStockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServer).SeatStock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Seat/SeatStock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServer).SeatStock(ctx, req.(*SeatStockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Seat_RemoveSeatOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveSeatOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServer).RemoveSeatOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Seat/RemoveSeatOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServer).RemoveSeatOrders(ctx, req.(*RemoveSeatOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Seat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ticket.service.item.v1.Seat",
	HandlerType: (*SeatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SeatInfo",
			Handler:    _Seat_SeatInfo_Handler,
		},
		{
			MethodName: "SeatStock",
			Handler:    _Seat_SeatStock_Handler,
		},
		{
			MethodName: "RemoveSeatOrders",
			Handler:    _Seat_RemoveSeatOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/openplatform/ticket-item/api/grpc/v1/seat.proto",
}

func (m *AreaSeatInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AreaSeatInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Y))
	}
	if len(m.Label) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSeat(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if len(m.Bgcolor) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSeat(dAtA, i, uint64(len(m.Bgcolor)))
		i += copy(dAtA[i:], m.Bgcolor)
	}
	if m.Area != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Area))
	}
	return i, nil
}

func (m *SeatInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeatInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Area != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Area))
	}
	if m.SeatsNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.SeatsNum))
	}
	if len(m.SeatMap) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSeat(dAtA, i, uint64(len(m.SeatMap)))
		i += copy(dAtA[i:], m.SeatMap)
	}
	if len(m.Seats) > 0 {
		for _, msg := range m.Seats {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSeat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Width != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Height))
	}
	if len(m.RowList) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSeat(dAtA, i, uint64(len(m.RowList)))
		i += copy(dAtA[i:], m.RowList)
	}
	if len(m.SeatStart) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSeat(dAtA, i, uint64(len(m.SeatStart)))
		i += copy(dAtA[i:], m.SeatStart)
	}
	return i, nil
}

func (m *SeatInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeatInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SeatPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeatPrice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Y))
	}
	if m.Price != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Price))
	}
	return i, nil
}

func (m *SeatStockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeatStockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Screen != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Screen))
	}
	if m.Area != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Area))
	}
	if len(m.SeatInfo) > 0 {
		for _, msg := range m.SeatInfo {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSeat(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SeatStockReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeatStockReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RemoveSeatOrdersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveSeatOrdersRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Price != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSeat(dAtA, i, uint64(m.Price))
	}
	return i, nil
}

func (m *RemoveSeatOrdersReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveSeatOrdersReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Areas) > 0 {
		dAtA2 := make([]byte, len(m.Areas)*10)
		var j1 int
		for _, num1 := range m.Areas {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintSeat(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func encodeVarintSeat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AreaSeatInfo) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovSeat(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovSeat(uint64(m.Y))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovSeat(uint64(l))
	}
	l = len(m.Bgcolor)
	if l > 0 {
		n += 1 + l + sovSeat(uint64(l))
	}
	if m.Area != 0 {
		n += 1 + sovSeat(uint64(m.Area))
	}
	return n
}

func (m *SeatInfoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Area != 0 {
		n += 1 + sovSeat(uint64(m.Area))
	}
	if m.SeatsNum != 0 {
		n += 1 + sovSeat(uint64(m.SeatsNum))
	}
	l = len(m.SeatMap)
	if l > 0 {
		n += 1 + l + sovSeat(uint64(l))
	}
	if len(m.Seats) > 0 {
		for _, e := range m.Seats {
			l = e.Size()
			n += 1 + l + sovSeat(uint64(l))
		}
	}
	if m.Width != 0 {
		n += 1 + sovSeat(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovSeat(uint64(m.Height))
	}
	l = len(m.RowList)
	if l > 0 {
		n += 1 + l + sovSeat(uint64(l))
	}
	l = len(m.SeatStart)
	if l > 0 {
		n += 1 + l + sovSeat(uint64(l))
	}
	return n
}

func (m *SeatInfoReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *SeatPrice) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovSeat(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovSeat(uint64(m.Y))
	}
	if m.Price != 0 {
		n += 1 + sovSeat(uint64(m.Price))
	}
	return n
}

func (m *SeatStockRequest) Size() (n int) {
	var l int
	_ = l
	if m.Screen != 0 {
		n += 1 + sovSeat(uint64(m.Screen))
	}
	if m.Area != 0 {
		n += 1 + sovSeat(uint64(m.Area))
	}
	if len(m.SeatInfo) > 0 {
		for _, e := range m.SeatInfo {
			l = e.Size()
			n += 1 + l + sovSeat(uint64(l))
		}
	}
	return n
}

func (m *SeatStockReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *RemoveSeatOrdersRequest) Size() (n int) {
	var l int
	_ = l
	if m.Price != 0 {
		n += 1 + sovSeat(uint64(m.Price))
	}
	return n
}

func (m *RemoveSeatOrdersReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Areas) > 0 {
		l = 0
		for _, e := range m.Areas {
			l += sovSeat(uint64(e))
		}
		n += 1 + sovSeat(uint64(l)) + l
	}
	return n
}

func sovSeat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSeat(x uint64) (n int) {
	return sovSeat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AreaSeatInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AreaSeatInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AreaSeatInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bgcolor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bgcolor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeatInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeatInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeatInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatsNum", wireType)
			}
			m.SeatsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatsNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatMap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeatMap = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seats = append(m.Seats, &AreaSeatInfo{})
			if err := m.Seats[len(m.Seats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeatStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeatInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeatInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeatInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeatPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeatPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeatPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeatStockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeatStockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeatStockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Screen", wireType)
			}
			m.Screen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Screen |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeatInfo = append(m.SeatInfo, &SeatPrice{})
			if err := m.SeatInfo[len(m.SeatInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeatStockReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeatStockReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeatStockReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveSeatOrdersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveSeatOrdersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveSeatOrdersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveSeatOrdersReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveSeatOrdersReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveSeatOrdersReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSeat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Areas = append(m.Areas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSeat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSeat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSeat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Areas = append(m.Areas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Areas", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSeat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSeat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSeat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSeat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSeat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSeat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSeat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSeat   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/ticket-item/api/grpc/v1/seat.proto", fileDescriptorSeat)
}

var fileDescriptorSeat = []byte{
	// 730 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x95, 0xdf, 0x6e, 0xd3, 0x3c,
	0x18, 0xc6, 0xe7, 0xfe, 0xaf, 0xf7, 0x7d, 0x30, 0x59, 0x02, 0x42, 0x05, 0x4d, 0x17, 0x31, 0xd6,
	0x93, 0x35, 0xeb, 0x26, 0x0d, 0x18, 0x9a, 0x04, 0x39, 0x02, 0x69, 0x0c, 0x94, 0x1e, 0xb0, 0x21,
	0xa4, 0xca, 0xcd, 0xbc, 0x36, 0x5a, 0x52, 0x87, 0xd8, 0xed, 0xd8, 0x29, 0xe2, 0x0a, 0xb8, 0x1d,
	0x6e, 0x60, 0x87, 0xbb, 0x01, 0x22, 0xb6, 0xc3, 0x1c, 0x72, 0x05, 0xc8, 0x76, 0xd3, 0x56, 0x2c,
	0x1d, 0xdd, 0x01, 0x67, 0xc9, 0x9b, 0xe7, 0xf7, 0xda, 0x7e, 0xde, 0xc7, 0x2d, 0x7c, 0x8e, 0x83,
	0xc0, 0x64, 0x24, 0x1c, 0xba, 0x0e, 0x31, 0x69, 0x40, 0xfa, 0x81, 0x87, 0xf9, 0x11, 0x0d, 0x7d,
	0x93, 0xbb, 0xce, 0x31, 0xe1, 0x6b, 0x2e, 0x27, 0xbe, 0x89, 0x03, 0xd7, 0xec, 0x86, 0x81, 0x63,
	0x0e, 0x9b, 0x26, 0x23, 0x98, 0x37, 0x82, 0x90, 0x72, 0x8a, 0xee, 0x2a, 0x4d, 0x63, 0xc4, 0x37,
	0x84, 0xb6, 0x31, 0x6c, 0x56, 0xd6, 0xba, 0x2e, 0xef, 0x0d, 0x3a, 0x0d, 0x87, 0xfa, 0x66, 0x97,
	0x76, 0xa9, 0x29, 0xe5, 0x9d, 0xc1, 0x91, 0x7c, 0x93, 0x2f, 0xf2, 0x49, 0xb5, 0x31, 0xbe, 0x64,
	0xe0, 0x7f, 0x2f, 0x43, 0x82, 0x5b, 0x04, 0xf3, 0xd7, 0xfd, 0x23, 0x8a, 0x56, 0x21, 0xd8, 0xd7,
	0x40, 0x0d, 0xd4, 0xf3, 0xd6, 0xfd, 0x38, 0xd2, 0xc1, 0xe7, 0x5f, 0x91, 0xbe, 0x34, 0xc4, 0x9e,
	0x7b, 0x88, 0x39, 0xd9, 0x36, 0x7c, 0xb7, 0xbf, 0xb3, 0x6e, 0xd8, 0x60, 0x5f, 0x08, 0x0f, 0xb4,
	0xcc, 0x44, 0x78, 0x9a, 0x2e, 0x3c, 0x40, 0x9b, 0x30, 0xbf, 0x8b, 0x3b, 0xc4, 0xd3, 0xb2, 0x35,
	0x50, 0x2f, 0x5b, 0x0f, 0xe3, 0x48, 0xcf, 0x7b, 0xa2, 0x70, 0x15, 0x68, 0x1a, 0xb6, 0xd2, 0xa2,
	0x67, 0xb0, 0x68, 0x75, 0x1d, 0xea, 0xd1, 0x50, 0xcb, 0x49, 0x4c, 0x8f, 0x23, 0xbd, 0xd8, 0x51,
	0xa5, 0x54, 0x30, 0xd1, 0xa3, 0x75, 0x98, 0x13, 0x27, 0xd2, 0xf2, 0x35, 0x50, 0xcf, 0x5a, 0x0f,
	0xe2, 0x48, 0xcf, 0xe1, 0x90, 0xe0, 0x54, 0x48, 0x2a, 0x8d, 0xaf, 0x39, 0x78, 0x3b, 0x31, 0xc0,
	0x26, 0x9f, 0x06, 0x84, 0xf1, 0x71, 0x17, 0x30, 0x6f, 0x17, 0xb4, 0x03, 0x4b, 0xa2, 0x09, 0xdb,
	0x1b, 0xf8, 0x23, 0x5f, 0x96, 0xe3, 0x48, 0x2f, 0x8b, 0x99, 0xb1, 0x76, 0x7f, 0xe0, 0xa7, 0xa2,
	0x63, 0x04, 0x6d, 0xc3, 0xa2, 0x78, 0x7e, 0x83, 0x83, 0x91, 0x51, 0xb5, 0x38, 0xd2, 0x4b, 0x82,
	0x6e, 0xfb, 0x38, 0x48, 0x3f, 0xf2, 0x08, 0x40, 0x07, 0x30, 0x2f, 0xfb, 0x68, 0xb9, 0x5a, 0xb6,
	0xbe, 0xb8, 0xf1, 0xa8, 0x91, 0x1e, 0x8e, 0xc6, 0xf4, 0xa4, 0xd5, 0x20, 0xe4, 0xee, 0xd2, 0x07,
	0x21, 0x3b, 0x8a, 0xe9, 0xbd, 0x77, 0x0f, 0x79, 0x4f, 0xda, 0x99, 0x57, 0xd0, 0x89, 0x28, 0xa4,
	0x43, 0x52, 0x8b, 0xb6, 0x60, 0xe1, 0x15, 0x71, 0xbb, 0x3d, 0xae, 0x15, 0x24, 0x55, 0x8d, 0x23,
	0xbd, 0xd0, 0x93, 0x95, 0x54, 0x6c, 0xa4, 0x16, 0x1e, 0xd8, 0xf4, 0x64, 0xd7, 0x65, 0x5c, 0x2b,
	0x4e, 0x3c, 0x08, 0xe9, 0x49, 0xdb, 0x73, 0x59, 0x3a, 0x9a, 0x00, 0xe8, 0x05, 0x2c, 0x8b, 0x1d,
	0xb7, 0x38, 0x0e, 0xb9, 0x56, 0x92, 0xb4, 0x11, 0x47, 0x3a, 0x94, 0x0e, 0x32, 0x51, 0x4d, 0xe5,
	0x27, 0x90, 0xb1, 0x05, 0xff, 0x9f, 0xa4, 0x20, 0xf0, 0x4e, 0xd1, 0x0a, 0x2c, 0xb6, 0x06, 0x8e,
	0x43, 0x18, 0x93, 0x31, 0x28, 0x59, 0x8b, 0x22, 0x84, 0x4c, 0x95, 0xec, 0xe4, 0x9b, 0xf1, 0x0d,
	0xa8, 0xa5, 0xdf, 0x85, 0xae, 0x43, 0xfe, 0xcd, 0x05, 0x92, 0xad, 0x65, 0x2e, 0xb2, 0x6a, 0x04,
	0x81, 0x28, 0xa4, 0x8f, 0x40, 0x6a, 0x8d, 0x1f, 0x00, 0x2e, 0xa9, 0xa3, 0x51, 0xe7, 0x38, 0x09,
	0xf5, 0x16, 0x2c, 0xb4, 0x9c, 0x90, 0x90, 0xfe, 0x28, 0xd6, 0x72, 0x2e, 0x4c, 0x56, 0xd2, 0xe7,
	0xa2, 0xd4, 0xe3, 0xcb, 0x90, 0x99, 0xfb, 0x32, 0xb4, 0xd5, 0x65, 0x10, 0x5e, 0x6a, 0x59, 0x19,
	0xca, 0xe5, 0x59, 0xa1, 0x1c, 0x5b, 0x37, 0x49, 0xbc, 0xc0, 0x66, 0x5f, 0x17, 0xf1, 0xd5, 0x78,
	0x02, 0x6f, 0x4d, 0x1d, 0xef, 0x06, 0xd3, 0xda, 0x83, 0xf7, 0x6c, 0xe2, 0xd3, 0x21, 0x11, 0xf8,
	0xdb, 0xf0, 0x90, 0x84, 0x2c, 0xb1, 0x67, 0x6c, 0x34, 0xb8, 0x81, 0xd1, 0x4f, 0xe1, 0x9d, 0xab,
	0xfd, 0xc4, 0x7e, 0x74, 0x98, 0x17, 0x56, 0x88, 0xdd, 0x64, 0xeb, 0x59, 0xab, 0x2c, 0xba, 0x09,
	0xd7, 0x98, 0xad, 0xea, 0x1b, 0xdf, 0x33, 0x30, 0x27, 0x20, 0xf4, 0x71, 0x62, 0x16, 0x5a, 0xbd,
	0xce, 0xa6, 0xa9, 0x1f, 0xa8, 0xca, 0xca, 0xdf, 0x85, 0x81, 0x77, 0x6a, 0x2c, 0xa0, 0x76, 0x72,
	0x31, 0xa8, 0x73, 0x8c, 0xea, 0xd7, 0x51, 0xd3, 0x59, 0xa9, 0x3c, 0x9e, 0x43, 0xa9, 0x16, 0xe0,
	0x70, 0xe9, 0x4f, 0x07, 0x90, 0x39, 0x8b, 0x9e, 0xe1, 0x7d, 0x65, 0x6d, 0x7e, 0x40, 0xae, 0x6a,
	0x69, 0x67, 0x17, 0xd5, 0x85, 0xf3, 0x8b, 0xea, 0xc2, 0xd9, 0x65, 0x15, 0x9c, 0x5f, 0x56, 0xc1,
	0xcf, 0xcb, 0x2a, 0xf8, 0x90, 0x19, 0x36, 0x3b, 0x05, 0xf9, 0xd7, 0xb6, 0xf9, 0x3b, 0x00, 0x00,
	0xff, 0xff, 0xca, 0x87, 0xda, 0x6f, 0x60, 0x07, 0x00, 0x00,
}
