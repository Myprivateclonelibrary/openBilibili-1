// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/ticket-item/api/grpc/v1/area.proto

/*
	Package v1 is a generated protocol buffer package.

	It is generated from these files:
		app/service/openplatform/ticket-item/api/grpc/v1/area.proto
		app/service/openplatform/ticket-item/api/grpc/v1/bulletin.proto
		app/service/openplatform/ticket-item/api/grpc/v1/guest.proto
		app/service/openplatform/ticket-item/api/grpc/v1/item.proto
		app/service/openplatform/ticket-item/api/grpc/v1/place.proto
		app/service/openplatform/ticket-item/api/grpc/v1/screen.proto
		app/service/openplatform/ticket-item/api/grpc/v1/seat.proto
		app/service/openplatform/ticket-item/api/grpc/v1/ticket.proto
		app/service/openplatform/ticket-item/api/grpc/v1/time.proto
		app/service/openplatform/ticket-item/api/grpc/v1/venue.proto

	It has these top-level messages:
		AreaInfo
		AreaInfoRequest
		AreaInfoReply
		DeleteAreaRequest
		DeleteAreaReply
		BulletinInfo
		BulletinInfoRequest
		BulletinCheckRequest
		BulletinStateRequest
		BulletinReply
		GuestInfoRequest
		GuestStatusRequest
		GuestInfoReply
		InfoRequest
		CardsRequest
		BillRequest
		InfoReply
		CardsReply
		CardReply
		BillReply
		ItemBase
		ItemExt
		ImgList
		BillOpt
		BuyNumLimit
		BnlLevel
		WishRequest
		WishReply
		FavRequest
		FavReply
		VersionRequest
		VersionReply
		BannerEditRequest
		BannerEditReply
		VersionReviewRequest
		VersionReviewReply
		VersionStatusRequest
		VersionStatusReply
		PlaceInfo
		PlaceInfoRequest
		PlaceInfoReply
		ScreenInfo
		AreaSeatInfo
		SeatInfoRequest
		SeatInfoReply
		SeatPrice
		SeatStockRequest
		SeatStockReply
		RemoveSeatOrdersRequest
		RemoveSeatOrdersReply
		TicketInfo
		TicketBuyNumLimit
		TicketStatus
		TicketPriceList
		ItemTime
		ScreenTime
		TicketTime
		VenueInfo
		VenueAddrInfo
		VenueInfoRequest
		VenueInfoReply
*/
package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// The response message containing the area info
type AreaInfo struct {
	ID           int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	AID          string `protobuf:"bytes,2,opt,name=a_id,json=aId,proto3" json:"a_id"`
	Name         string `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	SeatNum      int32  `protobuf:"varint,4,opt,name=seat_num,json=seatNum,proto3" json:"seat_num"`
	Width        int32  `protobuf:"varint,5,opt,name=width,proto3" json:"width"`
	Height       int32  `protobuf:"varint,6,opt,name=height,proto3" json:"height"`
	Place        int64  `protobuf:"varint,7,opt,name=place,proto3" json:"place"`
	ColStart     int32  `protobuf:"varint,8,opt,name=col_start,json=colStart,proto3" json:"col_start"`
	ColType      int32  `protobuf:"varint,9,opt,name=col_type,json=colType,proto3" json:"col_type"`
	ColDirection int32  `protobuf:"varint,10,opt,name=col_direction,json=colDirection,proto3" json:"col_direction"`
	RowList      string `protobuf:"bytes,11,opt,name=row_list,json=rowList,proto3" json:"row_list"`
	SeatStart    string `protobuf:"bytes,12,opt,name=seat_start,json=seatStart,proto3" json:"seat_start"`
}

func (m *AreaInfo) Reset()                    { *m = AreaInfo{} }
func (m *AreaInfo) String() string            { return proto.CompactTextString(m) }
func (*AreaInfo) ProtoMessage()               {}
func (*AreaInfo) Descriptor() ([]byte, []int) { return fileDescriptorArea, []int{0} }

// areaInfo接口请求
type AreaInfoRequest struct {
	// 待修改区域的ID（为0表示创建）
	ID int64 `protobuf:"varint,1,opt,name=ID,proto3" json:"id" validate:"min=0"`
	// 区域自定义编号
	AID string `protobuf:"bytes,2,opt,name=AID,proto3" json:"a_id" validate:"min=1,max=16"`
	// 区域名
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"name" validate:"min=1,max=16"`
	// 所属场地ID
	Place int64 `protobuf:"varint,4,opt,name=Place,proto3" json:"place" validate:"min=1"`
	// 区域坐标
	Coordinate string `protobuf:"bytes,5,opt,name=Coordinate,proto3" json:"coordinate" validate:"min=1"`
}

func (m *AreaInfoRequest) Reset()                    { *m = AreaInfoRequest{} }
func (m *AreaInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*AreaInfoRequest) ProtoMessage()               {}
func (*AreaInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorArea, []int{1} }

// areaInfo接口返回
type AreaInfoReply struct {
	// 操作结果
	Success bool `protobuf:"varint,1,opt,name=Success,proto3" json:"success"`
	// 操作区域ID
	ID int64 `protobuf:"varint,2,opt,name=ID,proto3" json:"id"`
	// 场地坐标
	Coordinate string `protobuf:"bytes,3,opt,name=Coordinate,proto3" json:"coordinate"`
}

func (m *AreaInfoReply) Reset()                    { *m = AreaInfoReply{} }
func (m *AreaInfoReply) String() string            { return proto.CompactTextString(m) }
func (*AreaInfoReply) ProtoMessage()               {}
func (*AreaInfoReply) Descriptor() ([]byte, []int) { return fileDescriptorArea, []int{2} }

// deleteArea接口请求
type DeleteAreaRequest struct {
	// 待删除区域的ID
	ID int64 `protobuf:"varint,1,opt,name=ID,proto3" json:"id" validate:"min=1"`
}

func (m *DeleteAreaRequest) Reset()                    { *m = DeleteAreaRequest{} }
func (m *DeleteAreaRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteAreaRequest) ProtoMessage()               {}
func (*DeleteAreaRequest) Descriptor() ([]byte, []int) { return fileDescriptorArea, []int{3} }

// deleteArea接口返回
type DeleteAreaReply struct {
	// 操作结果
	Success bool `protobuf:"varint,1,opt,name=Success,proto3" json:"success"`
}

func (m *DeleteAreaReply) Reset()                    { *m = DeleteAreaReply{} }
func (m *DeleteAreaReply) String() string            { return proto.CompactTextString(m) }
func (*DeleteAreaReply) ProtoMessage()               {}
func (*DeleteAreaReply) Descriptor() ([]byte, []int) { return fileDescriptorArea, []int{4} }

func init() {
	proto.RegisterType((*AreaInfo)(nil), "ticket.service.item.v1.AreaInfo")
	proto.RegisterType((*AreaInfoRequest)(nil), "ticket.service.item.v1.AreaInfoRequest")
	proto.RegisterType((*AreaInfoReply)(nil), "ticket.service.item.v1.AreaInfoReply")
	proto.RegisterType((*DeleteAreaRequest)(nil), "ticket.service.item.v1.DeleteAreaRequest")
	proto.RegisterType((*DeleteAreaReply)(nil), "ticket.service.item.v1.DeleteAreaReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Area service

type AreaClient interface {
	AreaInfo(ctx context.Context, in *AreaInfoRequest, opts ...grpc.CallOption) (*AreaInfoReply, error)
	DeleteArea(ctx context.Context, in *DeleteAreaRequest, opts ...grpc.CallOption) (*DeleteAreaReply, error)
}

type areaClient struct {
	cc *grpc.ClientConn
}

func NewAreaClient(cc *grpc.ClientConn) AreaClient {
	return &areaClient{cc}
}

func (c *areaClient) AreaInfo(ctx context.Context, in *AreaInfoRequest, opts ...grpc.CallOption) (*AreaInfoReply, error) {
	out := new(AreaInfoReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Area/AreaInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaClient) DeleteArea(ctx context.Context, in *DeleteAreaRequest, opts ...grpc.CallOption) (*DeleteAreaReply, error) {
	out := new(DeleteAreaReply)
	err := grpc.Invoke(ctx, "/ticket.service.item.v1.Area/DeleteArea", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Area service

type AreaServer interface {
	AreaInfo(context.Context, *AreaInfoRequest) (*AreaInfoReply, error)
	DeleteArea(context.Context, *DeleteAreaRequest) (*DeleteAreaReply, error)
}

func RegisterAreaServer(s *grpc.Server, srv AreaServer) {
	s.RegisterService(&_Area_serviceDesc, srv)
}

func _Area_AreaInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaServer).AreaInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Area/AreaInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaServer).AreaInfo(ctx, req.(*AreaInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Area_DeleteArea_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAreaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaServer).DeleteArea(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ticket.service.item.v1.Area/DeleteArea",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaServer).DeleteArea(ctx, req.(*DeleteAreaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Area_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ticket.service.item.v1.Area",
	HandlerType: (*AreaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AreaInfo",
			Handler:    _Area_AreaInfo_Handler,
		},
		{
			MethodName: "DeleteArea",
			Handler:    _Area_DeleteArea_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/openplatform/ticket-item/api/grpc/v1/area.proto",
}

func (m *AreaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AreaInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.ID))
	}
	if len(m.AID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintArea(dAtA, i, uint64(len(m.AID)))
		i += copy(dAtA[i:], m.AID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintArea(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.SeatNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.SeatNum))
	}
	if m.Width != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.Height))
	}
	if m.Place != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.Place))
	}
	if m.ColStart != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.ColStart))
	}
	if m.ColType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.ColType))
	}
	if m.ColDirection != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.ColDirection))
	}
	if len(m.RowList) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintArea(dAtA, i, uint64(len(m.RowList)))
		i += copy(dAtA[i:], m.RowList)
	}
	if len(m.SeatStart) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintArea(dAtA, i, uint64(len(m.SeatStart)))
		i += copy(dAtA[i:], m.SeatStart)
	}
	return i, nil
}

func (m *AreaInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AreaInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.ID))
	}
	if len(m.AID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintArea(dAtA, i, uint64(len(m.AID)))
		i += copy(dAtA[i:], m.AID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintArea(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Place != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.Place))
	}
	if len(m.Coordinate) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintArea(dAtA, i, uint64(len(m.Coordinate)))
		i += copy(dAtA[i:], m.Coordinate)
	}
	return i, nil
}

func (m *AreaInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AreaInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.ID))
	}
	if len(m.Coordinate) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintArea(dAtA, i, uint64(len(m.Coordinate)))
		i += copy(dAtA[i:], m.Coordinate)
	}
	return i, nil
}

func (m *DeleteAreaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAreaRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArea(dAtA, i, uint64(m.ID))
	}
	return i, nil
}

func (m *DeleteAreaReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAreaReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintArea(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AreaInfo) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovArea(uint64(m.ID))
	}
	l = len(m.AID)
	if l > 0 {
		n += 1 + l + sovArea(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovArea(uint64(l))
	}
	if m.SeatNum != 0 {
		n += 1 + sovArea(uint64(m.SeatNum))
	}
	if m.Width != 0 {
		n += 1 + sovArea(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovArea(uint64(m.Height))
	}
	if m.Place != 0 {
		n += 1 + sovArea(uint64(m.Place))
	}
	if m.ColStart != 0 {
		n += 1 + sovArea(uint64(m.ColStart))
	}
	if m.ColType != 0 {
		n += 1 + sovArea(uint64(m.ColType))
	}
	if m.ColDirection != 0 {
		n += 1 + sovArea(uint64(m.ColDirection))
	}
	l = len(m.RowList)
	if l > 0 {
		n += 1 + l + sovArea(uint64(l))
	}
	l = len(m.SeatStart)
	if l > 0 {
		n += 1 + l + sovArea(uint64(l))
	}
	return n
}

func (m *AreaInfoRequest) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovArea(uint64(m.ID))
	}
	l = len(m.AID)
	if l > 0 {
		n += 1 + l + sovArea(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovArea(uint64(l))
	}
	if m.Place != 0 {
		n += 1 + sovArea(uint64(m.Place))
	}
	l = len(m.Coordinate)
	if l > 0 {
		n += 1 + l + sovArea(uint64(l))
	}
	return n
}

func (m *AreaInfoReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.ID != 0 {
		n += 1 + sovArea(uint64(m.ID))
	}
	l = len(m.Coordinate)
	if l > 0 {
		n += 1 + l + sovArea(uint64(l))
	}
	return n
}

func (m *DeleteAreaRequest) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovArea(uint64(m.ID))
	}
	return n
}

func (m *DeleteAreaReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func sovArea(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozArea(x uint64) (n int) {
	return sovArea(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AreaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArea
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AreaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AreaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArea
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArea
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatNum", wireType)
			}
			m.SeatNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Place", wireType)
			}
			m.Place = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Place |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColStart", wireType)
			}
			m.ColStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColStart |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColType", wireType)
			}
			m.ColType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColDirection", wireType)
			}
			m.ColDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColDirection |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArea
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArea
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeatStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArea(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArea
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AreaInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArea
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AreaInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AreaInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArea
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArea
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Place", wireType)
			}
			m.Place = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Place |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArea
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArea(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArea
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AreaInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArea
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AreaInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AreaInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArea
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArea(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArea
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAreaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArea
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAreaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAreaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArea(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArea
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAreaReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArea
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAreaReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAreaReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArea
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipArea(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArea
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipArea(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowArea
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArea
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArea
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthArea
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowArea
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipArea(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthArea = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowArea   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/ticket-item/api/grpc/v1/area.proto", fileDescriptorArea)
}

var fileDescriptorArea = []byte{
	// 706 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xdd, 0x4e, 0xe3, 0x46,
	0x14, 0xc6, 0xce, 0xff, 0x10, 0x4a, 0x99, 0x0b, 0x6a, 0x45, 0x34, 0x46, 0x46, 0x08, 0x8a, 0x8a,
	0xdd, 0x14, 0x95, 0x56, 0xad, 0x50, 0x45, 0x9a, 0x9b, 0x48, 0x15, 0x5a, 0x0d, 0x7b, 0xb5, 0x5a,
	0x29, 0x9a, 0xd8, 0x43, 0x32, 0x5a, 0x3b, 0xe3, 0xb5, 0x27, 0x61, 0x73, 0xb3, 0x8f, 0xb3, 0xcf,
	0xc2, 0x25, 0x4f, 0x60, 0x2d, 0xb9, 0xf4, 0x25, 0x4f, 0xb0, 0x9a, 0xe3, 0x98, 0x24, 0x0b, 0xbb,
	0xcb, 0xde, 0x64, 0x66, 0xbe, 0xf9, 0xce, 0x39, 0x9f, 0xcf, 0x77, 0x32, 0xe8, 0x1f, 0x1a, 0x86,
	0x4e, 0xcc, 0xa2, 0x09, 0x77, 0x99, 0x23, 0x42, 0x36, 0x0a, 0x7d, 0x2a, 0xaf, 0x44, 0x14, 0x38,
	0x92, 0xbb, 0x6f, 0x98, 0x3c, 0xe6, 0x92, 0x05, 0x0e, 0x0d, 0xb9, 0x33, 0x88, 0x42, 0xd7, 0x99,
	0xb4, 0x1c, 0x1a, 0x31, 0x6a, 0x87, 0x91, 0x90, 0x02, 0x6f, 0x67, 0x1c, 0x7b, 0x1e, 0x6f, 0x2b,
	0xae, 0x3d, 0x69, 0x35, 0x8e, 0x07, 0x5c, 0x0e, 0xc7, 0x7d, 0xdb, 0x15, 0x81, 0x33, 0x10, 0x03,
	0xe1, 0x00, 0xbd, 0x3f, 0xbe, 0x82, 0x13, 0x1c, 0x60, 0x97, 0xa5, 0xb1, 0x92, 0x02, 0xaa, 0x9e,
	0x47, 0x8c, 0x76, 0x47, 0x57, 0x02, 0xef, 0x20, 0x9d, 0x7b, 0x86, 0xb6, 0xab, 0x1d, 0x16, 0xda,
	0xf5, 0x59, 0x62, 0xea, 0xdd, 0x4e, 0x9a, 0x98, 0x3a, 0xf7, 0x88, 0xce, 0x3d, 0x6c, 0xa1, 0x22,
	0xed, 0x71, 0xcf, 0xd0, 0x77, 0xb5, 0xc3, 0x5a, 0x7b, 0x73, 0x96, 0x98, 0x85, 0x73, 0x20, 0x00,
	0x4c, 0x0a, 0xb4, 0xeb, 0xe1, 0x1d, 0x54, 0x1c, 0xd1, 0x80, 0x19, 0x05, 0xe0, 0x54, 0xd5, 0xa5,
	0x3a, 0x13, 0xf8, 0xc5, 0x07, 0xa8, 0x1a, 0x33, 0x2a, 0x7b, 0xa3, 0x71, 0x60, 0x14, 0x77, 0xb5,
	0xc3, 0x52, 0xbb, 0x9e, 0x26, 0xe6, 0x03, 0x46, 0x2a, 0x6a, 0x77, 0x31, 0x0e, 0xb0, 0x89, 0x4a,
	0xd7, 0xdc, 0x93, 0x43, 0xa3, 0x04, 0xac, 0x5a, 0x9a, 0x98, 0x19, 0x40, 0xb2, 0x05, 0x5b, 0xa8,
	0x3c, 0x64, 0x7c, 0x30, 0x94, 0x46, 0x19, 0x18, 0x28, 0x4d, 0xcc, 0x39, 0x42, 0xe6, 0xab, 0x4a,
	0x12, 0xfa, 0xd4, 0x65, 0x46, 0x05, 0x3e, 0x08, 0x92, 0x00, 0x40, 0xb2, 0x05, 0x1f, 0xa1, 0x9a,
	0x2b, 0xfc, 0x5e, 0x2c, 0x69, 0x24, 0x8d, 0x2a, 0xe4, 0xd9, 0x48, 0x13, 0x73, 0x01, 0x92, 0xaa,
	0x2b, 0xfc, 0x4b, 0xb5, 0x53, 0xd2, 0x15, 0x2c, 0xa7, 0x21, 0x33, 0x6a, 0x0b, 0xe9, 0x39, 0x46,
	0x2a, 0xae, 0xf0, 0x5f, 0x4e, 0x43, 0x86, 0x4f, 0xd1, 0x86, 0x02, 0x3d, 0x1e, 0x31, 0x57, 0x72,
	0x31, 0x32, 0x10, 0xb0, 0xb7, 0xd2, 0xc4, 0x5c, 0xbd, 0x20, 0x75, 0x57, 0xf8, 0x9d, 0xfc, 0xa4,
	0x0a, 0x44, 0xe2, 0xba, 0xe7, 0xf3, 0x58, 0x1a, 0xeb, 0xd0, 0x3d, 0x28, 0x90, 0x63, 0xa4, 0x12,
	0x89, 0xeb, 0xff, 0x79, 0x2c, 0xf1, 0x31, 0x42, 0xd0, 0xb0, 0x4c, 0x76, 0x1d, 0xa8, 0x3f, 0xa4,
	0x89, 0xb9, 0x84, 0x92, 0x9a, 0xda, 0x83, 0x70, 0xeb, 0x83, 0x8e, 0x36, 0x73, 0x83, 0x09, 0x7b,
	0x3b, 0x66, 0xb1, 0xc4, 0x47, 0x48, 0xef, 0x76, 0xe6, 0x3e, 0x37, 0x32, 0x87, 0xef, 0x13, 0xf3,
	0xc7, 0x09, 0xf5, 0xb9, 0x47, 0x25, 0xfb, 0xdb, 0x0a, 0xf8, 0xe8, 0xec, 0x37, 0x8b, 0xe8, 0xdd,
	0x0e, 0xfe, 0x03, 0x29, 0x97, 0xe7, 0xa6, 0xef, 0xe5, 0x6e, 0xdf, 0x27, 0xe6, 0x4f, 0xab, 0xf4,
	0xd6, 0xaf, 0x01, 0x7d, 0x77, 0xd6, 0x3a, 0xb5, 0x88, 0xe2, 0xe3, 0x3f, 0x51, 0xf1, 0x62, 0x31,
	0x08, 0x7b, 0xf9, 0x20, 0x7c, 0x2d, 0x0e, 0x02, 0xf0, 0x09, 0x2a, 0xbd, 0x00, 0xd7, 0x8a, 0x20,
	0xef, 0xe7, 0x07, 0xd7, 0x1e, 0x2b, 0x6c, 0x59, 0x24, 0xe3, 0xe2, 0x36, 0x42, 0xff, 0x09, 0x11,
	0x79, 0x7c, 0x44, 0x25, 0x83, 0xa1, 0xa9, 0xb5, 0x2d, 0xd5, 0x13, 0xf7, 0x01, 0x7d, 0x32, 0x7c,
	0x29, 0xca, 0x7a, 0x8f, 0x36, 0x16, 0x7d, 0x0a, 0xfd, 0x29, 0xde, 0x47, 0x95, 0xcb, 0xb1, 0xeb,
	0xb2, 0x38, 0x86, 0x56, 0x55, 0xdb, 0xeb, 0x69, 0x62, 0x56, 0xe2, 0x0c, 0x22, 0xf9, 0x1d, 0xde,
	0x86, 0x66, 0xea, 0xa0, 0xb6, 0x9c, 0xff, 0x5d, 0xba, 0x1d, 0x6c, 0xaf, 0x68, 0x2a, 0x2c, 0x7c,
	0x5a, 0x68, 0x5a, 0xa9, 0xff, 0x2f, 0xda, 0xea, 0x30, 0x9f, 0x49, 0xa6, 0x54, 0x7c, 0x97, 0x53,
	0x2d, 0x70, 0xca, 0xfa, 0x0b, 0x6d, 0x2e, 0x27, 0x78, 0xfe, 0x27, 0xfc, 0x7e, 0xa3, 0xa1, 0xa2,
	0x0a, 0xc2, 0xaf, 0x97, 0x1e, 0x83, 0x03, 0xfb, 0xe9, 0x17, 0xc6, 0xfe, 0x6c, 0x9a, 0x1a, 0xfb,
	0xdf, 0x26, 0x86, 0xfe, 0xd4, 0x5a, 0xc3, 0x7d, 0x84, 0x16, 0x02, 0xf1, 0x2f, 0x5f, 0x0a, 0x7b,
	0xd4, 0x85, 0xc6, 0xc1, 0x73, 0xa8, 0x50, 0xa3, 0x6d, 0xdc, 0xdc, 0x35, 0xd7, 0x6e, 0xef, 0x9a,
	0x6b, 0x37, 0xb3, 0xa6, 0x76, 0x3b, 0x6b, 0x6a, 0x1f, 0x67, 0x4d, 0xed, 0x95, 0x3e, 0x69, 0xf5,
	0xcb, 0xf0, 0xe0, 0x9d, 0x7c, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x46, 0xa4, 0xbd, 0x11, 0x76, 0x05,
	0x00, 0x00,
}
