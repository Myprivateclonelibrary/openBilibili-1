// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/pgc-season/api/grpc/episode/v1/service.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// EpisodeInfoReq ep request param
type EpisodeInfoReq struct {
	// episode_ids
	EpisodeIds []int32 `protobuf:"varint,1,rep,packed,name=episode_ids,json=episodeIds" json:"episode_ids,omitempty"`
}

func (m *EpisodeInfoReq) Reset()                    { *m = EpisodeInfoReq{} }
func (m *EpisodeInfoReq) String() string            { return proto.CompactTextString(m) }
func (*EpisodeInfoReq) ProtoMessage()               {}
func (*EpisodeInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{0} }

func (m *EpisodeInfoReq) GetEpisodeIds() []int32 {
	if m != nil {
		return m.EpisodeIds
	}
	return nil
}

// EpAidReq aids request param
type EpAidReq struct {
	// aids
	Aids []int32 `protobuf:"varint,1,rep,packed,name=aids" json:"aids,omitempty"`
}

func (m *EpAidReq) Reset()                    { *m = EpAidReq{} }
func (m *EpAidReq) String() string            { return proto.CompactTextString(m) }
func (*EpAidReq) ProtoMessage()               {}
func (*EpAidReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{1} }

func (m *EpAidReq) GetAids() []int32 {
	if m != nil {
		return m.Aids
	}
	return nil
}

// EpisodeInfoReply ep response
type EpisodeInfoReply struct {
	// infos
	Infos map[int32]*EpisodeInfoProto `protobuf:"bytes,1,rep,name=infos" json:"infos,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EpisodeInfoReply) Reset()                    { *m = EpisodeInfoReply{} }
func (m *EpisodeInfoReply) String() string            { return proto.CompactTextString(m) }
func (*EpisodeInfoReply) ProtoMessage()               {}
func (*EpisodeInfoReply) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{2} }

func (m *EpisodeInfoReply) GetInfos() map[int32]*EpisodeInfoProto {
	if m != nil {
		return m.Infos
	}
	return nil
}

// EpisodeCardsReply cards
type EpisodeCardsReply struct {
	// cards
	Cards map[int32]*EpisodeCardsProto `protobuf:"bytes,1,rep,name=cards" json:"cards,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EpisodeCardsReply) Reset()                    { *m = EpisodeCardsReply{} }
func (m *EpisodeCardsReply) String() string            { return proto.CompactTextString(m) }
func (*EpisodeCardsReply) ProtoMessage()               {}
func (*EpisodeCardsReply) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{3} }

func (m *EpisodeCardsReply) GetCards() map[int32]*EpisodeCardsProto {
	if m != nil {
		return m.Cards
	}
	return nil
}

// EpReq epids请求参数
type EpReq struct {
	// aids
	Epids []int32 `protobuf:"varint,1,rep,packed,name=epids" json:"epids,omitempty"`
	// 是否要查出下架的 默认0
	NeedAll int32 `protobuf:"varint,2,opt,name=need_all,json=needAll,proto3" json:"need_all,omitempty"`
}

func (m *EpReq) Reset()                    { *m = EpReq{} }
func (m *EpReq) String() string            { return proto.CompactTextString(m) }
func (*EpReq) ProtoMessage()               {}
func (*EpReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{4} }

func (m *EpReq) GetEpids() []int32 {
	if m != nil {
		return m.Epids
	}
	return nil
}

func (m *EpReq) GetNeedAll() int32 {
	if m != nil {
		return m.NeedAll
	}
	return 0
}

// SectionEeq 请求参数
type SectionEpisodeReq struct {
	// sections
	Sections []int32 `protobuf:"varint,1,rep,packed,name=sections" json:"sections,omitempty"`
	// season_type
	SeasonType int32 `protobuf:"varint,2,opt,name=season_type,json=seasonType,proto3" json:"season_type,omitempty"`
}

func (m *SectionEpisodeReq) Reset()                    { *m = SectionEpisodeReq{} }
func (m *SectionEpisodeReq) String() string            { return proto.CompactTextString(m) }
func (*SectionEpisodeReq) ProtoMessage()               {}
func (*SectionEpisodeReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{5} }

func (m *SectionEpisodeReq) GetSections() []int32 {
	if m != nil {
		return m.Sections
	}
	return nil
}

func (m *SectionEpisodeReq) GetSeasonType() int32 {
	if m != nil {
		return m.SeasonType
	}
	return 0
}

// SectionReply 分节eps
type SectionEpisodeReply struct {
	// infos
	Episodes map[int32]*SectionEpisodeProto `protobuf:"bytes,1,rep,name=episodes" json:"episodes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SectionEpisodeReply) Reset()                    { *m = SectionEpisodeReply{} }
func (m *SectionEpisodeReply) String() string            { return proto.CompactTextString(m) }
func (*SectionEpisodeReply) ProtoMessage()               {}
func (*SectionEpisodeReply) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{6} }

func (m *SectionEpisodeReply) GetEpisodes() map[int32]*SectionEpisodeProto {
	if m != nil {
		return m.Episodes
	}
	return nil
}

// EpClearReq ClearCache请求参数
type EpClearReq struct {
	// ep_id
	EpId int32 `protobuf:"varint,1,opt,name=ep_id,json=epId,proto3" json:"ep_id,omitempty"`
	// aid
	Aid int32 `protobuf:"varint,2,opt,name=aid,proto3" json:"aid,omitempty"`
}

func (m *EpClearReq) Reset()                    { *m = EpClearReq{} }
func (m *EpClearReq) String() string            { return proto.CompactTextString(m) }
func (*EpClearReq) ProtoMessage()               {}
func (*EpClearReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{7} }

func (m *EpClearReq) GetEpId() int32 {
	if m != nil {
		return m.EpId
	}
	return 0
}

func (m *EpClearReq) GetAid() int32 {
	if m != nil {
		return m.Aid
	}
	return 0
}

// EpisodeBadgeReq 请求参数
type EpisodeBadgeReq struct {
	// ep_id
	EpId int32 `protobuf:"varint,1,opt,name=ep_id,json=epId,proto3" json:"ep_id,omitempty"`
	// ep_status
	EpStatus int32 `protobuf:"varint,2,opt,name=ep_status,json=epStatus,proto3" json:"ep_status,omitempty"`
	// is_finished
	IsFinished int32 `protobuf:"varint,3,opt,name=is_finished,json=isFinished,proto3" json:"is_finished,omitempty"`
}

func (m *EpisodeBadgeReq) Reset()                    { *m = EpisodeBadgeReq{} }
func (m *EpisodeBadgeReq) String() string            { return proto.CompactTextString(m) }
func (*EpisodeBadgeReq) ProtoMessage()               {}
func (*EpisodeBadgeReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{8} }

func (m *EpisodeBadgeReq) GetEpId() int32 {
	if m != nil {
		return m.EpId
	}
	return 0
}

func (m *EpisodeBadgeReq) GetEpStatus() int32 {
	if m != nil {
		return m.EpStatus
	}
	return 0
}

func (m *EpisodeBadgeReq) GetIsFinished() int32 {
	if m != nil {
		return m.IsFinished
	}
	return 0
}

// EpisodeBadgesReq 请求参数
type EpisodeBadgesReq struct {
	EpisodeBadges []*EpisodeBadgeReq `protobuf:"bytes,1,rep,name=episode_badges,json=episodeBadges" json:"episode_badges,omitempty"`
}

func (m *EpisodeBadgesReq) Reset()                    { *m = EpisodeBadgesReq{} }
func (m *EpisodeBadgesReq) String() string            { return proto.CompactTextString(m) }
func (*EpisodeBadgesReq) ProtoMessage()               {}
func (*EpisodeBadgesReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{9} }

func (m *EpisodeBadgesReq) GetEpisodeBadges() []*EpisodeBadgeReq {
	if m != nil {
		return m.EpisodeBadges
	}
	return nil
}

// EpisodeBadgesReply .
type EpisodeBadgesReply struct {
	Badges map[int32]*EpisodeBadgeProto `protobuf:"bytes,1,rep,name=badges" json:"badges,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EpisodeBadgesReply) Reset()                    { *m = EpisodeBadgesReply{} }
func (m *EpisodeBadgesReply) String() string            { return proto.CompactTextString(m) }
func (*EpisodeBadgesReply) ProtoMessage()               {}
func (*EpisodeBadgesReply) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{10} }

func (m *EpisodeBadgesReply) GetBadges() map[int32]*EpisodeBadgeProto {
	if m != nil {
		return m.Badges
	}
	return nil
}

func init() {
	proto.RegisterType((*EpisodeInfoReq)(nil), "pgc.service.season.episode.v1.EpisodeInfoReq")
	proto.RegisterType((*EpAidReq)(nil), "pgc.service.season.episode.v1.EpAidReq")
	proto.RegisterType((*EpisodeInfoReply)(nil), "pgc.service.season.episode.v1.EpisodeInfoReply")
	proto.RegisterType((*EpisodeCardsReply)(nil), "pgc.service.season.episode.v1.EpisodeCardsReply")
	proto.RegisterType((*EpReq)(nil), "pgc.service.season.episode.v1.EpReq")
	proto.RegisterType((*SectionEpisodeReq)(nil), "pgc.service.season.episode.v1.SectionEpisodeReq")
	proto.RegisterType((*SectionEpisodeReply)(nil), "pgc.service.season.episode.v1.SectionEpisodeReply")
	proto.RegisterType((*EpClearReq)(nil), "pgc.service.season.episode.v1.EpClearReq")
	proto.RegisterType((*EpisodeBadgeReq)(nil), "pgc.service.season.episode.v1.EpisodeBadgeReq")
	proto.RegisterType((*EpisodeBadgesReq)(nil), "pgc.service.season.episode.v1.EpisodeBadgesReq")
	proto.RegisterType((*EpisodeBadgesReply)(nil), "pgc.service.season.episode.v1.EpisodeBadgesReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Episode service

type EpisodeClient interface {
	// 根据ep_ids 返回ep详情
	List(ctx context.Context, in *EpisodeInfoReq, opts ...grpc.CallOption) (*EpisodeInfoReply, error)
	// 根据aids 返回ep详情
	ListByAids(ctx context.Context, in *EpAidReq, opts ...grpc.CallOption) (*EpisodeInfoReply, error)
	// 根据section返回eps
	ListBySection(ctx context.Context, in *SectionEpisodeReq, opts ...grpc.CallOption) (*SectionEpisodeReply, error)
	// 根据epid返回season,episode基本信息
	Cards(ctx context.Context, in *EpReq, opts ...grpc.CallOption) (*EpisodeCardsReply, error)
	// 根据ep_id or aid清除mc缓存
	ClearCache(ctx context.Context, in *EpClearReq, opts ...grpc.CallOption) (*EmptyProto, error)
	// 根据ep_ids 返回ep对应的badge
	Badges(ctx context.Context, in *EpisodeBadgesReq, opts ...grpc.CallOption) (*EpisodeBadgesReply, error)
	// 根据aids 返回ep对应的EpisodeCards
	CardsByAids(ctx context.Context, in *EpAidReq, opts ...grpc.CallOption) (*EpisodeCardsReply, error)
}

type episodeClient struct {
	cc *grpc.ClientConn
}

func NewEpisodeClient(cc *grpc.ClientConn) EpisodeClient {
	return &episodeClient{cc}
}

func (c *episodeClient) List(ctx context.Context, in *EpisodeInfoReq, opts ...grpc.CallOption) (*EpisodeInfoReply, error) {
	out := new(EpisodeInfoReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.episode.v1.Episode/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *episodeClient) ListByAids(ctx context.Context, in *EpAidReq, opts ...grpc.CallOption) (*EpisodeInfoReply, error) {
	out := new(EpisodeInfoReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.episode.v1.Episode/ListByAids", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *episodeClient) ListBySection(ctx context.Context, in *SectionEpisodeReq, opts ...grpc.CallOption) (*SectionEpisodeReply, error) {
	out := new(SectionEpisodeReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.episode.v1.Episode/ListBySection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *episodeClient) Cards(ctx context.Context, in *EpReq, opts ...grpc.CallOption) (*EpisodeCardsReply, error) {
	out := new(EpisodeCardsReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.episode.v1.Episode/Cards", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *episodeClient) ClearCache(ctx context.Context, in *EpClearReq, opts ...grpc.CallOption) (*EmptyProto, error) {
	out := new(EmptyProto)
	err := grpc.Invoke(ctx, "/pgc.service.season.episode.v1.Episode/ClearCache", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *episodeClient) Badges(ctx context.Context, in *EpisodeBadgesReq, opts ...grpc.CallOption) (*EpisodeBadgesReply, error) {
	out := new(EpisodeBadgesReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.episode.v1.Episode/Badges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *episodeClient) CardsByAids(ctx context.Context, in *EpAidReq, opts ...grpc.CallOption) (*EpisodeCardsReply, error) {
	out := new(EpisodeCardsReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.episode.v1.Episode/CardsByAids", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Episode service

type EpisodeServer interface {
	// 根据ep_ids 返回ep详情
	List(context.Context, *EpisodeInfoReq) (*EpisodeInfoReply, error)
	// 根据aids 返回ep详情
	ListByAids(context.Context, *EpAidReq) (*EpisodeInfoReply, error)
	// 根据section返回eps
	ListBySection(context.Context, *SectionEpisodeReq) (*SectionEpisodeReply, error)
	// 根据epid返回season,episode基本信息
	Cards(context.Context, *EpReq) (*EpisodeCardsReply, error)
	// 根据ep_id or aid清除mc缓存
	ClearCache(context.Context, *EpClearReq) (*EmptyProto, error)
	// 根据ep_ids 返回ep对应的badge
	Badges(context.Context, *EpisodeBadgesReq) (*EpisodeBadgesReply, error)
	// 根据aids 返回ep对应的EpisodeCards
	CardsByAids(context.Context, *EpAidReq) (*EpisodeCardsReply, error)
}

func RegisterEpisodeServer(s *grpc.Server, srv EpisodeServer) {
	s.RegisterService(&_Episode_serviceDesc, srv)
}

func _Episode_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpisodeInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EpisodeServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.episode.v1.Episode/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EpisodeServer).List(ctx, req.(*EpisodeInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Episode_ListByAids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpAidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EpisodeServer).ListByAids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.episode.v1.Episode/ListByAids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EpisodeServer).ListByAids(ctx, req.(*EpAidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Episode_ListBySection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SectionEpisodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EpisodeServer).ListBySection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.episode.v1.Episode/ListBySection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EpisodeServer).ListBySection(ctx, req.(*SectionEpisodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Episode_Cards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EpisodeServer).Cards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.episode.v1.Episode/Cards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EpisodeServer).Cards(ctx, req.(*EpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Episode_ClearCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpClearReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EpisodeServer).ClearCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.episode.v1.Episode/ClearCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EpisodeServer).ClearCache(ctx, req.(*EpClearReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Episode_Badges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpisodeBadgesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EpisodeServer).Badges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.episode.v1.Episode/Badges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EpisodeServer).Badges(ctx, req.(*EpisodeBadgesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Episode_CardsByAids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpAidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EpisodeServer).CardsByAids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.episode.v1.Episode/CardsByAids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EpisodeServer).CardsByAids(ctx, req.(*EpAidReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Episode_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pgc.service.season.episode.v1.Episode",
	HandlerType: (*EpisodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Episode_List_Handler,
		},
		{
			MethodName: "ListByAids",
			Handler:    _Episode_ListByAids_Handler,
		},
		{
			MethodName: "ListBySection",
			Handler:    _Episode_ListBySection_Handler,
		},
		{
			MethodName: "Cards",
			Handler:    _Episode_Cards_Handler,
		},
		{
			MethodName: "ClearCache",
			Handler:    _Episode_ClearCache_Handler,
		},
		{
			MethodName: "Badges",
			Handler:    _Episode_Badges_Handler,
		},
		{
			MethodName: "CardsByAids",
			Handler:    _Episode_CardsByAids_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/openplatform/pgc-season/api/grpc/episode/v1/service.proto",
}

func (m *EpisodeInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EpisodeIds) > 0 {
		dAtA2 := make([]byte, len(m.EpisodeIds)*10)
		var j1 int
		for _, num1 := range m.EpisodeIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintService(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *EpAidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpAidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Aids) > 0 {
		dAtA4 := make([]byte, len(m.Aids)*10)
		var j3 int
		for _, num1 := range m.Aids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintService(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *EpisodeInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for k, _ := range m.Infos {
			dAtA[i] = 0xa
			i++
			v := m.Infos[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovService(uint64(msgSize))
			}
			mapSize := 1 + sovService(uint64(k)) + msgSize
			i = encodeVarintService(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintService(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintService(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	return i, nil
}

func (m *EpisodeCardsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeCardsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for k, _ := range m.Cards {
			dAtA[i] = 0xa
			i++
			v := m.Cards[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovService(uint64(msgSize))
			}
			mapSize := 1 + sovService(uint64(k)) + msgSize
			i = encodeVarintService(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintService(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintService(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	return i, nil
}

func (m *EpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Epids) > 0 {
		dAtA8 := make([]byte, len(m.Epids)*10)
		var j7 int
		for _, num1 := range m.Epids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintService(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.NeedAll != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintService(dAtA, i, uint64(m.NeedAll))
	}
	return i, nil
}

func (m *SectionEpisodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionEpisodeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sections) > 0 {
		dAtA10 := make([]byte, len(m.Sections)*10)
		var j9 int
		for _, num1 := range m.Sections {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintService(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if m.SeasonType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintService(dAtA, i, uint64(m.SeasonType))
	}
	return i, nil
}

func (m *SectionEpisodeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionEpisodeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Episodes) > 0 {
		for k, _ := range m.Episodes {
			dAtA[i] = 0xa
			i++
			v := m.Episodes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovService(uint64(msgSize))
			}
			mapSize := 1 + sovService(uint64(k)) + msgSize
			i = encodeVarintService(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintService(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintService(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	return i, nil
}

func (m *EpClearReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpClearReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EpId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintService(dAtA, i, uint64(m.EpId))
	}
	if m.Aid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintService(dAtA, i, uint64(m.Aid))
	}
	return i, nil
}

func (m *EpisodeBadgeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeBadgeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EpId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintService(dAtA, i, uint64(m.EpId))
	}
	if m.EpStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintService(dAtA, i, uint64(m.EpStatus))
	}
	if m.IsFinished != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintService(dAtA, i, uint64(m.IsFinished))
	}
	return i, nil
}

func (m *EpisodeBadgesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeBadgesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EpisodeBadges) > 0 {
		for _, msg := range m.EpisodeBadges {
			dAtA[i] = 0xa
			i++
			i = encodeVarintService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EpisodeBadgesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeBadgesReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Badges) > 0 {
		for k, _ := range m.Badges {
			dAtA[i] = 0xa
			i++
			v := m.Badges[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovService(uint64(msgSize))
			}
			mapSize := 1 + sovService(uint64(k)) + msgSize
			i = encodeVarintService(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintService(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintService(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	return i, nil
}

func encodeVarintService(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EpisodeInfoReq) Size() (n int) {
	var l int
	_ = l
	if len(m.EpisodeIds) > 0 {
		l = 0
		for _, e := range m.EpisodeIds {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	return n
}

func (m *EpAidReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Aids) > 0 {
		l = 0
		for _, e := range m.Aids {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	return n
}

func (m *EpisodeInfoReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for k, v := range m.Infos {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovService(uint64(l))
			}
			mapEntrySize := 1 + sovService(uint64(k)) + l
			n += mapEntrySize + 1 + sovService(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EpisodeCardsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for k, v := range m.Cards {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovService(uint64(l))
			}
			mapEntrySize := 1 + sovService(uint64(k)) + l
			n += mapEntrySize + 1 + sovService(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EpReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Epids) > 0 {
		l = 0
		for _, e := range m.Epids {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	if m.NeedAll != 0 {
		n += 1 + sovService(uint64(m.NeedAll))
	}
	return n
}

func (m *SectionEpisodeReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Sections) > 0 {
		l = 0
		for _, e := range m.Sections {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	if m.SeasonType != 0 {
		n += 1 + sovService(uint64(m.SeasonType))
	}
	return n
}

func (m *SectionEpisodeReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Episodes) > 0 {
		for k, v := range m.Episodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovService(uint64(l))
			}
			mapEntrySize := 1 + sovService(uint64(k)) + l
			n += mapEntrySize + 1 + sovService(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EpClearReq) Size() (n int) {
	var l int
	_ = l
	if m.EpId != 0 {
		n += 1 + sovService(uint64(m.EpId))
	}
	if m.Aid != 0 {
		n += 1 + sovService(uint64(m.Aid))
	}
	return n
}

func (m *EpisodeBadgeReq) Size() (n int) {
	var l int
	_ = l
	if m.EpId != 0 {
		n += 1 + sovService(uint64(m.EpId))
	}
	if m.EpStatus != 0 {
		n += 1 + sovService(uint64(m.EpStatus))
	}
	if m.IsFinished != 0 {
		n += 1 + sovService(uint64(m.IsFinished))
	}
	return n
}

func (m *EpisodeBadgesReq) Size() (n int) {
	var l int
	_ = l
	if len(m.EpisodeBadges) > 0 {
		for _, e := range m.EpisodeBadges {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *EpisodeBadgesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Badges) > 0 {
		for k, v := range m.Badges {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovService(uint64(l))
			}
			mapEntrySize := 1 + sovService(uint64(k)) + l
			n += mapEntrySize + 1 + sovService(uint64(mapEntrySize))
		}
	}
	return n
}

func sovService(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozService(x uint64) (n int) {
	return sovService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EpisodeInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EpisodeIds = append(m.EpisodeIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EpisodeIds = append(m.EpisodeIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EpisodeIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpAidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpAidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpAidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Aids = append(m.Aids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Aids = append(m.Aids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Aids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpisodeInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infos == nil {
				m.Infos = make(map[int32]*EpisodeInfoProto)
			}
			var mapkey int32
			var mapvalue *EpisodeInfoProto
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EpisodeInfoProto{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Infos[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpisodeCardsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeCardsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeCardsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cards == nil {
				m.Cards = make(map[int32]*EpisodeCardsProto)
			}
			var mapkey int32
			var mapvalue *EpisodeCardsProto
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EpisodeCardsProto{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Cards[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Epids = append(m.Epids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Epids = append(m.Epids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Epids", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedAll", wireType)
			}
			m.NeedAll = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedAll |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionEpisodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionEpisodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionEpisodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sections = append(m.Sections, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sections = append(m.Sections, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sections", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonType", wireType)
			}
			m.SeasonType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionEpisodeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionEpisodeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionEpisodeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Episodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Episodes == nil {
				m.Episodes = make(map[int32]*SectionEpisodeProto)
			}
			var mapkey int32
			var mapvalue *SectionEpisodeProto
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SectionEpisodeProto{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Episodes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpClearReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpClearReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpClearReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpId", wireType)
			}
			m.EpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpisodeBadgeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeBadgeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeBadgeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpId", wireType)
			}
			m.EpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpStatus", wireType)
			}
			m.EpStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFinished", wireType)
			}
			m.IsFinished = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFinished |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpisodeBadgesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeBadgesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeBadgesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpisodeBadges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpisodeBadges = append(m.EpisodeBadges, &EpisodeBadgeReq{})
			if err := m.EpisodeBadges[len(m.EpisodeBadges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpisodeBadgesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeBadgesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeBadgesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Badges == nil {
				m.Badges = make(map[int32]*EpisodeBadgeProto)
			}
			var mapkey int32
			var mapvalue *EpisodeBadgeProto
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EpisodeBadgeProto{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Badges[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthService
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowService
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipService(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthService = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowService   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/pgc-season/api/grpc/episode/v1/service.proto", fileDescriptorService)
}

var fileDescriptorService = []byte{
	// 728 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x4f, 0xd4, 0x40,
	0x14, 0x4e, 0x81, 0xc2, 0xfa, 0x36, 0x20, 0x0c, 0x1e, 0xd6, 0x1a, 0x57, 0xd2, 0x98, 0x88, 0x31,
	0xb4, 0xec, 0x72, 0x21, 0x18, 0xa3, 0xb0, 0x59, 0x22, 0x89, 0x87, 0xb5, 0xc8, 0xc5, 0x98, 0x34,
	0xb3, 0x9d, 0xd9, 0x65, 0xa4, 0xb4, 0xb3, 0x9d, 0xee, 0x26, 0xfd, 0x0f, 0xbd, 0x69, 0x3c, 0x79,
	0x34, 0xc4, 0xab, 0xff, 0x83, 0x99, 0xce, 0x94, 0x65, 0x17, 0x70, 0xa9, 0xf1, 0x36, 0xf3, 0xfa,
	0xde, 0xf7, 0xcd, 0xfb, 0xde, 0x8f, 0x14, 0xda, 0x98, 0x73, 0x57, 0xd0, 0x64, 0xc4, 0x02, 0xea,
	0xc6, 0x9c, 0x46, 0x3c, 0xc4, 0x69, 0x2f, 0x4e, 0xce, 0x5d, 0xde, 0x0f, 0xb6, 0x04, 0xc5, 0x22,
	0x8e, 0x5c, 0xcc, 0x99, 0xdb, 0x4f, 0x78, 0xe0, 0x52, 0xce, 0x44, 0x4c, 0xa8, 0x3b, 0x6a, 0x14,
	0x31, 0x0e, 0x4f, 0xe2, 0x34, 0x46, 0x8f, 0x79, 0x3f, 0x70, 0x0a, 0x93, 0x8a, 0x72, 0xb4, 0xb3,
	0x33, 0x6a, 0x58, 0xad, 0x7f, 0x65, 0x39, 0x8f, 0x09, 0x0d, 0x15, 0x87, 0xdd, 0x80, 0x95, 0xb6,
	0xfa, 0x72, 0x14, 0xf5, 0x62, 0x8f, 0x0e, 0xd0, 0x13, 0xa8, 0x6a, 0x5f, 0x9f, 0x11, 0x51, 0x33,
	0x36, 0xe6, 0x37, 0x4d, 0x0f, 0xb4, 0xe9, 0x88, 0x08, 0xbb, 0x0e, 0x95, 0x36, 0xdf, 0x67, 0x44,
	0x3a, 0x23, 0x58, 0xc0, 0x63, 0xaf, 0xfc, 0x6c, 0x7f, 0x35, 0x60, 0x75, 0x02, 0x93, 0x87, 0x19,
	0xea, 0x80, 0xc9, 0xa2, 0x5e, 0xac, 0x3c, 0xab, 0xcd, 0x3d, 0xe7, 0xaf, 0xb9, 0x39, 0xd3, 0xf1,
	0x8e, 0x3c, 0x89, 0x76, 0x94, 0x26, 0x99, 0xa7, 0x80, 0x2c, 0x06, 0x30, 0x36, 0xa2, 0x55, 0x98,
	0x3f, 0xa3, 0x59, 0xcd, 0xd8, 0x30, 0x36, 0x4d, 0x4f, 0x1e, 0x51, 0x1b, 0xcc, 0x11, 0x0e, 0x87,
	0xb4, 0x36, 0xb7, 0x61, 0x6c, 0x56, 0x9b, 0xee, 0xdd, 0x19, 0x3b, 0x52, 0x19, 0x4f, 0x45, 0xef,
	0xcd, 0xed, 0x1a, 0xf6, 0x77, 0x03, 0xd6, 0xf4, 0xf7, 0x16, 0x4e, 0x88, 0x50, 0x29, 0xbd, 0x07,
	0x33, 0x90, 0x37, 0x9d, 0xd2, 0xcb, 0xbb, 0x11, 0x8c, 0x01, 0x9c, 0xfc, 0xa8, 0x73, 0xca, 0x91,
	0xac, 0xcf, 0x00, 0x63, 0xe3, 0x0d, 0x39, 0x1d, 0x4e, 0xe6, 0xb4, 0x5d, 0x82, 0xf2, 0x5a, 0x52,
	0xbb, 0x60, 0xb6, 0xb9, 0xac, 0xe1, 0x03, 0x30, 0x29, 0x1f, 0x17, 0x51, 0x5d, 0xd0, 0x43, 0xa8,
	0x44, 0x94, 0x12, 0x1f, 0x87, 0x61, 0xce, 0x66, 0x7a, 0x4b, 0xf2, 0xbe, 0x1f, 0x86, 0x76, 0x07,
	0xd6, 0x8e, 0x69, 0x90, 0xb2, 0x38, 0xd2, 0x04, 0x12, 0xc5, 0x82, 0x8a, 0x50, 0xc6, 0x02, 0xe8,
	0xf2, 0x2e, 0x5b, 0x4a, 0x3d, 0xce, 0x4f, 0x33, 0x4e, 0x35, 0x1c, 0x28, 0xd3, 0x87, 0x8c, 0x53,
	0xfb, 0x97, 0x01, 0xeb, 0xd3, 0x90, 0x52, 0xe2, 0x4f, 0x50, 0xd1, 0xe9, 0x14, 0x2a, 0xbf, 0x99,
	0x91, 0xf2, 0x0d, 0x28, 0x85, 0x0c, 0x5a, 0xea, 0x4b, 0x44, 0x2b, 0x86, 0xe5, 0x89, 0x4f, 0x37,
	0x08, 0xfe, 0x76, 0x52, 0xf0, 0x66, 0x29, 0xf6, 0x6b, 0x92, 0xef, 0x00, 0xb4, 0x79, 0x2b, 0xa4,
	0x38, 0x91, 0x8a, 0xad, 0x4b, 0xdd, 0x7d, 0x46, 0x34, 0xdf, 0x02, 0xe5, 0x47, 0x44, 0x3e, 0x01,
	0x33, 0xa2, 0x25, 0x92, 0x47, 0x9b, 0xc0, 0x7d, 0x8d, 0x77, 0x80, 0x49, 0x9f, 0xde, 0x1a, 0xf9,
	0x08, 0xee, 0x51, 0xee, 0x8b, 0x14, 0xa7, 0x43, 0xa1, 0xe3, 0x2b, 0x94, 0x1f, 0xe7, 0x77, 0x59,
	0x01, 0x26, 0xfc, 0x1e, 0x8b, 0x98, 0x38, 0xa5, 0xa4, 0x36, 0xaf, 0x2a, 0xc0, 0xc4, 0xa1, 0xb6,
	0xd8, 0xec, 0x72, 0x66, 0x73, 0x16, 0x21, 0x69, 0x4e, 0x60, 0xa5, 0xd8, 0x04, 0xdd, 0xdc, 0xa8,
	0x6b, 0xe0, 0xdc, 0xad, 0xed, 0x8a, 0xe7, 0x7a, 0xcb, 0xf4, 0x2a, 0xb2, 0xfd, 0xc3, 0x00, 0x34,
	0xc5, 0x25, 0x6b, 0x7d, 0x02, 0x8b, 0x13, 0x2c, 0xaf, 0x4a, 0xb0, 0xe8, 0x81, 0x52, 0x67, 0x55,
	0x66, 0x0d, 0x66, 0x9d, 0x41, 0xf5, 0x8a, 0xf9, 0xbf, 0xcd, 0x54, 0x8e, 0x39, 0x5d, 0xe0, 0xe6,
	0x6f, 0x13, 0x96, 0xb4, 0x03, 0xea, 0xc1, 0xc2, 0x3b, 0x26, 0x52, 0xb4, 0x55, 0x66, 0xd5, 0x0d,
	0x2c, 0xb7, 0xe4, 0x66, 0x44, 0x3d, 0x00, 0xc9, 0x73, 0x90, 0xed, 0xcb, 0xb1, 0x7d, 0x36, 0x33,
	0x5c, 0x6d, 0xee, 0xf2, 0x3c, 0x43, 0x58, 0x56, 0x3c, 0xba, 0xc9, 0xd1, 0x76, 0xc9, 0x51, 0x1c,
	0x58, 0xcd, 0xf2, 0xc3, 0x8b, 0x7c, 0x30, 0xf3, 0xfd, 0x85, 0x9e, 0xce, 0x7c, 0xb0, 0xa4, 0xd8,
	0x2e, 0xbb, 0x85, 0x51, 0x17, 0x20, 0x1f, 0xc9, 0x16, 0x0e, 0x4e, 0x29, 0x7a, 0x3e, 0x33, 0xbe,
	0x98, 0x5f, 0x6b, 0xa6, 0xeb, 0x39, 0x4f, 0xb3, 0xbc, 0x45, 0x50, 0x08, 0x8b, 0xaa, 0x09, 0x91,
	0x5b, 0xae, 0xab, 0x07, 0x56, 0xa3, 0xf4, 0x18, 0xa0, 0x53, 0xa8, 0xe6, 0xf9, 0x95, 0x6d, 0x89,
	0xd2, 0xda, 0x1d, 0xbc, 0xfe, 0x72, 0x51, 0x37, 0xbe, 0x5d, 0xd4, 0x8d, 0x9f, 0x17, 0x75, 0x03,
	0x5e, 0xf0, 0x90, 0x32, 0x4c, 0xa8, 0x70, 0xba, 0x43, 0xc1, 0x22, 0x2a, 0xc4, 0xed, 0x60, 0x1d,
	0xe3, 0xe3, 0xdc, 0xa8, 0xd1, 0x5d, 0xcc, 0xff, 0x42, 0x76, 0xfe, 0x04, 0x00, 0x00, 0xff, 0xff,
	0x77, 0xc1, 0x16, 0x76, 0x32, 0x09, 0x00, 0x00,
}
