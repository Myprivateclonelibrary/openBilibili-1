// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/pgc-season/api/grpc/episode/v1/model.proto

/*
	Package v1 is a generated protocol buffer package.

	It is generated from these files:
		app/service/openplatform/pgc-season/api/grpc/episode/v1/model.proto
		app/service/openplatform/pgc-season/api/grpc/episode/v1/service.proto

	It has these top-level messages:
		EpisodeInfoProto
		EpisodeCardsProto
		EpisodeSeasonProto
		StatsProto
		SectionEpisodeProto
		EmptyProto
		EpisodeBadgeProto
		EpisodeInfoReq
		EpAidReq
		EpisodeInfoReply
		EpisodeCardsReply
		EpReq
		SectionEpisodeReq
		SectionEpisodeReply
		EpClearReq
		EpisodeBadgeReq
		EpisodeBadgesReq
		EpisodeBadgesReply
*/
package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// EpisodeInfoProto .
type EpisodeInfoProto struct {
	// episode_id
	EpisodeId int32 `protobuf:"varint,1,opt,name=episode_id,json=episodeId,proto3" json:"episode_id,omitempty"`
	// aid
	Aid int32 `protobuf:"varint,2,opt,name=aid,proto3" json:"aid,omitempty"`
	// cid
	Cid int32 `protobuf:"varint,3,opt,name=cid,proto3" json:"cid,omitempty"`
	// 排序值 ord
	Index int32 `protobuf:"varint,4,opt,name=index,proto3" json:"index,omitempty"`
	// 短标题
	IndexTitle string `protobuf:"bytes,5,opt,name=index_title,json=indexTitle,proto3" json:"index_title,omitempty"`
	// 长标题
	LongTitle string `protobuf:"bytes,6,opt,name=long_title,json=longTitle,proto3" json:"long_title,omitempty"`
	// ep封面
	Cover string `protobuf:"bytes,7,opt,name=cover,proto3" json:"cover,omitempty"`
	// ep status
	EpisodeStatus int32 `protobuf:"varint,8,opt,name=episode_status,json=episodeStatus,proto3" json:"episode_status,omitempty"`
	// season_id
	SeasonId int32 `protobuf:"varint,9,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
	// 定时上线上线时是否设置对应番剧为已完结：0不设置，1设置
	OnlineFinish int32 `protobuf:"varint,10,opt,name=online_finish,json=onlineFinish,proto3" json:"online_finish,omitempty"`
	// ep对应分节id
	SectionId int32 `protobuf:"varint,11,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty"`
	// 视频来源 bangumi,cid,vupload,pptv,qq
	From string `protobuf:"bytes,12,opt,name=from,proto3" json:"from,omitempty"`
	// vid
	Vid string `protobuf:"bytes,13,opt,name=vid,proto3" json:"vid,omitempty"`
	// pub_real_time format:yyyy-mm-dd HH:mm:ss
	PubRealTime string `protobuf:"bytes,14,opt,name=pub_real_time,json=pubRealTime,proto3" json:"pub_real_time,omitempty"`
	// badge
	Badge string `protobuf:"bytes,15,opt,name=badge,proto3" json:"badge,omitempty"`
	// badge_type
	BadgeType int32 `protobuf:"varint,16,opt,name=badge_type,json=badgeType,proto3" json:"badge_type,omitempty"`
	// ep时长
	Duration int32 `protobuf:"varint,17,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *EpisodeInfoProto) Reset()                    { *m = EpisodeInfoProto{} }
func (m *EpisodeInfoProto) String() string            { return proto.CompactTextString(m) }
func (*EpisodeInfoProto) ProtoMessage()               {}
func (*EpisodeInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

func (m *EpisodeInfoProto) GetEpisodeId() int32 {
	if m != nil {
		return m.EpisodeId
	}
	return 0
}

func (m *EpisodeInfoProto) GetAid() int32 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *EpisodeInfoProto) GetCid() int32 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *EpisodeInfoProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *EpisodeInfoProto) GetIndexTitle() string {
	if m != nil {
		return m.IndexTitle
	}
	return ""
}

func (m *EpisodeInfoProto) GetLongTitle() string {
	if m != nil {
		return m.LongTitle
	}
	return ""
}

func (m *EpisodeInfoProto) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *EpisodeInfoProto) GetEpisodeStatus() int32 {
	if m != nil {
		return m.EpisodeStatus
	}
	return 0
}

func (m *EpisodeInfoProto) GetSeasonId() int32 {
	if m != nil {
		return m.SeasonId
	}
	return 0
}

func (m *EpisodeInfoProto) GetOnlineFinish() int32 {
	if m != nil {
		return m.OnlineFinish
	}
	return 0
}

func (m *EpisodeInfoProto) GetSectionId() int32 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

func (m *EpisodeInfoProto) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *EpisodeInfoProto) GetVid() string {
	if m != nil {
		return m.Vid
	}
	return ""
}

func (m *EpisodeInfoProto) GetPubRealTime() string {
	if m != nil {
		return m.PubRealTime
	}
	return ""
}

func (m *EpisodeInfoProto) GetBadge() string {
	if m != nil {
		return m.Badge
	}
	return ""
}

func (m *EpisodeInfoProto) GetBadgeType() int32 {
	if m != nil {
		return m.BadgeType
	}
	return 0
}

func (m *EpisodeInfoProto) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// EpisodeCardsProto .
type EpisodeCardsProto struct {
	// episode_id
	EpisodeId int32 `protobuf:"varint,1,opt,name=episode_id,json=episodeId,proto3" json:"episode_id,omitempty"`
	// ep status
	EpisodeStatus int32 `protobuf:"varint,2,opt,name=episode_status,json=episodeStatus,proto3" json:"episode_status,omitempty"`
	// 短标题
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// 长标题
	LongTitle string `protobuf:"bytes,4,opt,name=long_title,json=longTitle,proto3" json:"long_title,omitempty"`
	// 封面
	Cover string `protobuf:"bytes,5,opt,name=cover,proto3" json:"cover,omitempty"`
	// seasonBrief
	Season *EpisodeSeasonProto `protobuf:"bytes,6,opt,name=season" json:"season,omitempty"`
	// ep时长
	Duration int32 `protobuf:"varint,7,opt,name=duration,proto3" json:"duration,omitempty"`
	// 第x集 xxx
	ShowTitle string `protobuf:"bytes,8,opt,name=show_title,json=showTitle,proto3" json:"show_title,omitempty"`
}

func (m *EpisodeCardsProto) Reset()                    { *m = EpisodeCardsProto{} }
func (m *EpisodeCardsProto) String() string            { return proto.CompactTextString(m) }
func (*EpisodeCardsProto) ProtoMessage()               {}
func (*EpisodeCardsProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{1} }

func (m *EpisodeCardsProto) GetEpisodeId() int32 {
	if m != nil {
		return m.EpisodeId
	}
	return 0
}

func (m *EpisodeCardsProto) GetEpisodeStatus() int32 {
	if m != nil {
		return m.EpisodeStatus
	}
	return 0
}

func (m *EpisodeCardsProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *EpisodeCardsProto) GetLongTitle() string {
	if m != nil {
		return m.LongTitle
	}
	return ""
}

func (m *EpisodeCardsProto) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *EpisodeCardsProto) GetSeason() *EpisodeSeasonProto {
	if m != nil {
		return m.Season
	}
	return nil
}

func (m *EpisodeCardsProto) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *EpisodeCardsProto) GetShowTitle() string {
	if m != nil {
		return m.ShowTitle
	}
	return ""
}

// EpisodeSeasonProto .
type EpisodeSeasonProto struct {
	// season_id
	SeasonId int32 `protobuf:"varint,1,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
	// 标题
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// season status
	SeasonStatus int32 `protobuf:"varint,3,opt,name=season_status,json=seasonStatus,proto3" json:"season_status,omitempty"`
	// 是否完结 1完结 0未完结
	IsFinish int32 `protobuf:"varint,4,opt,name=is_finish,json=isFinish,proto3" json:"is_finish,omitempty"`
	// 总集数
	TotalCount int32 `protobuf:"varint,5,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// 更新至xx话
	NewEpShow string `protobuf:"bytes,6,opt,name=new_ep_show,json=newEpShow,proto3" json:"new_ep_show,omitempty"`
	// 最新一话epid
	NewEpId int32 `protobuf:"varint,7,opt,name=new_ep_id,json=newEpId,proto3" json:"new_ep_id,omitempty"`
	// season类型  1：番剧，2：电影，3：纪录片，4：国漫，5：电视剧
	SeasonType int32 `protobuf:"varint,8,opt,name=season_type,json=seasonType,proto3" json:"season_type,omitempty"`
	// cover
	Cover string `protobuf:"bytes,9,opt,name=cover,proto3" json:"cover,omitempty"`
	// 播放数(已废弃，请使用: stat.view)
	PlayCount int64 `protobuf:"varint,10,opt,name=play_count,json=playCount,proto3" json:"play_count,omitempty"`
	// episode 所属 season 计数信息
	Stat *StatsProto `protobuf:"bytes,11,opt,name=stat" json:"stat,omitempty"`
	// season类型名称
	SeasonTypeName string `protobuf:"bytes,12,opt,name=season_type_name,json=seasonTypeName,proto3" json:"season_type_name,omitempty"`
	// 角标
	Badge string `protobuf:"bytes,13,opt,name=badge,proto3" json:"badge,omitempty"`
	// 角标颜色
	BadgeType int32 `protobuf:"varint,14,opt,name=badge_type,json=badgeType,proto3" json:"badge_type,omitempty"`
	// 最新一话短标题
	NewEpIndex string `protobuf:"bytes,15,opt,name=new_ep_index,json=newEpIndex,proto3" json:"new_ep_index,omitempty"`
	// 模式1：单集， 2：多集
	Mode int32 `protobuf:"varint,16,opt,name=mode,proto3" json:"mode,omitempty"`
}

func (m *EpisodeSeasonProto) Reset()                    { *m = EpisodeSeasonProto{} }
func (m *EpisodeSeasonProto) String() string            { return proto.CompactTextString(m) }
func (*EpisodeSeasonProto) ProtoMessage()               {}
func (*EpisodeSeasonProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{2} }

func (m *EpisodeSeasonProto) GetSeasonId() int32 {
	if m != nil {
		return m.SeasonId
	}
	return 0
}

func (m *EpisodeSeasonProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *EpisodeSeasonProto) GetSeasonStatus() int32 {
	if m != nil {
		return m.SeasonStatus
	}
	return 0
}

func (m *EpisodeSeasonProto) GetIsFinish() int32 {
	if m != nil {
		return m.IsFinish
	}
	return 0
}

func (m *EpisodeSeasonProto) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *EpisodeSeasonProto) GetNewEpShow() string {
	if m != nil {
		return m.NewEpShow
	}
	return ""
}

func (m *EpisodeSeasonProto) GetNewEpId() int32 {
	if m != nil {
		return m.NewEpId
	}
	return 0
}

func (m *EpisodeSeasonProto) GetSeasonType() int32 {
	if m != nil {
		return m.SeasonType
	}
	return 0
}

func (m *EpisodeSeasonProto) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *EpisodeSeasonProto) GetPlayCount() int64 {
	if m != nil {
		return m.PlayCount
	}
	return 0
}

func (m *EpisodeSeasonProto) GetStat() *StatsProto {
	if m != nil {
		return m.Stat
	}
	return nil
}

func (m *EpisodeSeasonProto) GetSeasonTypeName() string {
	if m != nil {
		return m.SeasonTypeName
	}
	return ""
}

func (m *EpisodeSeasonProto) GetBadge() string {
	if m != nil {
		return m.Badge
	}
	return ""
}

func (m *EpisodeSeasonProto) GetBadgeType() int32 {
	if m != nil {
		return m.BadgeType
	}
	return 0
}

func (m *EpisodeSeasonProto) GetNewEpIndex() string {
	if m != nil {
		return m.NewEpIndex
	}
	return ""
}

func (m *EpisodeSeasonProto) GetMode() int32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

type StatsProto struct {
	// 追番数
	Follow int64 `protobuf:"varint,1,opt,name=follow,proto3" json:"follow,omitempty"`
	// 播放数
	View int64 `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	// 弹幕数
	Danmaku int64 `protobuf:"varint,3,opt,name=danmaku,proto3" json:"danmaku,omitempty"`
}

func (m *StatsProto) Reset()                    { *m = StatsProto{} }
func (m *StatsProto) String() string            { return proto.CompactTextString(m) }
func (*StatsProto) ProtoMessage()               {}
func (*StatsProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{3} }

func (m *StatsProto) GetFollow() int64 {
	if m != nil {
		return m.Follow
	}
	return 0
}

func (m *StatsProto) GetView() int64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *StatsProto) GetDanmaku() int64 {
	if m != nil {
		return m.Danmaku
	}
	return 0
}

// SectionEpisodeProto .
type SectionEpisodeProto struct {
	// info
	Info []*EpisodeInfoProto `protobuf:"bytes,1,rep,name=info" json:"info,omitempty"`
}

func (m *SectionEpisodeProto) Reset()                    { *m = SectionEpisodeProto{} }
func (m *SectionEpisodeProto) String() string            { return proto.CompactTextString(m) }
func (*SectionEpisodeProto) ProtoMessage()               {}
func (*SectionEpisodeProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{4} }

func (m *SectionEpisodeProto) GetInfo() []*EpisodeInfoProto {
	if m != nil {
		return m.Info
	}
	return nil
}

// EmptyProto .
type EmptyProto struct {
}

func (m *EmptyProto) Reset()                    { *m = EmptyProto{} }
func (m *EmptyProto) String() string            { return proto.CompactTextString(m) }
func (*EmptyProto) ProtoMessage()               {}
func (*EmptyProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{5} }

// EpisodeBadgeProto .
type EpisodeBadgeProto struct {
	// 角标类型，0粉色，1蓝色，2橙色
	BadgeType int32 `protobuf:"varint,1,opt,name=badge_type,json=badgeType,proto3" json:"badge_type,omitempty"`
	// 角标文字，如“抢先”这种
	Badge string `protobuf:"bytes,2,opt,name=badge,proto3" json:"badge,omitempty"`
}

func (m *EpisodeBadgeProto) Reset()                    { *m = EpisodeBadgeProto{} }
func (m *EpisodeBadgeProto) String() string            { return proto.CompactTextString(m) }
func (*EpisodeBadgeProto) ProtoMessage()               {}
func (*EpisodeBadgeProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{6} }

func (m *EpisodeBadgeProto) GetBadgeType() int32 {
	if m != nil {
		return m.BadgeType
	}
	return 0
}

func (m *EpisodeBadgeProto) GetBadge() string {
	if m != nil {
		return m.Badge
	}
	return ""
}

func init() {
	proto.RegisterType((*EpisodeInfoProto)(nil), "pgc.service.season.episode.v1.EpisodeInfoProto")
	proto.RegisterType((*EpisodeCardsProto)(nil), "pgc.service.season.episode.v1.EpisodeCardsProto")
	proto.RegisterType((*EpisodeSeasonProto)(nil), "pgc.service.season.episode.v1.EpisodeSeasonProto")
	proto.RegisterType((*StatsProto)(nil), "pgc.service.season.episode.v1.StatsProto")
	proto.RegisterType((*SectionEpisodeProto)(nil), "pgc.service.season.episode.v1.SectionEpisodeProto")
	proto.RegisterType((*EmptyProto)(nil), "pgc.service.season.episode.v1.EmptyProto")
	proto.RegisterType((*EpisodeBadgeProto)(nil), "pgc.service.season.episode.v1.EpisodeBadgeProto")
}
func (m *EpisodeInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EpisodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.EpisodeId))
	}
	if m.Aid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Aid))
	}
	if m.Cid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Cid))
	}
	if m.Index != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Index))
	}
	if len(m.IndexTitle) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.IndexTitle)))
		i += copy(dAtA[i:], m.IndexTitle)
	}
	if len(m.LongTitle) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.LongTitle)))
		i += copy(dAtA[i:], m.LongTitle)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if m.EpisodeStatus != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.EpisodeStatus))
	}
	if m.SeasonId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonId))
	}
	if m.OnlineFinish != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.OnlineFinish))
	}
	if m.SectionId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SectionId))
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.Vid) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Vid)))
		i += copy(dAtA[i:], m.Vid)
	}
	if len(m.PubRealTime) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PubRealTime)))
		i += copy(dAtA[i:], m.PubRealTime)
	}
	if len(m.Badge) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Badge)))
		i += copy(dAtA[i:], m.Badge)
	}
	if m.BadgeType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.BadgeType))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *EpisodeCardsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeCardsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EpisodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.EpisodeId))
	}
	if m.EpisodeStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.EpisodeStatus))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.LongTitle) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.LongTitle)))
		i += copy(dAtA[i:], m.LongTitle)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if m.Season != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Season.Size()))
		n1, err := m.Season.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Duration != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Duration))
	}
	if len(m.ShowTitle) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.ShowTitle)))
		i += copy(dAtA[i:], m.ShowTitle)
	}
	return i, nil
}

func (m *EpisodeSeasonProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeSeasonProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SeasonId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.SeasonStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonStatus))
	}
	if m.IsFinish != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsFinish))
	}
	if m.TotalCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.TotalCount))
	}
	if len(m.NewEpShow) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.NewEpShow)))
		i += copy(dAtA[i:], m.NewEpShow)
	}
	if m.NewEpId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NewEpId))
	}
	if m.SeasonType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonType))
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if m.PlayCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.PlayCount))
	}
	if m.Stat != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Stat.Size()))
		n2, err := m.Stat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.SeasonTypeName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.SeasonTypeName)))
		i += copy(dAtA[i:], m.SeasonTypeName)
	}
	if len(m.Badge) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Badge)))
		i += copy(dAtA[i:], m.Badge)
	}
	if m.BadgeType != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.BadgeType))
	}
	if len(m.NewEpIndex) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.NewEpIndex)))
		i += copy(dAtA[i:], m.NewEpIndex)
	}
	if m.Mode != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mode))
	}
	return i, nil
}

func (m *StatsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Follow != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Follow))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.View))
	}
	if m.Danmaku != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Danmaku))
	}
	return i, nil
}

func (m *SectionEpisodeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionEpisodeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, msg := range m.Info {
			dAtA[i] = 0xa
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EmptyProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EpisodeBadgeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpisodeBadgeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BadgeType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.BadgeType))
	}
	if len(m.Badge) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Badge)))
		i += copy(dAtA[i:], m.Badge)
	}
	return i, nil
}

func encodeVarintModel(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EpisodeInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.EpisodeId != 0 {
		n += 1 + sovModel(uint64(m.EpisodeId))
	}
	if m.Aid != 0 {
		n += 1 + sovModel(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovModel(uint64(m.Cid))
	}
	if m.Index != 0 {
		n += 1 + sovModel(uint64(m.Index))
	}
	l = len(m.IndexTitle)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.LongTitle)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.EpisodeStatus != 0 {
		n += 1 + sovModel(uint64(m.EpisodeStatus))
	}
	if m.SeasonId != 0 {
		n += 1 + sovModel(uint64(m.SeasonId))
	}
	if m.OnlineFinish != 0 {
		n += 1 + sovModel(uint64(m.OnlineFinish))
	}
	if m.SectionId != 0 {
		n += 1 + sovModel(uint64(m.SectionId))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Vid)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.PubRealTime)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Badge)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.BadgeType != 0 {
		n += 2 + sovModel(uint64(m.BadgeType))
	}
	if m.Duration != 0 {
		n += 2 + sovModel(uint64(m.Duration))
	}
	return n
}

func (m *EpisodeCardsProto) Size() (n int) {
	var l int
	_ = l
	if m.EpisodeId != 0 {
		n += 1 + sovModel(uint64(m.EpisodeId))
	}
	if m.EpisodeStatus != 0 {
		n += 1 + sovModel(uint64(m.EpisodeStatus))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.LongTitle)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Season != nil {
		l = m.Season.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovModel(uint64(m.Duration))
	}
	l = len(m.ShowTitle)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *EpisodeSeasonProto) Size() (n int) {
	var l int
	_ = l
	if m.SeasonId != 0 {
		n += 1 + sovModel(uint64(m.SeasonId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.SeasonStatus != 0 {
		n += 1 + sovModel(uint64(m.SeasonStatus))
	}
	if m.IsFinish != 0 {
		n += 1 + sovModel(uint64(m.IsFinish))
	}
	if m.TotalCount != 0 {
		n += 1 + sovModel(uint64(m.TotalCount))
	}
	l = len(m.NewEpShow)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.NewEpId != 0 {
		n += 1 + sovModel(uint64(m.NewEpId))
	}
	if m.SeasonType != 0 {
		n += 1 + sovModel(uint64(m.SeasonType))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.PlayCount != 0 {
		n += 1 + sovModel(uint64(m.PlayCount))
	}
	if m.Stat != nil {
		l = m.Stat.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.SeasonTypeName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Badge)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.BadgeType != 0 {
		n += 1 + sovModel(uint64(m.BadgeType))
	}
	l = len(m.NewEpIndex)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Mode != 0 {
		n += 2 + sovModel(uint64(m.Mode))
	}
	return n
}

func (m *StatsProto) Size() (n int) {
	var l int
	_ = l
	if m.Follow != 0 {
		n += 1 + sovModel(uint64(m.Follow))
	}
	if m.View != 0 {
		n += 1 + sovModel(uint64(m.View))
	}
	if m.Danmaku != 0 {
		n += 1 + sovModel(uint64(m.Danmaku))
	}
	return n
}

func (m *SectionEpisodeProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *EmptyProto) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EpisodeBadgeProto) Size() (n int) {
	var l int
	_ = l
	if m.BadgeType != 0 {
		n += 1 + sovModel(uint64(m.BadgeType))
	}
	l = len(m.Badge)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func sovModel(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EpisodeInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpisodeId", wireType)
			}
			m.EpisodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpisodeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LongTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpisodeStatus", wireType)
			}
			m.EpisodeStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpisodeStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineFinish", wireType)
			}
			m.OnlineFinish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnlineFinish |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubRealTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubRealTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Badge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeType", wireType)
			}
			m.BadgeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadgeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpisodeCardsProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeCardsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeCardsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpisodeId", wireType)
			}
			m.EpisodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpisodeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpisodeStatus", wireType)
			}
			m.EpisodeStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpisodeStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LongTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Season", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Season == nil {
				m.Season = &EpisodeSeasonProto{}
			}
			if err := m.Season.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShowTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpisodeSeasonProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeSeasonProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeSeasonProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonStatus", wireType)
			}
			m.SeasonStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFinish", wireType)
			}
			m.IsFinish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFinish |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEpShow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewEpShow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEpId", wireType)
			}
			m.NewEpId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewEpId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonType", wireType)
			}
			m.SeasonType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayCount", wireType)
			}
			m.PlayCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stat == nil {
				m.Stat = &StatsProto{}
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeasonTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Badge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeType", wireType)
			}
			m.BadgeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadgeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEpIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewEpIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			m.Follow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Follow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Danmaku", wireType)
			}
			m.Danmaku = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Danmaku |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionEpisodeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionEpisodeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionEpisodeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &EpisodeInfoProto{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpisodeBadgeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpisodeBadgeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpisodeBadgeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeType", wireType)
			}
			m.BadgeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadgeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Badge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModel
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModel(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModel = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/pgc-season/api/grpc/episode/v1/model.proto", fileDescriptorModel)
}

var fileDescriptorModel = []byte{
	// 803 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xc1, 0x6e, 0xe3, 0x36,
	0x10, 0x85, 0x2c, 0x3b, 0xb1, 0x46, 0x76, 0x9a, 0x65, 0x83, 0x82, 0xd8, 0x62, 0xbd, 0x86, 0x16,
	0x05, 0x5c, 0x14, 0x95, 0xe0, 0xf4, 0x5c, 0x14, 0x58, 0x23, 0x45, 0x7d, 0x29, 0x16, 0x72, 0x4e,
	0x7b, 0x11, 0x68, 0x91, 0x76, 0x88, 0x4a, 0x22, 0x21, 0xc9, 0x76, 0xfd, 0x17, 0xfd, 0x8e, 0x7e,
	0x49, 0x8f, 0xfd, 0x84, 0x22, 0xe8, 0x87, 0x14, 0x1c, 0xd2, 0x8e, 0x93, 0xdd, 0x74, 0xf7, 0xc6,
	0x79, 0x23, 0x92, 0x6f, 0xde, 0xcc, 0xa3, 0x60, 0xc6, 0xb4, 0x4e, 0x1a, 0x51, 0x6f, 0x65, 0x2e,
	0x12, 0xa5, 0x45, 0xa5, 0x0b, 0xd6, 0xae, 0x54, 0x5d, 0x26, 0x7a, 0x9d, 0x7f, 0xdf, 0x08, 0xd6,
	0xa8, 0x2a, 0x61, 0x5a, 0x26, 0xeb, 0x5a, 0xe7, 0x89, 0xd0, 0xb2, 0x51, 0x5c, 0x24, 0xdb, 0x69,
	0x52, 0x2a, 0x2e, 0x8a, 0x58, 0xd7, 0xaa, 0x55, 0xe4, 0x95, 0x5e, 0xe7, 0xb1, 0x3b, 0x24, 0xb6,
	0x7b, 0x62, 0xf7, 0x69, 0xbc, 0x9d, 0x46, 0xff, 0xfa, 0x70, 0x79, 0x63, 0xc3, 0x79, 0xb5, 0x52,
	0xef, 0xec, 0x1e, 0x00, 0xf7, 0x49, 0x26, 0x39, 0xf5, 0xc6, 0xde, 0xa4, 0x97, 0x06, 0x0e, 0x99,
	0x73, 0x72, 0x09, 0x3e, 0x93, 0x9c, 0x76, 0x10, 0x37, 0x4b, 0x83, 0xe4, 0x92, 0x53, 0xdf, 0x22,
	0xb9, 0xe4, 0xe4, 0x0a, 0x7a, 0xb2, 0xe2, 0xe2, 0x77, 0xda, 0x45, 0xcc, 0x06, 0xe4, 0x35, 0x84,
	0xb8, 0xc8, 0x5a, 0xd9, 0x16, 0x82, 0xf6, 0xc6, 0xde, 0x24, 0x48, 0x01, 0xa1, 0x5b, 0x83, 0x98,
	0x9b, 0x0b, 0x55, 0xad, 0x5d, 0xfe, 0x0c, 0xf3, 0x81, 0x41, 0x6c, 0xfa, 0x0a, 0x7a, 0xb9, 0xda,
	0x8a, 0x9a, 0x9e, 0x63, 0xc6, 0x06, 0xe4, 0x1b, 0xb8, 0x38, 0xd0, 0x6d, 0x5a, 0xd6, 0x6e, 0x1a,
	0xda, 0xc7, 0x4b, 0x87, 0x0e, 0x5d, 0x20, 0x48, 0xbe, 0x86, 0xc0, 0xd6, 0x6f, 0x8a, 0x0a, 0xf0,
	0x8b, 0xbe, 0x05, 0xe6, 0x9c, 0xbc, 0x81, 0xa1, 0xaa, 0x0a, 0x59, 0x89, 0x6c, 0x25, 0x2b, 0xd9,
	0xdc, 0x51, 0xc0, 0x0f, 0x06, 0x16, 0xfc, 0x19, 0x31, 0xc3, 0xae, 0x11, 0x79, 0x2b, 0xed, 0x11,
	0xa1, 0xd5, 0xc5, 0x21, 0x73, 0x4e, 0x08, 0x74, 0x57, 0xb5, 0x2a, 0xe9, 0x00, 0xc9, 0xe1, 0xda,
	0x28, 0xb3, 0x95, 0x9c, 0x0e, 0x11, 0x32, 0x4b, 0x12, 0xc1, 0x50, 0x6f, 0x96, 0x59, 0x2d, 0x58,
	0x91, 0xb5, 0xb2, 0x14, 0xf4, 0x02, 0x73, 0xa1, 0xde, 0x2c, 0x53, 0xc1, 0x8a, 0x5b, 0x59, 0x62,
	0x9d, 0x4b, 0xc6, 0xd7, 0x82, 0x7e, 0x61, 0xeb, 0xc4, 0xc0, 0x5c, 0x8f, 0x8b, 0xac, 0xdd, 0x6b,
	0x41, 0x2f, 0xed, 0xf5, 0x88, 0xdc, 0xee, 0xb5, 0x20, 0x2f, 0xa1, 0xcf, 0x37, 0x35, 0x33, 0x64,
	0xe8, 0x0b, 0x5b, 0xde, 0x21, 0x8e, 0xfe, 0xec, 0xc0, 0x0b, 0xd7, 0xe6, 0x19, 0xab, 0x79, 0xf3,
	0x59, 0x7d, 0xfe, 0x50, 0xd7, 0xce, 0xc7, 0x74, 0xbd, 0x82, 0x9e, 0x6d, 0x97, 0x6f, 0xc9, 0xb6,
	0x1f, 0xe9, 0x64, 0xf7, 0xd9, 0x4e, 0xf6, 0x4e, 0x3b, 0x39, 0x87, 0x33, 0xdb, 0x11, 0x6c, 0x7d,
	0x78, 0x3d, 0x8d, 0xff, 0x77, 0x7a, 0x63, 0x57, 0xd2, 0x02, 0x13, 0x58, 0x53, 0xea, 0x0e, 0x78,
	0xa4, 0xc6, 0xf9, 0x63, 0x35, 0xb0, 0x8f, 0x77, 0x6a, 0xe7, 0xb8, 0xf5, 0x2d, 0x37, 0x83, 0x20,
	0xb7, 0xe8, 0x8f, 0x2e, 0x90, 0x0f, 0x4f, 0x7e, 0x3c, 0x3f, 0xde, 0x93, 0xf9, 0x39, 0x8a, 0xd0,
	0x39, 0x15, 0xe1, 0x0d, 0x0c, 0xdd, 0x16, 0x27, 0xa0, 0x75, 0xc8, 0xc0, 0x82, 0x0f, 0x73, 0x29,
	0x9b, 0xc3, 0xd8, 0x59, 0xbb, 0xf4, 0x65, 0xe3, 0x46, 0xee, 0x35, 0x84, 0xad, 0x6a, 0x59, 0x91,
	0xe5, 0x6a, 0x53, 0xb5, 0xa8, 0x56, 0x2f, 0x05, 0x84, 0x66, 0x06, 0x21, 0x23, 0x08, 0x2b, 0xb1,
	0xcb, 0x84, 0xce, 0x4c, 0x01, 0x07, 0xcb, 0x54, 0x62, 0x77, 0xa3, 0x17, 0x77, 0x6a, 0x47, 0x5e,
	0x42, 0xe0, 0xf2, 0x92, 0x3b, 0x21, 0xce, 0x31, 0x3b, 0xe7, 0xe6, 0x70, 0x47, 0x0f, 0x27, 0xca,
	0xba, 0x06, 0x2c, 0x84, 0x23, 0x75, 0xec, 0x52, 0x70, 0xda, 0xa5, 0x57, 0x00, 0xba, 0x60, 0x7b,
	0x47, 0xc9, 0x18, 0xc5, 0x4f, 0x03, 0x83, 0x58, 0x46, 0x3f, 0x42, 0xd7, 0x54, 0x8b, 0xfe, 0x08,
	0xaf, 0xbf, 0xfd, 0x44, 0x0b, 0x8d, 0x08, 0x76, 0x1c, 0x53, 0xdc, 0x46, 0x26, 0x70, 0x79, 0x42,
	0x2a, 0xab, 0x58, 0x29, 0x9c, 0xa3, 0x2e, 0x1e, 0x98, 0xfd, 0xca, 0x4e, 0x5d, 0x32, 0x7c, 0xde,
	0x25, 0x17, 0x4f, 0x5d, 0x32, 0x86, 0xc1, 0x41, 0x0f, 0x7c, 0x9f, 0xac, 0xc3, 0xc0, 0x4a, 0x82,
	0x8f, 0x14, 0x81, 0xae, 0x79, 0x40, 0x9d, 0xc1, 0x70, 0x1d, 0xa5, 0x00, 0x0f, 0x44, 0xc9, 0x57,
	0x70, 0xb6, 0x52, 0x45, 0xa1, 0x76, 0x38, 0x06, 0x7e, 0xea, 0x22, 0xb3, 0x73, 0x2b, 0xc5, 0x0e,
	0x67, 0xc0, 0x4f, 0x71, 0x4d, 0x28, 0x9c, 0x73, 0x56, 0x95, 0xec, 0xb7, 0x0d, 0x36, 0xdf, 0x4f,
	0x0f, 0x61, 0xf4, 0x1e, 0xbe, 0x5c, 0xd8, 0xb7, 0xc3, 0x0d, 0x9b, 0x3d, 0x7c, 0x06, 0x5d, 0x59,
	0xad, 0x14, 0xf5, 0xc6, 0xfe, 0x24, 0xbc, 0x4e, 0x3e, 0xcf, 0x01, 0xc7, 0xb7, 0x3b, 0xc5, 0xcd,
	0xd1, 0x00, 0xe0, 0xa6, 0xd4, 0xed, 0x1e, 0xb1, 0xe8, 0x97, 0xa3, 0xf9, 0xdf, 0x1a, 0x1d, 0x8e,
	0xe6, 0x3f, 0xd1, 0xc9, 0x7b, 0xaa, 0xd3, 0x51, 0xdc, 0xce, 0x89, 0xb8, 0x6f, 0x7f, 0xfa, 0xeb,
	0x7e, 0xe4, 0xfd, 0x7d, 0x3f, 0xf2, 0xfe, 0xb9, 0x1f, 0x79, 0xf0, 0x9d, 0x2e, 0x84, 0x64, 0x5c,
	0x34, 0xf1, 0x72, 0xd3, 0xc8, 0x4a, 0x34, 0xcd, 0xf3, 0x4c, 0xdf, 0x79, 0xef, 0x3b, 0xdb, 0xe9,
	0xf2, 0x0c, 0xff, 0x4a, 0x3f, 0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0x0c, 0xf4, 0xd9, 0x72, 0xdc,
	0x06, 0x00, 0x00,
}
