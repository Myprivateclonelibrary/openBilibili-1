// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/pgc-season/api/grpc/season/v1/model.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// CardInfoProto .
type CardInfoProto struct {
	// season_id
	SeasonId int32 `protobuf:"varint,1,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
	// media_id
	MediaId int32 `protobuf:"varint,2,opt,name=media_id,json=mediaId,proto3" json:"media_id,omitempty"`
	// season类型  1：番剧，2：电影，3：纪录片，4：国漫，5：电视剧
	SeasonType int32 `protobuf:"varint,3,opt,name=season_type,json=seasonType,proto3" json:"season_type,omitempty"`
	// season类型显示名  1：番剧，2：电影，3：纪录片，4：国漫，5：电视剧
	SeasonTypeName string `protobuf:"bytes,4,opt,name=season_type_name,json=seasonTypeName,proto3" json:"season_type_name,omitempty"`
	// 标题
	Title string `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	// 封面
	Cover string `protobuf:"bytes,6,opt,name=cover,proto3" json:"cover,omitempty"`
	// 总集数
	TotalCount int32 `protobuf:"varint,7,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// 是否完结 1完结 0未完结
	IsFinish int32 `protobuf:"varint,8,opt,name=is_finish,json=isFinish,proto3" json:"is_finish,omitempty"`
	// 是否开播 1开播 0未开播
	IsStarted int32 `protobuf:"varint,9,opt,name=is_started,json=isStarted,proto3" json:"is_started,omitempty"`
	// 是否可以播放 0-不可以 1-可以
	IsPlay int32 `protobuf:"varint,10,opt,name=is_play,json=isPlay,proto3" json:"is_play,omitempty"`
	// 角标文字，如“抢先”这种
	Badge string `protobuf:"bytes,11,opt,name=badge,proto3" json:"badge,omitempty"`
	// 角标类型，0粉色，1蓝色，2橙色
	BadgeType int32 `protobuf:"varint,12,opt,name=badge_type,json=badgeType,proto3" json:"badge_type,omitempty"`
	// 扩展字段开关
	Rights *RightsProto `protobuf:"bytes,13,opt,name=rights" json:"rights,omitempty"`
	// 计数统计
	Stat *StatsProto `protobuf:"bytes,14,opt,name=stat" json:"stat,omitempty"`
	// 最新一话相关信息
	NewEp *NewEpProto `protobuf:"bytes,15,opt,name=new_ep,json=newEp" json:"new_ep,omitempty"`
	// 评分信息
	Rating *RatingProto `protobuf:"bytes,16,opt,name=rating" json:"rating,omitempty"`
	// 方图
	SquareCover string `protobuf:"bytes,17,opt,name=square_cover,json=squareCover,proto3" json:"square_cover,omitempty"`
	// season付费状态
	SeasonStatus int32 `protobuf:"varint,18,opt,name=season_status,json=seasonStatus,proto3" json:"season_status,omitempty"`
	// 分季标题 第一季
	SeasonTitle string `protobuf:"bytes,19,opt,name=season_title,json=seasonTitle,proto3" json:"season_title,omitempty"`
}

func (m *CardInfoProto) Reset()                    { *m = CardInfoProto{} }
func (m *CardInfoProto) String() string            { return proto.CompactTextString(m) }
func (*CardInfoProto) ProtoMessage()               {}
func (*CardInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

func (m *CardInfoProto) GetSeasonId() int32 {
	if m != nil {
		return m.SeasonId
	}
	return 0
}

func (m *CardInfoProto) GetMediaId() int32 {
	if m != nil {
		return m.MediaId
	}
	return 0
}

func (m *CardInfoProto) GetSeasonType() int32 {
	if m != nil {
		return m.SeasonType
	}
	return 0
}

func (m *CardInfoProto) GetSeasonTypeName() string {
	if m != nil {
		return m.SeasonTypeName
	}
	return ""
}

func (m *CardInfoProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CardInfoProto) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *CardInfoProto) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *CardInfoProto) GetIsFinish() int32 {
	if m != nil {
		return m.IsFinish
	}
	return 0
}

func (m *CardInfoProto) GetIsStarted() int32 {
	if m != nil {
		return m.IsStarted
	}
	return 0
}

func (m *CardInfoProto) GetIsPlay() int32 {
	if m != nil {
		return m.IsPlay
	}
	return 0
}

func (m *CardInfoProto) GetBadge() string {
	if m != nil {
		return m.Badge
	}
	return ""
}

func (m *CardInfoProto) GetBadgeType() int32 {
	if m != nil {
		return m.BadgeType
	}
	return 0
}

func (m *CardInfoProto) GetRights() *RightsProto {
	if m != nil {
		return m.Rights
	}
	return nil
}

func (m *CardInfoProto) GetStat() *StatsProto {
	if m != nil {
		return m.Stat
	}
	return nil
}

func (m *CardInfoProto) GetNewEp() *NewEpProto {
	if m != nil {
		return m.NewEp
	}
	return nil
}

func (m *CardInfoProto) GetRating() *RatingProto {
	if m != nil {
		return m.Rating
	}
	return nil
}

func (m *CardInfoProto) GetSquareCover() string {
	if m != nil {
		return m.SquareCover
	}
	return ""
}

func (m *CardInfoProto) GetSeasonStatus() int32 {
	if m != nil {
		return m.SeasonStatus
	}
	return 0
}

func (m *CardInfoProto) GetSeasonTitle() string {
	if m != nil {
		return m.SeasonTitle
	}
	return ""
}

// ProfileInfoProto .
type ProfileInfoProto struct {
	// season_id
	SeasonId int32 `protobuf:"varint,1,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
	// media_id
	MediaId int32 `protobuf:"varint,2,opt,name=media_id,json=mediaId,proto3" json:"media_id,omitempty"`
	// season类型  1：番剧，2：电影，3：纪录片，4：国漫，5：电视剧
	SeasonType int32 `protobuf:"varint,3,opt,name=season_type,json=seasonType,proto3" json:"season_type,omitempty"`
	// season类型显示名  1：番剧，2：电影，3：纪录片，4：国漫，5：电视剧
	SeasonTypeName string `protobuf:"bytes,4,opt,name=season_type_name,json=seasonTypeName,proto3" json:"season_type_name,omitempty"`
	// 标题
	Title string `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	// 封面
	Cover string `protobuf:"bytes,6,opt,name=cover,proto3" json:"cover,omitempty"`
	// 方图
	SquareCover string `protobuf:"bytes,7,opt,name=square_cover,json=squareCover,proto3" json:"square_cover,omitempty"`
	// 总集数
	TotalCount int32 `protobuf:"varint,8,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// 是否完结 1完结 0未完结
	IsFinish int32 `protobuf:"varint,9,opt,name=is_finish,json=isFinish,proto3" json:"is_finish,omitempty"`
	// 是否开播 1开播 0未开播
	IsStarted int32 `protobuf:"varint,10,opt,name=is_started,json=isStarted,proto3" json:"is_started,omitempty"`
	// 是否可以播放 0-不可以 1-可以
	IsPlay int32 `protobuf:"varint,11,opt,name=is_play,json=isPlay,proto3" json:"is_play,omitempty"`
	// 角标文字，如“抢先”这种
	Badge string `protobuf:"bytes,12,opt,name=badge,proto3" json:"badge,omitempty"`
	// 角标类型，0粉色，1蓝色，2橙色
	BadgeType int32 `protobuf:"varint,13,opt,name=badge_type,json=badgeType,proto3" json:"badge_type,omitempty"`
	// season付费状态
	SeasonStatus int32 `protobuf:"varint,14,opt,name=season_status,json=seasonStatus,proto3" json:"season_status,omitempty"`
	// 扩展字段开关
	Rights *RightsProto `protobuf:"bytes,15,opt,name=rights" json:"rights,omitempty"`
	// 计数统计
	Stat *StatsProto `protobuf:"bytes,16,opt,name=stat" json:"stat,omitempty"`
	// 最新一话相关信息
	NewEp *NewEpProto `protobuf:"bytes,17,opt,name=new_ep,json=newEp" json:"new_ep,omitempty"`
	// 评分信息
	Rating *RatingProto `protobuf:"bytes,18,opt,name=rating" json:"rating,omitempty"`
	// 系列信息
	Series *SeriesProto `protobuf:"bytes,19,opt,name=series" json:"series,omitempty"`
	// 分节信息
	Section []*SectionProto `protobuf:"bytes,20,rep,name=section" json:"section,omitempty"`
	// 分季标题 第一季
	SeasonTitle string `protobuf:"bytes,21,opt,name=season_title,json=seasonTitle,proto3" json:"season_title,omitempty"`
	// 剧集模式 1单集 2多集
	Mode int32 `protobuf:"varint,22,opt,name=mode,proto3" json:"mode,omitempty"`
	// 简介
	Evaluate string `protobuf:"bytes,23,opt,name=evaluate,proto3" json:"evaluate,omitempty"`
	// publish
	Publish *PublishProto `protobuf:"bytes,24,opt,name=publish" json:"publish,omitempty"`
	// mid
	Mid int64 `protobuf:"varint,25,opt,name=mid,proto3" json:"mid,omitempty"`
	// 备案号
	Record string `protobuf:"bytes,26,opt,name=record,proto3" json:"record,omitempty"`
	// 更新时间信息
	RenewalTime string `protobuf:"bytes,27,opt,name=renewal_time,json=renewalTime,proto3" json:"renewal_time,omitempty"`
}

func (m *ProfileInfoProto) Reset()                    { *m = ProfileInfoProto{} }
func (m *ProfileInfoProto) String() string            { return proto.CompactTextString(m) }
func (*ProfileInfoProto) ProtoMessage()               {}
func (*ProfileInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{1} }

func (m *ProfileInfoProto) GetSeasonId() int32 {
	if m != nil {
		return m.SeasonId
	}
	return 0
}

func (m *ProfileInfoProto) GetMediaId() int32 {
	if m != nil {
		return m.MediaId
	}
	return 0
}

func (m *ProfileInfoProto) GetSeasonType() int32 {
	if m != nil {
		return m.SeasonType
	}
	return 0
}

func (m *ProfileInfoProto) GetSeasonTypeName() string {
	if m != nil {
		return m.SeasonTypeName
	}
	return ""
}

func (m *ProfileInfoProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ProfileInfoProto) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *ProfileInfoProto) GetSquareCover() string {
	if m != nil {
		return m.SquareCover
	}
	return ""
}

func (m *ProfileInfoProto) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *ProfileInfoProto) GetIsFinish() int32 {
	if m != nil {
		return m.IsFinish
	}
	return 0
}

func (m *ProfileInfoProto) GetIsStarted() int32 {
	if m != nil {
		return m.IsStarted
	}
	return 0
}

func (m *ProfileInfoProto) GetIsPlay() int32 {
	if m != nil {
		return m.IsPlay
	}
	return 0
}

func (m *ProfileInfoProto) GetBadge() string {
	if m != nil {
		return m.Badge
	}
	return ""
}

func (m *ProfileInfoProto) GetBadgeType() int32 {
	if m != nil {
		return m.BadgeType
	}
	return 0
}

func (m *ProfileInfoProto) GetSeasonStatus() int32 {
	if m != nil {
		return m.SeasonStatus
	}
	return 0
}

func (m *ProfileInfoProto) GetRights() *RightsProto {
	if m != nil {
		return m.Rights
	}
	return nil
}

func (m *ProfileInfoProto) GetStat() *StatsProto {
	if m != nil {
		return m.Stat
	}
	return nil
}

func (m *ProfileInfoProto) GetNewEp() *NewEpProto {
	if m != nil {
		return m.NewEp
	}
	return nil
}

func (m *ProfileInfoProto) GetRating() *RatingProto {
	if m != nil {
		return m.Rating
	}
	return nil
}

func (m *ProfileInfoProto) GetSeries() *SeriesProto {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *ProfileInfoProto) GetSection() []*SectionProto {
	if m != nil {
		return m.Section
	}
	return nil
}

func (m *ProfileInfoProto) GetSeasonTitle() string {
	if m != nil {
		return m.SeasonTitle
	}
	return ""
}

func (m *ProfileInfoProto) GetMode() int32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *ProfileInfoProto) GetEvaluate() string {
	if m != nil {
		return m.Evaluate
	}
	return ""
}

func (m *ProfileInfoProto) GetPublish() *PublishProto {
	if m != nil {
		return m.Publish
	}
	return nil
}

func (m *ProfileInfoProto) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ProfileInfoProto) GetRecord() string {
	if m != nil {
		return m.Record
	}
	return ""
}

func (m *ProfileInfoProto) GetRenewalTime() string {
	if m != nil {
		return m.RenewalTime
	}
	return ""
}

// RatingProto 评分信息
type RatingProto struct {
	// 评分数
	Score float32 `protobuf:"fixed32,1,opt,name=score,proto3" json:"score,omitempty"`
	// 评分人数
	Count int32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *RatingProto) Reset()                    { *m = RatingProto{} }
func (m *RatingProto) String() string            { return proto.CompactTextString(m) }
func (*RatingProto) ProtoMessage()               {}
func (*RatingProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{2} }

func (m *RatingProto) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *RatingProto) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// NewEpProto 最新一话相关信息
type NewEpProto struct {
	// epid
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 更新至xx话
	IndexShow string `protobuf:"bytes,2,opt,name=index_show,json=indexShow,proto3" json:"index_show,omitempty"`
	// 最新一话封面
	Cover string `protobuf:"bytes,3,opt,name=cover,proto3" json:"cover,omitempty"`
	// 最新一话短标题
	Title string `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	// 最新一话长标题
	LongTitle string `protobuf:"bytes,5,opt,name=long_title,json=longTitle,proto3" json:"long_title,omitempty"`
	// 上线时间
	PubTime string `protobuf:"bytes,6,opt,name=pub_time,json=pubTime,proto3" json:"pub_time,omitempty"`
}

func (m *NewEpProto) Reset()                    { *m = NewEpProto{} }
func (m *NewEpProto) String() string            { return proto.CompactTextString(m) }
func (*NewEpProto) ProtoMessage()               {}
func (*NewEpProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{3} }

func (m *NewEpProto) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NewEpProto) GetIndexShow() string {
	if m != nil {
		return m.IndexShow
	}
	return ""
}

func (m *NewEpProto) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *NewEpProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *NewEpProto) GetLongTitle() string {
	if m != nil {
		return m.LongTitle
	}
	return ""
}

func (m *NewEpProto) GetPubTime() string {
	if m != nil {
		return m.PubTime
	}
	return ""
}

// StatsProto 计数
type StatsProto struct {
	// 追番数
	Follow int64 `protobuf:"varint,1,opt,name=follow,proto3" json:"follow,omitempty"`
	// 播放数
	View int64 `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	// 弹幕数
	Danmaku int64 `protobuf:"varint,3,opt,name=danmaku,proto3" json:"danmaku,omitempty"`
}

func (m *StatsProto) Reset()                    { *m = StatsProto{} }
func (m *StatsProto) String() string            { return proto.CompactTextString(m) }
func (*StatsProto) ProtoMessage()               {}
func (*StatsProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{4} }

func (m *StatsProto) GetFollow() int64 {
	if m != nil {
		return m.Follow
	}
	return 0
}

func (m *StatsProto) GetView() int64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *StatsProto) GetDanmaku() int64 {
	if m != nil {
		return m.Danmaku
	}
	return 0
}

// RightsProto  扩展字段开关
type RightsProto struct {
	// 是否允许点评 1 允许点评 0 禁止点评
	AllowReview int32 `protobuf:"varint,1,opt,name=allow_review,json=allowReview,proto3" json:"allow_review,omitempty"`
	// 是否允许承包
	AllowBp int32 `protobuf:"varint,2,opt,name=allow_bp,json=allowBp,proto3" json:"allow_bp,omitempty"`
	// 是否允许下周
	AllowDownload int32 `protobuf:"varint,3,opt,name=allow_download,json=allowDownload,proto3" json:"allow_download,omitempty"`
	// 是否允许预览
	AllowPreview int32 `protobuf:"varint,4,opt,name=allow_preview,json=allowPreview,proto3" json:"allow_preview,omitempty"`
}

func (m *RightsProto) Reset()                    { *m = RightsProto{} }
func (m *RightsProto) String() string            { return proto.CompactTextString(m) }
func (*RightsProto) ProtoMessage()               {}
func (*RightsProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{5} }

func (m *RightsProto) GetAllowReview() int32 {
	if m != nil {
		return m.AllowReview
	}
	return 0
}

func (m *RightsProto) GetAllowBp() int32 {
	if m != nil {
		return m.AllowBp
	}
	return 0
}

func (m *RightsProto) GetAllowDownload() int32 {
	if m != nil {
		return m.AllowDownload
	}
	return 0
}

func (m *RightsProto) GetAllowPreview() int32 {
	if m != nil {
		return m.AllowPreview
	}
	return 0
}

// SeriesProto  系列信息
type SeriesProto struct {
	// 系列id
	SeriesId int32 `protobuf:"varint,1,opt,name=series_id,json=seriesId,proto3" json:"series_id,omitempty"`
	// 系列标题
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
}

func (m *SeriesProto) Reset()                    { *m = SeriesProto{} }
func (m *SeriesProto) String() string            { return proto.CompactTextString(m) }
func (*SeriesProto) ProtoMessage()               {}
func (*SeriesProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{6} }

func (m *SeriesProto) GetSeriesId() int32 {
	if m != nil {
		return m.SeriesId
	}
	return 0
}

func (m *SeriesProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

// SectionProto  分节信息
type SectionProto struct {
	// 系列id
	SectionId int32 `protobuf:"varint,1,opt,name=section_id,json=sectionId,proto3" json:"section_id,omitempty"`
	// seasonId
	SeasonId int32 `protobuf:"varint,2,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
	// 地区限制
	LimitGroup int32 `protobuf:"varint,3,opt,name=limit_group,json=limitGroup,proto3" json:"limit_group,omitempty"`
	// 平台限制
	WatchPlatform int32 `protobuf:"varint,4,opt,name=watch_platform,json=watchPlatform,proto3" json:"watch_platform,omitempty"`
	// 类别 0正片1预告片2其他
	Type int32 `protobuf:"varint,5,opt,name=type,proto3" json:"type,omitempty"`
	// 版权
	Copyright string `protobuf:"bytes,6,opt,name=copyright,proto3" json:"copyright,omitempty"`
	// 分节标题
	Title string `protobuf:"bytes,7,opt,name=title,proto3" json:"title,omitempty"`
	// 禁播地区展示1.版权受限 2.隐藏剧集 3.下架剧集
	BanAreaShow int32 `protobuf:"varint,8,opt,name=ban_area_show,json=banAreaShow,proto3" json:"ban_area_show,omitempty"`
}

func (m *SectionProto) Reset()                    { *m = SectionProto{} }
func (m *SectionProto) String() string            { return proto.CompactTextString(m) }
func (*SectionProto) ProtoMessage()               {}
func (*SectionProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{7} }

func (m *SectionProto) GetSectionId() int32 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

func (m *SectionProto) GetSeasonId() int32 {
	if m != nil {
		return m.SeasonId
	}
	return 0
}

func (m *SectionProto) GetLimitGroup() int32 {
	if m != nil {
		return m.LimitGroup
	}
	return 0
}

func (m *SectionProto) GetWatchPlatform() int32 {
	if m != nil {
		return m.WatchPlatform
	}
	return 0
}

func (m *SectionProto) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *SectionProto) GetCopyright() string {
	if m != nil {
		return m.Copyright
	}
	return ""
}

func (m *SectionProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SectionProto) GetBanAreaShow() int32 {
	if m != nil {
		return m.BanAreaShow
	}
	return 0
}

// SeriesSeasonProto season信息
type SeriesSeasonProto struct {
	// season_id
	SeasonId int32 `protobuf:"varint,1,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
	// season_title
	SeasonTitle string `protobuf:"bytes,2,opt,name=season_title,json=seasonTitle,proto3" json:"season_title,omitempty"`
	// new_ep
	NewEp *NewEpProto `protobuf:"bytes,3,opt,name=new_ep,json=newEp" json:"new_ep,omitempty"`
}

func (m *SeriesSeasonProto) Reset()                    { *m = SeriesSeasonProto{} }
func (m *SeriesSeasonProto) String() string            { return proto.CompactTextString(m) }
func (*SeriesSeasonProto) ProtoMessage()               {}
func (*SeriesSeasonProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{8} }

func (m *SeriesSeasonProto) GetSeasonId() int32 {
	if m != nil {
		return m.SeasonId
	}
	return 0
}

func (m *SeriesSeasonProto) GetSeasonTitle() string {
	if m != nil {
		return m.SeasonTitle
	}
	return ""
}

func (m *SeriesSeasonProto) GetNewEp() *NewEpProto {
	if m != nil {
		return m.NewEp
	}
	return nil
}

// SeriesSeasonsProto season信息
type SeriesSeasonsProto struct {
	// seriesSeasons
	SeriesSeasons []*SeriesSeasonProto `protobuf:"bytes,1,rep,name=seriesSeasons" json:"seriesSeasons,omitempty"`
}

func (m *SeriesSeasonsProto) Reset()                    { *m = SeriesSeasonsProto{} }
func (m *SeriesSeasonsProto) String() string            { return proto.CompactTextString(m) }
func (*SeriesSeasonsProto) ProtoMessage()               {}
func (*SeriesSeasonsProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{9} }

func (m *SeriesSeasonsProto) GetSeriesSeasons() []*SeriesSeasonProto {
	if m != nil {
		return m.SeriesSeasons
	}
	return nil
}

// PublishProto publish信息
type PublishProto struct {
	// pub_time
	PubTime string `protobuf:"bytes,1,opt,name=pub_time,json=pubTime,proto3" json:"pub_time,omitempty"`
	// pub_time_show
	PubTimeShow string `protobuf:"bytes,2,opt,name=pub_time_show,json=pubTimeShow,proto3" json:"pub_time_show,omitempty"`
}

func (m *PublishProto) Reset()                    { *m = PublishProto{} }
func (m *PublishProto) String() string            { return proto.CompactTextString(m) }
func (*PublishProto) ProtoMessage()               {}
func (*PublishProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{10} }

func (m *PublishProto) GetPubTime() string {
	if m != nil {
		return m.PubTime
	}
	return ""
}

func (m *PublishProto) GetPubTimeShow() string {
	if m != nil {
		return m.PubTimeShow
	}
	return ""
}

// TimelineProto  时间表信息
type TimelineProto struct {
	// 日期
	Date string `protobuf:"bytes,1,opt,name=date,proto3" json:"date,omitempty"`
	// 日期时间戳
	DateTs int64 `protobuf:"varint,2,opt,name=date_ts,json=dateTs,proto3" json:"date_ts,omitempty"`
	// 周几
	DayOfWeek int32 `protobuf:"varint,3,opt,name=day_of_week,json=dayOfWeek,proto3" json:"day_of_week,omitempty"`
	// 是否是今天
	IsToday int32 `protobuf:"varint,4,opt,name=is_today,json=isToday,proto3" json:"is_today,omitempty"`
	// 该日期对应上线的剧集
	Episodes []*TimelineEpisodeProto `protobuf:"bytes,5,rep,name=episodes" json:"episodes,omitempty"`
}

func (m *TimelineProto) Reset()                    { *m = TimelineProto{} }
func (m *TimelineProto) String() string            { return proto.CompactTextString(m) }
func (*TimelineProto) ProtoMessage()               {}
func (*TimelineProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{11} }

func (m *TimelineProto) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *TimelineProto) GetDateTs() int64 {
	if m != nil {
		return m.DateTs
	}
	return 0
}

func (m *TimelineProto) GetDayOfWeek() int32 {
	if m != nil {
		return m.DayOfWeek
	}
	return 0
}

func (m *TimelineProto) GetIsToday() int32 {
	if m != nil {
		return m.IsToday
	}
	return 0
}

func (m *TimelineProto) GetEpisodes() []*TimelineEpisodeProto {
	if m != nil {
		return m.Episodes
	}
	return nil
}

// TimelineEpisodeProto  时间表下剧集信息
type TimelineEpisodeProto struct {
	// 分季封面
	Cover string `protobuf:"bytes,1,opt,name=cover,proto3" json:"cover,omitempty"`
	// 剧集id
	EpisodeId int32 `protobuf:"varint,2,opt,name=episode_id,json=episodeId,proto3" json:"episode_id,omitempty"`
	// 收藏数
	Favorites int64 `protobuf:"varint,3,opt,name=favorites,proto3" json:"favorites,omitempty"`
	// 是否收藏过
	Follow int32 `protobuf:"varint,4,opt,name=follow,proto3" json:"follow,omitempty"`
	// 是否已发布
	Published int32 `protobuf:"varint,5,opt,name=published,proto3" json:"published,omitempty"`
	// 第x话
	PubIndex string `protobuf:"bytes,6,opt,name=pub_index,json=pubIndex,proto3" json:"pub_index,omitempty"`
	// 发布时间
	PubTime string `protobuf:"bytes,7,opt,name=pub_time,json=pubTime,proto3" json:"pub_time,omitempty"`
	// 上线时间戳
	PubTs int64 `protobuf:"varint,8,opt,name=pub_ts,json=pubTs,proto3" json:"pub_ts,omitempty"`
	// 分季id
	SeasonId int32 `protobuf:"varint,9,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
	// 分季方图
	SquareCover string `protobuf:"bytes,10,opt,name=square_cover,json=squareCover,proto3" json:"square_cover,omitempty"`
	// 分季标题
	Title string `protobuf:"bytes,11,opt,name=title,proto3" json:"title,omitempty"`
	// 是否delay
	Delay int32 `protobuf:"varint,12,opt,name=delay,proto3" json:"delay,omitempty"`
	// delay id
	DelayId int32 `protobuf:"varint,13,opt,name=delay_id,json=delayId,proto3" json:"delay_id,omitempty"`
	// 停更原因
	DelayReason string `protobuf:"bytes,14,opt,name=delay_reason,json=delayReason,proto3" json:"delay_reason,omitempty"`
	// 停更那一话的短标题
	DelayIndex string `protobuf:"bytes,15,opt,name=delay_index,json=delayIndex,proto3" json:"delay_index,omitempty"`
}

func (m *TimelineEpisodeProto) Reset()                    { *m = TimelineEpisodeProto{} }
func (m *TimelineEpisodeProto) String() string            { return proto.CompactTextString(m) }
func (*TimelineEpisodeProto) ProtoMessage()               {}
func (*TimelineEpisodeProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{12} }

func (m *TimelineEpisodeProto) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *TimelineEpisodeProto) GetEpisodeId() int32 {
	if m != nil {
		return m.EpisodeId
	}
	return 0
}

func (m *TimelineEpisodeProto) GetFavorites() int64 {
	if m != nil {
		return m.Favorites
	}
	return 0
}

func (m *TimelineEpisodeProto) GetFollow() int32 {
	if m != nil {
		return m.Follow
	}
	return 0
}

func (m *TimelineEpisodeProto) GetPublished() int32 {
	if m != nil {
		return m.Published
	}
	return 0
}

func (m *TimelineEpisodeProto) GetPubIndex() string {
	if m != nil {
		return m.PubIndex
	}
	return ""
}

func (m *TimelineEpisodeProto) GetPubTime() string {
	if m != nil {
		return m.PubTime
	}
	return ""
}

func (m *TimelineEpisodeProto) GetPubTs() int64 {
	if m != nil {
		return m.PubTs
	}
	return 0
}

func (m *TimelineEpisodeProto) GetSeasonId() int32 {
	if m != nil {
		return m.SeasonId
	}
	return 0
}

func (m *TimelineEpisodeProto) GetSquareCover() string {
	if m != nil {
		return m.SquareCover
	}
	return ""
}

func (m *TimelineEpisodeProto) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *TimelineEpisodeProto) GetDelay() int32 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *TimelineEpisodeProto) GetDelayId() int32 {
	if m != nil {
		return m.DelayId
	}
	return 0
}

func (m *TimelineEpisodeProto) GetDelayReason() string {
	if m != nil {
		return m.DelayReason
	}
	return ""
}

func (m *TimelineEpisodeProto) GetDelayIndex() string {
	if m != nil {
		return m.DelayIndex
	}
	return ""
}

// EmptyProto
type EmptyProto struct {
}

func (m *EmptyProto) Reset()                    { *m = EmptyProto{} }
func (m *EmptyProto) String() string            { return proto.CompactTextString(m) }
func (*EmptyProto) ProtoMessage()               {}
func (*EmptyProto) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{13} }

func init() {
	proto.RegisterType((*CardInfoProto)(nil), "pgc.service.season.season.v1.CardInfoProto")
	proto.RegisterType((*ProfileInfoProto)(nil), "pgc.service.season.season.v1.ProfileInfoProto")
	proto.RegisterType((*RatingProto)(nil), "pgc.service.season.season.v1.RatingProto")
	proto.RegisterType((*NewEpProto)(nil), "pgc.service.season.season.v1.NewEpProto")
	proto.RegisterType((*StatsProto)(nil), "pgc.service.season.season.v1.StatsProto")
	proto.RegisterType((*RightsProto)(nil), "pgc.service.season.season.v1.RightsProto")
	proto.RegisterType((*SeriesProto)(nil), "pgc.service.season.season.v1.SeriesProto")
	proto.RegisterType((*SectionProto)(nil), "pgc.service.season.season.v1.SectionProto")
	proto.RegisterType((*SeriesSeasonProto)(nil), "pgc.service.season.season.v1.SeriesSeasonProto")
	proto.RegisterType((*SeriesSeasonsProto)(nil), "pgc.service.season.season.v1.SeriesSeasonsProto")
	proto.RegisterType((*PublishProto)(nil), "pgc.service.season.season.v1.PublishProto")
	proto.RegisterType((*TimelineProto)(nil), "pgc.service.season.season.v1.TimelineProto")
	proto.RegisterType((*TimelineEpisodeProto)(nil), "pgc.service.season.season.v1.TimelineEpisodeProto")
	proto.RegisterType((*EmptyProto)(nil), "pgc.service.season.season.v1.EmptyProto")
}
func (m *CardInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SeasonId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonId))
	}
	if m.MediaId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.MediaId))
	}
	if m.SeasonType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonType))
	}
	if len(m.SeasonTypeName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.SeasonTypeName)))
		i += copy(dAtA[i:], m.SeasonTypeName)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if m.TotalCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.TotalCount))
	}
	if m.IsFinish != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsFinish))
	}
	if m.IsStarted != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsStarted))
	}
	if m.IsPlay != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsPlay))
	}
	if len(m.Badge) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Badge)))
		i += copy(dAtA[i:], m.Badge)
	}
	if m.BadgeType != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.BadgeType))
	}
	if m.Rights != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Rights.Size()))
		n1, err := m.Rights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Stat != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Stat.Size()))
		n2, err := m.Stat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.NewEp != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NewEp.Size()))
		n3, err := m.NewEp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Rating != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Rating.Size()))
		n4, err := m.Rating.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.SquareCover) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.SquareCover)))
		i += copy(dAtA[i:], m.SquareCover)
	}
	if m.SeasonStatus != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonStatus))
	}
	if len(m.SeasonTitle) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.SeasonTitle)))
		i += copy(dAtA[i:], m.SeasonTitle)
	}
	return i, nil
}

func (m *ProfileInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfileInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SeasonId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonId))
	}
	if m.MediaId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.MediaId))
	}
	if m.SeasonType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonType))
	}
	if len(m.SeasonTypeName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.SeasonTypeName)))
		i += copy(dAtA[i:], m.SeasonTypeName)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if len(m.SquareCover) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.SquareCover)))
		i += copy(dAtA[i:], m.SquareCover)
	}
	if m.TotalCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.TotalCount))
	}
	if m.IsFinish != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsFinish))
	}
	if m.IsStarted != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsStarted))
	}
	if m.IsPlay != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsPlay))
	}
	if len(m.Badge) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Badge)))
		i += copy(dAtA[i:], m.Badge)
	}
	if m.BadgeType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.BadgeType))
	}
	if m.SeasonStatus != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonStatus))
	}
	if m.Rights != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Rights.Size()))
		n5, err := m.Rights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Stat != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Stat.Size()))
		n6, err := m.Stat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.NewEp != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NewEp.Size()))
		n7, err := m.NewEp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Rating != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Rating.Size()))
		n8, err := m.Rating.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Series != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Series.Size()))
		n9, err := m.Series.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Section) > 0 {
		for _, msg := range m.Section {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SeasonTitle) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.SeasonTitle)))
		i += copy(dAtA[i:], m.SeasonTitle)
	}
	if m.Mode != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mode))
	}
	if len(m.Evaluate) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Evaluate)))
		i += copy(dAtA[i:], m.Evaluate)
	}
	if m.Publish != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Publish.Size()))
		n10, err := m.Publish.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Mid != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mid))
	}
	if len(m.Record) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Record)))
		i += copy(dAtA[i:], m.Record)
	}
	if len(m.RenewalTime) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.RenewalTime)))
		i += copy(dAtA[i:], m.RenewalTime)
	}
	return i, nil
}

func (m *RatingProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RatingProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		dAtA[i] = 0xd
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Score))))
		i += 4
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *NewEpProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewEpProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Id))
	}
	if len(m.IndexShow) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.IndexShow)))
		i += copy(dAtA[i:], m.IndexShow)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.LongTitle) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.LongTitle)))
		i += copy(dAtA[i:], m.LongTitle)
	}
	if len(m.PubTime) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PubTime)))
		i += copy(dAtA[i:], m.PubTime)
	}
	return i, nil
}

func (m *StatsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Follow != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Follow))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.View))
	}
	if m.Danmaku != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Danmaku))
	}
	return i, nil
}

func (m *RightsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RightsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllowReview != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.AllowReview))
	}
	if m.AllowBp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.AllowBp))
	}
	if m.AllowDownload != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.AllowDownload))
	}
	if m.AllowPreview != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.AllowPreview))
	}
	return i, nil
}

func (m *SeriesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeriesProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SeriesId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeriesId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	return i, nil
}

func (m *SectionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SectionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SectionId))
	}
	if m.SeasonId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonId))
	}
	if m.LimitGroup != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.LimitGroup))
	}
	if m.WatchPlatform != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.WatchPlatform))
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Type))
	}
	if len(m.Copyright) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Copyright)))
		i += copy(dAtA[i:], m.Copyright)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.BanAreaShow != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.BanAreaShow))
	}
	return i, nil
}

func (m *SeriesSeasonProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeriesSeasonProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SeasonId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonId))
	}
	if len(m.SeasonTitle) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.SeasonTitle)))
		i += copy(dAtA[i:], m.SeasonTitle)
	}
	if m.NewEp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NewEp.Size()))
		n11, err := m.NewEp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *SeriesSeasonsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeriesSeasonsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SeriesSeasons) > 0 {
		for _, msg := range m.SeriesSeasons {
			dAtA[i] = 0xa
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PublishProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PubTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PubTime)))
		i += copy(dAtA[i:], m.PubTime)
	}
	if len(m.PubTimeShow) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PubTimeShow)))
		i += copy(dAtA[i:], m.PubTimeShow)
	}
	return i, nil
}

func (m *TimelineProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimelineProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Date) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	if m.DateTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.DateTs))
	}
	if m.DayOfWeek != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.DayOfWeek))
	}
	if m.IsToday != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsToday))
	}
	if len(m.Episodes) > 0 {
		for _, msg := range m.Episodes {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TimelineEpisodeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimelineEpisodeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cover) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if m.EpisodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.EpisodeId))
	}
	if m.Favorites != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Favorites))
	}
	if m.Follow != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Follow))
	}
	if m.Published != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Published))
	}
	if len(m.PubIndex) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PubIndex)))
		i += copy(dAtA[i:], m.PubIndex)
	}
	if len(m.PubTime) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PubTime)))
		i += copy(dAtA[i:], m.PubTime)
	}
	if m.PubTs != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.PubTs))
	}
	if m.SeasonId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SeasonId))
	}
	if len(m.SquareCover) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.SquareCover)))
		i += copy(dAtA[i:], m.SquareCover)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.Delay != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Delay))
	}
	if m.DelayId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.DelayId))
	}
	if len(m.DelayReason) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.DelayReason)))
		i += copy(dAtA[i:], m.DelayReason)
	}
	if len(m.DelayIndex) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.DelayIndex)))
		i += copy(dAtA[i:], m.DelayIndex)
	}
	return i, nil
}

func (m *EmptyProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintModel(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CardInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.SeasonId != 0 {
		n += 1 + sovModel(uint64(m.SeasonId))
	}
	if m.MediaId != 0 {
		n += 1 + sovModel(uint64(m.MediaId))
	}
	if m.SeasonType != 0 {
		n += 1 + sovModel(uint64(m.SeasonType))
	}
	l = len(m.SeasonTypeName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.TotalCount != 0 {
		n += 1 + sovModel(uint64(m.TotalCount))
	}
	if m.IsFinish != 0 {
		n += 1 + sovModel(uint64(m.IsFinish))
	}
	if m.IsStarted != 0 {
		n += 1 + sovModel(uint64(m.IsStarted))
	}
	if m.IsPlay != 0 {
		n += 1 + sovModel(uint64(m.IsPlay))
	}
	l = len(m.Badge)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.BadgeType != 0 {
		n += 1 + sovModel(uint64(m.BadgeType))
	}
	if m.Rights != nil {
		l = m.Rights.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Stat != nil {
		l = m.Stat.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.NewEp != nil {
		l = m.NewEp.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Rating != nil {
		l = m.Rating.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	l = len(m.SquareCover)
	if l > 0 {
		n += 2 + l + sovModel(uint64(l))
	}
	if m.SeasonStatus != 0 {
		n += 2 + sovModel(uint64(m.SeasonStatus))
	}
	l = len(m.SeasonTitle)
	if l > 0 {
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ProfileInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.SeasonId != 0 {
		n += 1 + sovModel(uint64(m.SeasonId))
	}
	if m.MediaId != 0 {
		n += 1 + sovModel(uint64(m.MediaId))
	}
	if m.SeasonType != 0 {
		n += 1 + sovModel(uint64(m.SeasonType))
	}
	l = len(m.SeasonTypeName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.SquareCover)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.TotalCount != 0 {
		n += 1 + sovModel(uint64(m.TotalCount))
	}
	if m.IsFinish != 0 {
		n += 1 + sovModel(uint64(m.IsFinish))
	}
	if m.IsStarted != 0 {
		n += 1 + sovModel(uint64(m.IsStarted))
	}
	if m.IsPlay != 0 {
		n += 1 + sovModel(uint64(m.IsPlay))
	}
	l = len(m.Badge)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.BadgeType != 0 {
		n += 1 + sovModel(uint64(m.BadgeType))
	}
	if m.SeasonStatus != 0 {
		n += 1 + sovModel(uint64(m.SeasonStatus))
	}
	if m.Rights != nil {
		l = m.Rights.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Stat != nil {
		l = m.Stat.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	if m.NewEp != nil {
		l = m.NewEp.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	if m.Rating != nil {
		l = m.Rating.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	if m.Series != nil {
		l = m.Series.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	if len(m.Section) > 0 {
		for _, e := range m.Section {
			l = e.Size()
			n += 2 + l + sovModel(uint64(l))
		}
	}
	l = len(m.SeasonTitle)
	if l > 0 {
		n += 2 + l + sovModel(uint64(l))
	}
	if m.Mode != 0 {
		n += 2 + sovModel(uint64(m.Mode))
	}
	l = len(m.Evaluate)
	if l > 0 {
		n += 2 + l + sovModel(uint64(l))
	}
	if m.Publish != nil {
		l = m.Publish.Size()
		n += 2 + l + sovModel(uint64(l))
	}
	if m.Mid != 0 {
		n += 2 + sovModel(uint64(m.Mid))
	}
	l = len(m.Record)
	if l > 0 {
		n += 2 + l + sovModel(uint64(l))
	}
	l = len(m.RenewalTime)
	if l > 0 {
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}

func (m *RatingProto) Size() (n int) {
	var l int
	_ = l
	if m.Score != 0 {
		n += 5
	}
	if m.Count != 0 {
		n += 1 + sovModel(uint64(m.Count))
	}
	return n
}

func (m *NewEpProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovModel(uint64(m.Id))
	}
	l = len(m.IndexShow)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.LongTitle)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.PubTime)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *StatsProto) Size() (n int) {
	var l int
	_ = l
	if m.Follow != 0 {
		n += 1 + sovModel(uint64(m.Follow))
	}
	if m.View != 0 {
		n += 1 + sovModel(uint64(m.View))
	}
	if m.Danmaku != 0 {
		n += 1 + sovModel(uint64(m.Danmaku))
	}
	return n
}

func (m *RightsProto) Size() (n int) {
	var l int
	_ = l
	if m.AllowReview != 0 {
		n += 1 + sovModel(uint64(m.AllowReview))
	}
	if m.AllowBp != 0 {
		n += 1 + sovModel(uint64(m.AllowBp))
	}
	if m.AllowDownload != 0 {
		n += 1 + sovModel(uint64(m.AllowDownload))
	}
	if m.AllowPreview != 0 {
		n += 1 + sovModel(uint64(m.AllowPreview))
	}
	return n
}

func (m *SeriesProto) Size() (n int) {
	var l int
	_ = l
	if m.SeriesId != 0 {
		n += 1 + sovModel(uint64(m.SeriesId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *SectionProto) Size() (n int) {
	var l int
	_ = l
	if m.SectionId != 0 {
		n += 1 + sovModel(uint64(m.SectionId))
	}
	if m.SeasonId != 0 {
		n += 1 + sovModel(uint64(m.SeasonId))
	}
	if m.LimitGroup != 0 {
		n += 1 + sovModel(uint64(m.LimitGroup))
	}
	if m.WatchPlatform != 0 {
		n += 1 + sovModel(uint64(m.WatchPlatform))
	}
	if m.Type != 0 {
		n += 1 + sovModel(uint64(m.Type))
	}
	l = len(m.Copyright)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.BanAreaShow != 0 {
		n += 1 + sovModel(uint64(m.BanAreaShow))
	}
	return n
}

func (m *SeriesSeasonProto) Size() (n int) {
	var l int
	_ = l
	if m.SeasonId != 0 {
		n += 1 + sovModel(uint64(m.SeasonId))
	}
	l = len(m.SeasonTitle)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.NewEp != nil {
		l = m.NewEp.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *SeriesSeasonsProto) Size() (n int) {
	var l int
	_ = l
	if len(m.SeriesSeasons) > 0 {
		for _, e := range m.SeriesSeasons {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *PublishProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.PubTime)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.PubTimeShow)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *TimelineProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.DateTs != 0 {
		n += 1 + sovModel(uint64(m.DateTs))
	}
	if m.DayOfWeek != 0 {
		n += 1 + sovModel(uint64(m.DayOfWeek))
	}
	if m.IsToday != 0 {
		n += 1 + sovModel(uint64(m.IsToday))
	}
	if len(m.Episodes) > 0 {
		for _, e := range m.Episodes {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *TimelineEpisodeProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.EpisodeId != 0 {
		n += 1 + sovModel(uint64(m.EpisodeId))
	}
	if m.Favorites != 0 {
		n += 1 + sovModel(uint64(m.Favorites))
	}
	if m.Follow != 0 {
		n += 1 + sovModel(uint64(m.Follow))
	}
	if m.Published != 0 {
		n += 1 + sovModel(uint64(m.Published))
	}
	l = len(m.PubIndex)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.PubTime)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.PubTs != 0 {
		n += 1 + sovModel(uint64(m.PubTs))
	}
	if m.SeasonId != 0 {
		n += 1 + sovModel(uint64(m.SeasonId))
	}
	l = len(m.SquareCover)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Delay != 0 {
		n += 1 + sovModel(uint64(m.Delay))
	}
	if m.DelayId != 0 {
		n += 1 + sovModel(uint64(m.DelayId))
	}
	l = len(m.DelayReason)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.DelayIndex)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *EmptyProto) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovModel(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CardInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaId", wireType)
			}
			m.MediaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonType", wireType)
			}
			m.SeasonType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeasonTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFinish", wireType)
			}
			m.IsFinish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFinish |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStarted", wireType)
			}
			m.IsStarted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsStarted |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPlay", wireType)
			}
			m.IsPlay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPlay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Badge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeType", wireType)
			}
			m.BadgeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadgeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rights == nil {
				m.Rights = &RightsProto{}
			}
			if err := m.Rights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stat == nil {
				m.Stat = &StatsProto{}
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewEp == nil {
				m.NewEp = &NewEpProto{}
			}
			if err := m.NewEp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rating", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rating == nil {
				m.Rating = &RatingProto{}
			}
			if err := m.Rating.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SquareCover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SquareCover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonStatus", wireType)
			}
			m.SeasonStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeasonTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfileInfoProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfileInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfileInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaId", wireType)
			}
			m.MediaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonType", wireType)
			}
			m.SeasonType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeasonTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SquareCover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SquareCover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFinish", wireType)
			}
			m.IsFinish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFinish |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStarted", wireType)
			}
			m.IsStarted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsStarted |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPlay", wireType)
			}
			m.IsPlay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsPlay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Badge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadgeType", wireType)
			}
			m.BadgeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadgeType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonStatus", wireType)
			}
			m.SeasonStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rights == nil {
				m.Rights = &RightsProto{}
			}
			if err := m.Rights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stat == nil {
				m.Stat = &StatsProto{}
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewEp == nil {
				m.NewEp = &NewEpProto{}
			}
			if err := m.NewEp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rating", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rating == nil {
				m.Rating = &RatingProto{}
			}
			if err := m.Rating.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Series == nil {
				m.Series = &SeriesProto{}
			}
			if err := m.Series.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Section", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Section = append(m.Section, &SectionProto{})
			if err := m.Section[len(m.Section)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeasonTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evaluate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Evaluate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Publish == nil {
				m.Publish = &PublishProto{}
			}
			if err := m.Publish.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Record = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenewalTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RenewalTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RatingProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RatingProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RatingProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewEpProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewEpProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewEpProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexShow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexShow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LongTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			m.Follow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Follow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Danmaku", wireType)
			}
			m.Danmaku = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Danmaku |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RightsProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RightsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RightsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowReview", wireType)
			}
			m.AllowReview = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowReview |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowBp", wireType)
			}
			m.AllowBp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowBp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDownload", wireType)
			}
			m.AllowDownload = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowDownload |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPreview", wireType)
			}
			m.AllowPreview = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowPreview |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeriesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesId", wireType)
			}
			m.SeriesId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeriesId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SectionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitGroup", wireType)
			}
			m.LimitGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitGroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WatchPlatform", wireType)
			}
			m.WatchPlatform = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WatchPlatform |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Copyright", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Copyright = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BanAreaShow", wireType)
			}
			m.BanAreaShow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BanAreaShow |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeriesSeasonProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesSeasonProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesSeasonProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeasonTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewEp == nil {
				m.NewEp = &NewEpProto{}
			}
			if err := m.NewEp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeriesSeasonsProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesSeasonsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesSeasonsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesSeasons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeriesSeasons = append(m.SeriesSeasons, &SeriesSeasonProto{})
			if err := m.SeriesSeasons[len(m.SeriesSeasons)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubTimeShow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubTimeShow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimelineProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimelineProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimelineProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTs", wireType)
			}
			m.DateTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayOfWeek", wireType)
			}
			m.DayOfWeek = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DayOfWeek |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsToday", wireType)
			}
			m.IsToday = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsToday |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Episodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Episodes = append(m.Episodes, &TimelineEpisodeProto{})
			if err := m.Episodes[len(m.Episodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimelineEpisodeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimelineEpisodeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimelineEpisodeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpisodeId", wireType)
			}
			m.EpisodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpisodeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Favorites", wireType)
			}
			m.Favorites = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Favorites |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			m.Follow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Follow |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Published", wireType)
			}
			m.Published = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Published |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubTs", wireType)
			}
			m.PubTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubTs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SquareCover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SquareCover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			m.Delay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayId", wireType)
			}
			m.DelayId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelayReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelayIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModel
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModel(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModel = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/pgc-season/api/grpc/season/v1/model.proto", fileDescriptorModel)
}

var fileDescriptorModel = []byte{
	// 1347 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0xcb, 0x6e, 0x23, 0x45,
	0x14, 0x55, 0xdb, 0xf1, 0xa3, 0x6f, 0xdb, 0x99, 0x4c, 0x33, 0x8f, 0x9e, 0x57, 0x26, 0x34, 0x42,
	0x32, 0x23, 0x11, 0x6b, 0x86, 0x15, 0x12, 0x02, 0xe6, 0x05, 0xf2, 0x82, 0xc1, 0xea, 0x04, 0x21,
	0xb1, 0x69, 0x95, 0x5d, 0x65, 0xa7, 0x94, 0x76, 0x57, 0xd3, 0xd5, 0xb6, 0xf1, 0x7f, 0x20, 0xb1,
	0x66, 0xc7, 0x2f, 0xf0, 0x05, 0xb0, 0x64, 0xcb, 0x0e, 0xcd, 0x87, 0x20, 0x74, 0x6f, 0x95, 0xd3,
	0xed, 0x24, 0x93, 0x89, 0x26, 0x2b, 0x56, 0xae, 0x7b, 0xaa, 0xea, 0x76, 0xdd, 0xc7, 0x39, 0x55,
	0x86, 0x67, 0x2c, 0xcb, 0xfa, 0x5a, 0xe4, 0x0b, 0x39, 0x16, 0x7d, 0x95, 0x89, 0x34, 0x4b, 0x58,
	0x31, 0x51, 0xf9, 0xac, 0x9f, 0x4d, 0xc7, 0x1f, 0x6b, 0xc1, 0xb4, 0x4a, 0xfb, 0x2c, 0x93, 0xfd,
	0x69, 0x9e, 0x8d, 0xfb, 0xd6, 0x5e, 0x3c, 0xee, 0xcf, 0x14, 0x17, 0xc9, 0x7e, 0x96, 0xab, 0x42,
	0xf9, 0xf7, 0xb3, 0xe9, 0x78, 0xdf, 0xfa, 0xd8, 0x37, 0x4b, 0xd6, 0x3f, 0x8b, 0xc7, 0xe1, 0xdf,
	0x0d, 0xe8, 0x3e, 0x67, 0x39, 0x1f, 0xa4, 0x13, 0x35, 0xa4, 0xf5, 0xf7, 0xc0, 0x35, 0xd3, 0xb1,
	0xe4, 0x81, 0xb3, 0xe7, 0xf4, 0x1a, 0x51, 0xdb, 0x00, 0x03, 0xee, 0xdf, 0x81, 0xf6, 0x4c, 0x70,
	0xc9, 0x70, 0xae, 0x46, 0x73, 0x2d, 0xb2, 0x07, 0xdc, 0x7f, 0x08, 0x9e, 0xdd, 0x57, 0xac, 0x32,
	0x11, 0xd4, 0x69, 0x16, 0x0c, 0x74, 0xb8, 0xca, 0x84, 0xdf, 0x83, 0x9d, 0xca, 0x82, 0x38, 0x65,
	0x33, 0x11, 0x6c, 0xed, 0x39, 0x3d, 0x37, 0xda, 0x2e, 0x57, 0xbd, 0x62, 0x33, 0xe1, 0xdf, 0x80,
	0x46, 0x21, 0x8b, 0x44, 0x04, 0x0d, 0x9a, 0x36, 0x06, 0xa2, 0x63, 0xb5, 0x10, 0x79, 0xd0, 0x34,
	0x28, 0x19, 0xf8, 0xd9, 0x42, 0x15, 0x2c, 0x89, 0xc7, 0x6a, 0x9e, 0x16, 0x41, 0xcb, 0x7c, 0x96,
	0xa0, 0xe7, 0x88, 0x60, 0x3c, 0x52, 0xc7, 0x13, 0x99, 0x4a, 0x7d, 0x14, 0xb4, 0x4d, 0x3c, 0x52,
	0x7f, 0x45, 0xb6, 0xff, 0x00, 0x40, 0xea, 0x58, 0x17, 0x2c, 0x2f, 0x04, 0x0f, 0x5c, 0x9a, 0x75,
	0xa5, 0x3e, 0x30, 0x80, 0x7f, 0x1b, 0x5a, 0x52, 0xc7, 0x59, 0xc2, 0x56, 0x01, 0xd0, 0x5c, 0x53,
	0xea, 0x61, 0xc2, 0x56, 0x78, 0x96, 0x11, 0xe3, 0x53, 0x11, 0x78, 0xe6, 0x2c, 0x64, 0xa0, 0x37,
	0x1a, 0x98, 0x0c, 0x74, 0x8c, 0x37, 0x42, 0x28, 0x01, 0x4f, 0xa1, 0x99, 0xcb, 0xe9, 0x51, 0xa1,
	0x83, 0xee, 0x9e, 0xd3, 0xf3, 0x9e, 0x7c, 0xb4, 0x7f, 0x51, 0x69, 0xf6, 0x23, 0x5a, 0x4b, 0x45,
	0x89, 0xec, 0x46, 0xff, 0x33, 0xd8, 0xd2, 0x05, 0x2b, 0x82, 0x6d, 0x72, 0xd0, 0xbb, 0xd8, 0xc1,
	0x41, 0xc1, 0xd6, 0xfb, 0x69, 0x97, 0xff, 0x05, 0x34, 0x53, 0xb1, 0x8c, 0x45, 0x16, 0x5c, 0xbb,
	0xcc, 0xfe, 0x57, 0x62, 0xf9, 0x32, 0x33, 0xfb, 0x1b, 0x29, 0x8e, 0x29, 0x02, 0x56, 0xc8, 0x74,
	0x1a, 0xec, 0x5c, 0x2a, 0x02, 0x5a, 0xbb, 0x8e, 0x80, 0x0c, 0xff, 0x7d, 0xe8, 0xe8, 0x1f, 0xe7,
	0x2c, 0x17, 0xb1, 0x29, 0xe6, 0x75, 0x4a, 0xa0, 0x67, 0xb0, 0xe7, 0x54, 0xd2, 0x0f, 0xa0, 0x6b,
	0x1b, 0x05, 0x4f, 0x3d, 0xd7, 0x81, 0x4f, 0x99, 0xec, 0x18, 0xf0, 0x80, 0x30, 0xf2, 0x63, 0xbb,
	0x89, 0x5a, 0xe5, 0x3d, 0xeb, 0xc7, 0x74, 0x12, 0x42, 0xe1, 0x6f, 0x6d, 0xd8, 0x19, 0xe6, 0x6a,
	0x22, 0x13, 0xf1, 0xbf, 0x6d, 0xef, 0xd3, 0xe9, 0x6a, 0x9d, 0x4d, 0xd7, 0x29, 0x06, 0xb4, 0x2f,
	0x66, 0x80, 0x7b, 0x21, 0x03, 0xe0, 0x02, 0x06, 0x78, 0xe7, 0x33, 0xa0, 0xf3, 0x66, 0x06, 0x74,
	0x4f, 0x33, 0xe0, 0x4c, 0x65, 0xb7, 0xcf, 0xa9, 0x6c, 0x49, 0x93, 0x6b, 0x57, 0xa5, 0xc9, 0xce,
	0x15, 0x69, 0x72, 0xfd, 0xaa, 0x34, 0xf1, 0xdf, 0x95, 0x26, 0x4f, 0xa1, 0xa9, 0x45, 0x2e, 0x85,
	0xa6, 0xc6, 0x7e, 0xab, 0x8b, 0x03, 0x5a, 0x6b, 0x5d, 0x98, 0x8d, 0xfe, 0x0b, 0x68, 0x69, 0x31,
	0x2e, 0xa4, 0x4a, 0x83, 0x1b, 0x7b, 0xf5, 0x9e, 0xf7, 0xe4, 0xd1, 0xdb, 0x7c, 0xd0, 0x62, 0xe3,
	0x64, 0xbd, 0xf5, 0x0c, 0xcf, 0x6e, 0x9e, 0xe1, 0x99, 0xef, 0xc3, 0x16, 0x5e, 0x38, 0xc1, 0x2d,
	0x2a, 0x26, 0x8d, 0xfd, 0xbb, 0xd0, 0x16, 0x0b, 0x96, 0xcc, 0x59, 0x21, 0x82, 0xdb, 0xb4, 0xe5,
	0xc4, 0xc6, 0x83, 0x65, 0xf3, 0x51, 0x82, 0xdd, 0x18, 0x50, 0x70, 0x6f, 0x39, 0xd8, 0xd0, 0x2c,
	0xb6, 0x07, 0xb3, 0x5b, 0xfd, 0x1d, 0xa8, 0xcf, 0x24, 0x0f, 0xee, 0xec, 0x39, 0xbd, 0x7a, 0x84,
	0x43, 0xff, 0x16, 0x34, 0x73, 0x31, 0x56, 0x39, 0x0f, 0xee, 0xd2, 0x17, 0xad, 0x85, 0x21, 0xe4,
	0x22, 0x15, 0x4b, 0x96, 0xc4, 0x85, 0x9c, 0x89, 0xe0, 0x9e, 0x09, 0xc1, 0x62, 0x87, 0x72, 0x26,
	0xc2, 0x4f, 0xc1, 0xab, 0x54, 0x01, 0x9b, 0x5b, 0x8f, 0x55, 0x2e, 0x48, 0x20, 0x6a, 0x91, 0x31,
	0x0c, 0x43, 0x91, 0x62, 0x46, 0x1a, 0x8c, 0x11, 0xfe, 0xea, 0x00, 0x94, 0x2d, 0xe0, 0x6f, 0x43,
	0xed, 0x44, 0x58, 0x6a, 0x92, 0x13, 0xbf, 0x52, 0x2e, 0x7e, 0x8a, 0xf5, 0x91, 0x5a, 0xd2, 0x4e,
	0x37, 0x72, 0x09, 0x39, 0x38, 0x52, 0xcb, 0x92, 0xf5, 0xf5, 0x2a, 0xeb, 0x4f, 0x14, 0x62, 0xab,
	0xaa, 0x10, 0x0f, 0x00, 0x12, 0x95, 0x4e, 0xe3, 0xaa, 0x78, 0xb8, 0x88, 0x98, 0x32, 0xdc, 0x81,
	0x76, 0x36, 0x1f, 0x99, 0x10, 0x8d, 0x86, 0x60, 0xae, 0x28, 0xbc, 0x08, 0xa0, 0xec, 0x72, 0xcc,
	0xd3, 0x44, 0x25, 0x89, 0x5a, 0xd2, 0x31, 0xeb, 0x91, 0xb5, 0xb0, 0x8e, 0x0b, 0x29, 0xcc, 0x21,
	0xeb, 0x11, 0x8d, 0xfd, 0x00, 0x5a, 0x9c, 0xa5, 0x33, 0x76, 0x3c, 0xa7, 0x13, 0xd6, 0xa3, 0xb5,
	0x19, 0xfe, 0xe2, 0x80, 0x57, 0xe1, 0x1e, 0x66, 0x99, 0xa1, 0x9b, 0x38, 0x17, 0xe4, 0xc5, 0xa4,
	0xc0, 0x23, 0x2c, 0x22, 0x08, 0x4f, 0x68, 0x96, 0x8c, 0xb2, 0xb5, 0xbc, 0x92, 0xfd, 0x2c, 0xf3,
	0x3f, 0x84, 0x6d, 0x33, 0xc5, 0xd5, 0x32, 0x4d, 0x14, 0xe3, 0x56, 0x61, 0xbb, 0x84, 0xbe, 0xb0,
	0x20, 0x0a, 0x88, 0x59, 0x96, 0xd9, 0xaf, 0x6c, 0x19, 0x01, 0x21, 0x70, 0x68, 0xb0, 0xf0, 0x4b,
	0xf0, 0x2a, 0x7c, 0x30, 0x8a, 0x8f, 0xe6, 0x86, 0xe2, 0x23, 0x30, 0xe0, 0x65, 0xa6, 0x6b, 0x95,
	0x4c, 0x87, 0xff, 0x3a, 0xd0, 0xa9, 0xd2, 0x01, 0x53, 0x6f, 0x09, 0x51, 0x3a, 0x71, 0x2d, 0x32,
	0xe0, 0x9b, 0x97, 0x4a, 0xed, 0xd4, 0xa5, 0xf2, 0x10, 0xbc, 0x44, 0xce, 0x64, 0x11, 0x4f, 0x73,
	0x35, 0xcf, 0xd6, 0x37, 0x07, 0x41, 0x5f, 0x23, 0x82, 0xb1, 0x2f, 0x59, 0x31, 0x3e, 0x8a, 0xd7,
	0xaf, 0x3b, 0x1b, 0x55, 0x97, 0xd0, 0xa1, 0x05, 0xb1, 0x3c, 0xa4, 0xaa, 0x0d, 0x43, 0x33, 0x1c,
	0xfb, 0xf7, 0xc1, 0x1d, 0xab, 0x6c, 0x45, 0xb2, 0x67, 0x8b, 0x5e, 0x02, 0x65, 0x70, 0xad, 0x6a,
	0x1b, 0x85, 0xd0, 0x1d, 0xb1, 0x34, 0x66, 0xb9, 0x60, 0xa6, 0x29, 0xcd, 0x8d, 0xe1, 0x8d, 0x58,
	0xfa, 0x34, 0x17, 0x0c, 0xdb, 0x32, 0xfc, 0xd9, 0x81, 0xeb, 0x26, 0x87, 0x07, 0x14, 0xc6, 0x25,
	0xee, 0xce, 0xd3, 0x42, 0x51, 0x3b, 0x2b, 0x14, 0xa5, 0xb0, 0xd6, 0xdf, 0x49, 0x58, 0xc3, 0x63,
	0xf0, 0xab, 0xa7, 0xb2, 0x05, 0xfe, 0x0e, 0x6f, 0x95, 0x0a, 0x1a, 0x38, 0x24, 0x77, 0xfd, 0xcb,
	0x48, 0x66, 0x25, 0xbc, 0x68, 0xd3, 0x4b, 0xf8, 0x0d, 0x74, 0xaa, 0xca, 0xb3, 0xc1, 0x2f, 0x67,
	0x83, 0x5f, 0x98, 0xd2, 0xf5, 0x54, 0x95, 0xe7, 0x9e, 0x9d, 0xa7, 0x94, 0xfe, 0xe1, 0x40, 0x17,
	0x8d, 0x44, 0xa6, 0xc2, 0x38, 0xf4, 0x61, 0x8b, 0xa3, 0x3e, 0x1a, 0x67, 0x34, 0xc6, 0xfb, 0x16,
	0x7f, 0xe3, 0x42, 0x5b, 0x1a, 0x36, 0xd1, 0x3c, 0xd4, 0xfe, 0x2e, 0x78, 0x9c, 0xad, 0x62, 0x35,
	0x89, 0x97, 0x42, 0x1c, 0xdb, 0x2e, 0x72, 0x39, 0x5b, 0x7d, 0x3b, 0xf9, 0x5e, 0x88, 0x63, 0x3c,
	0x9d, 0xd4, 0x71, 0xa1, 0x38, 0x5b, 0xd9, 0xf6, 0x69, 0x49, 0x7d, 0x88, 0xa6, 0xff, 0x0a, 0xda,
	0x22, 0x93, 0x5a, 0x71, 0xa1, 0x83, 0x06, 0xa5, 0xe6, 0xc9, 0xc5, 0xa9, 0x59, 0x1f, 0xf3, 0xa5,
	0xd9, 0x65, 0xb2, 0x73, 0xe2, 0x23, 0xfc, 0xbd, 0x0e, 0x37, 0xce, 0x5b, 0x52, 0x8a, 0x99, 0x53,
	0x15, 0xb3, 0x07, 0x00, 0x76, 0x6b, 0xc9, 0x0e, 0xd7, 0x22, 0x03, 0x8e, 0x2d, 0x3c, 0x61, 0x0b,
	0x95, 0xcb, 0x42, 0x68, 0xab, 0x31, 0x25, 0x50, 0xd1, 0x2a, 0x13, 0xd4, 0x5a, 0xab, 0xee, 0x83,
	0x6b, 0x2f, 0x02, 0xc1, 0x2d, 0x23, 0x4a, 0x00, 0x1b, 0x15, 0xeb, 0x41, 0x32, 0x6b, 0x69, 0x81,
	0xb5, 0x1b, 0xa0, 0xbd, 0x51, 0xc7, 0xd6, 0x66, 0x1d, 0x6f, 0x42, 0x93, 0xa6, 0x34, 0x71, 0xa2,
	0x1e, 0x35, 0x70, 0x42, 0x6f, 0xf6, 0xbd, 0x7b, 0x4e, 0xdf, 0x57, 0x5f, 0x68, 0x70, 0xf6, 0x85,
	0x76, 0xc2, 0x43, 0xef, 0xd4, 0x83, 0x8f, 0x0b, 0x7c, 0x58, 0x99, 0x3f, 0x0a, 0xc6, 0xc0, 0xd3,
	0xd1, 0x00, 0x3f, 0x65, 0xde, 0x4f, 0x2d, 0xb2, 0xcd, 0x97, 0xcc, 0x54, 0x4e, 0xdf, 0xa6, 0xc7,
	0x93, 0x1b, 0x79, 0x84, 0x45, 0x04, 0xa1, 0xd6, 0xd8, 0xdd, 0x14, 0xfa, 0x35, 0x5a, 0x01, 0xc6,
	0x01, 0x22, 0x61, 0x07, 0xe0, 0xe5, 0x2c, 0x2b, 0x56, 0x54, 0xb0, 0x67, 0x9f, 0xff, 0xf9, 0x7a,
	0xd7, 0xf9, 0xeb, 0xf5, 0xae, 0xf3, 0xcf, 0xeb, 0x5d, 0x07, 0x1e, 0x65, 0x89, 0x90, 0x8c, 0x0b,
	0xbd, 0x3f, 0x9a, 0x6b, 0x99, 0x0a, 0xad, 0xdf, 0xd8, 0x22, 0x43, 0xe7, 0x87, 0xda, 0xe2, 0xf1,
	0xa8, 0x49, 0x7f, 0x31, 0x3f, 0xf9, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x3e, 0x2c, 0x0f, 0xb0, 0xa8,
	0x0e, 0x00, 0x00,
}
