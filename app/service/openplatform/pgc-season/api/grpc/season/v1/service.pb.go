// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/openplatform/pgc-season/api/grpc/season/v1/service.proto

/*
	Package v1 is a generated protocol buffer package.

	It is generated from these files:
		app/service/openplatform/pgc-season/api/grpc/season/v1/service.proto
		app/service/openplatform/pgc-season/api/grpc/season/v1/model.proto

	It has these top-level messages:
		SeasonInfoReq
		CardsInfoReply
		SeasonIdReq
		ProfileInfoReply
		SeasonAidReq
		SectionReq
		SectionReply
		SeriesSeasonReq
		SeriesSeasonReply
		TimelineReq
		TimelineReply
		CardInfoProto
		ProfileInfoProto
		RatingProto
		NewEpProto
		StatsProto
		RightsProto
		SeriesProto
		SectionProto
		SeriesSeasonProto
		SeriesSeasonsProto
		PublishProto
		TimelineProto
		TimelineEpisodeProto
		EmptyProto
*/
package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// SeasonInfoReq season请求参数
type SeasonInfoReq struct {
	// season_ids
	SeasonIds []int32 `protobuf:"varint,1,rep,packed,name=season_ids,json=seasonIds" json:"season_ids,omitempty"`
}

func (m *SeasonInfoReq) Reset()                    { *m = SeasonInfoReq{} }
func (m *SeasonInfoReq) String() string            { return proto.CompactTextString(m) }
func (*SeasonInfoReq) ProtoMessage()               {}
func (*SeasonInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{0} }

func (m *SeasonInfoReq) GetSeasonIds() []int32 {
	if m != nil {
		return m.SeasonIds
	}
	return nil
}

// CardsInfoReply 卡片列表返回值
type CardsInfoReply struct {
	// cards
	Cards map[int32]*CardInfoProto `protobuf:"bytes,1,rep,name=cards" json:"cards,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CardsInfoReply) Reset()                    { *m = CardsInfoReply{} }
func (m *CardsInfoReply) String() string            { return proto.CompactTextString(m) }
func (*CardsInfoReply) ProtoMessage()               {}
func (*CardsInfoReply) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{1} }

func (m *CardsInfoReply) GetCards() map[int32]*CardInfoProto {
	if m != nil {
		return m.Cards
	}
	return nil
}

// SeasonIdReq season请求参数
type SeasonIdReq struct {
	// season_id
	SeasonId int32 `protobuf:"varint,1,opt,name=season_id,json=seasonId,proto3" json:"season_id,omitempty"`
}

func (m *SeasonIdReq) Reset()                    { *m = SeasonIdReq{} }
func (m *SeasonIdReq) String() string            { return proto.CompactTextString(m) }
func (*SeasonIdReq) ProtoMessage()               {}
func (*SeasonIdReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{2} }

func (m *SeasonIdReq) GetSeasonId() int32 {
	if m != nil {
		return m.SeasonId
	}
	return 0
}

// ProfileInfoReply 详情返回值
type ProfileInfoReply struct {
	// prfile
	Profile *ProfileInfoProto `protobuf:"bytes,1,opt,name=profile" json:"profile,omitempty"`
}

func (m *ProfileInfoReply) Reset()                    { *m = ProfileInfoReply{} }
func (m *ProfileInfoReply) String() string            { return proto.CompactTextString(m) }
func (*ProfileInfoReply) ProtoMessage()               {}
func (*ProfileInfoReply) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{3} }

func (m *ProfileInfoReply) GetProfile() *ProfileInfoProto {
	if m != nil {
		return m.Profile
	}
	return nil
}

// SeasonAidReq aids请求参数
type SeasonAidReq struct {
	// aids
	Aids []int32 `protobuf:"varint,1,rep,packed,name=aids" json:"aids,omitempty"`
}

func (m *SeasonAidReq) Reset()                    { *m = SeasonAidReq{} }
func (m *SeasonAidReq) String() string            { return proto.CompactTextString(m) }
func (*SeasonAidReq) ProtoMessage()               {}
func (*SeasonAidReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{4} }

func (m *SeasonAidReq) GetAids() []int32 {
	if m != nil {
		return m.Aids
	}
	return nil
}

// SectionReq 请求参数
type SectionReq struct {
	// season_ids
	SeasonIds []int32 `protobuf:"varint,1,rep,packed,name=season_ids,json=seasonIds" json:"season_ids,omitempty"`
}

func (m *SectionReq) Reset()                    { *m = SectionReq{} }
func (m *SectionReq) String() string            { return proto.CompactTextString(m) }
func (*SectionReq) ProtoMessage()               {}
func (*SectionReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{5} }

func (m *SectionReq) GetSeasonIds() []int32 {
	if m != nil {
		return m.SeasonIds
	}
	return nil
}

// SectionReply 分节信息返回值
type SectionReply struct {
	// sections
	Sections map[int32]*SectionProto `protobuf:"bytes,1,rep,name=sections" json:"sections,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SectionReply) Reset()                    { *m = SectionReply{} }
func (m *SectionReply) String() string            { return proto.CompactTextString(m) }
func (*SectionReply) ProtoMessage()               {}
func (*SectionReply) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{6} }

func (m *SectionReply) GetSections() map[int32]*SectionProto {
	if m != nil {
		return m.Sections
	}
	return nil
}

// SeriesReq 请求参数
type SeriesSeasonReq struct {
	// series_ids
	SeriesIds []int32 `protobuf:"varint,1,rep,packed,name=series_ids,json=seriesIds" json:"series_ids,omitempty"`
}

func (m *SeriesSeasonReq) Reset()                    { *m = SeriesSeasonReq{} }
func (m *SeriesSeasonReq) String() string            { return proto.CompactTextString(m) }
func (*SeriesSeasonReq) ProtoMessage()               {}
func (*SeriesSeasonReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{7} }

func (m *SeriesSeasonReq) GetSeriesIds() []int32 {
	if m != nil {
		return m.SeriesIds
	}
	return nil
}

// SeriesReply series
type SeriesSeasonReply struct {
	// seriesSeason
	Seasons map[int32]*SeriesSeasonsProto `protobuf:"bytes,1,rep,name=seasons" json:"seasons,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SeriesSeasonReply) Reset()                    { *m = SeriesSeasonReply{} }
func (m *SeriesSeasonReply) String() string            { return proto.CompactTextString(m) }
func (*SeriesSeasonReply) ProtoMessage()               {}
func (*SeriesSeasonReply) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{8} }

func (m *SeriesSeasonReply) GetSeasons() map[int32]*SeriesSeasonsProto {
	if m != nil {
		return m.Seasons
	}
	return nil
}

// TimelineReq  时间表请求参数
type TimelineReq struct {
	// 开始时间戳
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// 结束时间戳
	End int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	// 类型
	Types []int32 `protobuf:"varint,3,rep,packed,name=types" json:"types,omitempty"`
	// 排序方式，默认0，按照更新时间正序，1表示按照更新时间倒序
	Sort int32 `protobuf:"varint,4,opt,name=sort,proto3" json:"sort,omitempty"`
}

func (m *TimelineReq) Reset()                    { *m = TimelineReq{} }
func (m *TimelineReq) String() string            { return proto.CompactTextString(m) }
func (*TimelineReq) ProtoMessage()               {}
func (*TimelineReq) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{9} }

func (m *TimelineReq) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *TimelineReq) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *TimelineReq) GetTypes() []int32 {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *TimelineReq) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

// TimelineReply  时间表返回
type TimelineReply struct {
	Timeline []*TimelineProto `protobuf:"bytes,1,rep,name=timeline" json:"timeline,omitempty"`
}

func (m *TimelineReply) Reset()                    { *m = TimelineReply{} }
func (m *TimelineReply) String() string            { return proto.CompactTextString(m) }
func (*TimelineReply) ProtoMessage()               {}
func (*TimelineReply) Descriptor() ([]byte, []int) { return fileDescriptorService, []int{10} }

func (m *TimelineReply) GetTimeline() []*TimelineProto {
	if m != nil {
		return m.Timeline
	}
	return nil
}

func init() {
	proto.RegisterType((*SeasonInfoReq)(nil), "pgc.service.season.season.v1.SeasonInfoReq")
	proto.RegisterType((*CardsInfoReply)(nil), "pgc.service.season.season.v1.CardsInfoReply")
	proto.RegisterType((*SeasonIdReq)(nil), "pgc.service.season.season.v1.SeasonIdReq")
	proto.RegisterType((*ProfileInfoReply)(nil), "pgc.service.season.season.v1.ProfileInfoReply")
	proto.RegisterType((*SeasonAidReq)(nil), "pgc.service.season.season.v1.SeasonAidReq")
	proto.RegisterType((*SectionReq)(nil), "pgc.service.season.season.v1.SectionReq")
	proto.RegisterType((*SectionReply)(nil), "pgc.service.season.season.v1.SectionReply")
	proto.RegisterType((*SeriesSeasonReq)(nil), "pgc.service.season.season.v1.SeriesSeasonReq")
	proto.RegisterType((*SeriesSeasonReply)(nil), "pgc.service.season.season.v1.SeriesSeasonReply")
	proto.RegisterType((*TimelineReq)(nil), "pgc.service.season.season.v1.TimelineReq")
	proto.RegisterType((*TimelineReply)(nil), "pgc.service.season.season.v1.TimelineReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Season service

type SeasonClient interface {
	// 根据season_ids返回卡片信息
	Cards(ctx context.Context, in *SeasonInfoReq, opts ...grpc.CallOption) (*CardsInfoReply, error)
	// 根据aids返回卡片信息
	CardsByAids(ctx context.Context, in *SeasonAidReq, opts ...grpc.CallOption) (*CardsInfoReply, error)
	// 根据season_id返回详情
	Profile(ctx context.Context, in *SeasonIdReq, opts ...grpc.CallOption) (*ProfileInfoReply, error)
	// 根据开始结束时间和type获取时间表信息
	Timeline(ctx context.Context, in *TimelineReq, opts ...grpc.CallOption) (*TimelineReply, error)
	// 根据season_ids返回分节信息
	Sections(ctx context.Context, in *SectionReq, opts ...grpc.CallOption) (*SectionReply, error)
	// 根据series返回season信息
	SeriesSeason(ctx context.Context, in *SeriesSeasonReq, opts ...grpc.CallOption) (*SeriesSeasonReply, error)
	// 根据season_id清除season相关mc 缓存
	ClearCache(ctx context.Context, in *SeasonIdReq, opts ...grpc.CallOption) (*EmptyProto, error)
}

type seasonClient struct {
	cc *grpc.ClientConn
}

func NewSeasonClient(cc *grpc.ClientConn) SeasonClient {
	return &seasonClient{cc}
}

func (c *seasonClient) Cards(ctx context.Context, in *SeasonInfoReq, opts ...grpc.CallOption) (*CardsInfoReply, error) {
	out := new(CardsInfoReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.season.v1.Season/Cards", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seasonClient) CardsByAids(ctx context.Context, in *SeasonAidReq, opts ...grpc.CallOption) (*CardsInfoReply, error) {
	out := new(CardsInfoReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.season.v1.Season/CardsByAids", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seasonClient) Profile(ctx context.Context, in *SeasonIdReq, opts ...grpc.CallOption) (*ProfileInfoReply, error) {
	out := new(ProfileInfoReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.season.v1.Season/Profile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seasonClient) Timeline(ctx context.Context, in *TimelineReq, opts ...grpc.CallOption) (*TimelineReply, error) {
	out := new(TimelineReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.season.v1.Season/Timeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seasonClient) Sections(ctx context.Context, in *SectionReq, opts ...grpc.CallOption) (*SectionReply, error) {
	out := new(SectionReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.season.v1.Season/Sections", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seasonClient) SeriesSeason(ctx context.Context, in *SeriesSeasonReq, opts ...grpc.CallOption) (*SeriesSeasonReply, error) {
	out := new(SeriesSeasonReply)
	err := grpc.Invoke(ctx, "/pgc.service.season.season.v1.Season/SeriesSeason", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seasonClient) ClearCache(ctx context.Context, in *SeasonIdReq, opts ...grpc.CallOption) (*EmptyProto, error) {
	out := new(EmptyProto)
	err := grpc.Invoke(ctx, "/pgc.service.season.season.v1.Season/ClearCache", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Season service

type SeasonServer interface {
	// 根据season_ids返回卡片信息
	Cards(context.Context, *SeasonInfoReq) (*CardsInfoReply, error)
	// 根据aids返回卡片信息
	CardsByAids(context.Context, *SeasonAidReq) (*CardsInfoReply, error)
	// 根据season_id返回详情
	Profile(context.Context, *SeasonIdReq) (*ProfileInfoReply, error)
	// 根据开始结束时间和type获取时间表信息
	Timeline(context.Context, *TimelineReq) (*TimelineReply, error)
	// 根据season_ids返回分节信息
	Sections(context.Context, *SectionReq) (*SectionReply, error)
	// 根据series返回season信息
	SeriesSeason(context.Context, *SeriesSeasonReq) (*SeriesSeasonReply, error)
	// 根据season_id清除season相关mc 缓存
	ClearCache(context.Context, *SeasonIdReq) (*EmptyProto, error)
}

func RegisterSeasonServer(s *grpc.Server, srv SeasonServer) {
	s.RegisterService(&_Season_serviceDesc, srv)
}

func _Season_Cards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeasonInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeasonServer).Cards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.season.v1.Season/Cards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeasonServer).Cards(ctx, req.(*SeasonInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Season_CardsByAids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeasonAidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeasonServer).CardsByAids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.season.v1.Season/CardsByAids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeasonServer).CardsByAids(ctx, req.(*SeasonAidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Season_Profile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeasonIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeasonServer).Profile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.season.v1.Season/Profile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeasonServer).Profile(ctx, req.(*SeasonIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Season_Timeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimelineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeasonServer).Timeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.season.v1.Season/Timeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeasonServer).Timeline(ctx, req.(*TimelineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Season_Sections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SectionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeasonServer).Sections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.season.v1.Season/Sections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeasonServer).Sections(ctx, req.(*SectionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Season_SeriesSeason_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeriesSeasonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeasonServer).SeriesSeason(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.season.v1.Season/SeriesSeason",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeasonServer).SeriesSeason(ctx, req.(*SeriesSeasonReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Season_ClearCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeasonIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeasonServer).ClearCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pgc.service.season.season.v1.Season/ClearCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeasonServer).ClearCache(ctx, req.(*SeasonIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Season_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pgc.service.season.season.v1.Season",
	HandlerType: (*SeasonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Cards",
			Handler:    _Season_Cards_Handler,
		},
		{
			MethodName: "CardsByAids",
			Handler:    _Season_CardsByAids_Handler,
		},
		{
			MethodName: "Profile",
			Handler:    _Season_Profile_Handler,
		},
		{
			MethodName: "Timeline",
			Handler:    _Season_Timeline_Handler,
		},
		{
			MethodName: "Sections",
			Handler:    _Season_Sections_Handler,
		},
		{
			MethodName: "SeriesSeason",
			Handler:    _Season_SeriesSeason_Handler,
		},
		{
			MethodName: "ClearCache",
			Handler:    _Season_ClearCache_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/openplatform/pgc-season/api/grpc/season/v1/service.proto",
}

func (m *SeasonInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SeasonIds) > 0 {
		dAtA2 := make([]byte, len(m.SeasonIds)*10)
		var j1 int
		for _, num1 := range m.SeasonIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintService(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *CardsInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardsInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for k, _ := range m.Cards {
			dAtA[i] = 0xa
			i++
			v := m.Cards[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovService(uint64(msgSize))
			}
			mapSize := 1 + sovService(uint64(k)) + msgSize
			i = encodeVarintService(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintService(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintService(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *SeasonIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SeasonId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintService(dAtA, i, uint64(m.SeasonId))
	}
	return i, nil
}

func (m *ProfileInfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfileInfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Profile != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintService(dAtA, i, uint64(m.Profile.Size()))
		n4, err := m.Profile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *SeasonAidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonAidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Aids) > 0 {
		dAtA6 := make([]byte, len(m.Aids)*10)
		var j5 int
		for _, num1 := range m.Aids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintService(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *SectionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SeasonIds) > 0 {
		dAtA8 := make([]byte, len(m.SeasonIds)*10)
		var j7 int
		for _, num1 := range m.SeasonIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintService(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *SectionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SectionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sections) > 0 {
		for k, _ := range m.Sections {
			dAtA[i] = 0xa
			i++
			v := m.Sections[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovService(uint64(msgSize))
			}
			mapSize := 1 + sovService(uint64(k)) + msgSize
			i = encodeVarintService(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintService(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintService(dAtA, i, uint64(v.Size()))
				n9, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	return i, nil
}

func (m *SeriesSeasonReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeriesSeasonReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SeriesIds) > 0 {
		dAtA11 := make([]byte, len(m.SeriesIds)*10)
		var j10 int
		for _, num1 := range m.SeriesIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintService(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *SeriesSeasonReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeriesSeasonReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Seasons) > 0 {
		for k, _ := range m.Seasons {
			dAtA[i] = 0xa
			i++
			v := m.Seasons[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovService(uint64(msgSize))
			}
			mapSize := 1 + sovService(uint64(k)) + msgSize
			i = encodeVarintService(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintService(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintService(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	return i, nil
}

func (m *TimelineReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimelineReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintService(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintService(dAtA, i, uint64(m.End))
	}
	if len(m.Types) > 0 {
		dAtA14 := make([]byte, len(m.Types)*10)
		var j13 int
		for _, num1 := range m.Types {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintService(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.Sort != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintService(dAtA, i, uint64(m.Sort))
	}
	return i, nil
}

func (m *TimelineReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimelineReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Timeline) > 0 {
		for _, msg := range m.Timeline {
			dAtA[i] = 0xa
			i++
			i = encodeVarintService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintService(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SeasonInfoReq) Size() (n int) {
	var l int
	_ = l
	if len(m.SeasonIds) > 0 {
		l = 0
		for _, e := range m.SeasonIds {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	return n
}

func (m *CardsInfoReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for k, v := range m.Cards {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovService(uint64(l))
			}
			mapEntrySize := 1 + sovService(uint64(k)) + l
			n += mapEntrySize + 1 + sovService(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SeasonIdReq) Size() (n int) {
	var l int
	_ = l
	if m.SeasonId != 0 {
		n += 1 + sovService(uint64(m.SeasonId))
	}
	return n
}

func (m *ProfileInfoReply) Size() (n int) {
	var l int
	_ = l
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *SeasonAidReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Aids) > 0 {
		l = 0
		for _, e := range m.Aids {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	return n
}

func (m *SectionReq) Size() (n int) {
	var l int
	_ = l
	if len(m.SeasonIds) > 0 {
		l = 0
		for _, e := range m.SeasonIds {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	return n
}

func (m *SectionReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Sections) > 0 {
		for k, v := range m.Sections {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovService(uint64(l))
			}
			mapEntrySize := 1 + sovService(uint64(k)) + l
			n += mapEntrySize + 1 + sovService(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SeriesSeasonReq) Size() (n int) {
	var l int
	_ = l
	if len(m.SeriesIds) > 0 {
		l = 0
		for _, e := range m.SeriesIds {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	return n
}

func (m *SeriesSeasonReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Seasons) > 0 {
		for k, v := range m.Seasons {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovService(uint64(l))
			}
			mapEntrySize := 1 + sovService(uint64(k)) + l
			n += mapEntrySize + 1 + sovService(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TimelineReq) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovService(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovService(uint64(m.End))
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	if m.Sort != 0 {
		n += 1 + sovService(uint64(m.Sort))
	}
	return n
}

func (m *TimelineReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Timeline) > 0 {
		for _, e := range m.Timeline {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func sovService(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozService(x uint64) (n int) {
	return sovService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SeasonInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SeasonIds = append(m.SeasonIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SeasonIds = append(m.SeasonIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardsInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardsInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardsInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cards == nil {
				m.Cards = make(map[int32]*CardInfoProto)
			}
			var mapkey int32
			var mapvalue *CardInfoProto
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CardInfoProto{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Cards[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonId", wireType)
			}
			m.SeasonId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfileInfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfileInfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfileInfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &ProfileInfoProto{}
			}
			if err := m.Profile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonAidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonAidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonAidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Aids = append(m.Aids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Aids = append(m.Aids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Aids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SeasonIds = append(m.SeasonIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SeasonIds = append(m.SeasonIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SectionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SectionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SectionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sections == nil {
				m.Sections = make(map[int32]*SectionProto)
			}
			var mapkey int32
			var mapvalue *SectionProto
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SectionProto{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sections[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeriesSeasonReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesSeasonReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesSeasonReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SeriesIds = append(m.SeriesIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SeriesIds = append(m.SeriesIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeriesSeasonReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesSeasonReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesSeasonReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seasons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Seasons == nil {
				m.Seasons = make(map[int32]*SeriesSeasonsProto)
			}
			var mapkey int32
			var mapvalue *SeriesSeasonsProto
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SeriesSeasonsProto{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Seasons[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimelineReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimelineReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimelineReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimelineReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimelineReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimelineReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timeline = append(m.Timeline, &TimelineProto{})
			if err := m.Timeline[len(m.Timeline)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthService
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowService
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipService(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthService = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowService   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/openplatform/pgc-season/api/grpc/season/v1/service.proto", fileDescriptorService)
}

var fileDescriptorService = []byte{
	// 673 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4f, 0x6f, 0xd3, 0x4e,
	0x10, 0xd5, 0x36, 0x75, 0x9b, 0x8e, 0x7f, 0xfd, 0x51, 0x56, 0x1c, 0x22, 0x03, 0x55, 0xe5, 0x53,
	0x48, 0xa8, 0xdd, 0x86, 0x03, 0x15, 0x42, 0x88, 0xb6, 0x14, 0xe8, 0x01, 0xa9, 0x72, 0x2b, 0x84,
	0x10, 0x52, 0xd9, 0xd8, 0xdb, 0xb0, 0xc2, 0xb1, 0xb7, 0x5e, 0x37, 0x92, 0xbf, 0x20, 0xe2, 0x82,
	0xc4, 0x81, 0x0b, 0x37, 0xd4, 0x4f, 0x82, 0x76, 0xd7, 0x9b, 0x3f, 0x94, 0xd6, 0x0e, 0xa7, 0xec,
	0x8c, 0x67, 0xe6, 0xbd, 0x79, 0xb3, 0xb3, 0x81, 0x17, 0x84, 0x73, 0x5f, 0xd0, 0x6c, 0xc4, 0x42,
	0xea, 0xa7, 0x9c, 0x26, 0x3c, 0x26, 0xf9, 0x59, 0x9a, 0x0d, 0x7d, 0x3e, 0x08, 0x37, 0x05, 0x25,
	0x22, 0x4d, 0x7c, 0xc2, 0x99, 0x3f, 0xc8, 0x78, 0xe8, 0x97, 0xf6, 0x68, 0xdb, 0xa4, 0x78, 0x3c,
	0x4b, 0xf3, 0x14, 0xdf, 0xe3, 0x83, 0xd0, 0x33, 0x2e, 0x1d, 0x64, 0x7e, 0x46, 0xdb, 0xce, 0xde,
	0x3f, 0x62, 0x0c, 0xd3, 0x88, 0xc6, 0x1a, 0xc1, 0xf5, 0x60, 0xf5, 0x58, 0x7d, 0x38, 0x4c, 0xce,
	0xd2, 0x80, 0x9e, 0xe3, 0xfb, 0x00, 0x3a, 0xf2, 0x94, 0x45, 0xa2, 0x85, 0x36, 0x1a, 0x6d, 0x2b,
	0x58, 0xd1, 0x9e, 0xc3, 0x48, 0xb8, 0x5f, 0x10, 0xfc, 0xbf, 0x4f, 0xb2, 0x48, 0xe8, 0x78, 0x1e,
	0x17, 0xf8, 0x0d, 0x58, 0xa1, 0xf4, 0xa8, 0x60, 0xbb, 0xf7, 0xd8, 0xbb, 0x89, 0xb4, 0x37, 0x9b,
	0xac, 0xcd, 0x83, 0x24, 0xcf, 0x8a, 0x40, 0x57, 0x71, 0x28, 0xc0, 0xc4, 0x89, 0xd7, 0xa0, 0xf1,
	0x99, 0x16, 0x2d, 0xb4, 0x81, 0xda, 0x56, 0x20, 0x8f, 0x78, 0x17, 0xac, 0x11, 0x89, 0x2f, 0x68,
	0x6b, 0x61, 0x03, 0xb5, 0xed, 0x5e, 0xb7, 0x1a, 0x4e, 0xa2, 0x1d, 0xc9, 0x6e, 0x03, 0x9d, 0xf9,
	0x64, 0x61, 0x07, 0xb9, 0x1d, 0xb0, 0xcb, 0xc6, 0x23, 0xd9, 0xf6, 0x5d, 0x58, 0x19, 0xb7, 0x5d,
	0xa2, 0x35, 0x4d, 0xd7, 0xee, 0x07, 0x58, 0x3b, 0xca, 0xd2, 0x33, 0x16, 0xd3, 0x49, 0xd7, 0xaf,
	0x61, 0x99, 0x6b, 0x9f, 0x0a, 0xb7, 0x7b, 0xde, 0xcd, 0x44, 0xa6, 0x0a, 0x68, 0x2e, 0x26, 0xdd,
	0x75, 0xe1, 0x3f, 0xcd, 0x64, 0x97, 0x29, 0x2a, 0x18, 0x16, 0xc9, 0x44, 0x7b, 0x75, 0x76, 0xbb,
	0x00, 0xc7, 0x34, 0xcc, 0x59, 0x9a, 0xd4, 0x98, 0xd1, 0x37, 0x24, 0x2b, 0x96, 0xd1, 0x92, 0xeb,
	0x09, 0x34, 0x85, 0xb6, 0xcd, 0x90, 0x76, 0x6e, 0x26, 0x3b, 0x9d, 0x6d, 0x8c, 0x72, 0x4a, 0xe3,
	0x4a, 0xce, 0x40, 0x5e, 0x9d, 0xa9, 0x4f, 0x7f, 0x99, 0xd5, 0xf3, 0xd9, 0x59, 0x75, 0x6a, 0xa1,
	0x5e, 0x19, 0xd5, 0x16, 0xdc, 0x3a, 0xa6, 0x19, 0xa3, 0x42, 0xcb, 0x34, 0x56, 0x40, 0xba, 0x66,
	0x15, 0x90, 0x1e, 0xa9, 0xc0, 0x4f, 0x04, 0xb7, 0x67, 0x53, 0xa4, 0x0c, 0x6f, 0x61, 0x59, 0x83,
	0x19, 0x15, 0x9e, 0x56, 0xf1, 0xf9, 0xa3, 0x82, 0xa7, 0xcf, 0xa5, 0x12, 0xa6, 0x98, 0x13, 0x9b,
	0x01, 0x5e, 0xab, 0xc3, 0xcb, 0x59, 0x1d, 0xb6, 0xea, 0xe3, 0x8a, 0x2b, 0x6a, 0x9c, 0x82, 0x7d,
	0xc2, 0x86, 0x34, 0x66, 0x09, 0x95, 0x4a, 0xdc, 0x01, 0x4b, 0xe4, 0x24, 0xcb, 0x15, 0x5c, 0x23,
	0xd0, 0x86, 0xa4, 0x40, 0x93, 0x48, 0xc1, 0x35, 0x02, 0x79, 0x94, 0x71, 0x79, 0xc1, 0xa9, 0x68,
	0x35, 0x94, 0x58, 0xda, 0x90, 0x77, 0x4d, 0xa4, 0x59, 0xde, 0x5a, 0x54, 0x5c, 0xd5, 0xd9, 0x7d,
	0x07, 0xab, 0x13, 0x00, 0xa9, 0xdb, 0x2b, 0x68, 0xe6, 0xa5, 0xa3, 0x14, 0xae, 0x62, 0xe9, 0x4c,
	0xba, 0xe6, 0x3e, 0x4e, 0xee, 0xfd, 0xb0, 0x60, 0x49, 0xb7, 0x85, 0xfb, 0x60, 0xa9, 0x2d, 0xc7,
	0xdd, 0x2a, 0x2d, 0xa6, 0x1e, 0x27, 0xe7, 0xe1, 0x3c, 0x6f, 0x0b, 0x1e, 0x80, 0xad, 0x3c, 0x7b,
	0xc5, 0x2e, 0x8b, 0x04, 0xee, 0xd4, 0x41, 0xd2, 0x3b, 0x38, 0x27, 0x50, 0x04, 0xcb, 0xe5, 0x7a,
	0xe3, 0x07, 0xb5, 0xda, 0x51, 0x18, 0xf5, 0x1f, 0x0c, 0x8d, 0xd2, 0x87, 0xa6, 0x11, 0xb6, 0x0a,
	0x66, 0xea, 0x82, 0x38, 0xdd, 0xba, 0xa1, 0x12, 0xe3, 0x23, 0x34, 0xcd, 0x4e, 0xe3, 0x76, 0xcd,
	0x37, 0xe2, 0xdc, 0xe9, 0xd4, 0x7f, 0x4d, 0x70, 0x22, 0x97, 0x65, 0x72, 0xbf, 0xf1, 0xe6, 0x3c,
	0x3b, 0x78, 0xee, 0xf8, 0x73, 0xae, 0x2c, 0x26, 0x00, 0xfb, 0x31, 0x25, 0xd9, 0x3e, 0x09, 0x3f,
	0xcd, 0x35, 0x9e, 0x8a, 0xf6, 0x0f, 0x86, 0x3c, 0x2f, 0xd4, 0x05, 0xdf, 0x7b, 0xf6, 0xf5, 0x72,
	0x1d, 0x7d, 0xbf, 0x5c, 0x47, 0xbf, 0x2e, 0xd7, 0x11, 0x74, 0x78, 0x4c, 0x19, 0x89, 0xa8, 0xf0,
	0xfa, 0x17, 0x82, 0x25, 0x54, 0x88, 0x6b, 0x8b, 0x1c, 0xa1, 0xf7, 0x0b, 0xa3, 0xed, 0xfe, 0x92,
	0xfa, 0x2b, 0x7e, 0xf4, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xe7, 0xff, 0x31, 0x2e, 0x34, 0x08, 0x00,
	0x00,
}
