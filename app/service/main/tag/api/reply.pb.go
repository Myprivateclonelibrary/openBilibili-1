// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/main/tag/api/reply.proto

package v1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type AddReportReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddReportReply) Reset()         { *m = AddReportReply{} }
func (m *AddReportReply) String() string { return proto.CompactTextString(m) }
func (*AddReportReply) ProtoMessage()    {}
func (*AddReportReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{0}
}
func (m *AddReportReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddReportReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddReportReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddReportReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddReportReply.Merge(m, src)
}
func (m *AddReportReply) XXX_Size() int {
	return m.Size()
}
func (m *AddReportReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AddReportReply.DiscardUnknown(m)
}

var xxx_messageInfo_AddReportReply proto.InternalMessageInfo

type TagReply struct {
	Tag                  *Tag     `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TagReply) Reset()         { *m = TagReply{} }
func (m *TagReply) String() string { return proto.CompactTextString(m) }
func (*TagReply) ProtoMessage()    {}
func (*TagReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{1}
}
func (m *TagReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagReply.Merge(m, src)
}
func (m *TagReply) XXX_Size() int {
	return m.Size()
}
func (m *TagReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TagReply.DiscardUnknown(m)
}

var xxx_messageInfo_TagReply proto.InternalMessageInfo

func (m *TagReply) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type TagMapByIDReply struct {
	Tags                 map[int64]*Tag `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TagMapByIDReply) Reset()         { *m = TagMapByIDReply{} }
func (m *TagMapByIDReply) String() string { return proto.CompactTextString(m) }
func (*TagMapByIDReply) ProtoMessage()    {}
func (*TagMapByIDReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{2}
}
func (m *TagMapByIDReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagMapByIDReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagMapByIDReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TagMapByIDReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagMapByIDReply.Merge(m, src)
}
func (m *TagMapByIDReply) XXX_Size() int {
	return m.Size()
}
func (m *TagMapByIDReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TagMapByIDReply.DiscardUnknown(m)
}

var xxx_messageInfo_TagMapByIDReply proto.InternalMessageInfo

func (m *TagMapByIDReply) GetTags() map[int64]*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ChannelCategoriesReply struct {
	Categories           []*ChannelCategory `protobuf:"bytes,1,rep,name=categories,proto3" json:"categories,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ChannelCategoriesReply) Reset()         { *m = ChannelCategoriesReply{} }
func (m *ChannelCategoriesReply) String() string { return proto.CompactTextString(m) }
func (*ChannelCategoriesReply) ProtoMessage()    {}
func (*ChannelCategoriesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{3}
}
func (m *ChannelCategoriesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelCategoriesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelCategoriesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelCategoriesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelCategoriesReply.Merge(m, src)
}
func (m *ChannelCategoriesReply) XXX_Size() int {
	return m.Size()
}
func (m *ChannelCategoriesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelCategoriesReply.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelCategoriesReply proto.InternalMessageInfo

func (m *ChannelCategoriesReply) GetCategories() []*ChannelCategory {
	if m != nil {
		return m.Categories
	}
	return nil
}

type ChannelsReply struct {
	Channels             []*Channel `protobuf:"bytes,1,rep,name=channels,proto3" json:"channels,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ChannelsReply) Reset()         { *m = ChannelsReply{} }
func (m *ChannelsReply) String() string { return proto.CompactTextString(m) }
func (*ChannelsReply) ProtoMessage()    {}
func (*ChannelsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{4}
}
func (m *ChannelsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelsReply.Merge(m, src)
}
func (m *ChannelsReply) XXX_Size() int {
	return m.Size()
}
func (m *ChannelsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelsReply.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelsReply proto.InternalMessageInfo

func (m *ChannelsReply) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type ChannelRulesReply struct {
	Rules                []*ChannelRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ChannelRulesReply) Reset()         { *m = ChannelRulesReply{} }
func (m *ChannelRulesReply) String() string { return proto.CompactTextString(m) }
func (*ChannelRulesReply) ProtoMessage()    {}
func (*ChannelRulesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{5}
}
func (m *ChannelRulesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelRulesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelRulesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelRulesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelRulesReply.Merge(m, src)
}
func (m *ChannelRulesReply) XXX_Size() int {
	return m.Size()
}
func (m *ChannelRulesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelRulesReply.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelRulesReply proto.InternalMessageInfo

func (m *ChannelRulesReply) GetRules() []*ChannelRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type ChannelGroupReply struct {
	Groups               []*ChannelGroup `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ChannelGroupReply) Reset()         { *m = ChannelGroupReply{} }
func (m *ChannelGroupReply) String() string { return proto.CompactTextString(m) }
func (*ChannelGroupReply) ProtoMessage()    {}
func (*ChannelGroupReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{6}
}
func (m *ChannelGroupReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelGroupReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelGroupReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelGroupReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelGroupReply.Merge(m, src)
}
func (m *ChannelGroupReply) XXX_Size() int {
	return m.Size()
}
func (m *ChannelGroupReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelGroupReply.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelGroupReply proto.InternalMessageInfo

func (m *ChannelGroupReply) GetGroups() []*ChannelGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

type ResTagReply struct {
	Resource             []*Resource `protobuf:"bytes,1,rep,name=resource,proto3" json:"resource,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ResTagReply) Reset()         { *m = ResTagReply{} }
func (m *ResTagReply) String() string { return proto.CompactTextString(m) }
func (*ResTagReply) ProtoMessage()    {}
func (*ResTagReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{7}
}
func (m *ResTagReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResTagReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResTagReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResTagReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResTagReply.Merge(m, src)
}
func (m *ResTagReply) XXX_Size() int {
	return m.Size()
}
func (m *ResTagReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ResTagReply.DiscardUnknown(m)
}

var xxx_messageInfo_ResTagReply proto.InternalMessageInfo

func (m *ResTagReply) GetResource() []*Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

type ResTagMapReply struct {
	Resource             map[int64]*Resource `protobuf:"bytes,1,rep,name=resource,proto3" json:"resource,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ResTagMapReply) Reset()         { *m = ResTagMapReply{} }
func (m *ResTagMapReply) String() string { return proto.CompactTextString(m) }
func (*ResTagMapReply) ProtoMessage()    {}
func (*ResTagMapReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{8}
}
func (m *ResTagMapReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResTagMapReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResTagMapReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResTagMapReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResTagMapReply.Merge(m, src)
}
func (m *ResTagMapReply) XXX_Size() int {
	return m.Size()
}
func (m *ResTagMapReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ResTagMapReply.DiscardUnknown(m)
}

var xxx_messageInfo_ResTagMapReply proto.InternalMessageInfo

func (m *ResTagMapReply) GetResource() map[int64]*Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

type ResTag struct {
	Resource             []*Resource `protobuf:"bytes,1,rep,name=resource,proto3" json:"resource,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ResTag) Reset()         { *m = ResTag{} }
func (m *ResTag) String() string { return proto.CompactTextString(m) }
func (*ResTag) ProtoMessage()    {}
func (*ResTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{9}
}
func (m *ResTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResTag.Merge(m, src)
}
func (m *ResTag) XXX_Size() int {
	return m.Size()
}
func (m *ResTag) XXX_DiscardUnknown() {
	xxx_messageInfo_ResTag.DiscardUnknown(m)
}

var xxx_messageInfo_ResTag proto.InternalMessageInfo

func (m *ResTag) GetResource() []*Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

type ResTagsReply struct {
	Resource             map[int64]*ResTag `protobuf:"bytes,1,rep,name=resource,proto3" json:"resource,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ResTagsReply) Reset()         { *m = ResTagsReply{} }
func (m *ResTagsReply) String() string { return proto.CompactTextString(m) }
func (*ResTagsReply) ProtoMessage()    {}
func (*ResTagsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{10}
}
func (m *ResTagsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResTagsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResTagsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResTagsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResTagsReply.Merge(m, src)
}
func (m *ResTagsReply) XXX_Size() int {
	return m.Size()
}
func (m *ResTagsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ResTagsReply.DiscardUnknown(m)
}

var xxx_messageInfo_ResTagsReply proto.InternalMessageInfo

func (m *ResTagsReply) GetResource() map[int64]*ResTag {
	if m != nil {
		return m.Resource
	}
	return nil
}

type ResTagActionReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResTagActionReply) Reset()         { *m = ResTagActionReply{} }
func (m *ResTagActionReply) String() string { return proto.CompactTextString(m) }
func (*ResTagActionReply) ProtoMessage()    {}
func (*ResTagActionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{11}
}
func (m *ResTagActionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResTagActionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResTagActionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResTagActionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResTagActionReply.Merge(m, src)
}
func (m *ResTagActionReply) XXX_Size() int {
	return m.Size()
}
func (m *ResTagActionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ResTagActionReply.DiscardUnknown(m)
}

var xxx_messageInfo_ResTagActionReply proto.InternalMessageInfo

type ResTagActionMapReply struct {
	ActionMap            map[int64]int32 `protobuf:"bytes,1,rep,name=action_map,json=actionMap,proto3" json:"action_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ResTagActionMapReply) Reset()         { *m = ResTagActionMapReply{} }
func (m *ResTagActionMapReply) String() string { return proto.CompactTextString(m) }
func (*ResTagActionMapReply) ProtoMessage()    {}
func (*ResTagActionMapReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{12}
}
func (m *ResTagActionMapReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResTagActionMapReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResTagActionMapReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResTagActionMapReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResTagActionMapReply.Merge(m, src)
}
func (m *ResTagActionMapReply) XXX_Size() int {
	return m.Size()
}
func (m *ResTagActionMapReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ResTagActionMapReply.DiscardUnknown(m)
}

var xxx_messageInfo_ResTagActionMapReply proto.InternalMessageInfo

func (m *ResTagActionMapReply) GetActionMap() map[int64]int32 {
	if m != nil {
		return m.ActionMap
	}
	return nil
}

type UpBindReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpBindReply) Reset()         { *m = UpBindReply{} }
func (m *UpBindReply) String() string { return proto.CompactTextString(m) }
func (*UpBindReply) ProtoMessage()    {}
func (*UpBindReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{13}
}
func (m *UpBindReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpBindReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpBindReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpBindReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpBindReply.Merge(m, src)
}
func (m *UpBindReply) XXX_Size() int {
	return m.Size()
}
func (m *UpBindReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpBindReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpBindReply proto.InternalMessageInfo

type AdminBindReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdminBindReply) Reset()         { *m = AdminBindReply{} }
func (m *AdminBindReply) String() string { return proto.CompactTextString(m) }
func (*AdminBindReply) ProtoMessage()    {}
func (*AdminBindReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0536e1934f52ad7f, []int{14}
}
func (m *AdminBindReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminBindReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminBindReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminBindReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminBindReply.Merge(m, src)
}
func (m *AdminBindReply) XXX_Size() int {
	return m.Size()
}
func (m *AdminBindReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminBindReply.DiscardUnknown(m)
}

var xxx_messageInfo_AdminBindReply proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AddReportReply)(nil), "community.service.tag.v1.AddReportReply")
	proto.RegisterType((*TagReply)(nil), "community.service.tag.v1.TagReply")
	proto.RegisterType((*TagMapByIDReply)(nil), "community.service.tag.v1.TagMapByIDReply")
	proto.RegisterMapType((map[int64]*Tag)(nil), "community.service.tag.v1.TagMapByIDReply.TagsEntry")
	proto.RegisterType((*ChannelCategoriesReply)(nil), "community.service.tag.v1.ChannelCategoriesReply")
	proto.RegisterType((*ChannelsReply)(nil), "community.service.tag.v1.ChannelsReply")
	proto.RegisterType((*ChannelRulesReply)(nil), "community.service.tag.v1.ChannelRulesReply")
	proto.RegisterType((*ChannelGroupReply)(nil), "community.service.tag.v1.ChannelGroupReply")
	proto.RegisterType((*ResTagReply)(nil), "community.service.tag.v1.ResTagReply")
	proto.RegisterType((*ResTagMapReply)(nil), "community.service.tag.v1.ResTagMapReply")
	proto.RegisterMapType((map[int64]*Resource)(nil), "community.service.tag.v1.ResTagMapReply.ResourceEntry")
	proto.RegisterType((*ResTag)(nil), "community.service.tag.v1.ResTag")
	proto.RegisterType((*ResTagsReply)(nil), "community.service.tag.v1.ResTagsReply")
	proto.RegisterMapType((map[int64]*ResTag)(nil), "community.service.tag.v1.ResTagsReply.ResourceEntry")
	proto.RegisterType((*ResTagActionReply)(nil), "community.service.tag.v1.ResTagActionReply")
	proto.RegisterType((*ResTagActionMapReply)(nil), "community.service.tag.v1.ResTagActionMapReply")
	proto.RegisterMapType((map[int64]int32)(nil), "community.service.tag.v1.ResTagActionMapReply.ActionMapEntry")
	proto.RegisterType((*UpBindReply)(nil), "community.service.tag.v1.UpBindReply")
	proto.RegisterType((*AdminBindReply)(nil), "community.service.tag.v1.AdminBindReply")
}

func init() {
	proto.RegisterFile("app/service/main/tag/api/reply.proto", fileDescriptor_0536e1934f52ad7f)
}

var fileDescriptor_0536e1934f52ad7f = []byte{
	// 574 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0xd1, 0x6a, 0xdb, 0x3c,
	0x14, 0xc7, 0x51, 0xf3, 0x35, 0xa4, 0x27, 0x5f, 0xb2, 0x34, 0x2b, 0x23, 0x04, 0x16, 0x32, 0xb1,
	0x95, 0xee, 0x62, 0x36, 0x6d, 0x46, 0x29, 0xeb, 0x5a, 0x68, 0xba, 0xd1, 0xf5, 0x22, 0xa3, 0x68,
	0xdd, 0x2e, 0xc6, 0x46, 0x51, 0x1c, 0x4d, 0x35, 0x8b, 0x2d, 0x63, 0xcb, 0x01, 0xbf, 0x56, 0x5f,
	0x60, 0x57, 0x83, 0x5d, 0xee, 0x11, 0x46, 0x9e, 0x64, 0xd8, 0x52, 0x84, 0x4d, 0x9b, 0xb8, 0xb0,
	0x3b, 0x9f, 0xa3, 0xf3, 0xff, 0xe9, 0xfc, 0x8f, 0x0f, 0x82, 0xa7, 0x34, 0x08, 0xec, 0x88, 0x85,
	0x33, 0xd7, 0x61, 0xb6, 0x47, 0x5d, 0xdf, 0x96, 0x94, 0xdb, 0x34, 0x70, 0xed, 0x90, 0x05, 0xd3,
	0xc4, 0x0a, 0x42, 0x21, 0x45, 0xbb, 0xe3, 0x08, 0xcf, 0x8b, 0x7d, 0x57, 0x26, 0x96, 0xae, 0xb5,
	0x24, 0xe5, 0xd6, 0x6c, 0xb7, 0xbb, 0xbd, 0x54, 0xef, 0x5c, 0x53, 0xdf, 0x67, 0x53, 0x45, 0xe8,
	0xe2, 0xa5, 0x75, 0x29, 0x48, 0xd5, 0xbc, 0xe0, 0xae, 0xbc, 0x8e, 0xc7, 0x96, 0x23, 0x3c, 0x9b,
	0x0b, 0x2e, 0xec, 0x2c, 0x3d, 0x8e, 0xbf, 0x65, 0x51, 0x16, 0x64, 0x5f, 0xaa, 0x1c, 0xb7, 0xa0,
	0x79, 0x32, 0x99, 0x10, 0x16, 0x88, 0x50, 0x92, 0xb4, 0x59, 0x7c, 0x08, 0xb5, 0x4b, 0xca, 0xb3,
	0xef, 0xb6, 0x0d, 0x15, 0x49, 0x79, 0x07, 0xf5, 0xd1, 0x4e, 0x7d, 0xef, 0xb1, 0xb5, 0xcc, 0x80,
	0x95, 0x0a, 0xd2, 0x4a, 0x7c, 0x83, 0xe0, 0xc1, 0x25, 0xe5, 0x23, 0x1a, 0x0c, 0x93, 0xf3, 0x37,
	0x0a, 0x72, 0x06, 0xff, 0x49, 0xca, 0xa3, 0x0e, 0xea, 0x57, 0x76, 0xea, 0x7b, 0x83, 0x95, 0x94,
	0xbc, 0x30, 0x8d, 0xa3, 0xb7, 0xbe, 0x0c, 0x13, 0x92, 0x01, 0xba, 0x9f, 0x60, 0xc3, 0xa4, 0xda,
	0x2d, 0xa8, 0x7c, 0x67, 0x49, 0xd6, 0x5a, 0x85, 0xa4, 0x9f, 0xed, 0x01, 0xac, 0xcf, 0xe8, 0x34,
	0x66, 0x9d, 0xb5, 0xfb, 0xb4, 0xab, 0x6a, 0x5f, 0xad, 0x1d, 0x20, 0xec, 0xc0, 0xa3, 0x53, 0x35,
	0xe7, 0x53, 0x2a, 0x19, 0x17, 0xa1, 0xcb, 0x22, 0xd5, 0xfa, 0x39, 0x80, 0x63, 0x52, 0xda, 0xc0,
	0xf3, 0xe5, 0xdc, 0x22, 0x25, 0x21, 0x39, 0x31, 0x7e, 0x0f, 0x0d, 0x7d, 0xac, 0xd9, 0x47, 0x50,
	0xd3, 0x7f, 0x77, 0x41, 0x7e, 0x52, 0x4a, 0x26, 0x46, 0x82, 0x2f, 0x60, 0x73, 0x91, 0x8c, 0xa7,
	0x8b, 0x7e, 0x0f, 0x61, 0x3d, 0x4c, 0x23, 0x0d, 0x7c, 0x56, 0x0e, 0x8c, 0xa7, 0x8c, 0x28, 0x0d,
	0xfe, 0x60, 0x88, 0x67, 0xa1, 0x88, 0x03, 0x45, 0x3c, 0x86, 0x2a, 0x4f, 0xa3, 0x05, 0x72, 0xbb,
	0x14, 0xa9, 0xc4, 0x5a, 0x85, 0x47, 0x50, 0x27, 0x2c, 0x32, 0x0b, 0x75, 0x0c, 0xb5, 0x90, 0x45,
	0x22, 0x0e, 0x1d, 0xa6, 0x81, 0x78, 0x39, 0x90, 0xe8, 0x4a, 0x62, 0x34, 0xf8, 0x27, 0x82, 0xa6,
	0xe2, 0x8d, 0xa8, 0xee, 0x90, 0xdc, 0x42, 0xee, 0xaf, 0x44, 0xe6, 0xb4, 0xe6, 0x06, 0xb5, 0x65,
	0x86, 0xd3, 0xbd, 0x82, 0x46, 0xe1, 0xe8, 0x8e, 0x6d, 0x3b, 0x28, 0x6e, 0xdb, 0x7d, 0x6c, 0xe4,
	0x56, 0xee, 0x1d, 0x54, 0x55, 0x2b, 0xff, 0x3c, 0x91, 0x1f, 0x08, 0xfe, 0x57, 0x28, 0xbd, 0x03,
	0x17, 0xb7, 0x80, 0x2f, 0xcb, 0xe6, 0x11, 0xad, 0x9e, 0xc6, 0xd7, 0xf2, 0x69, 0xec, 0x17, 0xa7,
	0xd1, 0x2f, 0xbb, 0x31, 0x3f, 0x8b, 0x87, 0xb0, 0xa9, 0x92, 0x27, 0x8e, 0x74, 0x85, 0xaf, 0x5e,
	0xa1, 0x1b, 0x04, 0x5b, 0xf9, 0xac, 0xf9, 0xdd, 0x5f, 0x00, 0x68, 0x96, 0xb9, 0xf2, 0x68, 0xa0,
	0x0d, 0x1e, 0x95, 0x5d, 0x57, 0x64, 0x58, 0x26, 0x54, 0x4e, 0x37, 0xe8, 0x22, 0xee, 0xbe, 0x86,
	0x66, 0xf1, 0xf0, 0x0e, 0xaf, 0x5b, 0x79, 0xaf, 0xeb, 0x79, 0x27, 0x0d, 0xa8, 0x7f, 0x0c, 0x86,
	0xae, 0x3f, 0x51, 0x1e, 0xb2, 0xb7, 0xd5, 0x73, 0x7d, 0x93, 0x19, 0xb6, 0x7e, 0xcd, 0x7b, 0xe8,
	0xf7, 0xbc, 0x87, 0xfe, 0xcc, 0x7b, 0xe8, 0xf3, 0xda, 0x6c, 0x77, 0x5c, 0xcd, 0x9e, 0xe1, 0xc1,
	0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x30, 0xd3, 0xda, 0x1d, 0x43, 0x06, 0x00, 0x00,
}

func (m *AddReportReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddReportReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TagReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReply(dAtA, i, uint64(m.Tag.Size()))
		n1, err := m.Tag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TagMapByIDReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagMapByIDReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0xa
			i++
			v := m.Tags[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovReply(uint64(msgSize))
			}
			mapSize := 1 + sovReply(uint64(k)) + msgSize
			i = encodeVarintReply(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintReply(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintReply(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChannelCategoriesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelCategoriesReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for _, msg := range m.Categories {
			dAtA[i] = 0xa
			i++
			i = encodeVarintReply(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChannelsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for _, msg := range m.Channels {
			dAtA[i] = 0xa
			i++
			i = encodeVarintReply(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChannelRulesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelRulesReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintReply(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChannelGroupReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelGroupReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintReply(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResTagReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResTagReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for _, msg := range m.Resource {
			dAtA[i] = 0xa
			i++
			i = encodeVarintReply(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResTagMapReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResTagMapReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for k, _ := range m.Resource {
			dAtA[i] = 0xa
			i++
			v := m.Resource[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovReply(uint64(msgSize))
			}
			mapSize := 1 + sovReply(uint64(k)) + msgSize
			i = encodeVarintReply(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintReply(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintReply(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for _, msg := range m.Resource {
			dAtA[i] = 0xa
			i++
			i = encodeVarintReply(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResTagsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResTagsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for k, _ := range m.Resource {
			dAtA[i] = 0xa
			i++
			v := m.Resource[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovReply(uint64(msgSize))
			}
			mapSize := 1 + sovReply(uint64(k)) + msgSize
			i = encodeVarintReply(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintReply(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintReply(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResTagActionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResTagActionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResTagActionMapReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResTagActionMapReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionMap) > 0 {
		for k, _ := range m.ActionMap {
			dAtA[i] = 0xa
			i++
			v := m.ActionMap[k]
			mapSize := 1 + sovReply(uint64(k)) + 1 + sovReply(uint64(v))
			i = encodeVarintReply(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintReply(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintReply(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpBindReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpBindReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AdminBindReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminBindReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintReply(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AddReportReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TagReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovReply(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TagMapByIDReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovReply(uint64(l))
			}
			mapEntrySize := 1 + sovReply(uint64(k)) + l
			n += mapEntrySize + 1 + sovReply(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChannelCategoriesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for _, e := range m.Categories {
			l = e.Size()
			n += 1 + l + sovReply(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChannelsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			l = e.Size()
			n += 1 + l + sovReply(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChannelRulesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovReply(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChannelGroupReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovReply(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResTagReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for _, e := range m.Resource {
			l = e.Size()
			n += 1 + l + sovReply(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResTagMapReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for k, v := range m.Resource {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovReply(uint64(l))
			}
			mapEntrySize := 1 + sovReply(uint64(k)) + l
			n += mapEntrySize + 1 + sovReply(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for _, e := range m.Resource {
			l = e.Size()
			n += 1 + l + sovReply(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResTagsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resource) > 0 {
		for k, v := range m.Resource {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovReply(uint64(l))
			}
			mapEntrySize := 1 + sovReply(uint64(k)) + l
			n += mapEntrySize + 1 + sovReply(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResTagActionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResTagActionMapReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ActionMap) > 0 {
		for k, v := range m.ActionMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovReply(uint64(k)) + 1 + sovReply(uint64(v))
			n += mapEntrySize + 1 + sovReply(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpBindReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdminBindReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovReply(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozReply(x uint64) (n int) {
	return sovReply(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddReportReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddReportReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddReportReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &Tag{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagMapByIDReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagMapByIDReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagMapByIDReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[int64]*Tag)
			}
			var mapkey int64
			var mapvalue *Tag
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReply
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReply
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReply
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthReply
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthReply
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Tag{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipReply(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthReply
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelCategoriesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelCategoriesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelCategoriesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Categories = append(m.Categories, &ChannelCategory{})
			if err := m.Categories[len(m.Categories)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, &Channel{})
			if err := m.Channels[len(m.Channels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelRulesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelRulesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelRulesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &ChannelRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelGroupReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelGroupReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelGroupReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &ChannelGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResTagReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResTagReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResTagReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = append(m.Resource, &Resource{})
			if err := m.Resource[len(m.Resource)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResTagMapReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResTagMapReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResTagMapReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = make(map[int64]*Resource)
			}
			var mapkey int64
			var mapvalue *Resource
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReply
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReply
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReply
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthReply
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthReply
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Resource{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipReply(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthReply
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resource[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = append(m.Resource, &Resource{})
			if err := m.Resource[len(m.Resource)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResTagsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResTagsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResTagsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = make(map[int64]*ResTag)
			}
			var mapkey int64
			var mapvalue *ResTag
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReply
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReply
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReply
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthReply
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthReply
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ResTag{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipReply(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthReply
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resource[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResTagActionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResTagActionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResTagActionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResTagActionMapReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResTagActionMapReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResTagActionMapReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReply
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReply
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionMap == nil {
				m.ActionMap = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReply
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReply
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReply
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipReply(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthReply
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ActionMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpBindReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpBindReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpBindReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminBindReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReply
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminBindReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminBindReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipReply(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReply
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReply(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReply
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReply
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReply
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthReply
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowReply
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipReply(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthReply = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReply   = fmt.Errorf("proto: integer overflow")
)
