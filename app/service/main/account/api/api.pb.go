// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/main/account/api/api.proto

package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import go_common_library_time "go-common/library/time"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Card struct {
	Mid                  int64         `protobuf:"varint,1,opt,name=mid,proto3" json:"mid"`
	Name                 string        `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Sex                  string        `protobuf:"bytes,3,opt,name=sex,proto3" json:"sex"`
	Face                 string        `protobuf:"bytes,4,opt,name=face,proto3" json:"face"`
	Sign                 string        `protobuf:"bytes,5,opt,name=sign,proto3" json:"sign"`
	Rank                 int32         `protobuf:"varint,6,opt,name=rank,proto3" json:"rank"`
	Level                int32         `protobuf:"varint,7,opt,name=level,proto3" json:"level"`
	Silence              int32         `protobuf:"varint,8,opt,name=silence,proto3" json:"silence"`
	Vip                  VipInfo       `protobuf:"bytes,9,opt,name=vip" json:"vip"`
	Pendant              PendantInfo   `protobuf:"bytes,10,opt,name=pendant" json:"pendant"`
	Nameplate            NameplateInfo `protobuf:"bytes,11,opt,name=nameplate" json:"nameplate"`
	Official             OfficialInfo  `protobuf:"bytes,12,opt,name=official" json:"official"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Card) Reset()         { *m = Card{} }
func (m *Card) String() string { return proto.CompactTextString(m) }
func (*Card) ProtoMessage()    {}
func (*Card) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{0}
}
func (m *Card) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Card) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Card.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Card) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Card.Merge(dst, src)
}
func (m *Card) XXX_Size() int {
	return m.Size()
}
func (m *Card) XXX_DiscardUnknown() {
	xxx_messageInfo_Card.DiscardUnknown(m)
}

var xxx_messageInfo_Card proto.InternalMessageInfo

func (m *Card) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *Card) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Card) GetSex() string {
	if m != nil {
		return m.Sex
	}
	return ""
}

func (m *Card) GetFace() string {
	if m != nil {
		return m.Face
	}
	return ""
}

func (m *Card) GetSign() string {
	if m != nil {
		return m.Sign
	}
	return ""
}

func (m *Card) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *Card) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Card) GetSilence() int32 {
	if m != nil {
		return m.Silence
	}
	return 0
}

func (m *Card) GetVip() VipInfo {
	if m != nil {
		return m.Vip
	}
	return VipInfo{}
}

func (m *Card) GetPendant() PendantInfo {
	if m != nil {
		return m.Pendant
	}
	return PendantInfo{}
}

func (m *Card) GetNameplate() NameplateInfo {
	if m != nil {
		return m.Nameplate
	}
	return NameplateInfo{}
}

func (m *Card) GetOfficial() OfficialInfo {
	if m != nil {
		return m.Official
	}
	return OfficialInfo{}
}

type Info struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Sex                  string   `protobuf:"bytes,3,opt,name=sex,proto3" json:"sex"`
	Face                 string   `protobuf:"bytes,4,opt,name=face,proto3" json:"face"`
	Sign                 string   `protobuf:"bytes,5,opt,name=sign,proto3" json:"sign"`
	Rank                 int32    `protobuf:"varint,6,opt,name=rank,proto3" json:"rank"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Info) Reset()         { *m = Info{} }
func (m *Info) String() string { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()    {}
func (*Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{1}
}
func (m *Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Info.Merge(dst, src)
}
func (m *Info) XXX_Size() int {
	return m.Size()
}
func (m *Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Info proto.InternalMessageInfo

func (m *Info) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *Info) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Info) GetSex() string {
	if m != nil {
		return m.Sex
	}
	return ""
}

func (m *Info) GetFace() string {
	if m != nil {
		return m.Face
	}
	return ""
}

func (m *Info) GetSign() string {
	if m != nil {
		return m.Sign
	}
	return ""
}

func (m *Info) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

type Profile struct {
	Mid                  int64                       `protobuf:"varint,1,opt,name=mid,proto3" json:"mid"`
	Name                 string                      `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Sex                  string                      `protobuf:"bytes,3,opt,name=sex,proto3" json:"sex"`
	Face                 string                      `protobuf:"bytes,4,opt,name=face,proto3" json:"face"`
	Sign                 string                      `protobuf:"bytes,5,opt,name=sign,proto3" json:"sign"`
	Rank                 int32                       `protobuf:"varint,6,opt,name=rank,proto3" json:"rank"`
	Level                int32                       `protobuf:"varint,7,opt,name=level,proto3" json:"level"`
	JoinTime             int32                       `protobuf:"varint,8,opt,name=join_time,json=joinTime,proto3" json:"jointime"`
	Moral                int32                       `protobuf:"varint,9,opt,name=moral,proto3" json:"moral"`
	Silence              int32                       `protobuf:"varint,10,opt,name=silence,proto3" json:"silence"`
	EmailStatus          int32                       `protobuf:"varint,11,opt,name=email_status,json=emailStatus,proto3" json:"email_status"`
	TelStatus            int32                       `protobuf:"varint,12,opt,name=tel_status,json=telStatus,proto3" json:"tel_status"`
	Identification       int32                       `protobuf:"varint,13,opt,name=identification,proto3" json:"identification"`
	Vip                  VipInfo                     `protobuf:"bytes,14,opt,name=vip" json:"vip"`
	Pendant              PendantInfo                 `protobuf:"bytes,15,opt,name=pendant" json:"pendant"`
	Nameplate            NameplateInfo               `protobuf:"bytes,16,opt,name=nameplate" json:"nameplate"`
	Official             OfficialInfo                `protobuf:"bytes,17,opt,name=official" json:"official"`
	Birthday             go_common_library_time.Time `protobuf:"varint,18,opt,name=birthday,proto3,casttype=go-common/library/time.Time" json:"birthday"`
	IsTourist            int32                       `protobuf:"varint,19,opt,name=is_tourist,json=isTourist,proto3" json:"is_tourist"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Profile) Reset()         { *m = Profile{} }
func (m *Profile) String() string { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()    {}
func (*Profile) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{2}
}
func (m *Profile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Profile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Profile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Profile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Profile.Merge(dst, src)
}
func (m *Profile) XXX_Size() int {
	return m.Size()
}
func (m *Profile) XXX_DiscardUnknown() {
	xxx_messageInfo_Profile.DiscardUnknown(m)
}

var xxx_messageInfo_Profile proto.InternalMessageInfo

func (m *Profile) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *Profile) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Profile) GetSex() string {
	if m != nil {
		return m.Sex
	}
	return ""
}

func (m *Profile) GetFace() string {
	if m != nil {
		return m.Face
	}
	return ""
}

func (m *Profile) GetSign() string {
	if m != nil {
		return m.Sign
	}
	return ""
}

func (m *Profile) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *Profile) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Profile) GetJoinTime() int32 {
	if m != nil {
		return m.JoinTime
	}
	return 0
}

func (m *Profile) GetMoral() int32 {
	if m != nil {
		return m.Moral
	}
	return 0
}

func (m *Profile) GetSilence() int32 {
	if m != nil {
		return m.Silence
	}
	return 0
}

func (m *Profile) GetEmailStatus() int32 {
	if m != nil {
		return m.EmailStatus
	}
	return 0
}

func (m *Profile) GetTelStatus() int32 {
	if m != nil {
		return m.TelStatus
	}
	return 0
}

func (m *Profile) GetIdentification() int32 {
	if m != nil {
		return m.Identification
	}
	return 0
}

func (m *Profile) GetVip() VipInfo {
	if m != nil {
		return m.Vip
	}
	return VipInfo{}
}

func (m *Profile) GetPendant() PendantInfo {
	if m != nil {
		return m.Pendant
	}
	return PendantInfo{}
}

func (m *Profile) GetNameplate() NameplateInfo {
	if m != nil {
		return m.Nameplate
	}
	return NameplateInfo{}
}

func (m *Profile) GetOfficial() OfficialInfo {
	if m != nil {
		return m.Official
	}
	return OfficialInfo{}
}

func (m *Profile) GetBirthday() go_common_library_time.Time {
	if m != nil {
		return m.Birthday
	}
	return 0
}

func (m *Profile) GetIsTourist() int32 {
	if m != nil {
		return m.IsTourist
	}
	return 0
}

// +bili:deepcopy-gen=true
// +bili:deepcopy-gen:structs=go-common/app/service/main/member/model.LevelInfo
type LevelInfo struct {
	Cur                  int32    `protobuf:"varint,1,opt,name=cur,proto3" json:"current_level"`
	Min                  int32    `protobuf:"varint,2,opt,name=min,proto3" json:"current_min"`
	NowExp               int32    `protobuf:"varint,3,opt,name=now_exp,json=nowExp,proto3" json:"current_exp"`
	NextExp              int32    `protobuf:"varint,4,opt,name=next_exp,json=nextExp,proto3" json:"next_exp"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LevelInfo) Reset()         { *m = LevelInfo{} }
func (m *LevelInfo) String() string { return proto.CompactTextString(m) }
func (*LevelInfo) ProtoMessage()    {}
func (*LevelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{3}
}
func (m *LevelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LevelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LevelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LevelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LevelInfo.Merge(dst, src)
}
func (m *LevelInfo) XXX_Size() int {
	return m.Size()
}
func (m *LevelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LevelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LevelInfo proto.InternalMessageInfo

func (m *LevelInfo) GetCur() int32 {
	if m != nil {
		return m.Cur
	}
	return 0
}

func (m *LevelInfo) GetMin() int32 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *LevelInfo) GetNowExp() int32 {
	if m != nil {
		return m.NowExp
	}
	return 0
}

func (m *LevelInfo) GetNextExp() int32 {
	if m != nil {
		return m.NextExp
	}
	return 0
}

type VipInfo struct {
	Type                 int32    `protobuf:"varint,1,opt,name=type,proto3" json:"type"`
	Status               int32    `protobuf:"varint,2,opt,name=status,proto3" json:"status"`
	DueDate              int64    `protobuf:"varint,3,opt,name=due_date,json=dueDate,proto3" json:"due_date"`
	VipPayType           int32    `protobuf:"varint,4,opt,name=vip_pay_type,json=vipPayType,proto3" json:"vip_pay_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VipInfo) Reset()         { *m = VipInfo{} }
func (m *VipInfo) String() string { return proto.CompactTextString(m) }
func (*VipInfo) ProtoMessage()    {}
func (*VipInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{4}
}
func (m *VipInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VipInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VipInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VipInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VipInfo.Merge(dst, src)
}
func (m *VipInfo) XXX_Size() int {
	return m.Size()
}
func (m *VipInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VipInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VipInfo proto.InternalMessageInfo

func (m *VipInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *VipInfo) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *VipInfo) GetDueDate() int64 {
	if m != nil {
		return m.DueDate
	}
	return 0
}

func (m *VipInfo) GetVipPayType() int32 {
	if m != nil {
		return m.VipPayType
	}
	return 0
}

type PendantInfo struct {
	Pid                  int      `protobuf:"varint,1,opt,name=pid,proto3,casttype=int" json:"pid"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Image                string   `protobuf:"bytes,3,opt,name=image,proto3" json:"image"`
	Expire               int      `protobuf:"varint,4,opt,name=expire,proto3,casttype=int" json:"expire"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PendantInfo) Reset()         { *m = PendantInfo{} }
func (m *PendantInfo) String() string { return proto.CompactTextString(m) }
func (*PendantInfo) ProtoMessage()    {}
func (*PendantInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{5}
}
func (m *PendantInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendantInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendantInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PendantInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendantInfo.Merge(dst, src)
}
func (m *PendantInfo) XXX_Size() int {
	return m.Size()
}
func (m *PendantInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PendantInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PendantInfo proto.InternalMessageInfo

func (m *PendantInfo) GetPid() int {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *PendantInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PendantInfo) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *PendantInfo) GetExpire() int {
	if m != nil {
		return m.Expire
	}
	return 0
}

type NameplateInfo struct {
	Nid                  int      `protobuf:"varint,1,opt,name=nid,proto3,casttype=int" json:"nid"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Image                string   `protobuf:"bytes,3,opt,name=image,proto3" json:"image"`
	ImageSmall           string   `protobuf:"bytes,4,opt,name=image_small,json=imageSmall,proto3" json:"image_small"`
	Level                string   `protobuf:"bytes,5,opt,name=level,proto3" json:"level"`
	Condition            string   `protobuf:"bytes,6,opt,name=condition,proto3" json:"condition"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NameplateInfo) Reset()         { *m = NameplateInfo{} }
func (m *NameplateInfo) String() string { return proto.CompactTextString(m) }
func (*NameplateInfo) ProtoMessage()    {}
func (*NameplateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{6}
}
func (m *NameplateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NameplateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NameplateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NameplateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NameplateInfo.Merge(dst, src)
}
func (m *NameplateInfo) XXX_Size() int {
	return m.Size()
}
func (m *NameplateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NameplateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NameplateInfo proto.InternalMessageInfo

func (m *NameplateInfo) GetNid() int {
	if m != nil {
		return m.Nid
	}
	return 0
}

func (m *NameplateInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NameplateInfo) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *NameplateInfo) GetImageSmall() string {
	if m != nil {
		return m.ImageSmall
	}
	return ""
}

func (m *NameplateInfo) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *NameplateInfo) GetCondition() string {
	if m != nil {
		return m.Condition
	}
	return ""
}

// +bili:deepcopy-gen=true
// +bili:deepcopy-gen:structs=go-common/app/service/main/member/model.OfficialInfo
type OfficialInfo struct {
	Role                 int8     `protobuf:"varint,1,opt,name=role,proto3,casttype=int8" json:"role"`
	Title                string   `protobuf:"bytes,2,opt,name=title,proto3" json:"title"`
	Desc                 string   `protobuf:"bytes,3,opt,name=desc,proto3" json:"desc"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OfficialInfo) Reset()         { *m = OfficialInfo{} }
func (m *OfficialInfo) String() string { return proto.CompactTextString(m) }
func (*OfficialInfo) ProtoMessage()    {}
func (*OfficialInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{7}
}
func (m *OfficialInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OfficialInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OfficialInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OfficialInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OfficialInfo.Merge(dst, src)
}
func (m *OfficialInfo) XXX_Size() int {
	return m.Size()
}
func (m *OfficialInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OfficialInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OfficialInfo proto.InternalMessageInfo

func (m *OfficialInfo) GetRole() int8 {
	if m != nil {
		return m.Role
	}
	return 0
}

func (m *OfficialInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *OfficialInfo) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

type MidReq struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" validate:"gt=0,required"`
	RealIp               string   `protobuf:"bytes,2,opt,name=real_ip,json=realIp,proto3" json:"real_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MidReq) Reset()         { *m = MidReq{} }
func (m *MidReq) String() string { return proto.CompactTextString(m) }
func (*MidReq) ProtoMessage()    {}
func (*MidReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{8}
}
func (m *MidReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MidReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MidReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MidReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MidReq.Merge(dst, src)
}
func (m *MidReq) XXX_Size() int {
	return m.Size()
}
func (m *MidReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MidReq.DiscardUnknown(m)
}

var xxx_messageInfo_MidReq proto.InternalMessageInfo

func (m *MidReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *MidReq) GetRealIp() string {
	if m != nil {
		return m.RealIp
	}
	return ""
}

type MidsReq struct {
	Mids                 []int64  `protobuf:"varint,1,rep,packed,name=mids" json:"mids,omitempty" validate:"gt=0,dive,gt=0"`
	RealIp               string   `protobuf:"bytes,2,opt,name=real_ip,json=realIp,proto3" json:"real_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MidsReq) Reset()         { *m = MidsReq{} }
func (m *MidsReq) String() string { return proto.CompactTextString(m) }
func (*MidsReq) ProtoMessage()    {}
func (*MidsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{9}
}
func (m *MidsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MidsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MidsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MidsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MidsReq.Merge(dst, src)
}
func (m *MidsReq) XXX_Size() int {
	return m.Size()
}
func (m *MidsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MidsReq.DiscardUnknown(m)
}

var xxx_messageInfo_MidsReq proto.InternalMessageInfo

func (m *MidsReq) GetMids() []int64 {
	if m != nil {
		return m.Mids
	}
	return nil
}

func (m *MidsReq) GetRealIp() string {
	if m != nil {
		return m.RealIp
	}
	return ""
}

type NamesReq struct {
	Names                []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty" validate:"gt=0,dive,gt=0"`
	RealIp               string   `protobuf:"bytes,2,opt,name=real_ip,json=realIp,proto3" json:"real_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NamesReq) Reset()         { *m = NamesReq{} }
func (m *NamesReq) String() string { return proto.CompactTextString(m) }
func (*NamesReq) ProtoMessage()    {}
func (*NamesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{10}
}
func (m *NamesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NamesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamesReq.Merge(dst, src)
}
func (m *NamesReq) XXX_Size() int {
	return m.Size()
}
func (m *NamesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NamesReq.DiscardUnknown(m)
}

var xxx_messageInfo_NamesReq proto.InternalMessageInfo

func (m *NamesReq) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *NamesReq) GetRealIp() string {
	if m != nil {
		return m.RealIp
	}
	return ""
}

type ExpReq struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" validate:"gt=0,required"`
	Exp                  float64  `protobuf:"fixed64,2,opt,name=exp,proto3" json:"exp,omitempty"`
	Operater             string   `protobuf:"bytes,3,opt,name=operater,proto3" json:"operater,omitempty"`
	Operate              string   `protobuf:"bytes,4,opt,name=operate,proto3" json:"operate,omitempty"`
	Reason               string   `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	RealIp               string   `protobuf:"bytes,6,opt,name=real_ip,json=realIp,proto3" json:"real_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExpReq) Reset()         { *m = ExpReq{} }
func (m *ExpReq) String() string { return proto.CompactTextString(m) }
func (*ExpReq) ProtoMessage()    {}
func (*ExpReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{11}
}
func (m *ExpReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ExpReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpReq.Merge(dst, src)
}
func (m *ExpReq) XXX_Size() int {
	return m.Size()
}
func (m *ExpReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpReq.DiscardUnknown(m)
}

var xxx_messageInfo_ExpReq proto.InternalMessageInfo

func (m *ExpReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ExpReq) GetExp() float64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *ExpReq) GetOperater() string {
	if m != nil {
		return m.Operater
	}
	return ""
}

func (m *ExpReq) GetOperate() string {
	if m != nil {
		return m.Operate
	}
	return ""
}

func (m *ExpReq) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ExpReq) GetRealIp() string {
	if m != nil {
		return m.RealIp
	}
	return ""
}

type MoralReq struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" validate:"gt=0,required"`
	Moral                float64  `protobuf:"fixed64,2,opt,name=moral,proto3" json:"moral,omitempty"`
	Oper                 string   `protobuf:"bytes,3,opt,name=oper,proto3" json:"oper,omitempty"`
	Reason               string   `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Remark               string   `protobuf:"bytes,5,opt,name=remark,proto3" json:"remark,omitempty"`
	RealIp               string   `protobuf:"bytes,6,opt,name=real_ip,json=realIp,proto3" json:"real_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MoralReq) Reset()         { *m = MoralReq{} }
func (m *MoralReq) String() string { return proto.CompactTextString(m) }
func (*MoralReq) ProtoMessage()    {}
func (*MoralReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{12}
}
func (m *MoralReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoralReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoralReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MoralReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoralReq.Merge(dst, src)
}
func (m *MoralReq) XXX_Size() int {
	return m.Size()
}
func (m *MoralReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MoralReq.DiscardUnknown(m)
}

var xxx_messageInfo_MoralReq proto.InternalMessageInfo

func (m *MoralReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *MoralReq) GetMoral() float64 {
	if m != nil {
		return m.Moral
	}
	return 0
}

func (m *MoralReq) GetOper() string {
	if m != nil {
		return m.Oper
	}
	return ""
}

func (m *MoralReq) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *MoralReq) GetRemark() string {
	if m != nil {
		return m.Remark
	}
	return ""
}

func (m *MoralReq) GetRealIp() string {
	if m != nil {
		return m.RealIp
	}
	return ""
}

type RelationReq struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" validate:"gt=0,required"`
	Owner                int64    `protobuf:"varint,2,opt,name=owner,proto3" json:"owner,omitempty"`
	RealIp               string   `protobuf:"bytes,3,opt,name=real_ip,json=realIp,proto3" json:"real_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RelationReq) Reset()         { *m = RelationReq{} }
func (m *RelationReq) String() string { return proto.CompactTextString(m) }
func (*RelationReq) ProtoMessage()    {}
func (*RelationReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{13}
}
func (m *RelationReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RelationReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationReq.Merge(dst, src)
}
func (m *RelationReq) XXX_Size() int {
	return m.Size()
}
func (m *RelationReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationReq.DiscardUnknown(m)
}

var xxx_messageInfo_RelationReq proto.InternalMessageInfo

func (m *RelationReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *RelationReq) GetOwner() int64 {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *RelationReq) GetRealIp() string {
	if m != nil {
		return m.RealIp
	}
	return ""
}

type RelationsReq struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" validate:"gt=0,required"`
	Owners               []int64  `protobuf:"varint,2,rep,packed,name=owners" json:"owners,omitempty"`
	RealIp               string   `protobuf:"bytes,3,opt,name=real_ip,json=realIp,proto3" json:"real_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RelationsReq) Reset()         { *m = RelationsReq{} }
func (m *RelationsReq) String() string { return proto.CompactTextString(m) }
func (*RelationsReq) ProtoMessage()    {}
func (*RelationsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{14}
}
func (m *RelationsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RelationsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationsReq.Merge(dst, src)
}
func (m *RelationsReq) XXX_Size() int {
	return m.Size()
}
func (m *RelationsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationsReq.DiscardUnknown(m)
}

var xxx_messageInfo_RelationsReq proto.InternalMessageInfo

func (m *RelationsReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *RelationsReq) GetOwners() []int64 {
	if m != nil {
		return m.Owners
	}
	return nil
}

func (m *RelationsReq) GetRealIp() string {
	if m != nil {
		return m.RealIp
	}
	return ""
}

type RichRelationReq struct {
	Owner                int64    `protobuf:"varint,1,opt,name=owner,proto3" json:"owner,omitempty"`
	Mids                 []int64  `protobuf:"varint,2,rep,packed,name=mids" json:"mids,omitempty" validate:"gt=0,dive,gt=0"`
	RealIp               string   `protobuf:"bytes,3,opt,name=real_ip,json=realIp,proto3" json:"real_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RichRelationReq) Reset()         { *m = RichRelationReq{} }
func (m *RichRelationReq) String() string { return proto.CompactTextString(m) }
func (*RichRelationReq) ProtoMessage()    {}
func (*RichRelationReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{15}
}
func (m *RichRelationReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RichRelationReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RichRelationReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RichRelationReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RichRelationReq.Merge(dst, src)
}
func (m *RichRelationReq) XXX_Size() int {
	return m.Size()
}
func (m *RichRelationReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RichRelationReq.DiscardUnknown(m)
}

var xxx_messageInfo_RichRelationReq proto.InternalMessageInfo

func (m *RichRelationReq) GetOwner() int64 {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *RichRelationReq) GetMids() []int64 {
	if m != nil {
		return m.Mids
	}
	return nil
}

func (m *RichRelationReq) GetRealIp() string {
	if m != nil {
		return m.RealIp
	}
	return ""
}

type InfoReply struct {
	Info                 *Info    `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InfoReply) Reset()         { *m = InfoReply{} }
func (m *InfoReply) String() string { return proto.CompactTextString(m) }
func (*InfoReply) ProtoMessage()    {}
func (*InfoReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{16}
}
func (m *InfoReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfoReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfoReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InfoReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfoReply.Merge(dst, src)
}
func (m *InfoReply) XXX_Size() int {
	return m.Size()
}
func (m *InfoReply) XXX_DiscardUnknown() {
	xxx_messageInfo_InfoReply.DiscardUnknown(m)
}

var xxx_messageInfo_InfoReply proto.InternalMessageInfo

func (m *InfoReply) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

type InfosReply struct {
	Infos                map[int64]*Info `protobuf:"bytes,1,rep,name=infos" json:"infos,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *InfosReply) Reset()         { *m = InfosReply{} }
func (m *InfosReply) String() string { return proto.CompactTextString(m) }
func (*InfosReply) ProtoMessage()    {}
func (*InfosReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{17}
}
func (m *InfosReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InfosReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InfosReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InfosReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfosReply.Merge(dst, src)
}
func (m *InfosReply) XXX_Size() int {
	return m.Size()
}
func (m *InfosReply) XXX_DiscardUnknown() {
	xxx_messageInfo_InfosReply.DiscardUnknown(m)
}

var xxx_messageInfo_InfosReply proto.InternalMessageInfo

func (m *InfosReply) GetInfos() map[int64]*Info {
	if m != nil {
		return m.Infos
	}
	return nil
}

type CardReply struct {
	Card                 *Card    `protobuf:"bytes,1,opt,name=card" json:"card,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CardReply) Reset()         { *m = CardReply{} }
func (m *CardReply) String() string { return proto.CompactTextString(m) }
func (*CardReply) ProtoMessage()    {}
func (*CardReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{18}
}
func (m *CardReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CardReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardReply.Merge(dst, src)
}
func (m *CardReply) XXX_Size() int {
	return m.Size()
}
func (m *CardReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CardReply.DiscardUnknown(m)
}

var xxx_messageInfo_CardReply proto.InternalMessageInfo

func (m *CardReply) GetCard() *Card {
	if m != nil {
		return m.Card
	}
	return nil
}

type CardsReply struct {
	Cards                map[int64]*Card `protobuf:"bytes,1,rep,name=cards" json:"cards,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CardsReply) Reset()         { *m = CardsReply{} }
func (m *CardsReply) String() string { return proto.CompactTextString(m) }
func (*CardsReply) ProtoMessage()    {}
func (*CardsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{19}
}
func (m *CardsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CardsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CardsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardsReply.Merge(dst, src)
}
func (m *CardsReply) XXX_Size() int {
	return m.Size()
}
func (m *CardsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CardsReply.DiscardUnknown(m)
}

var xxx_messageInfo_CardsReply proto.InternalMessageInfo

func (m *CardsReply) GetCards() map[int64]*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

type ProfileReply struct {
	Profile              *Profile `protobuf:"bytes,1,opt,name=profile" json:"profile,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProfileReply) Reset()         { *m = ProfileReply{} }
func (m *ProfileReply) String() string { return proto.CompactTextString(m) }
func (*ProfileReply) ProtoMessage()    {}
func (*ProfileReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{20}
}
func (m *ProfileReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfileReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfileReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProfileReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfileReply.Merge(dst, src)
}
func (m *ProfileReply) XXX_Size() int {
	return m.Size()
}
func (m *ProfileReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfileReply.DiscardUnknown(m)
}

var xxx_messageInfo_ProfileReply proto.InternalMessageInfo

func (m *ProfileReply) GetProfile() *Profile {
	if m != nil {
		return m.Profile
	}
	return nil
}

type ProfileStatReply struct {
	Profile              *Profile  `protobuf:"bytes,1,opt,name=profile" json:"profile,omitempty"`
	LevelInfo            LevelInfo `protobuf:"bytes,2,opt,name=level_info,json=levelInfo" json:"level_info"`
	Coins                float64   `protobuf:"fixed64,3,opt,name=coins,proto3" json:"coins,omitempty"`
	Following            int64     `protobuf:"varint,4,opt,name=following,proto3" json:"following,omitempty"`
	Follower             int64     `protobuf:"varint,5,opt,name=follower,proto3" json:"follower,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ProfileStatReply) Reset()         { *m = ProfileStatReply{} }
func (m *ProfileStatReply) String() string { return proto.CompactTextString(m) }
func (*ProfileStatReply) ProtoMessage()    {}
func (*ProfileStatReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{21}
}
func (m *ProfileStatReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfileStatReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfileStatReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ProfileStatReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfileStatReply.Merge(dst, src)
}
func (m *ProfileStatReply) XXX_Size() int {
	return m.Size()
}
func (m *ProfileStatReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfileStatReply.DiscardUnknown(m)
}

var xxx_messageInfo_ProfileStatReply proto.InternalMessageInfo

func (m *ProfileStatReply) GetProfile() *Profile {
	if m != nil {
		return m.Profile
	}
	return nil
}

func (m *ProfileStatReply) GetLevelInfo() LevelInfo {
	if m != nil {
		return m.LevelInfo
	}
	return LevelInfo{}
}

func (m *ProfileStatReply) GetCoins() float64 {
	if m != nil {
		return m.Coins
	}
	return 0
}

func (m *ProfileStatReply) GetFollowing() int64 {
	if m != nil {
		return m.Following
	}
	return 0
}

func (m *ProfileStatReply) GetFollower() int64 {
	if m != nil {
		return m.Follower
	}
	return 0
}

type RelationReply struct {
	Following            bool     `protobuf:"varint,1,opt,name=following,proto3" json:"following,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RelationReply) Reset()         { *m = RelationReply{} }
func (m *RelationReply) String() string { return proto.CompactTextString(m) }
func (*RelationReply) ProtoMessage()    {}
func (*RelationReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{22}
}
func (m *RelationReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RelationReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationReply.Merge(dst, src)
}
func (m *RelationReply) XXX_Size() int {
	return m.Size()
}
func (m *RelationReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationReply.DiscardUnknown(m)
}

var xxx_messageInfo_RelationReply proto.InternalMessageInfo

func (m *RelationReply) GetFollowing() bool {
	if m != nil {
		return m.Following
	}
	return false
}

type AttentionsReply struct {
	Attentions           []int64  `protobuf:"varint,1,rep,packed,name=attentions" json:"attentions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttentionsReply) Reset()         { *m = AttentionsReply{} }
func (m *AttentionsReply) String() string { return proto.CompactTextString(m) }
func (*AttentionsReply) ProtoMessage()    {}
func (*AttentionsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{23}
}
func (m *AttentionsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttentionsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttentionsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AttentionsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttentionsReply.Merge(dst, src)
}
func (m *AttentionsReply) XXX_Size() int {
	return m.Size()
}
func (m *AttentionsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AttentionsReply.DiscardUnknown(m)
}

var xxx_messageInfo_AttentionsReply proto.InternalMessageInfo

func (m *AttentionsReply) GetAttentions() []int64 {
	if m != nil {
		return m.Attentions
	}
	return nil
}

type BlacksReply struct {
	BlackList            map[int64]bool `protobuf:"bytes,1,rep,name=black_list,json=blackList" json:"black_list,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BlacksReply) Reset()         { *m = BlacksReply{} }
func (m *BlacksReply) String() string { return proto.CompactTextString(m) }
func (*BlacksReply) ProtoMessage()    {}
func (*BlacksReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{24}
}
func (m *BlacksReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlacksReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlacksReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlacksReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlacksReply.Merge(dst, src)
}
func (m *BlacksReply) XXX_Size() int {
	return m.Size()
}
func (m *BlacksReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BlacksReply.DiscardUnknown(m)
}

var xxx_messageInfo_BlacksReply proto.InternalMessageInfo

func (m *BlacksReply) GetBlackList() map[int64]bool {
	if m != nil {
		return m.BlackList
	}
	return nil
}

type RelationsReply struct {
	Relations            map[int64]*RelationReply `protobuf:"bytes,1,rep,name=relations" json:"relations,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *RelationsReply) Reset()         { *m = RelationsReply{} }
func (m *RelationsReply) String() string { return proto.CompactTextString(m) }
func (*RelationsReply) ProtoMessage()    {}
func (*RelationsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{25}
}
func (m *RelationsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RelationsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationsReply.Merge(dst, src)
}
func (m *RelationsReply) XXX_Size() int {
	return m.Size()
}
func (m *RelationsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationsReply.DiscardUnknown(m)
}

var xxx_messageInfo_RelationsReply proto.InternalMessageInfo

func (m *RelationsReply) GetRelations() map[int64]*RelationReply {
	if m != nil {
		return m.Relations
	}
	return nil
}

type RichRelationsReply struct {
	RichRelations        map[int64]int32 `protobuf:"bytes,1,rep,name=rich_relations,json=richRelations" json:"rich_relations,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RichRelationsReply) Reset()         { *m = RichRelationsReply{} }
func (m *RichRelationsReply) String() string { return proto.CompactTextString(m) }
func (*RichRelationsReply) ProtoMessage()    {}
func (*RichRelationsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{26}
}
func (m *RichRelationsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RichRelationsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RichRelationsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RichRelationsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RichRelationsReply.Merge(dst, src)
}
func (m *RichRelationsReply) XXX_Size() int {
	return m.Size()
}
func (m *RichRelationsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RichRelationsReply.DiscardUnknown(m)
}

var xxx_messageInfo_RichRelationsReply proto.InternalMessageInfo

func (m *RichRelationsReply) GetRichRelations() map[int64]int32 {
	if m != nil {
		return m.RichRelations
	}
	return nil
}

// +bili:deepcopy-gen=true
// +bili:deepcopy-gen:structs=go-common/app/service/main/account/api.VipInfo
type VipReply struct {
	Type                 int32    `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Status               int32    `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	DueDate              int64    `protobuf:"varint,3,opt,name=due_date,json=dueDate,proto3" json:"due_date,omitempty"`
	VipPayType           int32    `protobuf:"varint,4,opt,name=vip_pay_type,json=vipPayType,proto3" json:"vip_pay_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VipReply) Reset()         { *m = VipReply{} }
func (m *VipReply) String() string { return proto.CompactTextString(m) }
func (*VipReply) ProtoMessage()    {}
func (*VipReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{27}
}
func (m *VipReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VipReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VipReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VipReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VipReply.Merge(dst, src)
}
func (m *VipReply) XXX_Size() int {
	return m.Size()
}
func (m *VipReply) XXX_DiscardUnknown() {
	xxx_messageInfo_VipReply.DiscardUnknown(m)
}

var xxx_messageInfo_VipReply proto.InternalMessageInfo

func (m *VipReply) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *VipReply) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *VipReply) GetDueDate() int64 {
	if m != nil {
		return m.DueDate
	}
	return 0
}

func (m *VipReply) GetVipPayType() int32 {
	if m != nil {
		return m.VipPayType
	}
	return 0
}

type VipsReply struct {
	Vips                 map[int64]*VipReply `protobuf:"bytes,1,rep,name=vips" json:"vips,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *VipsReply) Reset()         { *m = VipsReply{} }
func (m *VipsReply) String() string { return proto.CompactTextString(m) }
func (*VipsReply) ProtoMessage()    {}
func (*VipsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{28}
}
func (m *VipsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VipsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VipsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VipsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VipsReply.Merge(dst, src)
}
func (m *VipsReply) XXX_Size() int {
	return m.Size()
}
func (m *VipsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_VipsReply.DiscardUnknown(m)
}

var xxx_messageInfo_VipsReply proto.InternalMessageInfo

func (m *VipsReply) GetVips() map[int64]*VipReply {
	if m != nil {
		return m.Vips
	}
	return nil
}

type ExpReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExpReply) Reset()         { *m = ExpReply{} }
func (m *ExpReply) String() string { return proto.CompactTextString(m) }
func (*ExpReply) ProtoMessage()    {}
func (*ExpReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{29}
}
func (m *ExpReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ExpReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpReply.Merge(dst, src)
}
func (m *ExpReply) XXX_Size() int {
	return m.Size()
}
func (m *ExpReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpReply.DiscardUnknown(m)
}

var xxx_messageInfo_ExpReply proto.InternalMessageInfo

type MoralReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MoralReply) Reset()         { *m = MoralReply{} }
func (m *MoralReply) String() string { return proto.CompactTextString(m) }
func (*MoralReply) ProtoMessage()    {}
func (*MoralReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_f24f062ee2ba9e19, []int{30}
}
func (m *MoralReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoralReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoralReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MoralReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoralReply.Merge(dst, src)
}
func (m *MoralReply) XXX_Size() int {
	return m.Size()
}
func (m *MoralReply) XXX_DiscardUnknown() {
	xxx_messageInfo_MoralReply.DiscardUnknown(m)
}

var xxx_messageInfo_MoralReply proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Card)(nil), "account.service.Card")
	proto.RegisterType((*Info)(nil), "account.service.Info")
	proto.RegisterType((*Profile)(nil), "account.service.Profile")
	proto.RegisterType((*LevelInfo)(nil), "account.service.LevelInfo")
	proto.RegisterType((*VipInfo)(nil), "account.service.VipInfo")
	proto.RegisterType((*PendantInfo)(nil), "account.service.PendantInfo")
	proto.RegisterType((*NameplateInfo)(nil), "account.service.NameplateInfo")
	proto.RegisterType((*OfficialInfo)(nil), "account.service.OfficialInfo")
	proto.RegisterType((*MidReq)(nil), "account.service.MidReq")
	proto.RegisterType((*MidsReq)(nil), "account.service.MidsReq")
	proto.RegisterType((*NamesReq)(nil), "account.service.NamesReq")
	proto.RegisterType((*ExpReq)(nil), "account.service.ExpReq")
	proto.RegisterType((*MoralReq)(nil), "account.service.MoralReq")
	proto.RegisterType((*RelationReq)(nil), "account.service.RelationReq")
	proto.RegisterType((*RelationsReq)(nil), "account.service.RelationsReq")
	proto.RegisterType((*RichRelationReq)(nil), "account.service.RichRelationReq")
	proto.RegisterType((*InfoReply)(nil), "account.service.InfoReply")
	proto.RegisterType((*InfosReply)(nil), "account.service.InfosReply")
	proto.RegisterMapType((map[int64]*Info)(nil), "account.service.InfosReply.InfosEntry")
	proto.RegisterType((*CardReply)(nil), "account.service.CardReply")
	proto.RegisterType((*CardsReply)(nil), "account.service.CardsReply")
	proto.RegisterMapType((map[int64]*Card)(nil), "account.service.CardsReply.CardsEntry")
	proto.RegisterType((*ProfileReply)(nil), "account.service.ProfileReply")
	proto.RegisterType((*ProfileStatReply)(nil), "account.service.ProfileStatReply")
	proto.RegisterType((*RelationReply)(nil), "account.service.RelationReply")
	proto.RegisterType((*AttentionsReply)(nil), "account.service.AttentionsReply")
	proto.RegisterType((*BlacksReply)(nil), "account.service.BlacksReply")
	proto.RegisterMapType((map[int64]bool)(nil), "account.service.BlacksReply.BlackListEntry")
	proto.RegisterType((*RelationsReply)(nil), "account.service.RelationsReply")
	proto.RegisterMapType((map[int64]*RelationReply)(nil), "account.service.RelationsReply.RelationsEntry")
	proto.RegisterType((*RichRelationsReply)(nil), "account.service.RichRelationsReply")
	proto.RegisterMapType((map[int64]int32)(nil), "account.service.RichRelationsReply.RichRelationsEntry")
	proto.RegisterType((*VipReply)(nil), "account.service.VipReply")
	proto.RegisterType((*VipsReply)(nil), "account.service.VipsReply")
	proto.RegisterMapType((map[int64]*VipReply)(nil), "account.service.VipsReply.VipsEntry")
	proto.RegisterType((*ExpReply)(nil), "account.service.ExpReply")
	proto.RegisterType((*MoralReply)(nil), "account.service.MoralReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AccountClient is the client API for Account service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccountClient interface {
	Info3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*InfoReply, error)
	Infos3(ctx context.Context, in *MidsReq, opts ...grpc.CallOption) (*InfosReply, error)
	InfosByName3(ctx context.Context, in *NamesReq, opts ...grpc.CallOption) (*InfosReply, error)
	Card3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*CardReply, error)
	Cards3(ctx context.Context, in *MidsReq, opts ...grpc.CallOption) (*CardsReply, error)
	Profile3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*ProfileReply, error)
	ProfileWithStat3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*ProfileStatReply, error)
	AddExp3(ctx context.Context, in *ExpReq, opts ...grpc.CallOption) (*ExpReply, error)
	AddMoral3(ctx context.Context, in *MoralReq, opts ...grpc.CallOption) (*MoralReply, error)
	Relation3(ctx context.Context, in *RelationReq, opts ...grpc.CallOption) (*RelationReply, error)
	Attentions3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*AttentionsReply, error)
	Blacks3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*BlacksReply, error)
	Relations3(ctx context.Context, in *RelationsReq, opts ...grpc.CallOption) (*RelationsReply, error)
	RichRelations3(ctx context.Context, in *RichRelationReq, opts ...grpc.CallOption) (*RichRelationsReply, error)
	Vip3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*VipReply, error)
	Vips3(ctx context.Context, in *MidsReq, opts ...grpc.CallOption) (*VipsReply, error)
}

type accountClient struct {
	cc *grpc.ClientConn
}

func NewAccountClient(cc *grpc.ClientConn) AccountClient {
	return &accountClient{cc}
}

func (c *accountClient) Info3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*InfoReply, error) {
	out := new(InfoReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Info3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Infos3(ctx context.Context, in *MidsReq, opts ...grpc.CallOption) (*InfosReply, error) {
	out := new(InfosReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Infos3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) InfosByName3(ctx context.Context, in *NamesReq, opts ...grpc.CallOption) (*InfosReply, error) {
	out := new(InfosReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/InfosByName3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Card3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*CardReply, error) {
	out := new(CardReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Card3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Cards3(ctx context.Context, in *MidsReq, opts ...grpc.CallOption) (*CardsReply, error) {
	out := new(CardsReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Cards3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Profile3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*ProfileReply, error) {
	out := new(ProfileReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Profile3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) ProfileWithStat3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*ProfileStatReply, error) {
	out := new(ProfileStatReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/ProfileWithStat3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) AddExp3(ctx context.Context, in *ExpReq, opts ...grpc.CallOption) (*ExpReply, error) {
	out := new(ExpReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/AddExp3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) AddMoral3(ctx context.Context, in *MoralReq, opts ...grpc.CallOption) (*MoralReply, error) {
	out := new(MoralReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/AddMoral3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Relation3(ctx context.Context, in *RelationReq, opts ...grpc.CallOption) (*RelationReply, error) {
	out := new(RelationReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Relation3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Attentions3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*AttentionsReply, error) {
	out := new(AttentionsReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Attentions3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Blacks3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*BlacksReply, error) {
	out := new(BlacksReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Blacks3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Relations3(ctx context.Context, in *RelationsReq, opts ...grpc.CallOption) (*RelationsReply, error) {
	out := new(RelationsReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Relations3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) RichRelations3(ctx context.Context, in *RichRelationReq, opts ...grpc.CallOption) (*RichRelationsReply, error) {
	out := new(RichRelationsReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/RichRelations3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Vip3(ctx context.Context, in *MidReq, opts ...grpc.CallOption) (*VipReply, error) {
	out := new(VipReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Vip3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) Vips3(ctx context.Context, in *MidsReq, opts ...grpc.CallOption) (*VipsReply, error) {
	out := new(VipsReply)
	err := c.cc.Invoke(ctx, "/account.service.Account/Vips3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountServer is the server API for Account service.
type AccountServer interface {
	Info3(context.Context, *MidReq) (*InfoReply, error)
	Infos3(context.Context, *MidsReq) (*InfosReply, error)
	InfosByName3(context.Context, *NamesReq) (*InfosReply, error)
	Card3(context.Context, *MidReq) (*CardReply, error)
	Cards3(context.Context, *MidsReq) (*CardsReply, error)
	Profile3(context.Context, *MidReq) (*ProfileReply, error)
	ProfileWithStat3(context.Context, *MidReq) (*ProfileStatReply, error)
	AddExp3(context.Context, *ExpReq) (*ExpReply, error)
	AddMoral3(context.Context, *MoralReq) (*MoralReply, error)
	Relation3(context.Context, *RelationReq) (*RelationReply, error)
	Attentions3(context.Context, *MidReq) (*AttentionsReply, error)
	Blacks3(context.Context, *MidReq) (*BlacksReply, error)
	Relations3(context.Context, *RelationsReq) (*RelationsReply, error)
	RichRelations3(context.Context, *RichRelationReq) (*RichRelationsReply, error)
	Vip3(context.Context, *MidReq) (*VipReply, error)
	Vips3(context.Context, *MidsReq) (*VipsReply, error)
}

func RegisterAccountServer(s *grpc.Server, srv AccountServer) {
	s.RegisterService(&_Account_serviceDesc, srv)
}

func _Account_Info3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Info3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Info3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Info3(ctx, req.(*MidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Infos3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Infos3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Infos3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Infos3(ctx, req.(*MidsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_InfosByName3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).InfosByName3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/InfosByName3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).InfosByName3(ctx, req.(*NamesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Card3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Card3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Card3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Card3(ctx, req.(*MidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Cards3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Cards3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Cards3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Cards3(ctx, req.(*MidsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Profile3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Profile3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Profile3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Profile3(ctx, req.(*MidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_ProfileWithStat3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).ProfileWithStat3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/ProfileWithStat3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).ProfileWithStat3(ctx, req.(*MidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_AddExp3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).AddExp3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/AddExp3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).AddExp3(ctx, req.(*ExpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_AddMoral3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoralReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).AddMoral3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/AddMoral3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).AddMoral3(ctx, req.(*MoralReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Relation3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Relation3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Relation3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Relation3(ctx, req.(*RelationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Attentions3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Attentions3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Attentions3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Attentions3(ctx, req.(*MidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Blacks3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Blacks3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Blacks3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Blacks3(ctx, req.(*MidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Relations3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RelationsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Relations3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Relations3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Relations3(ctx, req.(*RelationsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_RichRelations3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RichRelationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).RichRelations3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/RichRelations3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).RichRelations3(ctx, req.(*RichRelationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Vip3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Vip3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Vip3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Vip3(ctx, req.(*MidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_Vips3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).Vips3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/account.service.Account/Vips3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).Vips3(ctx, req.(*MidsReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Account_serviceDesc = grpc.ServiceDesc{
	ServiceName: "account.service.Account",
	HandlerType: (*AccountServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info3",
			Handler:    _Account_Info3_Handler,
		},
		{
			MethodName: "Infos3",
			Handler:    _Account_Infos3_Handler,
		},
		{
			MethodName: "InfosByName3",
			Handler:    _Account_InfosByName3_Handler,
		},
		{
			MethodName: "Card3",
			Handler:    _Account_Card3_Handler,
		},
		{
			MethodName: "Cards3",
			Handler:    _Account_Cards3_Handler,
		},
		{
			MethodName: "Profile3",
			Handler:    _Account_Profile3_Handler,
		},
		{
			MethodName: "ProfileWithStat3",
			Handler:    _Account_ProfileWithStat3_Handler,
		},
		{
			MethodName: "AddExp3",
			Handler:    _Account_AddExp3_Handler,
		},
		{
			MethodName: "AddMoral3",
			Handler:    _Account_AddMoral3_Handler,
		},
		{
			MethodName: "Relation3",
			Handler:    _Account_Relation3_Handler,
		},
		{
			MethodName: "Attentions3",
			Handler:    _Account_Attentions3_Handler,
		},
		{
			MethodName: "Blacks3",
			Handler:    _Account_Blacks3_Handler,
		},
		{
			MethodName: "Relations3",
			Handler:    _Account_Relations3_Handler,
		},
		{
			MethodName: "RichRelations3",
			Handler:    _Account_RichRelations3_Handler,
		},
		{
			MethodName: "Vip3",
			Handler:    _Account_Vip3_Handler,
		},
		{
			MethodName: "Vips3",
			Handler:    _Account_Vips3_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/main/account/api/api.proto",
}

func (m *Card) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Card) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Sex) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sex)))
		i += copy(dAtA[i:], m.Sex)
	}
	if len(m.Face) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Face)))
		i += copy(dAtA[i:], m.Face)
	}
	if len(m.Sign) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if m.Rank != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
	}
	if m.Level != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Level))
	}
	if m.Silence != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Silence))
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Vip.Size()))
	n1, err := m.Vip.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x52
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Pendant.Size()))
	n2, err := m.Pendant.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x5a
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Nameplate.Size()))
	n3, err := m.Nameplate.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x62
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Official.Size()))
	n4, err := m.Official.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Sex) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sex)))
		i += copy(dAtA[i:], m.Sex)
	}
	if len(m.Face) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Face)))
		i += copy(dAtA[i:], m.Face)
	}
	if len(m.Sign) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if m.Rank != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Profile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Profile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Sex) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sex)))
		i += copy(dAtA[i:], m.Sex)
	}
	if len(m.Face) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Face)))
		i += copy(dAtA[i:], m.Face)
	}
	if len(m.Sign) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sign)))
		i += copy(dAtA[i:], m.Sign)
	}
	if m.Rank != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rank))
	}
	if m.Level != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Level))
	}
	if m.JoinTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.JoinTime))
	}
	if m.Moral != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Moral))
	}
	if m.Silence != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Silence))
	}
	if m.EmailStatus != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.EmailStatus))
	}
	if m.TelStatus != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TelStatus))
	}
	if m.Identification != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Identification))
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Vip.Size()))
	n5, err := m.Vip.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x7a
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Pendant.Size()))
	n6, err := m.Pendant.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Nameplate.Size()))
	n7, err := m.Nameplate.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Official.Size()))
	n8, err := m.Official.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.Birthday != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Birthday))
	}
	if m.IsTourist != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IsTourist))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LevelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LevelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cur != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cur))
	}
	if m.Min != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Min))
	}
	if m.NowExp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NowExp))
	}
	if m.NextExp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NextExp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VipInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if m.DueDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DueDate))
	}
	if m.VipPayType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VipPayType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PendantInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendantInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.Expire != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Expire))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NameplateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NameplateInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Nid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Nid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ImageSmall) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ImageSmall)))
		i += copy(dAtA[i:], m.ImageSmall)
	}
	if len(m.Level) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Level)))
		i += copy(dAtA[i:], m.Level)
	}
	if len(m.Condition) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Condition)))
		i += copy(dAtA[i:], m.Condition)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OfficialInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OfficialInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Role != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Role))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.RealIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RealIp)))
		i += copy(dAtA[i:], m.RealIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MidsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MidsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mids) > 0 {
		dAtA10 := make([]byte, len(m.Mids)*10)
		var j9 int
		for _, num1 := range m.Mids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if len(m.RealIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RealIp)))
		i += copy(dAtA[i:], m.RealIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NamesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RealIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RealIp)))
		i += copy(dAtA[i:], m.RealIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Exp))))
		i += 8
	}
	if len(m.Operater) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Operater)))
		i += copy(dAtA[i:], m.Operater)
	}
	if len(m.Operate) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Operate)))
		i += copy(dAtA[i:], m.Operate)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.RealIp) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RealIp)))
		i += copy(dAtA[i:], m.RealIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MoralReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoralReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Moral != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Moral))))
		i += 8
	}
	if len(m.Oper) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Oper)))
		i += copy(dAtA[i:], m.Oper)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Remark) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Remark)))
		i += copy(dAtA[i:], m.Remark)
	}
	if len(m.RealIp) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RealIp)))
		i += copy(dAtA[i:], m.RealIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RelationReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Owner != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Owner))
	}
	if len(m.RealIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RealIp)))
		i += copy(dAtA[i:], m.RealIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RelationsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Owners) > 0 {
		dAtA12 := make([]byte, len(m.Owners)*10)
		var j11 int
		for _, num1 := range m.Owners {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if len(m.RealIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RealIp)))
		i += copy(dAtA[i:], m.RealIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RichRelationReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RichRelationReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Owner != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Owner))
	}
	if len(m.Mids) > 0 {
		dAtA14 := make([]byte, len(m.Mids)*10)
		var j13 int
		for _, num1 := range m.Mids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if len(m.RealIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RealIp)))
		i += copy(dAtA[i:], m.RealIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InfoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Info.Size()))
		n15, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InfosReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfosReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for k, _ := range m.Infos {
			dAtA[i] = 0xa
			i++
			v := m.Infos[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n16, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n16
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Card.Size()))
		n17, err := m.Card.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CardsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for k, _ := range m.Cards {
			dAtA[i] = 0xa
			i++
			v := m.Cards[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n18, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n18
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProfileReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfileReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Profile != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Profile.Size()))
		n19, err := m.Profile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProfileStatReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfileStatReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Profile != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Profile.Size()))
		n20, err := m.Profile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.LevelInfo.Size()))
	n21, err := m.LevelInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	if m.Coins != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Coins))))
		i += 8
	}
	if m.Following != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Following))
	}
	if m.Follower != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Follower))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RelationReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Following {
		dAtA[i] = 0x8
		i++
		if m.Following {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttentionsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttentionsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attentions) > 0 {
		dAtA23 := make([]byte, len(m.Attentions)*10)
		var j22 int
		for _, num1 := range m.Attentions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlacksReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlacksReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlackList) > 0 {
		for k, _ := range m.BlackList {
			dAtA[i] = 0xa
			i++
			v := m.BlackList[k]
			mapSize := 1 + sovApi(uint64(k)) + 1 + 1
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RelationsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Relations) > 0 {
		for k, _ := range m.Relations {
			dAtA[i] = 0xa
			i++
			v := m.Relations[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n24, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n24
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RichRelationsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RichRelationsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RichRelations) > 0 {
		for k, _ := range m.RichRelations {
			dAtA[i] = 0xa
			i++
			v := m.RichRelations[k]
			mapSize := 1 + sovApi(uint64(k)) + 1 + sovApi(uint64(v))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintApi(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VipReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Status))
	}
	if m.DueDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DueDate))
	}
	if m.VipPayType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VipPayType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VipsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vips) > 0 {
		for k, _ := range m.Vips {
			dAtA[i] = 0xa
			i++
			v := m.Vips[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n25, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n25
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExpReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MoralReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoralReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Card) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sex)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.Level != 0 {
		n += 1 + sovApi(uint64(m.Level))
	}
	if m.Silence != 0 {
		n += 1 + sovApi(uint64(m.Silence))
	}
	l = m.Vip.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Pendant.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Nameplate.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Official.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sex)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Profile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sex)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovApi(uint64(m.Rank))
	}
	if m.Level != 0 {
		n += 1 + sovApi(uint64(m.Level))
	}
	if m.JoinTime != 0 {
		n += 1 + sovApi(uint64(m.JoinTime))
	}
	if m.Moral != 0 {
		n += 1 + sovApi(uint64(m.Moral))
	}
	if m.Silence != 0 {
		n += 1 + sovApi(uint64(m.Silence))
	}
	if m.EmailStatus != 0 {
		n += 1 + sovApi(uint64(m.EmailStatus))
	}
	if m.TelStatus != 0 {
		n += 1 + sovApi(uint64(m.TelStatus))
	}
	if m.Identification != 0 {
		n += 1 + sovApi(uint64(m.Identification))
	}
	l = m.Vip.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Pendant.Size()
	n += 1 + l + sovApi(uint64(l))
	l = m.Nameplate.Size()
	n += 2 + l + sovApi(uint64(l))
	l = m.Official.Size()
	n += 2 + l + sovApi(uint64(l))
	if m.Birthday != 0 {
		n += 2 + sovApi(uint64(m.Birthday))
	}
	if m.IsTourist != 0 {
		n += 2 + sovApi(uint64(m.IsTourist))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LevelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cur != 0 {
		n += 1 + sovApi(uint64(m.Cur))
	}
	if m.Min != 0 {
		n += 1 + sovApi(uint64(m.Min))
	}
	if m.NowExp != 0 {
		n += 1 + sovApi(uint64(m.NowExp))
	}
	if m.NextExp != 0 {
		n += 1 + sovApi(uint64(m.NextExp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VipInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.DueDate != 0 {
		n += 1 + sovApi(uint64(m.DueDate))
	}
	if m.VipPayType != 0 {
		n += 1 + sovApi(uint64(m.VipPayType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PendantInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovApi(uint64(m.Pid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Expire != 0 {
		n += 1 + sovApi(uint64(m.Expire))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NameplateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nid != 0 {
		n += 1 + sovApi(uint64(m.Nid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ImageSmall)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Condition)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OfficialInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != 0 {
		n += 1 + sovApi(uint64(m.Role))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MidReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.RealIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MidsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mids) > 0 {
		l = 0
		for _, e := range m.Mids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	l = len(m.RealIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NamesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.RealIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExpReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Exp != 0 {
		n += 9
	}
	l = len(m.Operater)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Operate)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.RealIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MoralReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Moral != 0 {
		n += 9
	}
	l = len(m.Oper)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.RealIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RelationReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Owner != 0 {
		n += 1 + sovApi(uint64(m.Owner))
	}
	l = len(m.RealIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RelationsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if len(m.Owners) > 0 {
		l = 0
		for _, e := range m.Owners {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	l = len(m.RealIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RichRelationReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != 0 {
		n += 1 + sovApi(uint64(m.Owner))
	}
	if len(m.Mids) > 0 {
		l = 0
		for _, e := range m.Mids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	l = len(m.RealIp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InfoReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InfosReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for k, v := range m.Infos {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CardReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CardsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for k, v := range m.Cards {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProfileReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProfileStatReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.LevelInfo.Size()
	n += 1 + l + sovApi(uint64(l))
	if m.Coins != 0 {
		n += 9
	}
	if m.Following != 0 {
		n += 1 + sovApi(uint64(m.Following))
	}
	if m.Follower != 0 {
		n += 1 + sovApi(uint64(m.Follower))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RelationReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Following {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttentionsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attentions) > 0 {
		l = 0
		for _, e := range m.Attentions {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlacksReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BlackList) > 0 {
		for k, v := range m.BlackList {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RelationsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Relations) > 0 {
		for k, v := range m.Relations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RichRelationsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RichRelations) > 0 {
		for k, v := range m.RichRelations {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VipReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovApi(uint64(m.Status))
	}
	if m.DueDate != 0 {
		n += 1 + sovApi(uint64(m.DueDate))
	}
	if m.VipPayType != 0 {
		n += 1 + sovApi(uint64(m.VipPayType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VipsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vips) > 0 {
		for k, v := range m.Vips {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExpReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MoralReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Card) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Card: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Card: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silence", wireType)
			}
			m.Silence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Silence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Vip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pendant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pendant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nameplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Nameplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Official.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinTime", wireType)
			}
			m.JoinTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moral", wireType)
			}
			m.Moral = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Moral |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silence", wireType)
			}
			m.Silence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Silence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailStatus", wireType)
			}
			m.EmailStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmailStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelStatus", wireType)
			}
			m.TelStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TelStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identification", wireType)
			}
			m.Identification = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Identification |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Vip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pendant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pendant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nameplate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Nameplate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Official.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Birthday", wireType)
			}
			m.Birthday = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Birthday |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTourist", wireType)
			}
			m.IsTourist = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsTourist |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LevelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LevelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LevelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cur", wireType)
			}
			m.Cur = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cur |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			m.Min = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Min |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowExp", wireType)
			}
			m.NowExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextExp", wireType)
			}
			m.NextExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextExp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DueDate", wireType)
			}
			m.DueDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DueDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipPayType", wireType)
			}
			m.VipPayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipPayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendantInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendantInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendantInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameplateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameplateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameplateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nid", wireType)
			}
			m.Nid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nid |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageSmall", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageSmall = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OfficialInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OfficialInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OfficialInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (int8(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MidsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MidsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MidsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mids = append(m.Mids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mids) == 0 {
					m.Mids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mids = append(m.Mids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mids", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Exp = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operater", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operater = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoralReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoralReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoralReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moral", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Moral = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oper = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Owners = append(m.Owners, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Owners) == 0 {
					m.Owners = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Owners = append(m.Owners, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Owners", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RichRelationReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RichRelationReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RichRelationReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mids = append(m.Mids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mids) == 0 {
					m.Mids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mids = append(m.Mids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mids", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfosReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfosReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfosReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Infos == nil {
				m.Infos = make(map[int64]*Info)
			}
			var mapkey int64
			var mapvalue *Info
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Info{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Infos[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &Card{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cards == nil {
				m.Cards = make(map[int64]*Card)
			}
			var mapkey int64
			var mapvalue *Card
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Card{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Cards[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfileReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfileReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfileReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &Profile{}
			}
			if err := m.Profile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfileStatReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfileStatReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfileStatReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &Profile{}
			}
			if err := m.Profile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LevelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Coins = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Following", wireType)
			}
			m.Following = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Following |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follower", wireType)
			}
			m.Follower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Follower |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Following", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Following = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttentionsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttentionsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttentionsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Attentions = append(m.Attentions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Attentions) == 0 {
					m.Attentions = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Attentions = append(m.Attentions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Attentions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlacksReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlacksReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlacksReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlackList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlackList == nil {
				m.BlackList = make(map[int64]bool)
			}
			var mapkey int64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BlackList[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Relations == nil {
				m.Relations = make(map[int64]*RelationReply)
			}
			var mapkey int64
			var mapvalue *RelationReply
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RelationReply{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Relations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RichRelationsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RichRelationsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RichRelationsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RichRelations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RichRelations == nil {
				m.RichRelations = make(map[int64]int32)
			}
			var mapkey int64
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RichRelations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DueDate", wireType)
			}
			m.DueDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DueDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipPayType", wireType)
			}
			m.VipPayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipPayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vips == nil {
				m.Vips = make(map[int64]*VipReply)
			}
			var mapkey int64
			var mapvalue *VipReply
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VipReply{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Vips[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoralReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoralReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoralReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/main/account/api/api.proto", fileDescriptor_api_f24f062ee2ba9e19)
}

var fileDescriptor_api_f24f062ee2ba9e19 = []byte{
	// 1986 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x19, 0x4d, 0x93, 0x1b, 0x57,
	0x91, 0xb1, 0xbe, 0x5b, 0xda, 0x0f, 0x3f, 0x8c, 0x33, 0xab, 0xac, 0x57, 0x9b, 0x49, 0x08, 0xeb,
	0x72, 0xbc, 0x9b, 0xec, 0x52, 0xc1, 0xe5, 0xb2, 0xcb, 0xb1, 0x82, 0x09, 0x06, 0x3b, 0x36, 0x2f,
	0xc6, 0xa1, 0x28, 0x28, 0xd5, 0xac, 0xe6, 0x69, 0xf7, 0xe1, 0xd1, 0xcc, 0x78, 0x66, 0x24, 0x4b,
	0x67, 0x7e, 0x04, 0x45, 0xc1, 0x99, 0xe2, 0xc2, 0x81, 0x2a, 0xb8, 0xf1, 0x03, 0x72, 0xe4, 0xc6,
	0x4d, 0x95, 0xf2, 0x51, 0x27, 0x2a, 0xc7, 0x9c, 0xa8, 0xee, 0xf7, 0x46, 0x33, 0xfa, 0xdc, 0x64,
	0x9d, 0x0b, 0x39, 0xec, 0x9b, 0xee, 0x7e, 0xdd, 0xfd, 0xba, 0xdf, 0xeb, 0x2f, 0xd5, 0xc2, 0xdb,
	0x76, 0x10, 0x1c, 0x44, 0x22, 0xec, 0xcb, 0xb6, 0x38, 0xe8, 0xda, 0xd2, 0x3b, 0xb0, 0xdb, 0x6d,
	0xbf, 0xe7, 0xc5, 0x07, 0x76, 0x20, 0xf1, 0x6f, 0x3f, 0x08, 0xfd, 0xd8, 0x67, 0x1b, 0x9a, 0xbc,
	0xaf, 0x79, 0xeb, 0xd7, 0x4f, 0x64, 0x7c, 0xda, 0x3b, 0xde, 0x6f, 0xfb, 0xdd, 0x83, 0x13, 0xff,
	0xc4, 0x3f, 0x20, 0xbe, 0xe3, 0x5e, 0x87, 0x30, 0x42, 0x08, 0x52, 0xf2, 0xd6, 0x9f, 0xf3, 0x90,
	0xff, 0xd0, 0x0e, 0x1d, 0xb6, 0x05, 0xb9, 0xae, 0x74, 0x4c, 0x63, 0xd7, 0xd8, 0xcb, 0x35, 0x4b,
	0xe3, 0x51, 0x03, 0x51, 0x8e, 0x0b, 0xdb, 0x86, 0xbc, 0x67, 0x77, 0x85, 0x79, 0x61, 0xd7, 0xd8,
	0xab, 0x34, 0xcb, 0xe3, 0x51, 0x83, 0x70, 0x4e, 0x2b, 0x0a, 0x46, 0x62, 0x60, 0xe6, 0x68, 0x93,
	0x04, 0x23, 0x31, 0xe0, 0xb8, 0xa0, 0x60, 0xc7, 0x6e, 0x0b, 0x33, 0x9f, 0x0a, 0x22, 0xce, 0x69,
	0xc5, 0xdd, 0x48, 0x9e, 0x78, 0x66, 0x21, 0xdd, 0x45, 0x9c, 0xd3, 0x8a, 0xbb, 0xa1, 0xed, 0x3d,
	0x33, 0x8b, 0xbb, 0xc6, 0x5e, 0x41, 0xed, 0x22, 0xce, 0x69, 0x65, 0x0d, 0x28, 0xb8, 0xa2, 0x2f,
	0x5c, 0xb3, 0x44, 0xdb, 0x95, 0xf1, 0xa8, 0xa1, 0x08, 0x5c, 0x7d, 0xd8, 0xf7, 0xa1, 0x14, 0x49,
	0x57, 0x78, 0x6d, 0x61, 0x96, 0x89, 0xa5, 0x3a, 0x1e, 0x35, 0x12, 0x12, 0x4f, 0x00, 0xf6, 0x23,
	0xc8, 0xf5, 0x65, 0x60, 0x56, 0x76, 0x8d, 0xbd, 0xea, 0xa1, 0xb9, 0x3f, 0x73, 0x99, 0xfb, 0x4f,
	0x65, 0x70, 0xdf, 0xeb, 0xf8, 0xcd, 0xea, 0x67, 0xa3, 0xc6, 0x77, 0xd0, 0xb5, 0xbe, 0x0c, 0x38,
	0x2e, 0xec, 0x23, 0x28, 0x05, 0xc2, 0x73, 0x6c, 0x2f, 0x36, 0x81, 0x84, 0xb7, 0xe7, 0x84, 0x1f,
	0xab, 0x7d, 0x52, 0xb0, 0xa1, 0x15, 0x24, 0x42, 0x3c, 0x01, 0xd8, 0x23, 0xa8, 0xe0, 0x35, 0x06,
	0xae, 0x1d, 0x0b, 0xb3, 0x4a, 0xaa, 0x76, 0xe6, 0x54, 0x7d, 0x9c, 0x70, 0x90, 0xb2, 0x8b, 0x5a,
	0x59, 0x2a, 0xc8, 0x53, 0x90, 0xfd, 0x1c, 0xca, 0x7e, 0xa7, 0x23, 0xdb, 0xd2, 0x76, 0xcd, 0x1a,
	0xe9, 0xbb, 0x32, 0xa7, 0xef, 0x91, 0x66, 0x20, 0x75, 0x9b, 0x5a, 0xdd, 0x44, 0x8c, 0x4f, 0x20,
	0xeb, 0x1f, 0x06, 0xe4, 0x91, 0xe9, 0xff, 0x2b, 0x3c, 0xac, 0xdf, 0x97, 0xa0, 0xf4, 0x38, 0xf4,
	0x3b, 0xd2, 0x15, 0xdf, 0xb6, 0xc0, 0xbe, 0x0a, 0x95, 0xdf, 0xf9, 0xd2, 0x6b, 0xc5, 0xb2, 0x9b,
	0x84, 0x76, 0x0d, 0x1f, 0x0f, 0x89, 0x48, 0xe3, 0x04, 0x3d, 0x91, 0x5d, 0x81, 0xba, 0xba, 0x7e,
	0x68, 0xbb, 0x14, 0xde, 0x5a, 0x17, 0x11, 0xb8, 0xfa, 0x64, 0x93, 0x04, 0x56, 0x24, 0xc9, 0x11,
	0xd4, 0x44, 0xd7, 0x96, 0x6e, 0x2b, 0x8a, 0xed, 0xb8, 0x17, 0x51, 0x94, 0x16, 0x9a, 0x9b, 0xe3,
	0x51, 0x63, 0x8a, 0xce, 0xab, 0x84, 0x7d, 0x42, 0x08, 0xbb, 0x0e, 0x10, 0x8b, 0x89, 0x48, 0x8d,
	0x44, 0xd6, 0xc7, 0xa3, 0x46, 0x86, 0xca, 0x2b, 0xb1, 0x48, 0xd8, 0x6f, 0xc2, 0xba, 0x74, 0x84,
	0x17, 0xcb, 0x8e, 0x6c, 0xdb, 0xb1, 0xf4, 0x3d, 0x73, 0x8d, 0x44, 0xd8, 0x78, 0xd4, 0x98, 0xd9,
	0xe1, 0x33, 0x78, 0x92, 0xc4, 0xeb, 0xaf, 0x92, 0xc4, 0x1b, 0xdf, 0x5c, 0x12, 0x6f, 0x7e, 0xc3,
	0x49, 0x7c, 0xf1, 0x15, 0x93, 0x98, 0x7d, 0x04, 0xe5, 0x63, 0x19, 0xc6, 0xa7, 0x8e, 0x3d, 0x34,
	0x19, 0xa5, 0xc1, 0x35, 0xe4, 0x4c, 0x68, 0x5f, 0x8e, 0x1a, 0xaf, 0x9f, 0xf8, 0xd7, 0xdb, 0x7e,
	0xb7, 0xeb, 0x7b, 0x07, 0xae, 0x3c, 0x0e, 0xed, 0x70, 0x78, 0x80, 0xb1, 0xb4, 0xff, 0x84, 0x02,
	0x2a, 0x61, 0xc4, 0x37, 0x95, 0x51, 0x2b, 0xf6, 0x7b, 0xa1, 0x8c, 0x62, 0xf3, 0xbb, 0xe9, 0x9b,
	0xa6, 0x54, 0x5e, 0x91, 0xd1, 0x13, 0x05, 0x5a, 0x7f, 0x31, 0xa0, 0xf2, 0x00, 0x83, 0x96, 0x2a,
	0xc8, 0x9b, 0x90, 0x6b, 0xf7, 0x42, 0xca, 0xc3, 0x42, 0xf3, 0xe2, 0x78, 0xd4, 0x58, 0x6b, 0xf7,
	0xc2, 0x50, 0x78, 0x71, 0x4b, 0xc5, 0x37, 0xee, 0xb2, 0x37, 0x30, 0x59, 0x3d, 0x4a, 0xc8, 0x42,
	0x73, 0x63, 0x3c, 0x6a, 0x54, 0x13, 0xa6, 0xae, 0xf4, 0x30, 0x69, 0x3d, 0xb6, 0x07, 0x25, 0xcf,
	0x7f, 0xd1, 0x12, 0x83, 0x80, 0x52, 0x73, 0x86, 0x4d, 0x0c, 0x02, 0x5e, 0xf4, 0xfc, 0x17, 0xf7,
	0x06, 0x01, 0xfb, 0x01, 0x94, 0x3d, 0x31, 0x20, 0x1a, 0x65, 0xaa, 0xce, 0x94, 0x84, 0xc6, 0x4b,
	0x08, 0xdd, 0x1b, 0x04, 0xd6, 0x5f, 0x0d, 0x28, 0xe9, 0x28, 0xc1, 0xf4, 0x8c, 0x87, 0x81, 0xd0,
	0x76, 0x52, 0x7a, 0x22, 0xce, 0x69, 0x65, 0x16, 0x14, 0x75, 0x44, 0x2b, 0x13, 0x61, 0x3c, 0x6a,
	0x68, 0x0a, 0xd7, 0x5f, 0x3c, 0xd6, 0xe9, 0x89, 0x96, 0x83, 0xb1, 0x90, 0xa3, 0xeb, 0xa6, 0x63,
	0x13, 0x1a, 0x2f, 0x39, 0x3d, 0xf1, 0x63, 0x7c, 0xe4, 0x43, 0xa8, 0xf5, 0x65, 0xd0, 0x0a, 0xec,
	0x61, 0x8b, 0x8e, 0xcc, 0xa7, 0x79, 0x95, 0xa5, 0x73, 0xe8, 0xcb, 0xe0, 0xb1, 0x3d, 0x7c, 0x32,
	0x0c, 0x84, 0xf5, 0x47, 0x03, 0xaa, 0x99, 0x98, 0x64, 0xbb, 0x90, 0x0b, 0x74, 0x75, 0x53, 0x6f,
	0x81, 0xe8, 0x97, 0xa3, 0x46, 0x4e, 0x7a, 0x31, 0x47, 0xf8, 0x8c, 0x22, 0xd7, 0x80, 0x82, 0xec,
	0xda, 0x27, 0x42, 0x97, 0x39, 0xaa, 0x11, 0x44, 0xe0, 0xea, 0xc3, 0xae, 0x42, 0x51, 0x0c, 0x02,
	0x19, 0x2a, 0xf3, 0x72, 0xf4, 0x72, 0x9a, 0x92, 0x1c, 0xa3, 0x51, 0xeb, 0xbf, 0x06, 0xac, 0x4d,
	0x05, 0x39, 0x5a, 0xe7, 0x4d, 0x5b, 0xe7, 0x65, 0xac, 0xf3, 0x5e, 0xdd, 0xba, 0x77, 0xa1, 0x4a,
	0x40, 0x2b, 0xea, 0xda, 0xae, 0xab, 0xeb, 0x31, 0x05, 0x44, 0x86, 0xcc, 0x81, 0x90, 0x4f, 0x10,
	0x4e, 0x0b, 0x6c, 0x21, 0x55, 0x39, 0x55, 0x60, 0xaf, 0x41, 0xa5, 0xed, 0x7b, 0x8e, 0xa4, 0x22,
	0x54, 0x24, 0xa6, 0x35, 0xcc, 0xd3, 0x09, 0x91, 0xa7, 0xa0, 0x15, 0x41, 0x2d, 0x9b, 0x86, 0xec,
	0x2d, 0xc8, 0x87, 0xbe, 0x9b, 0x44, 0xcf, 0x26, 0x15, 0x77, 0xdf, 0xc5, 0x9b, 0xca, 0x4b, 0x2f,
	0xbe, 0xc1, 0x09, 0x43, 0x1b, 0x62, 0x19, 0xbb, 0x89, 0xd7, 0x64, 0x03, 0x11, 0xb8, 0xfa, 0xe0,
	0xad, 0x38, 0x22, 0x6a, 0x6b, 0xb7, 0xe9, 0x56, 0x10, 0xe7, 0xb4, 0x5a, 0xbf, 0x80, 0xe2, 0x43,
	0xe9, 0x70, 0xf1, 0x9c, 0xed, 0x67, 0x7b, 0xdb, 0xf6, 0x17, 0xa3, 0x86, 0xd9, 0xb7, 0x5d, 0x89,
	0x51, 0x76, 0xd3, 0x3a, 0x89, 0x6f, 0xbf, 0xfb, 0x4e, 0x28, 0x9e, 0xf7, 0x64, 0x28, 0x1c, 0x4b,
	0x35, 0xbc, 0xd7, 0xa0, 0x14, 0x0a, 0xdb, 0x6d, 0xc9, 0x40, 0x1d, 0xcd, 0x8b, 0x88, 0xde, 0x0f,
	0xac, 0x5f, 0x42, 0xe9, 0xa1, 0x74, 0x22, 0xd4, 0xf9, 0x1e, 0xe4, 0xbb, 0xd2, 0x89, 0x4c, 0x63,
	0x37, 0xb7, 0x97, 0x6b, 0x5e, 0xf9, 0x62, 0xd4, 0xd8, 0x9a, 0x51, 0xea, 0xc8, 0xbe, 0x78, 0x07,
	0x21, 0x8b, 0x13, 0xeb, 0x72, 0xb5, 0xbf, 0x82, 0x32, 0x06, 0x04, 0xe9, 0x3d, 0x82, 0x02, 0xbe,
	0xa9, 0x52, 0x5c, 0x39, 0x4b, 0xb1, 0xe2, 0x5d, 0xae, 0xf9, 0xef, 0x06, 0x14, 0xef, 0x0d, 0x82,
	0xf3, 0x5c, 0xc2, 0x26, 0xe4, 0xb0, 0x22, 0xa0, 0x3e, 0x83, 0x23, 0xc8, 0xea, 0x50, 0xf6, 0x03,
	0x11, 0xda, 0xb1, 0x08, 0xd5, 0x95, 0xf3, 0x09, 0xce, 0x4c, 0x28, 0x69, 0x58, 0x45, 0x17, 0x4f,
	0x50, 0x76, 0x19, 0xd0, 0x98, 0xc8, 0xd7, 0x8d, 0x9e, 0x6b, 0x2c, 0x6b, 0x73, 0x71, 0xca, 0xe6,
	0xbf, 0x19, 0x50, 0x7e, 0x48, 0xfd, 0xf7, 0x1c, 0x56, 0x5f, 0x4a, 0x9a, 0xb9, 0xb2, 0x5b, 0x77,
	0x70, 0x06, 0x79, 0x34, 0x47, 0x5b, 0x4d, 0x70, 0xc6, 0xae, 0xfc, 0x94, 0x5d, 0x44, 0xef, 0xda,
	0xe1, 0xb3, 0xd4, 0x5e, 0xc4, 0x96, 0xdb, 0xeb, 0x42, 0x95, 0x0b, 0x57, 0xf5, 0xdc, 0xf3, 0x59,
	0xec, 0xbf, 0xf0, 0x44, 0x48, 0x16, 0xe7, 0xb8, 0x42, 0xb2, 0xa7, 0xe5, 0xa6, 0x4e, 0xf3, 0xa1,
	0x96, 0x9c, 0x16, 0x9d, 0xe7, 0xb8, 0xcb, 0x50, 0xa4, 0x13, 0xb0, 0x34, 0xe7, 0xf6, 0x72, 0x5c,
	0x63, 0xcb, 0x0f, 0x8c, 0x60, 0x83, 0xcb, 0xf6, 0x69, 0xd6, 0xc5, 0x89, 0xc9, 0x46, 0xd6, 0xe4,
	0x24, 0x23, 0x2e, 0x9c, 0x2b, 0x23, 0xa6, 0x0f, 0x7d, 0x1f, 0x2a, 0x58, 0x28, 0xb8, 0x08, 0xdc,
	0x21, 0xbb, 0x0a, 0x79, 0xe9, 0x75, 0x7c, 0x3a, 0xad, 0x7a, 0xf8, 0xbd, 0xb9, 0x0e, 0x4f, 0x9c,
	0xc4, 0x62, 0xfd, 0xc9, 0x00, 0x40, 0x34, 0x52, 0x92, 0xb7, 0xa0, 0x80, 0x64, 0x95, 0x4c, 0xd5,
	0xc3, 0xb7, 0x17, 0x8a, 0x2a, 0x5e, 0x05, 0xde, 0xf3, 0xe2, 0x70, 0xc8, 0x95, 0x50, 0xfd, 0x91,
	0xd6, 0x45, 0x44, 0xcc, 0x87, 0x67, 0x62, 0xa8, 0x5d, 0x46, 0x90, 0x5d, 0x83, 0x42, 0xdf, 0x76,
	0x7b, 0xaa, 0x3e, 0x2d, 0x35, 0x4c, 0xf1, 0xdc, 0xbc, 0x70, 0xc3, 0x40, 0xaf, 0xf0, 0x47, 0xe4,
	0xc4, 0xab, 0xb6, 0x1d, 0x3a, 0x4b, 0xbd, 0x22, 0x4e, 0x62, 0x21, 0xaf, 0x10, 0x4d, 0xbd, 0x42,
	0xf2, 0x72, 0xaf, 0x52, 0x5e, 0x05, 0x6a, 0xaf, 0x48, 0x08, 0xbd, 0x4a, 0x89, 0xe7, 0xf1, 0x8a,
	0x0c, 0xcb, 0x78, 0xd5, 0x84, 0x9a, 0xfe, 0x11, 0xa1, 0xcc, 0x3b, 0x84, 0x52, 0xa0, 0x70, 0xed,
	0xdb, 0xfc, 0xac, 0x99, 0xf0, 0x27, 0x8c, 0xd6, 0x7f, 0x0c, 0xd8, 0xd4, 0x44, 0x9c, 0x74, 0xcf,
	0xad, 0x88, 0xdd, 0x01, 0xa0, 0xfe, 0xd4, 0xa2, 0x88, 0x51, 0x2e, 0xd4, 0xe7, 0xc4, 0x26, 0xe3,
	0x56, 0x33, 0x8f, 0x03, 0x21, 0xaf, 0xb8, 0x93, 0xf9, 0xeb, 0x12, 0x14, 0xda, 0xbe, 0xf4, 0x22,
	0x0a, 0x48, 0x83, 0x2b, 0x84, 0x6d, 0x43, 0xa5, 0xe3, 0xbb, 0xae, 0xff, 0x42, 0x7a, 0x27, 0xaa,
	0xc3, 0xf3, 0x94, 0x80, 0x85, 0x51, 0x21, 0x22, 0xa4, 0xa2, 0x91, 0xe3, 0x13, 0xdc, 0xba, 0x0e,
	0x6b, 0x69, 0xea, 0xa0, 0x57, 0x53, 0xaa, 0xd0, 0xaf, 0x72, 0x46, 0x95, 0xf5, 0x1e, 0x6c, 0xdc,
	0x8d, 0x63, 0x9c, 0xdb, 0x29, 0xbf, 0x51, 0x60, 0x07, 0xc0, 0x9e, 0x90, 0x54, 0xbf, 0xe1, 0x19,
	0x8a, 0xf5, 0x07, 0x03, 0xaa, 0x4d, 0xd7, 0x6e, 0x3f, 0xd3, 0xfc, 0x3f, 0x03, 0x38, 0x46, 0xb4,
	0xe5, 0xe2, 0xf8, 0xa9, 0x62, 0xe4, 0xda, 0xdc, 0x15, 0x64, 0x24, 0x14, 0xfc, 0x40, 0x46, 0xb1,
	0x0a, 0x94, 0xca, 0x71, 0x82, 0xd7, 0x6f, 0xc1, 0xfa, 0xf4, 0xe6, 0x82, 0x80, 0xb9, 0x94, 0x0d,
	0x98, 0x72, 0x36, 0x32, 0xfe, 0x65, 0xc0, 0x7a, 0xa6, 0x58, 0xa1, 0x71, 0x0f, 0xa0, 0x12, 0x26,
	0x14, 0x6d, 0xdb, 0xfe, 0x9c, 0x6d, 0xd3, 0x32, 0x29, 0xaa, 0xcd, 0x9b, 0x28, 0xa8, 0xff, 0x26,
	0xa3, 0x7f, 0x99, 0x79, 0x3f, 0x9c, 0x8e, 0xe7, 0x9d, 0xa5, 0xa7, 0xd1, 0x61, 0x59, 0xf3, 0xff,
	0x69, 0x00, 0xcb, 0x96, 0x3e, 0xed, 0xc2, 0x6f, 0x61, 0x3d, 0x94, 0xed, 0xd3, 0xd6, 0xac, 0x1f,
	0xef, 0xcf, 0x6b, 0x9e, 0x13, 0x9e, 0x26, 0x29, 0x7f, 0xd6, 0xc2, 0x2c, 0xad, 0xfe, 0xc1, 0xcc,
	0xa1, 0x5f, 0xe9, 0xda, 0x0b, 0x59, 0xbb, 0x23, 0x28, 0x3f, 0x95, 0x81, 0x32, 0x96, 0x65, 0xe7,
	0x74, 0x3d, 0x9d, 0x5f, 0x9e, 0x9e, 0xce, 0x27, 0x13, 0xf9, 0xd6, 0xec, 0x44, 0x9e, 0xce, 0xe0,
	0xbb, 0x8b, 0x66, 0xf0, 0xd9, 0x89, 0xbb, 0xf2, 0x54, 0x06, 0xfa, 0x8e, 0x6e, 0x40, 0xbe, 0x2f,
	0x83, 0xe4, 0x66, 0xde, 0x5a, 0xf4, 0x63, 0x53, 0x5f, 0x08, 0x42, 0xea, 0x1e, 0x48, 0xa2, 0xce,
	0x95, 0x9a, 0x65, 0x5e, 0x1f, 0x4c, 0xbf, 0xe6, 0xd6, 0x22, 0xcd, 0x73, 0x0f, 0x09, 0x50, 0xa6,
	0x21, 0x28, 0x70, 0x87, 0x56, 0x0d, 0x40, 0x0f, 0x17, 0x81, 0x3b, 0x3c, 0xfc, 0xbc, 0x0c, 0xa5,
	0xbb, 0x4a, 0x03, 0x96, 0x55, 0xac, 0x00, 0x47, 0xec, 0xb5, 0x39, 0xa5, 0x6a, 0x8e, 0xac, 0xd7,
	0x17, 0x57, 0x78, 0xf2, 0xf8, 0x0e, 0x14, 0xa9, 0x59, 0x1c, 0x31, 0x73, 0x91, 0x38, 0xf6, 0xea,
	0xfa, 0xeb, 0x2b, 0xfa, 0x0f, 0xfb, 0x09, 0xd4, 0x08, 0x6b, 0x0e, 0x71, 0x16, 0x3c, 0x62, 0x5b,
	0x0b, 0x7f, 0x19, 0x9f, 0xad, 0xe7, 0x16, 0x14, 0xb0, 0x42, 0x7f, 0x2d, 0x37, 0xd2, 0xae, 0x74,
	0x07, 0x8a, 0xd4, 0x1d, 0xbe, 0x9e, 0x1b, 0x99, 0xe6, 0xd4, 0x84, 0xb2, 0x2e, 0xca, 0x2b, 0x2c,
	0xb8, 0xb2, 0xb4, 0x90, 0x93, 0x8e, 0x8f, 0x27, 0xcd, 0xe0, 0x53, 0x19, 0x9f, 0x62, 0x43, 0x58,
	0xa1, 0xeb, 0x8d, 0x65, 0xba, 0xd2, 0x46, 0x72, 0x1b, 0x4a, 0x77, 0x1d, 0xe7, 0xde, 0x20, 0x58,
	0xa4, 0x46, 0x8d, 0xc7, 0xf5, 0xad, 0xc5, 0x1b, 0x28, 0xfe, 0x21, 0x54, 0xee, 0x3a, 0x0e, 0x45,
	0xcd, 0xa2, 0x67, 0x49, 0x66, 0xd5, 0x05, 0xf7, 0x92, 0x46, 0x1a, 0xbb, 0x0f, 0x95, 0x24, 0xa5,
	0x8f, 0xd8, 0xf6, 0x8a, 0x22, 0xf4, 0xbc, 0x7e, 0x46, 0x89, 0x62, 0x3f, 0x85, 0x6a, 0xda, 0x23,
	0x56, 0xdc, 0xcc, 0xee, 0xdc, 0xc6, 0x6c, 0x6b, 0xf9, 0x00, 0x4a, 0xaa, 0x0f, 0xac, 0xd0, 0xb2,
	0xbd, 0xaa, 0x75, 0xb0, 0x07, 0x00, 0x93, 0x4a, 0x75, 0xc4, 0xae, 0xac, 0x2a, 0xe5, 0xcf, 0xeb,
	0x8d, 0x33, 0x2a, 0x3d, 0xfb, 0x14, 0xd6, 0xa7, 0x6a, 0xdf, 0x11, 0xdb, 0x5d, 0x59, 0x54, 0x51,
	0xe9, 0x9b, 0x5f, 0xa1, 0xec, 0xb2, 0x9b, 0x90, 0x7f, 0x2a, 0x83, 0x15, 0x5e, 0x2e, 0x2f, 0x24,
	0xec, 0x36, 0x14, 0xb0, 0x22, 0xad, 0xca, 0x88, 0xfa, 0xf2, 0x02, 0xd7, 0xbc, 0xf8, 0xd9, 0xcb,
	0x1d, 0xe3, 0xdf, 0x2f, 0x77, 0x8c, 0xcf, 0x5f, 0xee, 0x18, 0xbf, 0xce, 0xd9, 0x81, 0x3c, 0x2e,
	0xd2, 0x3f, 0x15, 0x8e, 0xfe, 0x17, 0x00, 0x00, 0xff, 0xff, 0xb1, 0x1e, 0x0b, 0xf4, 0xbe, 0x18,
	0x00, 0x00,
}
