// +build linux darwin

package resolvconf

import (
	"bytes"
	"io"
	"reflect"
	"testing"
)

const (
	testdata1 = `domain localdomain
search localdomain
nameserver 192.168.6.2`
	testdata2 = `#
# macOS Notice
#
# This file is not consulted for DNS hostname resolution, address
# resolution, or the DNS query routing mechanism used by most
# processes on this system.
#
# To view the DNS configuration used by this system, use:
#   scutil --dns
#
# SEE ALSO
#   dns-sd(1), scutil(8)
#
# This file is automatically generated.
#
nameserver 10.23.194.202
nameserver 10.23.194.203`
)

func Test_parse(t *testing.T) {
	type args struct {
		fp io.Reader
	}
	tests := []struct {
		name    string
		args    args
		want    []string
		wantErr bool
	}{
		{
			name: "test1",
			args: args{
				bytes.NewBufferString(testdata1),
			},
			want: []string{"192.168.6.2"},
		},
		{
			name: "test2",
			args: args{
				bytes.NewBufferString(testdata2),
			},
			want: []string{"10.23.194.202", "10.23.194.203"},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := parse(tt.args.fp)
			if (err != nil) != tt.wantErr {
				t.Errorf("parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("parse() = %v, want %v", got, tt.want)
			}
		})
	}
}
