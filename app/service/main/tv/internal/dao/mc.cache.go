// Code generated by $GOPATH/src/go-common/app/tool/cache/mc. DO NOT EDIT.

/*
  Package dao is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=userInfoKey
		CacheUserInfoByMid(c context.Context, key int64) (*model.UserInfo, error)
		// mc: -key=userInfoKey -expire=d.cacheTTL.UserInfoTTL -encode=json
		AddCacheUserInfoByMid(c context.Context, key int64, value *model.UserInfo) error
		// mc: -key=userInfoKey
		DelCacheUserInfoByMid(c context.Context, key int64) error
		// mc: -key=payParamKey
		CachePayParamByToken(c context.Context, token string) (*model.PayParam, error)
		// mc: -key=payParamKey
		CachePayParamsByTokens(c context.Context, tokens []string) (map[string]*model.PayParam, error)
		// mc: -key=payParamKey -expire=d.cacheTTL.PayParamTTL -encode=json
		AddCachePayParam(c context.Context, key string, value *model.PayParam) error
		// mc: -type=replace -key=payParamKey -expire=d.cacheTTL.PayParamTTL -encode=json
		UpdateCachePayParam(c context.Context, key string, value *model.PayParam) error
	}
*/

package dao

import (
	"context"
	"fmt"

	"go-common/app/service/main/tv/internal/model"
	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
)

var _ _mc

// CacheUserInfoByMid get data from mc
func (d *Dao) CacheUserInfoByMid(c context.Context, id int64) (res *model.UserInfo, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := userInfoKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheUserInfoByMid")
		log.Errorv(c, log.KV("CacheUserInfoByMid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.UserInfo{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheUserInfoByMid")
		log.Errorv(c, log.KV("CacheUserInfoByMid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheUserInfoByMid Set data to mc
func (d *Dao) AddCacheUserInfoByMid(c context.Context, id int64, val *model.UserInfo) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := userInfoKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.cacheTTL.UserInfoTTL, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheUserInfoByMid")
		log.Errorv(c, log.KV("AddCacheUserInfoByMid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheUserInfoByMid delete data from mc
func (d *Dao) DelCacheUserInfoByMid(c context.Context, id int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := userInfoKey(id)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheUserInfoByMid")
		log.Errorv(c, log.KV("DelCacheUserInfoByMid", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CachePayParamByToken get data from mc
func (d *Dao) CachePayParamByToken(c context.Context, id string) (res *model.PayParam, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := payParamKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CachePayParamByToken")
		log.Errorv(c, log.KV("CachePayParamByToken", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.PayParam{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CachePayParamByToken")
		log.Errorv(c, log.KV("CachePayParamByToken", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CachePayParamsByTokens get data from mc
func (d *Dao) CachePayParamsByTokens(c context.Context, ids []string) (res map[string]*model.PayParam, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]string, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := payParamKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	replies, err := conn.GetMulti(keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CachePayParamsByTokens")
		log.Errorv(c, log.KV("CachePayParamsByTokens", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for key, reply := range replies {
		var v *model.PayParam
		v = &model.PayParam{}
		err = conn.Scan(reply, v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CachePayParamsByTokens")
			log.Errorv(c, log.KV("CachePayParamsByTokens", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[string]*model.PayParam, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCachePayParam Set data to mc
func (d *Dao) AddCachePayParam(c context.Context, id string, val *model.PayParam) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := payParamKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.cacheTTL.PayParamTTL, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCachePayParam")
		log.Errorv(c, log.KV("AddCachePayParam", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// UpdateCachePayParam Replace data to mc
func (d *Dao) UpdateCachePayParam(c context.Context, id string, val *model.PayParam) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := payParamKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.cacheTTL.PayParamTTL, Flags: memcache.FlagJSON}
	if err = conn.Replace(item); err != nil {
		prom.BusinessErrCount.Incr("mc:UpdateCachePayParam")
		log.Errorv(c, log.KV("UpdateCachePayParam", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
