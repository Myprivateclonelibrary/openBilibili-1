// Code generated by deepcopy-gen. DO NOT EDIT.

package api

import (
	model "go-common/app/service/main/relation/model"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FollowingReply) DeepCopyInto(out *FollowingReply) {
	*out = *in
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = make([]int64, len(*in))
		copy(*out, *in)
	}
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FollowingReply.
func (in *FollowingReply) DeepCopy() *FollowingReply {
	if in == nil {
		return nil
	}
	out := new(FollowingReply)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyAsIntoFollowing is an autogenerated deepcopy function, copying the receiver, writing into model.Following.
func (in *FollowingReply) DeepCopyAsIntoFollowing(out *model.Following) {
	out.Mid = in.Mid
	out.Attribute = in.Attribute
	out.Source = in.Source
	out.CTime = in.CTime
	out.MTime = in.MTime
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = make([]int64, len(*in))
		copy(*out, *in)
	}
	out.Special = in.Special
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	out.XXX_sizecache = in.XXX_sizecache
	return
}

// DeepCopyFromFollowing is an autogenerated deepcopy function, copying the receiver, writing into model.Following.
func (out *FollowingReply) DeepCopyFromFollowing(in *model.Following) {
	out.Mid = in.Mid
	out.Attribute = in.Attribute
	out.Source = in.Source
	out.CTime = in.CTime
	out.MTime = in.MTime
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = make([]int64, len(*in))
		copy(*out, *in)
	}
	out.Special = in.Special
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	out.XXX_sizecache = in.XXX_sizecache
	return
}

// DeepCopyAsFollowing is an autogenerated deepcopy function, copying the receiver, creating a new model.Following.
func (in *FollowingReply) DeepCopyAsFollowing() *model.Following {
	if in == nil {
		return nil
	}
	out := new(model.Following)
	in.DeepCopyAsIntoFollowing(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StatReply) DeepCopyInto(out *StatReply) {
	*out = *in
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StatReply.
func (in *StatReply) DeepCopy() *StatReply {
	if in == nil {
		return nil
	}
	out := new(StatReply)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyAsIntoStat is an autogenerated deepcopy function, copying the receiver, writing into model.Stat.
func (in *StatReply) DeepCopyAsIntoStat(out *model.Stat) {
	out.Mid = in.Mid
	out.Following = in.Following
	out.Whisper = in.Whisper
	out.Black = in.Black
	out.Follower = in.Follower
	out.CTime = in.CTime
	out.MTime = in.MTime
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	out.XXX_sizecache = in.XXX_sizecache
	return
}

// DeepCopyFromStat is an autogenerated deepcopy function, copying the receiver, writing into model.Stat.
func (out *StatReply) DeepCopyFromStat(in *model.Stat) {
	out.Mid = in.Mid
	out.Following = in.Following
	out.Whisper = in.Whisper
	out.Black = in.Black
	out.Follower = in.Follower
	out.CTime = in.CTime
	out.MTime = in.MTime
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	out.XXX_sizecache = in.XXX_sizecache
	return
}

// DeepCopyAsStat is an autogenerated deepcopy function, copying the receiver, creating a new model.Stat.
func (in *StatReply) DeepCopyAsStat() *model.Stat {
	if in == nil {
		return nil
	}
	out := new(model.Stat)
	in.DeepCopyAsIntoStat(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TagCountReply) DeepCopyInto(out *TagCountReply) {
	*out = *in
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TagCountReply.
func (in *TagCountReply) DeepCopy() *TagCountReply {
	if in == nil {
		return nil
	}
	out := new(TagCountReply)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyAsIntoTagCount is an autogenerated deepcopy function, copying the receiver, writing into model.TagCount.
func (in *TagCountReply) DeepCopyAsIntoTagCount(out *model.TagCount) {
	out.Tagid = in.Tagid
	out.Name = in.Name
	out.Count = in.Count
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	out.XXX_sizecache = in.XXX_sizecache
	return
}

// DeepCopyFromTagCount is an autogenerated deepcopy function, copying the receiver, writing into model.TagCount.
func (out *TagCountReply) DeepCopyFromTagCount(in *model.TagCount) {
	out.Tagid = in.Tagid
	out.Name = in.Name
	out.Count = in.Count
	out.XXX_NoUnkeyedLiteral = in.XXX_NoUnkeyedLiteral
	if in.XXX_unrecognized != nil {
		in, out := &in.XXX_unrecognized, &out.XXX_unrecognized
		*out = make([]byte, len(*in))
		copy(*out, *in)
	}
	out.XXX_sizecache = in.XXX_sizecache
	return
}

// DeepCopyAsTagCount is an autogenerated deepcopy function, copying the receiver, creating a new model.TagCount.
func (in *TagCountReply) DeepCopyAsTagCount() *model.TagCount {
	if in == nil {
		return nil
	}
	out := new(model.TagCount)
	in.DeepCopyAsIntoTagCount(out)
	return out
}
