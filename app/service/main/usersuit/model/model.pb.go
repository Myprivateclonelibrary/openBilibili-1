// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/main/usersuit/model/model.proto

/*
	Package model is a generated protocol buffer package.

	It is generated from these files:
		app/service/main/usersuit/model/model.proto

	It has these top-level messages:
		ArgPendantHistory
		ArgOrderHistory
		PendantGroupInfo
		PendantGroup
		PendantPrice
		PendantHistory
		PendantOrderInfo
		PayInfo
		Pendant
		PendantPackage
		PendantEquip
		GroupPendantList
		MedalInfo
		MedalHomeInfo
		MedalUserInfo
		MedalPopup
		MedalMyInfo
		MedalMyInfos
		MedalAllInfos
		MedalCategoryInfo
		MedalItemInfo
		PointFlag
*/
package model

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import go_common_library_time "go-common/library/time"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ArgPendantHistory struct {
	Mid        int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid"`
	SourceType int32 `protobuf:"varint,2,opt,name=source_type,json=sourceType,proto3" json:"sourceType"`
	StartTime  int64 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"startTime"`
	EndTime    int64 `protobuf:"varint,4,opt,name=end_time,json=endTime,proto3" json:"endTime"`
	Page       int64 `protobuf:"varint,5,opt,name=page,proto3" json:"page"`
}

func (m *ArgPendantHistory) Reset()                    { *m = ArgPendantHistory{} }
func (m *ArgPendantHistory) String() string            { return proto.CompactTextString(m) }
func (*ArgPendantHistory) ProtoMessage()               {}
func (*ArgPendantHistory) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

func (m *ArgPendantHistory) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ArgPendantHistory) GetSourceType() int32 {
	if m != nil {
		return m.SourceType
	}
	return 0
}

func (m *ArgPendantHistory) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ArgPendantHistory) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *ArgPendantHistory) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type ArgOrderHistory struct {
	OrderID   string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"oderID"`
	PayID     string `protobuf:"bytes,2,opt,name=pay_id,json=payId,proto3" json:"payID"`
	Mid       int64  `protobuf:"varint,3,opt,name=mid,proto3" json:"mid"`
	Pid       int64  `protobuf:"varint,4,opt,name=pid,proto3" json:"pid"`
	Status    int32  `protobuf:"varint,5,opt,name=status,proto3" json:"status"`
	PayType   int32  `protobuf:"varint,6,opt,name=pay_type,json=payType,proto3" json:"payType"`
	StartTime int64  `protobuf:"varint,7,opt,name=start_time,json=startTime,proto3" json:"startTime"`
	EndTime   int64  `protobuf:"varint,8,opt,name=end_time,json=endTime,proto3" json:"endTime"`
	Page      int64  `protobuf:"varint,9,opt,name=page,proto3" json:"page"`
}

func (m *ArgOrderHistory) Reset()                    { *m = ArgOrderHistory{} }
func (m *ArgOrderHistory) String() string            { return proto.CompactTextString(m) }
func (*ArgOrderHistory) ProtoMessage()               {}
func (*ArgOrderHistory) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{1} }

func (m *ArgOrderHistory) GetOrderID() string {
	if m != nil {
		return m.OrderID
	}
	return ""
}

func (m *ArgOrderHistory) GetPayID() string {
	if m != nil {
		return m.PayID
	}
	return ""
}

func (m *ArgOrderHistory) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ArgOrderHistory) GetPid() int64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *ArgOrderHistory) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *ArgOrderHistory) GetPayType() int32 {
	if m != nil {
		return m.PayType
	}
	return 0
}

func (m *ArgOrderHistory) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ArgOrderHistory) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *ArgOrderHistory) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type PendantGroupInfo struct {
	ID             int64      `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Name           string     `protobuf:"bytes,2,opt,name=name,proto3" json:"group_name"`
	Rank           int32      `protobuf:"varint,3,opt,name=rank,proto3" json:"rank"`
	Status         int32      `protobuf:"varint,4,opt,name=status,proto3" json:"status"`
	Image          string     `protobuf:"bytes,5,opt,name=image,proto3" json:"image"`
	ImageModel     string     `protobuf:"bytes,6,opt,name=image_model,json=imageModel,proto3" json:"image_model"`
	FrequencyLimit int32      `protobuf:"varint,7,opt,name=frequency_limit,json=frequencyLimit,proto3" json:"-"`
	TimeLimit      int32      `protobuf:"varint,8,opt,name=time_limit,json=timeLimit,proto3" json:"-"`
	Number         int64      `protobuf:"varint,9,opt,name=number,proto3" json:"group_count"`
	SubPendant     []*Pendant `protobuf:"bytes,10,rep,name=sub_pendant,json=subPendant" json:"pendant_info"`
}

func (m *PendantGroupInfo) Reset()                    { *m = PendantGroupInfo{} }
func (m *PendantGroupInfo) String() string            { return proto.CompactTextString(m) }
func (*PendantGroupInfo) ProtoMessage()               {}
func (*PendantGroupInfo) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{2} }

func (m *PendantGroupInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PendantGroupInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PendantGroupInfo) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *PendantGroupInfo) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *PendantGroupInfo) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *PendantGroupInfo) GetImageModel() string {
	if m != nil {
		return m.ImageModel
	}
	return ""
}

func (m *PendantGroupInfo) GetFrequencyLimit() int32 {
	if m != nil {
		return m.FrequencyLimit
	}
	return 0
}

func (m *PendantGroupInfo) GetTimeLimit() int32 {
	if m != nil {
		return m.TimeLimit
	}
	return 0
}

func (m *PendantGroupInfo) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *PendantGroupInfo) GetSubPendant() []*Pendant {
	if m != nil {
		return m.SubPendant
	}
	return nil
}

type PendantGroup struct {
	ID  int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Gid int64 `protobuf:"varint,2,opt,name=gid,proto3" json:"gid"`
	Pid int64 `protobuf:"varint,3,opt,name=pid,proto3" json:"pid"`
}

func (m *PendantGroup) Reset()                    { *m = PendantGroup{} }
func (m *PendantGroup) String() string            { return proto.CompactTextString(m) }
func (*PendantGroup) ProtoMessage()               {}
func (*PendantGroup) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{3} }

func (m *PendantGroup) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PendantGroup) GetGid() int64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *PendantGroup) GetPid() int64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type PendantPrice struct {
	ID    int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Pid   int64 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid"`
	Type  int64 `protobuf:"varint,3,opt,name=type,proto3" json:"type"`
	Price int64 `protobuf:"varint,4,opt,name=price,proto3" json:"price"`
}

func (m *PendantPrice) Reset()                    { *m = PendantPrice{} }
func (m *PendantPrice) String() string            { return proto.CompactTextString(m) }
func (*PendantPrice) ProtoMessage()               {}
func (*PendantPrice) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{4} }

func (m *PendantPrice) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PendantPrice) GetPid() int64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *PendantPrice) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *PendantPrice) GetPrice() int64 {
	if m != nil {
		return m.Price
	}
	return 0
}

type PendantHistory struct {
	ID             int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Mid            int64  `protobuf:"varint,2,opt,name=mid,proto3" json:"mid"`
	Pid            int64  `protobuf:"varint,3,opt,name=pid,proto3" json:"pid"`
	SourceType     int32  `protobuf:"varint,4,opt,name=source_type,json=sourceType,proto3" json:"source_type"`
	Expire         int64  `protobuf:"varint,5,opt,name=expire,proto3" json:"expire"`
	OperatorName   string `protobuf:"bytes,6,opt,name=operator_name,json=operatorName,proto3" json:"opeartor_name"`
	OperatorAction int32  `protobuf:"varint,7,opt,name=operator_action,json=operatorAction,proto3" json:"opeartor_action"`
}

func (m *PendantHistory) Reset()                    { *m = PendantHistory{} }
func (m *PendantHistory) String() string            { return proto.CompactTextString(m) }
func (*PendantHistory) ProtoMessage()               {}
func (*PendantHistory) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{5} }

func (m *PendantHistory) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PendantHistory) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *PendantHistory) GetPid() int64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *PendantHistory) GetSourceType() int32 {
	if m != nil {
		return m.SourceType
	}
	return 0
}

func (m *PendantHistory) GetExpire() int64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *PendantHistory) GetOperatorName() string {
	if m != nil {
		return m.OperatorName
	}
	return ""
}

func (m *PendantHistory) GetOperatorAction() int32 {
	if m != nil {
		return m.OperatorAction
	}
	return 0
}

type PendantOrderInfo struct {
	ID           int64   `protobuf:"varint,1,opt,name=id,proto3" json:"_"`
	Mid          int64   `protobuf:"varint,2,opt,name=mid,proto3" json:"mid"`
	OrderID      string  `protobuf:"bytes,3,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	PayID        string  `protobuf:"bytes,4,opt,name=pay_id,json=payId,proto3" json:"pay_id"`
	PayType      int64   `protobuf:"varint,5,opt,name=pay_type,json=payType,proto3" json:"pay_type"`
	PayPrice     float64 `protobuf:"fixed64,6,opt,name=pay_price,json=payPrice,proto3" json:"pay_price"`
	AppID        int64   `protobuf:"varint,7,opt,name=app_id,json=appId,proto3" json:"app_id"`
	Stauts       int32   `protobuf:"varint,8,opt,name=stauts,proto3" json:"status"`
	Pid          int64   `protobuf:"varint,9,opt,name=pid,proto3" json:"pid"`
	TimeLength   int64   `protobuf:"varint,10,opt,name=time_length,json=timeLength,proto3" json:"time_length"`
	Cost         string  `protobuf:"bytes,11,opt,name=cost,proto3" json:"cost"`
	BuyTime      int64   `protobuf:"varint,12,opt,name=buy_time,json=buyTime,proto3" json:"buy_time"`
	IsCallback   int32   `protobuf:"varint,13,opt,name=is_callback,json=isCallback,proto3" json:"is_callback"`
	CallbackTime int64   `protobuf:"varint,14,opt,name=callback_time,json=callbackTime,proto3" json:"callback_time"`
	Image        string  `protobuf:"bytes,15,opt,name=image,proto3" json:"image"`
	Name         string  `protobuf:"bytes,16,opt,name=name,proto3" json:"name"`
}

func (m *PendantOrderInfo) Reset()                    { *m = PendantOrderInfo{} }
func (m *PendantOrderInfo) String() string            { return proto.CompactTextString(m) }
func (*PendantOrderInfo) ProtoMessage()               {}
func (*PendantOrderInfo) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{6} }

func (m *PendantOrderInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PendantOrderInfo) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *PendantOrderInfo) GetOrderID() string {
	if m != nil {
		return m.OrderID
	}
	return ""
}

func (m *PendantOrderInfo) GetPayID() string {
	if m != nil {
		return m.PayID
	}
	return ""
}

func (m *PendantOrderInfo) GetPayType() int64 {
	if m != nil {
		return m.PayType
	}
	return 0
}

func (m *PendantOrderInfo) GetPayPrice() float64 {
	if m != nil {
		return m.PayPrice
	}
	return 0
}

func (m *PendantOrderInfo) GetAppID() int64 {
	if m != nil {
		return m.AppID
	}
	return 0
}

func (m *PendantOrderInfo) GetStauts() int32 {
	if m != nil {
		return m.Stauts
	}
	return 0
}

func (m *PendantOrderInfo) GetPid() int64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *PendantOrderInfo) GetTimeLength() int64 {
	if m != nil {
		return m.TimeLength
	}
	return 0
}

func (m *PendantOrderInfo) GetCost() string {
	if m != nil {
		return m.Cost
	}
	return ""
}

func (m *PendantOrderInfo) GetBuyTime() int64 {
	if m != nil {
		return m.BuyTime
	}
	return 0
}

func (m *PendantOrderInfo) GetIsCallback() int32 {
	if m != nil {
		return m.IsCallback
	}
	return 0
}

func (m *PendantOrderInfo) GetCallbackTime() int64 {
	if m != nil {
		return m.CallbackTime
	}
	return 0
}

func (m *PendantOrderInfo) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *PendantOrderInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PayInfo struct {
	OrderID  string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id"`
	OrderNum string `protobuf:"bytes,2,opt,name=order_num,json=orderNum,proto3" json:"order_no"`
	PayURL   string `protobuf:"bytes,3,opt,name=pay_url,json=payUrl,proto3" json:"pay_url"`
}

func (m *PayInfo) Reset()                    { *m = PayInfo{} }
func (m *PayInfo) String() string            { return proto.CompactTextString(m) }
func (*PayInfo) ProtoMessage()               {}
func (*PayInfo) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{7} }

func (m *PayInfo) GetOrderID() string {
	if m != nil {
		return m.OrderID
	}
	return ""
}

func (m *PayInfo) GetOrderNum() string {
	if m != nil {
		return m.OrderNum
	}
	return ""
}

func (m *PayInfo) GetPayURL() string {
	if m != nil {
		return m.PayURL
	}
	return ""
}

type Pendant struct {
	ID         int64  `protobuf:"varint,1,opt,name=id,proto3" json:"pid"`
	Name       string `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Image      string `protobuf:"bytes,3,opt,name=image,proto3" json:"image"`
	ImageModel string `protobuf:"bytes,4,opt,name=image_model,json=imageModel,proto3" json:"image_model"`
	Status     int32  `protobuf:"varint,5,opt,name=status,proto3" json:"status"`
	Coin       int64  `protobuf:"varint,6,opt,name=coin,proto3" json:"coin"`
	Point      int64  `protobuf:"varint,7,opt,name=point,proto3" json:"point"`
	BCoin      int64  `protobuf:"varint,8,opt,name=bcoin,proto3" json:"bcoin"`
	Expires    int64  `protobuf:"varint,9,opt,name=expires,proto3" json:"expire"`
	Gid        int64  `protobuf:"varint,10,opt,name=gid,proto3" json:"gid"`
	Rank       int32  `protobuf:"varint,11,opt,name=rank,proto3" json:"rank"`
}

func (m *Pendant) Reset()                    { *m = Pendant{} }
func (m *Pendant) String() string            { return proto.CompactTextString(m) }
func (*Pendant) ProtoMessage()               {}
func (*Pendant) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{8} }

func (m *Pendant) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Pendant) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pendant) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Pendant) GetImageModel() string {
	if m != nil {
		return m.ImageModel
	}
	return ""
}

func (m *Pendant) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Pendant) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *Pendant) GetPoint() int64 {
	if m != nil {
		return m.Point
	}
	return 0
}

func (m *Pendant) GetBCoin() int64 {
	if m != nil {
		return m.BCoin
	}
	return 0
}

func (m *Pendant) GetExpires() int64 {
	if m != nil {
		return m.Expires
	}
	return 0
}

func (m *Pendant) GetGid() int64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *Pendant) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

type PendantPackage struct {
	ID      int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Mid     int64    `protobuf:"varint,2,opt,name=mid,proto3" json:"mid"`
	Pid     int64    `protobuf:"varint,3,opt,name=pid,proto3" json:"pid"`
	Expires int64    `protobuf:"varint,4,opt,name=expires,proto3" json:"expire"`
	Type    int64    `protobuf:"varint,5,opt,name=type,proto3" json:"type"`
	Status  int32    `protobuf:"varint,6,opt,name=status,proto3" json:"status"`
	IsVIP   int32    `protobuf:"varint,7,opt,name=is_vip,json=isVip,proto3" json:"isVIP"`
	Pendant *Pendant `protobuf:"bytes,8,opt,name=pendant" json:"pendant"`
}

func (m *PendantPackage) Reset()                    { *m = PendantPackage{} }
func (m *PendantPackage) String() string            { return proto.CompactTextString(m) }
func (*PendantPackage) ProtoMessage()               {}
func (*PendantPackage) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{9} }

func (m *PendantPackage) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PendantPackage) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *PendantPackage) GetPid() int64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *PendantPackage) GetExpires() int64 {
	if m != nil {
		return m.Expires
	}
	return 0
}

func (m *PendantPackage) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *PendantPackage) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *PendantPackage) GetIsVIP() int32 {
	if m != nil {
		return m.IsVIP
	}
	return 0
}

func (m *PendantPackage) GetPendant() *Pendant {
	if m != nil {
		return m.Pendant
	}
	return nil
}

type PendantEquip struct {
	Mid     int64    `protobuf:"varint,1,opt,name=mid,proto3" json:"mid"`
	Pid     int64    `protobuf:"varint,2,opt,name=pid,proto3" json:"pid"`
	Expires int64    `protobuf:"varint,3,opt,name=expires,proto3" json:"expire"`
	Pendant *Pendant `protobuf:"bytes,4,opt,name=pendant" json:"pendant"`
}

func (m *PendantEquip) Reset()                    { *m = PendantEquip{} }
func (m *PendantEquip) String() string            { return proto.CompactTextString(m) }
func (*PendantEquip) ProtoMessage()               {}
func (*PendantEquip) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{10} }

func (m *PendantEquip) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *PendantEquip) GetPid() int64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *PendantEquip) GetExpires() int64 {
	if m != nil {
		return m.Expires
	}
	return 0
}

func (m *PendantEquip) GetPendant() *Pendant {
	if m != nil {
		return m.Pendant
	}
	return nil
}

type GroupPendantList struct {
	PkgExpires int64 `protobuf:"varint,1,opt,name=pkgExpires,proto3" json:"pkg_expires"`
	PkgStatus  int32 `protobuf:"varint,2,opt,name=pkgStatus,proto3" json:"pkg_status"`
	*Pendant   `protobuf:"bytes,3,opt,name=pendant,embedded=pendant" json:""`
}

func (m *GroupPendantList) Reset()                    { *m = GroupPendantList{} }
func (m *GroupPendantList) String() string            { return proto.CompactTextString(m) }
func (*GroupPendantList) ProtoMessage()               {}
func (*GroupPendantList) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{11} }

func (m *GroupPendantList) GetPkgExpires() int64 {
	if m != nil {
		return m.PkgExpires
	}
	return 0
}

func (m *GroupPendantList) GetPkgStatus() int32 {
	if m != nil {
		return m.PkgStatus
	}
	return 0
}

type MedalInfo struct {
	ID          int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"nid"`
	Name        string                      `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	Description string                      `protobuf:"bytes,3,opt,name=Description,proto3" json:"description"`
	Image       string                      `protobuf:"bytes,4,opt,name=Image,proto3" json:"image"`
	ImageSmall  string                      `protobuf:"bytes,5,opt,name=ImageSmall,proto3" json:"image_small"`
	Condition   string                      `protobuf:"bytes,6,opt,name=Condition,proto3" json:"condition"`
	GID         int64                       `protobuf:"varint,7,opt,name=GID,proto3" json:"gid"`
	Level       int32                       `protobuf:"varint,8,opt,name=Level,proto3" json:"level,omitempty"`
	LevelRank   string                      `protobuf:"bytes,9,opt,name=LevelRank,proto3" json:"level_rank,omitempty"`
	LevelDesc   string                      `protobuf:"bytes,10,opt,name=LevelDesc,proto3" json:"level_desc,omitempty"`
	Sort        int32                       `protobuf:"varint,11,opt,name=Sort,proto3" json:"sort,omitempty"`
	IsOnline    int32                       `protobuf:"varint,12,opt,name=IsOnline,proto3" json:"is_online,omitempty"`
	IsGet       int32                       `protobuf:"varint,13,opt,name=IsGet,proto3" json:"is_get,omitempty"`
	Ctime       go_common_library_time.Time `protobuf:"varint,14,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime,omitempty"`
	Mtime       go_common_library_time.Time `protobuf:"varint,15,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime,omitempty"`
}

func (m *MedalInfo) Reset()                    { *m = MedalInfo{} }
func (m *MedalInfo) String() string            { return proto.CompactTextString(m) }
func (*MedalInfo) ProtoMessage()               {}
func (*MedalInfo) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{12} }

func (m *MedalInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MedalInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MedalInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MedalInfo) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MedalInfo) GetImageSmall() string {
	if m != nil {
		return m.ImageSmall
	}
	return ""
}

func (m *MedalInfo) GetCondition() string {
	if m != nil {
		return m.Condition
	}
	return ""
}

func (m *MedalInfo) GetGID() int64 {
	if m != nil {
		return m.GID
	}
	return 0
}

func (m *MedalInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *MedalInfo) GetLevelRank() string {
	if m != nil {
		return m.LevelRank
	}
	return ""
}

func (m *MedalInfo) GetLevelDesc() string {
	if m != nil {
		return m.LevelDesc
	}
	return ""
}

func (m *MedalInfo) GetSort() int32 {
	if m != nil {
		return m.Sort
	}
	return 0
}

func (m *MedalInfo) GetIsOnline() int32 {
	if m != nil {
		return m.IsOnline
	}
	return 0
}

func (m *MedalInfo) GetIsGet() int32 {
	if m != nil {
		return m.IsGet
	}
	return 0
}

func (m *MedalInfo) GetCtime() go_common_library_time.Time {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *MedalInfo) GetMtime() go_common_library_time.Time {
	if m != nil {
		return m.Mtime
	}
	return 0
}

type MedalHomeInfo struct {
	Description string `protobuf:"bytes,1,opt,name=Description,proto3" json:"description"`
	Image       string `protobuf:"bytes,2,opt,name=Image,proto3" json:"image"`
	ImageSmall  string `protobuf:"bytes,3,opt,name=ImageSmall,proto3" json:"image_small"`
	IsActivated int32  `protobuf:"varint,4,opt,name=IsActivated,proto3" json:"is_activated"`
	Level       string `protobuf:"bytes,5,opt,name=Level,proto3" json:"level"`
	Name        string `protobuf:"bytes,6,opt,name=Name,proto3" json:"name"`
	NID         int64  `protobuf:"varint,7,opt,name=NID,proto3" json:"nid"`
}

func (m *MedalHomeInfo) Reset()                    { *m = MedalHomeInfo{} }
func (m *MedalHomeInfo) String() string            { return proto.CompactTextString(m) }
func (*MedalHomeInfo) ProtoMessage()               {}
func (*MedalHomeInfo) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{13} }

func (m *MedalHomeInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MedalHomeInfo) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MedalHomeInfo) GetImageSmall() string {
	if m != nil {
		return m.ImageSmall
	}
	return ""
}

func (m *MedalHomeInfo) GetIsActivated() int32 {
	if m != nil {
		return m.IsActivated
	}
	return 0
}

func (m *MedalHomeInfo) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *MedalHomeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MedalHomeInfo) GetNID() int64 {
	if m != nil {
		return m.NID
	}
	return 0
}

type MedalUserInfo struct {
	Name       string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	Face       string `protobuf:"bytes,2,opt,name=Face,proto3" json:"face"`
	Level      int32  `protobuf:"varint,3,opt,name=Level,proto3" json:"level"`
	TrueLove   bool   `protobuf:"varint,4,opt,name=TrueLove,proto3" json:"truelove"`
	NID        int64  `protobuf:"varint,5,opt,name=NID,proto3" json:"nid"`
	ImageSmall string `protobuf:"bytes,6,opt,name=ImageSmall,proto3" json:"image_small"`
}

func (m *MedalUserInfo) Reset()                    { *m = MedalUserInfo{} }
func (m *MedalUserInfo) String() string            { return proto.CompactTextString(m) }
func (*MedalUserInfo) ProtoMessage()               {}
func (*MedalUserInfo) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{14} }

func (m *MedalUserInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MedalUserInfo) GetFace() string {
	if m != nil {
		return m.Face
	}
	return ""
}

func (m *MedalUserInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *MedalUserInfo) GetTrueLove() bool {
	if m != nil {
		return m.TrueLove
	}
	return false
}

func (m *MedalUserInfo) GetNID() int64 {
	if m != nil {
		return m.NID
	}
	return 0
}

func (m *MedalUserInfo) GetImageSmall() string {
	if m != nil {
		return m.ImageSmall
	}
	return ""
}

type MedalPopup struct {
	NID   int64  `protobuf:"varint,1,opt,name=NID,proto3" json:"nid"`
	Name  string `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	Image string `protobuf:"bytes,3,opt,name=Image,proto3" json:"image"`
}

func (m *MedalPopup) Reset()                    { *m = MedalPopup{} }
func (m *MedalPopup) String() string            { return proto.CompactTextString(m) }
func (*MedalPopup) ProtoMessage()               {}
func (*MedalPopup) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{15} }

func (m *MedalPopup) GetNID() int64 {
	if m != nil {
		return m.NID
	}
	return 0
}

func (m *MedalPopup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MedalPopup) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

type MedalMyInfo struct {
	*MedalInfo  `protobuf:"bytes,1,opt,name=MedalInfo,embedded=MedalInfo" json:""`
	IsActivated int32                       `protobuf:"varint,2,opt,name=IsActivated,proto3" json:"is_activated"`
	IsNewGet    int32                       `protobuf:"varint,3,opt,name=IsNewGet,proto3" json:"is_new_get"`
	GetTime     go_common_library_time.Time `protobuf:"varint,4,opt,name=GetTime,proto3,casttype=go-common/library/time.Time" json:"get_time,omitempty"`
}

func (m *MedalMyInfo) Reset()                    { *m = MedalMyInfo{} }
func (m *MedalMyInfo) String() string            { return proto.CompactTextString(m) }
func (*MedalMyInfo) ProtoMessage()               {}
func (*MedalMyInfo) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{16} }

func (m *MedalMyInfo) GetIsActivated() int32 {
	if m != nil {
		return m.IsActivated
	}
	return 0
}

func (m *MedalMyInfo) GetIsNewGet() int32 {
	if m != nil {
		return m.IsNewGet
	}
	return 0
}

func (m *MedalMyInfo) GetGetTime() go_common_library_time.Time {
	if m != nil {
		return m.GetTime
	}
	return 0
}

type MedalMyInfos struct {
	Count int32          `protobuf:"varint,1,opt,name=Count,proto3" json:"count"`
	Name  string         `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	List  []*MedalMyInfo `protobuf:"bytes,3,rep,name=List" json:"list"`
}

func (m *MedalMyInfos) Reset()                    { *m = MedalMyInfos{} }
func (m *MedalMyInfos) String() string            { return proto.CompactTextString(m) }
func (*MedalMyInfos) ProtoMessage()               {}
func (*MedalMyInfos) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{17} }

func (m *MedalMyInfos) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *MedalMyInfos) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MedalMyInfos) GetList() []*MedalMyInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type MedalAllInfos struct {
	HasActivated int64                        `protobuf:"varint,1,opt,name=HasActivated,proto3" json:"has_activated"`
	RedPoint     bool                         `protobuf:"varint,2,opt,name=RedPoint,proto3" json:"is_show_red_point"`
	HasGet       []int64                      `protobuf:"varint,3,rep,packed,name=HasGet" json:"has_get"`
	List         map[int64]*MedalCategoryInfo `protobuf:"bytes,4,rep,name=List" json:"list" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MedalAllInfos) Reset()                    { *m = MedalAllInfos{} }
func (m *MedalAllInfos) String() string            { return proto.CompactTextString(m) }
func (*MedalAllInfos) ProtoMessage()               {}
func (*MedalAllInfos) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{18} }

func (m *MedalAllInfos) GetHasActivated() int64 {
	if m != nil {
		return m.HasActivated
	}
	return 0
}

func (m *MedalAllInfos) GetRedPoint() bool {
	if m != nil {
		return m.RedPoint
	}
	return false
}

func (m *MedalAllInfos) GetHasGet() []int64 {
	if m != nil {
		return m.HasGet
	}
	return nil
}

func (m *MedalAllInfos) GetList() map[int64]*MedalCategoryInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type MedalCategoryInfo struct {
	Count int32            `protobuf:"varint,1,opt,name=Count,proto3" json:"count"`
	Name  string           `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	Data  []*MedalItemInfo `protobuf:"bytes,3,rep,name=Data" json:"data"`
}

func (m *MedalCategoryInfo) Reset()                    { *m = MedalCategoryInfo{} }
func (m *MedalCategoryInfo) String() string            { return proto.CompactTextString(m) }
func (*MedalCategoryInfo) ProtoMessage()               {}
func (*MedalCategoryInfo) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{19} }

func (m *MedalCategoryInfo) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *MedalCategoryInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MedalCategoryInfo) GetData() []*MedalItemInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type MedalItemInfo struct {
	Left  *MedalInfo   `protobuf:"bytes,1,opt,name=Left" json:"left"`
	Count int32        `protobuf:"varint,2,opt,name=Count,proto3" json:"count"`
	Right []*MedalInfo `protobuf:"bytes,3,rep,name=Right" json:"right,omitempty"`
}

func (m *MedalItemInfo) Reset()                    { *m = MedalItemInfo{} }
func (m *MedalItemInfo) String() string            { return proto.CompactTextString(m) }
func (*MedalItemInfo) ProtoMessage()               {}
func (*MedalItemInfo) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{20} }

func (m *MedalItemInfo) GetLeft() *MedalInfo {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *MedalItemInfo) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *MedalItemInfo) GetRight() []*MedalInfo {
	if m != nil {
		return m.Right
	}
	return nil
}

type PointFlag struct {
	Pendant bool `protobuf:"varint,1,opt,name=Pendant,proto3" json:"pendant"`
	Medal   bool `protobuf:"varint,2,opt,name=Medal,proto3" json:"medal"`
}

func (m *PointFlag) Reset()                    { *m = PointFlag{} }
func (m *PointFlag) String() string            { return proto.CompactTextString(m) }
func (*PointFlag) ProtoMessage()               {}
func (*PointFlag) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{21} }

func (m *PointFlag) GetPendant() bool {
	if m != nil {
		return m.Pendant
	}
	return false
}

func (m *PointFlag) GetMedal() bool {
	if m != nil {
		return m.Medal
	}
	return false
}

func init() {
	proto.RegisterType((*ArgPendantHistory)(nil), "account.service.usersuit.ArgPendantHistory")
	proto.RegisterType((*ArgOrderHistory)(nil), "account.service.usersuit.ArgOrderHistory")
	proto.RegisterType((*PendantGroupInfo)(nil), "account.service.usersuit.PendantGroupInfo")
	proto.RegisterType((*PendantGroup)(nil), "account.service.usersuit.PendantGroup")
	proto.RegisterType((*PendantPrice)(nil), "account.service.usersuit.PendantPrice")
	proto.RegisterType((*PendantHistory)(nil), "account.service.usersuit.PendantHistory")
	proto.RegisterType((*PendantOrderInfo)(nil), "account.service.usersuit.PendantOrderInfo")
	proto.RegisterType((*PayInfo)(nil), "account.service.usersuit.PayInfo")
	proto.RegisterType((*Pendant)(nil), "account.service.usersuit.Pendant")
	proto.RegisterType((*PendantPackage)(nil), "account.service.usersuit.PendantPackage")
	proto.RegisterType((*PendantEquip)(nil), "account.service.usersuit.PendantEquip")
	proto.RegisterType((*GroupPendantList)(nil), "account.service.usersuit.GroupPendantList")
	proto.RegisterType((*MedalInfo)(nil), "account.service.usersuit.MedalInfo")
	proto.RegisterType((*MedalHomeInfo)(nil), "account.service.usersuit.MedalHomeInfo")
	proto.RegisterType((*MedalUserInfo)(nil), "account.service.usersuit.MedalUserInfo")
	proto.RegisterType((*MedalPopup)(nil), "account.service.usersuit.MedalPopup")
	proto.RegisterType((*MedalMyInfo)(nil), "account.service.usersuit.MedalMyInfo")
	proto.RegisterType((*MedalMyInfos)(nil), "account.service.usersuit.MedalMyInfos")
	proto.RegisterType((*MedalAllInfos)(nil), "account.service.usersuit.MedalAllInfos")
	proto.RegisterType((*MedalCategoryInfo)(nil), "account.service.usersuit.MedalCategoryInfo")
	proto.RegisterType((*MedalItemInfo)(nil), "account.service.usersuit.MedalItemInfo")
	proto.RegisterType((*PointFlag)(nil), "account.service.usersuit.PointFlag")
}
func (m *ArgPendantHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgPendantHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mid))
	}
	if m.SourceType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SourceType))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.EndTime))
	}
	if m.Page != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *ArgOrderHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgOrderHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.OrderID)))
		i += copy(dAtA[i:], m.OrderID)
	}
	if len(m.PayID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PayID)))
		i += copy(dAtA[i:], m.PayID)
	}
	if m.Mid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mid))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pid))
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Status))
	}
	if m.PayType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.PayType))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.EndTime))
	}
	if m.Page != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *PendantGroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendantGroupInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Rank != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Rank))
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Status))
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ImageModel) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.ImageModel)))
		i += copy(dAtA[i:], m.ImageModel)
	}
	if m.FrequencyLimit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.FrequencyLimit))
	}
	if m.TimeLimit != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.TimeLimit))
	}
	if m.Number != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Number))
	}
	if len(m.SubPendant) > 0 {
		for _, msg := range m.SubPendant {
			dAtA[i] = 0x52
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PendantGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendantGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.ID))
	}
	if m.Gid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Gid))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pid))
	}
	return i, nil
}

func (m *PendantPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendantPrice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.ID))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pid))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Type))
	}
	if m.Price != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Price))
	}
	return i, nil
}

func (m *PendantHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendantHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.ID))
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mid))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pid))
	}
	if m.SourceType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.SourceType))
	}
	if m.Expire != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Expire))
	}
	if len(m.OperatorName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.OperatorName)))
		i += copy(dAtA[i:], m.OperatorName)
	}
	if m.OperatorAction != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.OperatorAction))
	}
	return i, nil
}

func (m *PendantOrderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendantOrderInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.ID))
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mid))
	}
	if len(m.OrderID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.OrderID)))
		i += copy(dAtA[i:], m.OrderID)
	}
	if len(m.PayID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PayID)))
		i += copy(dAtA[i:], m.PayID)
	}
	if m.PayType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.PayType))
	}
	if m.PayPrice != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PayPrice))))
		i += 8
	}
	if m.AppID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.AppID))
	}
	if m.Stauts != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Stauts))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pid))
	}
	if m.TimeLength != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.TimeLength))
	}
	if len(m.Cost) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Cost)))
		i += copy(dAtA[i:], m.Cost)
	}
	if m.BuyTime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.BuyTime))
	}
	if m.IsCallback != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsCallback))
	}
	if m.CallbackTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.CallbackTime))
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *PayInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.OrderID)))
		i += copy(dAtA[i:], m.OrderID)
	}
	if len(m.OrderNum) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.OrderNum)))
		i += copy(dAtA[i:], m.OrderNum)
	}
	if len(m.PayURL) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.PayURL)))
		i += copy(dAtA[i:], m.PayURL)
	}
	return i, nil
}

func (m *Pendant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pendant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ImageModel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.ImageModel)))
		i += copy(dAtA[i:], m.ImageModel)
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Status))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Coin))
	}
	if m.Point != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Point))
	}
	if m.BCoin != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.BCoin))
	}
	if m.Expires != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Expires))
	}
	if m.Gid != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Gid))
	}
	if m.Rank != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Rank))
	}
	return i, nil
}

func (m *PendantPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendantPackage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.ID))
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mid))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pid))
	}
	if m.Expires != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Expires))
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Type))
	}
	if m.Status != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Status))
	}
	if m.IsVIP != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsVIP))
	}
	if m.Pendant != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pendant.Size()))
		n1, err := m.Pendant.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *PendantEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendantEquip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mid))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pid))
	}
	if m.Expires != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Expires))
	}
	if m.Pendant != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pendant.Size()))
		n2, err := m.Pendant.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *GroupPendantList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupPendantList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PkgExpires != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.PkgExpires))
	}
	if m.PkgStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.PkgStatus))
	}
	if m.Pendant != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Pendant.Size()))
		n3, err := m.Pendant.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *MedalInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedalInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ImageSmall) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.ImageSmall)))
		i += copy(dAtA[i:], m.ImageSmall)
	}
	if len(m.Condition) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Condition)))
		i += copy(dAtA[i:], m.Condition)
	}
	if m.GID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.GID))
	}
	if m.Level != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Level))
	}
	if len(m.LevelRank) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.LevelRank)))
		i += copy(dAtA[i:], m.LevelRank)
	}
	if len(m.LevelDesc) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.LevelDesc)))
		i += copy(dAtA[i:], m.LevelDesc)
	}
	if m.Sort != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Sort))
	}
	if m.IsOnline != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsOnline))
	}
	if m.IsGet != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsGet))
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Mtime))
	}
	return i, nil
}

func (m *MedalHomeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedalHomeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ImageSmall) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.ImageSmall)))
		i += copy(dAtA[i:], m.ImageSmall)
	}
	if m.IsActivated != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsActivated))
	}
	if len(m.Level) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Level)))
		i += copy(dAtA[i:], m.Level)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.NID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NID))
	}
	return i, nil
}

func (m *MedalUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedalUserInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Face) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Face)))
		i += copy(dAtA[i:], m.Face)
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Level))
	}
	if m.TrueLove {
		dAtA[i] = 0x20
		i++
		if m.TrueLove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NID))
	}
	if len(m.ImageSmall) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.ImageSmall)))
		i += copy(dAtA[i:], m.ImageSmall)
	}
	return i, nil
}

func (m *MedalPopup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedalPopup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.NID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	return i, nil
}

func (m *MedalMyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedalMyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MedalInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.MedalInfo.Size()))
		n4, err := m.MedalInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.IsActivated != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsActivated))
	}
	if m.IsNewGet != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.IsNewGet))
	}
	if m.GetTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.GetTime))
	}
	return i, nil
}

func (m *MedalMyInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedalMyInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Count))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MedalAllInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedalAllInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HasActivated != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.HasActivated))
	}
	if m.RedPoint {
		dAtA[i] = 0x10
		i++
		if m.RedPoint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.HasGet) > 0 {
		dAtA6 := make([]byte, len(m.HasGet)*10)
		var j5 int
		for _, num1 := range m.HasGet {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModel(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.List) > 0 {
		for k, _ := range m.List {
			dAtA[i] = 0x22
			i++
			v := m.List[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovModel(uint64(msgSize))
			}
			mapSize := 1 + sovModel(uint64(k)) + msgSize
			i = encodeVarintModel(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintModel(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintModel(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	return i, nil
}

func (m *MedalCategoryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedalCategoryInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Count))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MedalItemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MedalItemInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Left != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Left.Size()))
		n8, err := m.Left.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModel(dAtA, i, uint64(m.Count))
	}
	if len(m.Right) > 0 {
		for _, msg := range m.Right {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintModel(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PointFlag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointFlag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pendant {
		dAtA[i] = 0x8
		i++
		if m.Pendant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Medal {
		dAtA[i] = 0x10
		i++
		if m.Medal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintModel(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ArgPendantHistory) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovModel(uint64(m.Mid))
	}
	if m.SourceType != 0 {
		n += 1 + sovModel(uint64(m.SourceType))
	}
	if m.StartTime != 0 {
		n += 1 + sovModel(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovModel(uint64(m.EndTime))
	}
	if m.Page != 0 {
		n += 1 + sovModel(uint64(m.Page))
	}
	return n
}

func (m *ArgOrderHistory) Size() (n int) {
	var l int
	_ = l
	l = len(m.OrderID)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.PayID)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovModel(uint64(m.Mid))
	}
	if m.Pid != 0 {
		n += 1 + sovModel(uint64(m.Pid))
	}
	if m.Status != 0 {
		n += 1 + sovModel(uint64(m.Status))
	}
	if m.PayType != 0 {
		n += 1 + sovModel(uint64(m.PayType))
	}
	if m.StartTime != 0 {
		n += 1 + sovModel(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovModel(uint64(m.EndTime))
	}
	if m.Page != 0 {
		n += 1 + sovModel(uint64(m.Page))
	}
	return n
}

func (m *PendantGroupInfo) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovModel(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovModel(uint64(m.Rank))
	}
	if m.Status != 0 {
		n += 1 + sovModel(uint64(m.Status))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ImageModel)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.FrequencyLimit != 0 {
		n += 1 + sovModel(uint64(m.FrequencyLimit))
	}
	if m.TimeLimit != 0 {
		n += 1 + sovModel(uint64(m.TimeLimit))
	}
	if m.Number != 0 {
		n += 1 + sovModel(uint64(m.Number))
	}
	if len(m.SubPendant) > 0 {
		for _, e := range m.SubPendant {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *PendantGroup) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovModel(uint64(m.ID))
	}
	if m.Gid != 0 {
		n += 1 + sovModel(uint64(m.Gid))
	}
	if m.Pid != 0 {
		n += 1 + sovModel(uint64(m.Pid))
	}
	return n
}

func (m *PendantPrice) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovModel(uint64(m.ID))
	}
	if m.Pid != 0 {
		n += 1 + sovModel(uint64(m.Pid))
	}
	if m.Type != 0 {
		n += 1 + sovModel(uint64(m.Type))
	}
	if m.Price != 0 {
		n += 1 + sovModel(uint64(m.Price))
	}
	return n
}

func (m *PendantHistory) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovModel(uint64(m.ID))
	}
	if m.Mid != 0 {
		n += 1 + sovModel(uint64(m.Mid))
	}
	if m.Pid != 0 {
		n += 1 + sovModel(uint64(m.Pid))
	}
	if m.SourceType != 0 {
		n += 1 + sovModel(uint64(m.SourceType))
	}
	if m.Expire != 0 {
		n += 1 + sovModel(uint64(m.Expire))
	}
	l = len(m.OperatorName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.OperatorAction != 0 {
		n += 1 + sovModel(uint64(m.OperatorAction))
	}
	return n
}

func (m *PendantOrderInfo) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovModel(uint64(m.ID))
	}
	if m.Mid != 0 {
		n += 1 + sovModel(uint64(m.Mid))
	}
	l = len(m.OrderID)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.PayID)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.PayType != 0 {
		n += 1 + sovModel(uint64(m.PayType))
	}
	if m.PayPrice != 0 {
		n += 9
	}
	if m.AppID != 0 {
		n += 1 + sovModel(uint64(m.AppID))
	}
	if m.Stauts != 0 {
		n += 1 + sovModel(uint64(m.Stauts))
	}
	if m.Pid != 0 {
		n += 1 + sovModel(uint64(m.Pid))
	}
	if m.TimeLength != 0 {
		n += 1 + sovModel(uint64(m.TimeLength))
	}
	l = len(m.Cost)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.BuyTime != 0 {
		n += 1 + sovModel(uint64(m.BuyTime))
	}
	if m.IsCallback != 0 {
		n += 1 + sovModel(uint64(m.IsCallback))
	}
	if m.CallbackTime != 0 {
		n += 1 + sovModel(uint64(m.CallbackTime))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovModel(uint64(l))
	}
	return n
}

func (m *PayInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.OrderID)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.OrderNum)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.PayURL)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *Pendant) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovModel(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ImageModel)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovModel(uint64(m.Status))
	}
	if m.Coin != 0 {
		n += 1 + sovModel(uint64(m.Coin))
	}
	if m.Point != 0 {
		n += 1 + sovModel(uint64(m.Point))
	}
	if m.BCoin != 0 {
		n += 1 + sovModel(uint64(m.BCoin))
	}
	if m.Expires != 0 {
		n += 1 + sovModel(uint64(m.Expires))
	}
	if m.Gid != 0 {
		n += 1 + sovModel(uint64(m.Gid))
	}
	if m.Rank != 0 {
		n += 1 + sovModel(uint64(m.Rank))
	}
	return n
}

func (m *PendantPackage) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovModel(uint64(m.ID))
	}
	if m.Mid != 0 {
		n += 1 + sovModel(uint64(m.Mid))
	}
	if m.Pid != 0 {
		n += 1 + sovModel(uint64(m.Pid))
	}
	if m.Expires != 0 {
		n += 1 + sovModel(uint64(m.Expires))
	}
	if m.Type != 0 {
		n += 1 + sovModel(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovModel(uint64(m.Status))
	}
	if m.IsVIP != 0 {
		n += 1 + sovModel(uint64(m.IsVIP))
	}
	if m.Pendant != nil {
		l = m.Pendant.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *PendantEquip) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovModel(uint64(m.Mid))
	}
	if m.Pid != 0 {
		n += 1 + sovModel(uint64(m.Pid))
	}
	if m.Expires != 0 {
		n += 1 + sovModel(uint64(m.Expires))
	}
	if m.Pendant != nil {
		l = m.Pendant.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *GroupPendantList) Size() (n int) {
	var l int
	_ = l
	if m.PkgExpires != 0 {
		n += 1 + sovModel(uint64(m.PkgExpires))
	}
	if m.PkgStatus != 0 {
		n += 1 + sovModel(uint64(m.PkgStatus))
	}
	if m.Pendant != nil {
		l = m.Pendant.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *MedalInfo) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovModel(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ImageSmall)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Condition)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.GID != 0 {
		n += 1 + sovModel(uint64(m.GID))
	}
	if m.Level != 0 {
		n += 1 + sovModel(uint64(m.Level))
	}
	l = len(m.LevelRank)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.LevelDesc)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovModel(uint64(m.Sort))
	}
	if m.IsOnline != 0 {
		n += 1 + sovModel(uint64(m.IsOnline))
	}
	if m.IsGet != 0 {
		n += 1 + sovModel(uint64(m.IsGet))
	}
	if m.Ctime != 0 {
		n += 1 + sovModel(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovModel(uint64(m.Mtime))
	}
	return n
}

func (m *MedalHomeInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ImageSmall)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.IsActivated != 0 {
		n += 1 + sovModel(uint64(m.IsActivated))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.NID != 0 {
		n += 1 + sovModel(uint64(m.NID))
	}
	return n
}

func (m *MedalUserInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovModel(uint64(m.Level))
	}
	if m.TrueLove {
		n += 2
	}
	if m.NID != 0 {
		n += 1 + sovModel(uint64(m.NID))
	}
	l = len(m.ImageSmall)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *MedalPopup) Size() (n int) {
	var l int
	_ = l
	if m.NID != 0 {
		n += 1 + sovModel(uint64(m.NID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *MedalMyInfo) Size() (n int) {
	var l int
	_ = l
	if m.MedalInfo != nil {
		l = m.MedalInfo.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.IsActivated != 0 {
		n += 1 + sovModel(uint64(m.IsActivated))
	}
	if m.IsNewGet != 0 {
		n += 1 + sovModel(uint64(m.IsNewGet))
	}
	if m.GetTime != 0 {
		n += 1 + sovModel(uint64(m.GetTime))
	}
	return n
}

func (m *MedalMyInfos) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovModel(uint64(m.Count))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *MedalAllInfos) Size() (n int) {
	var l int
	_ = l
	if m.HasActivated != 0 {
		n += 1 + sovModel(uint64(m.HasActivated))
	}
	if m.RedPoint {
		n += 2
	}
	if len(m.HasGet) > 0 {
		l = 0
		for _, e := range m.HasGet {
			l += sovModel(uint64(e))
		}
		n += 1 + sovModel(uint64(l)) + l
	}
	if len(m.List) > 0 {
		for k, v := range m.List {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovModel(uint64(l))
			}
			mapEntrySize := 1 + sovModel(uint64(k)) + l
			n += mapEntrySize + 1 + sovModel(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MedalCategoryInfo) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovModel(uint64(m.Count))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *MedalItemInfo) Size() (n int) {
	var l int
	_ = l
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovModel(uint64(m.Count))
	}
	if len(m.Right) > 0 {
		for _, e := range m.Right {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *PointFlag) Size() (n int) {
	var l int
	_ = l
	if m.Pendant {
		n += 2
	}
	if m.Medal {
		n += 2
	}
	return n
}

func sovModel(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ArgPendantHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgPendantHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgPendantHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgOrderHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgOrderHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgOrderHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayType", wireType)
			}
			m.PayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendantGroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendantGroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendantGroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyLimit", wireType)
			}
			m.FrequencyLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLimit", wireType)
			}
			m.TimeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPendant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPendant = append(m.SubPendant, &Pendant{})
			if err := m.SubPendant[len(m.SubPendant)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendantGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendantGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendantGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendantPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendantPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendantPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendantHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendantHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendantHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAction", wireType)
			}
			m.OperatorAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatorAction |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendantOrderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendantOrderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendantOrderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayType", wireType)
			}
			m.PayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PayPrice = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			m.AppID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stauts", wireType)
			}
			m.Stauts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stauts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeLength", wireType)
			}
			m.TimeLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyTime", wireType)
			}
			m.BuyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCallback", wireType)
			}
			m.IsCallback = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCallback |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackTime", wireType)
			}
			m.CallbackTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallbackTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pendant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pendant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pendant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			m.Point = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Point |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BCoin", wireType)
			}
			m.BCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BCoin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			m.Expires = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expires |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendantPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendantPackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendantPackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			m.Expires = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expires |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVIP", wireType)
			}
			m.IsVIP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsVIP |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pendant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pendant == nil {
				m.Pendant = &Pendant{}
			}
			if err := m.Pendant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendantEquip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendantEquip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendantEquip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			m.Expires = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expires |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pendant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pendant == nil {
				m.Pendant = &Pendant{}
			}
			if err := m.Pendant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupPendantList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupPendantList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupPendantList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgExpires", wireType)
			}
			m.PkgExpires = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgExpires |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgStatus", wireType)
			}
			m.PkgStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pendant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pendant == nil {
				m.Pendant = &Pendant{}
			}
			if err := m.Pendant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedalInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedalInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedalInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageSmall", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageSmall = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GID", wireType)
			}
			m.GID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelRank", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LevelRank = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LevelDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnline", wireType)
			}
			m.IsOnline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsOnline |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsGet", wireType)
			}
			m.IsGet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsGet |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedalHomeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedalHomeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedalHomeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageSmall", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageSmall = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActivated", wireType)
			}
			m.IsActivated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsActivated |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NID", wireType)
			}
			m.NID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedalUserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedalUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedalUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrueLove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrueLove = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NID", wireType)
			}
			m.NID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageSmall", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageSmall = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedalPopup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedalPopup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedalPopup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NID", wireType)
			}
			m.NID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedalMyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedalMyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedalMyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedalInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MedalInfo == nil {
				m.MedalInfo = &MedalInfo{}
			}
			if err := m.MedalInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActivated", wireType)
			}
			m.IsActivated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsActivated |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNewGet", wireType)
			}
			m.IsNewGet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsNewGet |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetTime", wireType)
			}
			m.GetTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedalMyInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedalMyInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedalMyInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &MedalMyInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedalAllInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedalAllInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedalAllInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasActivated", wireType)
			}
			m.HasActivated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasActivated |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPoint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedPoint = bool(v != 0)
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HasGet = append(m.HasGet, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModel
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HasGet = append(m.HasGet, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HasGet", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = make(map[int64]*MedalCategoryInfo)
			}
			var mapkey int64
			var mapvalue *MedalCategoryInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthModel
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthModel
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MedalCategoryInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModel(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModel
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.List[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedalCategoryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedalCategoryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedalCategoryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &MedalItemInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MedalItemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MedalItemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MedalItemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &MedalInfo{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Right = append(m.Right, &MedalInfo{})
			if err := m.Right[len(m.Right)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointFlag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointFlag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointFlag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pendant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pendant = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Medal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModel
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModel(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModel = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app/service/main/usersuit/model/model.proto", fileDescriptorModel) }

var fileDescriptorModel = []byte{
	// 2187 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcb, 0x6e, 0x1b, 0xc9,
	0xd5, 0xfe, 0x9b, 0xcd, 0xe6, 0xe5, 0x50, 0x96, 0xe4, 0xf6, 0x0c, 0x4c, 0xcf, 0xf8, 0x77, 0x3b,
	0x3d, 0x17, 0xdf, 0xa5, 0xb1, 0x06, 0x33, 0x08, 0x82, 0x6c, 0x44, 0xc9, 0x63, 0x11, 0x91, 0x65,
	0xa1, 0x6c, 0x67, 0x91, 0x0d, 0xd1, 0x24, 0x4b, 0xad, 0x82, 0xd8, 0x97, 0xe9, 0x8b, 0x1c, 0x3e,
	0x40, 0xb2, 0x49, 0x56, 0x59, 0x25, 0xdb, 0x3c, 0x41, 0x16, 0x59, 0x64, 0x15, 0x20, 0xc8, 0x22,
	0x59, 0x0e, 0x10, 0x64, 0xdb, 0x08, 0x84, 0xac, 0xf8, 0x08, 0x59, 0x05, 0xe7, 0x54, 0xf5, 0x45,
	0x14, 0x65, 0xca, 0x98, 0x6c, 0xba, 0xab, 0x4e, 0x9d, 0xba, 0x7d, 0xf5, 0x9d, 0xaf, 0x4e, 0x37,
	0x3c, 0x72, 0xc2, 0x70, 0x33, 0xe6, 0xd1, 0xa9, 0x18, 0xf1, 0x4d, 0xcf, 0x11, 0xfe, 0x66, 0x1a,
	0xf3, 0x28, 0x4e, 0x45, 0xb2, 0xe9, 0x05, 0x63, 0x3e, 0x91, 0xcf, 0x8d, 0x30, 0x0a, 0x92, 0xc0,
	0xec, 0x3a, 0xa3, 0x51, 0x90, 0xfa, 0xc9, 0x86, 0xea, 0xb0, 0x91, 0xfb, 0x7e, 0xf4, 0xc4, 0x15,
	0xc9, 0x71, 0x3a, 0xdc, 0x18, 0x05, 0xde, 0xa6, 0x1b, 0xb8, 0xc1, 0x26, 0x75, 0x18, 0xa6, 0x47,
	0x54, 0xa3, 0x0a, 0x95, 0xe4, 0x40, 0xf6, 0x3f, 0x34, 0xb8, 0xbe, 0x1d, 0xb9, 0x87, 0xdc, 0x1f,
	0x3b, 0x7e, 0xb2, 0x27, 0xe2, 0x24, 0x88, 0xa6, 0xe6, 0x2d, 0xd0, 0x3d, 0x31, 0xee, 0x6a, 0x77,
	0xb5, 0xfb, 0x7a, 0xaf, 0x39, 0xcb, 0x2c, 0xac, 0x32, 0x7c, 0x98, 0x9b, 0xd0, 0x89, 0x83, 0x34,
	0x1a, 0xf1, 0x41, 0x32, 0x0d, 0x79, 0xb7, 0x76, 0x57, 0xbb, 0x6f, 0xf4, 0x56, 0x67, 0x99, 0x05,
	0xd2, 0xfc, 0x7a, 0x1a, 0x72, 0x56, 0x29, 0x9b, 0x8f, 0x01, 0xe2, 0xc4, 0x89, 0x92, 0x41, 0x22,
	0x3c, 0xde, 0xd5, 0x69, 0xc8, 0x6b, 0xb3, 0xcc, 0x6a, 0x93, 0xf5, 0xb5, 0xf0, 0x38, 0x2b, 0x8b,
	0xe6, 0xe7, 0xd0, 0xe2, 0xfe, 0x58, 0xfa, 0xd6, 0xc9, 0xb7, 0x33, 0xcb, 0xac, 0x26, 0xf7, 0xc7,
	0xe4, 0x99, 0x17, 0xcc, 0xdb, 0x50, 0x0f, 0x1d, 0x97, 0x77, 0x0d, 0xf2, 0x69, 0xcd, 0x32, 0x8b,
	0xea, 0x8c, 0x9e, 0xf6, 0xbf, 0x6b, 0xb0, 0xb6, 0x1d, 0xb9, 0x2f, 0xa3, 0x31, 0x8f, 0xf2, 0x3d,
	0x7d, 0x01, 0xad, 0x00, 0xeb, 0x03, 0xb5, 0xb1, 0x76, 0xef, 0xc3, 0xb3, 0xcc, 0x6a, 0x92, 0x4f,
	0x7f, 0x77, 0x96, 0x59, 0x8d, 0x80, 0x4a, 0xac, 0x49, 0x6e, 0xfd, 0xb1, 0xf9, 0x00, 0x1a, 0xa1,
	0x33, 0x45, 0xff, 0x1a, 0xf9, 0x9b, 0x67, 0x99, 0x65, 0x1c, 0x3a, 0x53, 0xf2, 0x36, 0x42, 0x2c,
	0x30, 0x7a, 0x8d, 0x73, 0xc0, 0xf4, 0x05, 0x80, 0xdd, 0x02, 0x3d, 0x14, 0x63, 0xb5, 0x19, 0x6a,
	0x0a, 0xb1, 0x29, 0x14, 0x63, 0xd3, 0x86, 0x46, 0x9c, 0x38, 0x49, 0x1a, 0xd3, 0x36, 0x8c, 0x1e,
	0xe0, 0x2a, 0xa4, 0x85, 0xa9, 0x37, 0x02, 0x82, 0x8b, 0x20, 0xb0, 0x1b, 0xe4, 0x45, 0x80, 0x84,
	0xce, 0x94, 0x90, 0xce, 0x0b, 0x73, 0x30, 0x37, 0xdf, 0x03, 0xe6, 0xd6, 0x15, 0x60, 0x6e, 0x2f,
	0x84, 0xf9, 0xcf, 0x3a, 0xac, 0x2b, 0xe6, 0x3c, 0x8f, 0x82, 0x34, 0xec, 0xfb, 0x47, 0x81, 0x79,
	0x1b, 0x6a, 0x05, 0x75, 0x56, 0xce, 0x32, 0xab, 0x46, 0x70, 0xd5, 0xc4, 0x98, 0xd5, 0x68, 0xcb,
	0x75, 0xdf, 0xf1, 0xb8, 0x42, 0x94, 0x78, 0xe3, 0x62, 0xd7, 0x01, 0x5a, 0x19, 0xb5, 0xe1, 0xa4,
	0x91, 0xe3, 0x9f, 0x10, 0x9a, 0x86, 0x9c, 0x14, 0xeb, 0x8c, 0x9e, 0x15, 0xd0, 0xea, 0x97, 0x82,
	0x66, 0x81, 0x21, 0xbc, 0x9c, 0x1e, 0xed, 0x5e, 0x1b, 0xcf, 0x8b, 0x0c, 0x4c, 0xbe, 0xcc, 0x2f,
	0xa0, 0x43, 0x85, 0x01, 0x05, 0x15, 0x01, 0xdb, 0xee, 0xad, 0xcd, 0x32, 0xab, 0x6a, 0x66, 0x40,
	0x95, 0x17, 0x58, 0x36, 0x37, 0x60, 0xed, 0x28, 0xe2, 0xdf, 0xa6, 0xdc, 0x1f, 0x4d, 0x07, 0x13,
	0xe1, 0x89, 0x84, 0x40, 0x36, 0x7a, 0xc6, 0x2c, 0xb3, 0xb4, 0x27, 0x6c, 0xb5, 0x68, 0xdd, 0xc7,
	0x46, 0xf3, 0x53, 0x00, 0x44, 0x57, 0xb9, 0xb6, 0xaa, 0xae, 0x6d, 0x6c, 0x90, 0x5e, 0xf7, 0xa0,
	0xe1, 0xa7, 0xde, 0x90, 0x47, 0x0a, 0x61, 0x5a, 0x82, 0x04, 0x84, 0xe2, 0x9b, 0xa9, 0x66, 0xf3,
	0x35, 0x74, 0xe2, 0x74, 0x38, 0x08, 0x25, 0xda, 0x5d, 0xb8, 0xab, 0xdf, 0xef, 0x6c, 0xfd, 0x60,
	0xe3, 0x32, 0x19, 0xd8, 0x50, 0xc7, 0xd2, 0x5b, 0x9f, 0x65, 0xd6, 0x8a, 0xea, 0x35, 0x10, 0xfe,
	0x51, 0xc0, 0x20, 0x4e, 0x87, 0xaa, 0xd5, 0x1e, 0xc2, 0x4a, 0xf5, 0xfc, 0x96, 0x9c, 0xdd, 0x2d,
	0xd0, 0x5d, 0x15, 0x0c, 0x8a, 0xc9, 0x2e, 0x32, 0xd9, 0x2d, 0x49, 0xae, 0x5f, 0x24, 0xb9, 0xfd,
	0x4b, 0xad, 0x98, 0xe4, 0x30, 0x12, 0x23, 0xbe, 0x7c, 0x92, 0xf0, 0xfc, 0x24, 0x45, 0xb8, 0xdc,
	0x86, 0x3a, 0x85, 0x81, 0x5e, 0x92, 0x11, 0xeb, 0x8c, 0x9e, 0x78, 0xe6, 0x21, 0x8e, 0xaf, 0x22,
	0x8d, 0xce, 0x9c, 0x0c, 0x4c, 0xbe, 0xec, 0x3f, 0xd4, 0x60, 0x75, 0x4e, 0xe7, 0x96, 0x2e, 0xc5,
	0x3b, 0xbf, 0x94, 0xf9, 0xa0, 0x5e, 0xb0, 0x5f, 0xa4, 0x56, 0x55, 0x20, 0x25, 0x49, 0xe9, 0x5c,
	0x2b, 0xe6, 0x73, 0x0a, 0x69, 0x43, 0x83, 0xff, 0x3c, 0x14, 0x51, 0xae, 0x66, 0xc4, 0x68, 0x69,
	0x61, 0xea, 0x6d, 0x7e, 0x0d, 0xd7, 0x82, 0x90, 0x47, 0x4e, 0x12, 0x44, 0x14, 0x2a, 0x8a, 0xb2,
	0xd7, 0x67, 0x99, 0x85, 0x0d, 0x4e, 0x94, 0x37, 0xb0, 0x95, 0xdc, 0xef, 0x00, 0x63, 0xe9, 0xc7,
	0xb0, 0x56, 0xf4, 0x73, 0x46, 0x89, 0x08, 0x7c, 0x45, 0xdb, 0x1b, 0xb3, 0xcc, 0x5a, 0x2b, 0x7a,
	0xca, 0x26, 0xb6, 0x9a, 0xfb, 0x6e, 0x53, 0xdd, 0xfe, 0xb5, 0x51, 0x04, 0xb8, 0xd4, 0x49, 0x0c,
	0xf0, 0x8f, 0x2b, 0xa0, 0x75, 0x0a, 0xd0, 0xb4, 0xc1, 0x32, 0xcc, 0xb6, 0x2a, 0x02, 0xac, 0xd3,
	0xea, 0x6f, 0x9e, 0x17, 0xe0, 0xa2, 0xb9, 0x94, 0xe0, 0x87, 0x85, 0x04, 0xd7, 0xa9, 0xc7, 0x8d,
	0xaa, 0x04, 0xab, 0xa6, 0x5c, 0x83, 0xef, 0x55, 0x94, 0x52, 0x02, 0xb9, 0x82, 0x83, 0xe6, 0xb6,
	0x52, 0x2a, 0x1f, 0x42, 0x1b, 0x8d, 0x92, 0x2d, 0x88, 0xa3, 0x26, 0x95, 0xb2, 0x30, 0x32, 0xec,
	0x24, 0xc9, 0xfa, 0x10, 0x1a, 0x4e, 0x18, 0xe2, 0x02, 0xa4, 0xa4, 0xd2, 0x02, 0xb6, 0xc3, 0x50,
	0x2e, 0x40, 0x36, 0x31, 0xc3, 0x09, 0xc3, 0x7e, 0x2e, 0xe7, 0x69, 0x12, 0xab, 0x70, 0x9f, 0x57,
	0xa6, 0x34, 0x89, 0x73, 0xe2, 0xb4, 0x17, 0x13, 0x47, 0x2a, 0x06, 0xf7, 0xdd, 0xe4, 0xb8, 0x0b,
	0xa5, 0x20, 0x54, 0xcc, 0x8c, 0x54, 0x65, 0x9f, 0xca, 0x18, 0x10, 0xa3, 0x20, 0x4e, 0xba, 0x1d,
	0xc2, 0x86, 0x02, 0x02, 0xeb, 0x8c, 0x9e, 0x88, 0xc7, 0x30, 0x9d, 0x4a, 0x8d, 0x5f, 0x29, 0xf1,
	0xc8, 0x6d, 0xac, 0x39, 0x4c, 0xa7, 0x24, 0xf2, 0x28, 0x86, 0xf1, 0x60, 0xe4, 0x4c, 0x26, 0x43,
	0x67, 0x74, 0xd2, 0xbd, 0x56, 0x32, 0xb6, 0x62, 0x66, 0x20, 0xe2, 0x1d, 0x55, 0x46, 0x36, 0xe6,
	0x76, 0x39, 0xfe, 0x2a, 0x8d, 0x4f, 0x6c, 0x3c, 0xd7, 0xc0, 0x56, 0xf2, 0x2a, 0xcd, 0x54, 0xe8,
	0xf2, 0xda, 0x25, 0xba, 0x7c, 0x5b, 0x5d, 0x0f, 0xeb, 0xe5, 0x8e, 0xca, 0x8b, 0xc1, 0xfe, 0xad,
	0x06, 0x4d, 0x3c, 0x7c, 0x64, 0xe1, 0xd6, 0x85, 0xeb, 0x7c, 0x39, 0x9b, 0x1e, 0x40, 0x5b, 0x1a,
	0xfd, 0xd4, 0x53, 0x37, 0xd0, 0x4a, 0xe9, 0xe9, 0x07, 0x4c, 0x96, 0x0e, 0x52, 0xcf, 0xdc, 0x00,
	0xa4, 0xcb, 0x20, 0x8d, 0x26, 0x8a, 0xab, 0x98, 0x2c, 0x34, 0x0e, 0x9d, 0xe9, 0x1b, 0xb6, 0xaf,
	0xee, 0x5f, 0x6c, 0x64, 0xc8, 0xc1, 0x37, 0xd1, 0xc4, 0xfe, 0x85, 0x0e, 0x4d, 0x15, 0x29, 0xe6,
	0xff, 0x57, 0x02, 0xe4, 0x5a, 0x11, 0x20, 0x74, 0xd0, 0x35, 0x29, 0x63, 0x95, 0x2b, 0x70, 0x6e,
	0x8f, 0x25, 0x44, 0xfa, 0xd5, 0xae, 0xae, 0xfa, 0xf2, 0xab, 0xeb, 0x2a, 0x69, 0x06, 0x51, 0x49,
	0xf8, 0x14, 0x0e, 0x7a, 0x4e, 0x25, 0xe1, 0x33, 0x7a, 0x92, 0xb6, 0x06, 0xc2, 0x4f, 0x54, 0x10,
	0x48, 0x6d, 0x45, 0x03, 0x93, 0x2f, 0xf3, 0x3e, 0x18, 0x43, 0xea, 0x2f, 0x93, 0x09, 0xca, 0x94,
	0x7a, 0x3b, 0x81, 0xf0, 0xd1, 0x93, 0x5a, 0x98, 0x7c, 0x99, 0x9f, 0x42, 0x53, 0x4a, 0x5a, 0xac,
	0x82, 0xa0, 0xaa, 0x76, 0x79, 0x53, 0x7e, 0xd5, 0xc0, 0x82, 0xab, 0x26, 0xcf, 0x0e, 0x3a, 0x8b,
	0xb2, 0x03, 0xfb, 0x2f, 0xa5, 0xc8, 0x1f, 0x3a, 0xa3, 0x13, 0xc9, 0xa9, 0xff, 0xbd, 0xc8, 0x57,
	0x76, 0x51, 0xbf, 0x7c, 0x17, 0xf9, 0x85, 0x65, 0x2c, 0xbc, 0xb0, 0xca, 0x63, 0x69, 0x5c, 0x7a,
	0x2c, 0x0f, 0xa0, 0x21, 0xe2, 0xc1, 0xa9, 0x08, 0x95, 0x6a, 0x13, 0xb0, 0xfd, 0xf8, 0xa7, 0xfd,
	0x43, 0xe2, 0x05, 0x16, 0x18, 0xbe, 0x44, 0x68, 0xee, 0x41, 0x33, 0xcf, 0x0e, 0xf0, 0x10, 0xae,
	0x94, 0x1d, 0xc8, 0x54, 0x52, 0x56, 0x58, 0x5e, 0xb0, 0xff, 0x58, 0xde, 0xd8, 0xcf, 0xbe, 0x4d,
	0x45, 0xf8, 0xae, 0xcf, 0x81, 0x77, 0x5c, 0xd7, 0x15, 0x8c, 0xf4, 0xcb, 0x31, 0xaa, 0x2c, 0xbb,
	0xfe, 0xfd, 0x96, 0xfd, 0x27, 0x0d, 0xd6, 0x29, 0x8d, 0x51, 0x6e, 0xfb, 0x22, 0x4e, 0xcc, 0x4d,
	0x80, 0xf0, 0xc4, 0x7d, 0xa6, 0xd6, 0xa1, 0x95, 0x9a, 0x1a, 0x9e, 0xb8, 0x03, 0xb5, 0x06, 0x56,
	0x71, 0x31, 0x1f, 0x43, 0x3b, 0x3c, 0x71, 0x5f, 0xc9, 0x83, 0xa9, 0x7c, 0xdd, 0xa0, 0xbf, 0x3a,
	0x9c, 0xd2, 0xc1, 0x7c, 0x56, 0xae, 0x5e, 0xbf, 0xea, 0xea, 0x5b, 0xdf, 0x65, 0x96, 0x36, 0xcb,
	0xac, 0xff, 0x2b, 0x97, 0xfe, 0x37, 0x03, 0xda, 0x2f, 0xf8, 0xd8, 0x99, 0x90, 0xb4, 0xdd, 0x84,
	0x5a, 0x7f, 0xb7, 0x8a, 0xb6, 0x8f, 0x5c, 0xed, 0xef, 0x22, 0x9f, 0x0e, 0x16, 0x2a, 0x07, 0x5d,
	0xf5, 0x4f, 0xa1, 0xb3, 0xcb, 0xe3, 0x51, 0x24, 0x42, 0xba, 0xe6, 0xf5, 0x52, 0x18, 0xc6, 0xa5,
	0x99, 0x55, 0x7d, 0x30, 0xae, 0xfb, 0x24, 0x36, 0xf5, 0x0b, 0x62, 0x43, 0x76, 0x84, 0x8f, 0x0a,
	0xaf, 0x3c, 0x67, 0x32, 0x51, 0xd9, 0x74, 0x45, 0x6b, 0x62, 0x34, 0xb3, 0x8a, 0x8b, 0xf9, 0x08,
	0xda, 0x3b, 0x81, 0x3f, 0x16, 0xb4, 0x04, 0x99, 0xa3, 0xd0, 0xdd, 0x3a, 0xca, 0x8d, 0xac, 0x6c,
	0x47, 0xf2, 0x3c, 0xef, 0xef, 0x2a, 0x51, 0x29, 0xa3, 0xfc, 0x79, 0x7f, 0xd7, 0x7c, 0x00, 0xc6,
	0x3e, 0x3f, 0xe5, 0x13, 0x75, 0x95, 0x52, 0xb6, 0x32, 0x41, 0xc3, 0xe3, 0xc0, 0x13, 0x09, 0xf7,
	0xc2, 0x64, 0xca, 0xa4, 0x87, 0xf9, 0x35, 0xb4, 0xa9, 0xc0, 0x50, 0x15, 0xda, 0x34, 0x65, 0x77,
	0x96, 0x59, 0x1f, 0x90, 0xfb, 0x00, 0x55, 0xa1, 0xd2, 0xa7, 0x74, 0x2d, 0xfa, 0x21, 0x20, 0xa4,
	0x34, 0xe7, 0xfa, 0x21, 0x66, 0x17, 0xfa, 0xa1, 0xab, 0xf9, 0x39, 0xd4, 0x5f, 0x05, 0x51, 0xa2,
	0x04, 0xc8, 0x9c, 0x65, 0xd6, 0x6a, 0x1c, 0x44, 0x49, 0xc5, 0x99, 0xda, 0xcd, 0x2f, 0xa1, 0xd5,
	0x8f, 0x5f, 0xfa, 0x13, 0xe1, 0xcb, 0xfb, 0xd7, 0xe8, 0xdd, 0x9c, 0x65, 0xd6, 0x0d, 0x11, 0x0f,
	0x02, 0x32, 0x56, 0x3a, 0x14, 0x8e, 0xe6, 0x43, 0x30, 0xfa, 0xf1, 0x73, 0x9e, 0xa8, 0x5b, 0xf8,
	0x83, 0x59, 0x66, 0xad, 0x8b, 0x78, 0xe0, 0xf2, 0xea, 0xf8, 0xd2, 0xc5, 0xdc, 0x03, 0x63, 0xa7,
	0x72, 0xfb, 0x6e, 0x21, 0x46, 0x23, 0x34, 0x94, 0xae, 0xff, 0xc9, 0xac, 0x8f, 0xdd, 0xe0, 0xc9,
	0x28, 0xf0, 0xbc, 0xc0, 0xdf, 0x9c, 0x88, 0x61, 0xe4, 0x44, 0xd3, 0x4d, 0xf4, 0xd9, 0xa0, 0x0f,
	0x3d, 0x39, 0x00, 0x8e, 0xf4, 0x82, 0x46, 0x5a, 0x2b, 0x47, 0xf2, 0xde, 0x73, 0x24, 0x1a, 0xc0,
	0xfe, 0x7d, 0x0d, 0xae, 0x11, 0x93, 0xf7, 0x02, 0x8f, 0x13, 0x9b, 0xe7, 0x68, 0xa9, 0xbd, 0x0f,
	0x2d, 0x6b, 0x57, 0xa2, 0xa5, 0xbe, 0x9c, 0x96, 0x5b, 0xd0, 0xe9, 0xc7, 0x98, 0xd4, 0x9e, 0x3a,
	0x09, 0x1f, 0xab, 0xa4, 0x9c, 0xbe, 0x8d, 0x44, 0x4c, 0xc9, 0x2f, 0xd9, 0x59, 0xd5, 0x09, 0x57,
	0x21, 0x29, 0x58, 0xf9, 0x88, 0x24, 0x6e, 0xe4, 0xc4, 0xcb, 0xc3, 0xb1, 0xb1, 0x30, 0x1c, 0x6f,
	0x81, 0x7e, 0x70, 0x9e, 0xdc, 0x18, 0xc6, 0x68, 0xb3, 0xcf, 0x34, 0x05, 0xd2, 0x9b, 0x58, 0xe5,
	0xd4, 0xf9, 0x50, 0xda, 0xc2, 0xa1, 0x6e, 0x43, 0xfd, 0x1b, 0x67, 0x74, 0x2e, 0xee, 0x8f, 0x9c,
	0x11, 0x67, 0x64, 0x2d, 0xd7, 0x29, 0xbf, 0x97, 0x2f, 0xae, 0xf3, 0x3e, 0xb4, 0x5e, 0x47, 0x29,
	0xdf, 0x0f, 0x4e, 0x65, 0xa0, 0xb7, 0x64, 0xd6, 0x93, 0x44, 0x29, 0x9f, 0x04, 0xa7, 0x9c, 0x15,
	0xad, 0xf9, 0x9a, 0x8d, 0x8b, 0x6b, 0x9e, 0x83, 0xbc, 0xb1, 0x14, 0x72, 0xfb, 0x08, 0x80, 0xf6,
	0x78, 0x18, 0x84, 0x69, 0x98, 0x8f, 0xac, 0x2d, 0x18, 0xf9, 0xdd, 0xaa, 0x56, 0x70, 0x41, 0x5f,
	0xcc, 0x05, 0xfb, 0x57, 0x35, 0xe8, 0xd0, 0x44, 0x2f, 0x64, 0x62, 0xf8, 0x93, 0x8a, 0x94, 0xd2,
	0x7c, 0x9d, 0xad, 0x4f, 0x2e, 0x17, 0xe5, 0xc2, 0xb5, 0x22, 0xcb, 0x15, 0x29, 0x9e, 0xe3, 0x4d,
	0xed, 0x2a, 0xbc, 0x79, 0x88, 0x71, 0x7f, 0xc0, 0xdf, 0x62, 0x14, 0xeb, 0xe5, 0x05, 0x22, 0xe2,
	0x81, 0xcf, 0xdf, 0x62, 0x24, 0xb3, 0xa2, 0xdd, 0x7c, 0x09, 0xcd, 0xe7, 0x9c, 0x7e, 0xc9, 0xa8,
	0x3c, 0xe2, 0xab, 0x59, 0x66, 0x99, 0x2e, 0x97, 0xbf, 0x71, 0xae, 0x1e, 0x7d, 0xf9, 0x28, 0xf6,
	0x6f, 0x34, 0x58, 0xa9, 0xa0, 0x41, 0xbf, 0x42, 0x76, 0x70, 0xeb, 0x04, 0x85, 0x62, 0x87, 0xfc,
	0xb5, 0x20, 0xed, 0x4b, 0xe0, 0xdf, 0x81, 0x3a, 0xde, 0xa3, 0x5d, 0x9d, 0x7e, 0x38, 0x7c, 0xb6,
	0x04, 0x48, 0x39, 0xa9, 0x1c, 0x64, 0x22, 0xf0, 0x4b, 0x04, 0x3b, 0xdb, 0xff, 0xcc, 0x45, 0x61,
	0x7b, 0x32, 0x91, 0xab, 0xfa, 0x0a, 0x56, 0xf6, 0x9c, 0x0a, 0xb0, 0x5a, 0xf9, 0xfd, 0x70, 0xec,
	0x54, 0x91, 0x3d, 0xe7, 0x66, 0x3e, 0x85, 0x16, 0xe3, 0xe3, 0x43, 0x4a, 0x45, 0x6b, 0xc4, 0xe4,
	0x0f, 0x67, 0x99, 0x75, 0x5d, 0xc4, 0x83, 0xf8, 0x38, 0x78, 0x3b, 0x88, 0xf8, 0x78, 0x20, 0xd3,
	0xd2, 0xc2, 0xcd, 0xfc, 0x04, 0x1a, 0x7b, 0x4e, 0x2c, 0xcf, 0x42, 0xcf, 0xff, 0x73, 0xe1, 0x1c,
	0x78, 0x10, 0xaa, 0xc9, 0x7c, 0xa9, 0x76, 0x59, 0xa7, 0x5d, 0x3e, 0x5d, 0xb2, 0xcb, 0x7c, 0x17,
	0x1b, 0xd8, 0xe7, 0x99, 0x9f, 0x44, 0xd3, 0xf9, 0x1d, 0x7f, 0x34, 0x86, 0x76, 0xd1, 0x68, 0xae,
	0x83, 0x7e, 0xc2, 0xa7, 0x72, 0x8f, 0x0c, 0x8b, 0xe6, 0x36, 0x18, 0xa7, 0xce, 0x24, 0x95, 0xa0,
	0x77, 0xb6, 0x1e, 0x2d, 0x99, 0x70, 0xc7, 0x49, 0xb8, 0x1b, 0x44, 0x04, 0x2e, 0x93, 0x3d, 0x7f,
	0x54, 0xfb, 0xa1, 0x66, 0xff, 0x4e, 0x83, 0xeb, 0x17, 0x1c, 0xbe, 0xef, 0x89, 0x3f, 0x83, 0xfa,
	0xae, 0x93, 0x38, 0xea, 0xc4, 0xef, 0x2d, 0x0b, 0x9d, 0x84, 0x7b, 0xe5, 0x99, 0x8f, 0x9d, 0xc4,
	0x61, 0xd4, 0xdd, 0xfe, 0x6b, 0xae, 0x71, 0xb9, 0x87, 0xb9, 0x0d, 0xf5, 0x7d, 0x7e, 0x94, 0xbc,
	0x57, 0x4c, 0x12, 0xac, 0xfc, 0x08, 0x61, 0xe5, 0x47, 0x49, 0xb9, 0xb5, 0xda, 0x25, 0x5b, 0x3b,
	0x00, 0x83, 0x09, 0xf7, 0x38, 0xe7, 0xeb, 0x95, 0x26, 0xa1, 0xdc, 0x22, 0xc2, 0x5e, 0xd5, 0x2b,
	0x96, 0x86, 0xb1, 0x5f, 0x41, 0x9b, 0x68, 0xf4, 0xcd, 0xc4, 0x71, 0xcd, 0xcf, 0x8a, 0x4f, 0x3c,
	0xda, 0x43, 0x6b, 0x2e, 0x0f, 0xcd, 0x3f, 0xff, 0x2c, 0x30, 0x68, 0x70, 0xc5, 0x50, 0x5a, 0xa4,
	0x87, 0x06, 0x26, 0xed, 0xbd, 0x1b, 0x7f, 0x3f, 0xbb, 0xa3, 0x7d, 0x77, 0x76, 0x47, 0xfb, 0xd7,
	0xd9, 0x1d, 0xed, 0x67, 0x06, 0x7d, 0xb0, 0x0d, 0x1b, 0xf4, 0x3f, 0xfe, 0xcb, 0xff, 0x06, 0x00,
	0x00, 0xff, 0xff, 0xd1, 0x33, 0x4c, 0x86, 0x07, 0x18, 0x00, 0x00,
}
