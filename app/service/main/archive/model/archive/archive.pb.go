// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: archive.proto

/*
	Package archive is a generated protocol buffer package.

	It is generated from these files:
		archive.proto
		bvc.proto

	It has these top-level messages:
		Archive3
		StaffInfo
		Dimension
		Rights3
		Author3
		Stat3
		Click3
		AidVideos3
		View3
		Page3
		VideoFileInfo
		VideoFormatFileInfo
		DashItem
		ResponseDash
		BvcVideoItem
		BvcResponseMsg
*/
package archive

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import go_common_library_time "go-common/library/time"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Archive3 struct {
	Aid          int64                       `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	Videos       int64                       `protobuf:"varint,2,opt,name=Videos,proto3" json:"videos"`
	TypeID       int32                       `protobuf:"varint,3,opt,name=TypeID,proto3" json:"tid"`
	TypeName     string                      `protobuf:"bytes,4,opt,name=TypeName,proto3" json:"tname"`
	Copyright    int32                       `protobuf:"varint,5,opt,name=Copyright,proto3" json:"copyright"`
	Pic          string                      `protobuf:"bytes,6,opt,name=Pic,proto3" json:"pic"`
	Title        string                      `protobuf:"bytes,7,opt,name=Title,proto3" json:"title"`
	PubDate      go_common_library_time.Time `protobuf:"varint,8,opt,name=PubDate,proto3,casttype=go-common/library/time.Time" json:"pubdate"`
	Ctime        go_common_library_time.Time `protobuf:"varint,9,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Desc         string                      `protobuf:"bytes,10,opt,name=Desc,proto3" json:"desc"`
	State        int32                       `protobuf:"varint,11,opt,name=State,proto3" json:"state"`
	Access       int32                       `protobuf:"varint,12,opt,name=Access,proto3" json:"access,omitempty"`
	Attribute    int32                       `protobuf:"varint,13,opt,name=Attribute,proto3" json:"attribute,omitempty"`
	Tag          string                      `protobuf:"bytes,14,opt,name=Tag,proto3" json:"-"`
	Tags         []string                    `protobuf:"bytes,15,rep,name=Tags" json:"tags,omitempty"`
	Duration     int64                       `protobuf:"varint,16,opt,name=Duration,proto3" json:"duration"`
	MissionID    int64                       `protobuf:"varint,17,opt,name=MissionID,proto3" json:"mission_id,omitempty"`
	OrderID      int64                       `protobuf:"varint,18,opt,name=OrderID,proto3" json:"order_id,omitempty"`
	RedirectURL  string                      `protobuf:"bytes,19,opt,name=RedirectURL,proto3" json:"redirect_url,omitempty"`
	Forward      int64                       `protobuf:"varint,20,opt,name=Forward,proto3" json:"forward,omitempty"`
	Rights       Rights3                     `protobuf:"bytes,21,opt,name=Rights" json:"rights"`
	Author       Author3                     `protobuf:"bytes,22,opt,name=Author" json:"owner"`
	Stat         Stat3                       `protobuf:"bytes,23,opt,name=Stat" json:"stat"`
	ReportResult string                      `protobuf:"bytes,24,opt,name=ReportResult,proto3" json:"report_result,omitempty"`
	Dynamic      string                      `protobuf:"bytes,25,opt,name=Dynamic,proto3" json:"dynamic"`
	FirstCid     int64                       `protobuf:"varint,26,opt,name=FirstCid,proto3" json:"cid,omitempty"`
	Dimension    Dimension                   `protobuf:"bytes,27,opt,name=Dimension" json:"dimension,omitempty"`
	StaffInfo    []*StaffInfo                `protobuf:"bytes,28,rep,name=StaffInfo" json:"-"`
}

func (m *Archive3) Reset()                    { *m = Archive3{} }
func (m *Archive3) String() string            { return proto.CompactTextString(m) }
func (*Archive3) ProtoMessage()               {}
func (*Archive3) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{0} }

type StaffInfo struct {
	Mid   int64  `protobuf:"varint,1,opt,name=Mid,proto3" json:"mid"`
	Title string `protobuf:"bytes,2,opt,name=Title,proto3" json:"title"`
}

func (m *StaffInfo) Reset()                    { *m = StaffInfo{} }
func (m *StaffInfo) String() string            { return proto.CompactTextString(m) }
func (*StaffInfo) ProtoMessage()               {}
func (*StaffInfo) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{1} }

type Dimension struct {
	Width  int64 `protobuf:"varint,1,opt,name=Width,proto3" json:"width"`
	Height int64 `protobuf:"varint,2,opt,name=Height,proto3" json:"height"`
	Rotate int64 `protobuf:"varint,3,opt,name=Rotate,proto3" json:"rotate"`
}

func (m *Dimension) Reset()                    { *m = Dimension{} }
func (m *Dimension) String() string            { return proto.CompactTextString(m) }
func (*Dimension) ProtoMessage()               {}
func (*Dimension) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{2} }

type Rights3 struct {
	Bp            int32 `protobuf:"varint,1,opt,name=Bp,proto3" json:"bp"`
	Elec          int32 `protobuf:"varint,2,opt,name=Elec,proto3" json:"elec"`
	Download      int32 `protobuf:"varint,3,opt,name=Download,proto3" json:"download"`
	Movie         int32 `protobuf:"varint,4,opt,name=Movie,proto3" json:"movie"`
	Pay           int32 `protobuf:"varint,5,opt,name=Pay,proto3" json:"pay"`
	HD5           int32 `protobuf:"varint,6,opt,name=HD5,proto3" json:"hd5"`
	NoReprint     int32 `protobuf:"varint,7,opt,name=NoReprint,proto3" json:"no_reprint"`
	Autoplay      int32 `protobuf:"varint,8,opt,name=Autoplay,proto3" json:"autoplay"`
	UGCPay        int32 `protobuf:"varint,9,opt,name=UGCPay,proto3" json:"ugc_pay"`
	IsCooperation int32 `protobuf:"varint,10,opt,name=IsCooperation,proto3" json:"is_cooperation"`
}

func (m *Rights3) Reset()                    { *m = Rights3{} }
func (m *Rights3) String() string            { return proto.CompactTextString(m) }
func (*Rights3) ProtoMessage()               {}
func (*Rights3) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{3} }

type Author3 struct {
	Mid  int64  `protobuf:"varint,1,opt,name=Mid,proto3" json:"mid"`
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	Face string `protobuf:"bytes,3,opt,name=Face,proto3" json:"face"`
}

func (m *Author3) Reset()                    { *m = Author3{} }
func (m *Author3) String() string            { return proto.CompactTextString(m) }
func (*Author3) ProtoMessage()               {}
func (*Author3) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{4} }

type Stat3 struct {
	Aid     int64 `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	View    int32 `protobuf:"varint,2,opt,name=View,proto3" json:"view"`
	Danmaku int32 `protobuf:"varint,3,opt,name=Danmaku,proto3" json:"danmaku"`
	Reply   int32 `protobuf:"varint,4,opt,name=Reply,proto3" json:"reply"`
	Fav     int32 `protobuf:"varint,5,opt,name=Fav,proto3" json:"favorite"`
	Coin    int32 `protobuf:"varint,6,opt,name=Coin,proto3" json:"coin"`
	Share   int32 `protobuf:"varint,7,opt,name=Share,proto3" json:"share"`
	NowRank int32 `protobuf:"varint,8,opt,name=NowRank,proto3" json:"now_rank"`
	HisRank int32 `protobuf:"varint,9,opt,name=HisRank,proto3" json:"his_rank"`
	Like    int32 `protobuf:"varint,10,opt,name=Like,proto3" json:"like"`
	DisLike int32 `protobuf:"varint,11,opt,name=DisLike,proto3" json:"dislike"`
}

func (m *Stat3) Reset()                    { *m = Stat3{} }
func (m *Stat3) String() string            { return proto.CompactTextString(m) }
func (*Stat3) ProtoMessage()               {}
func (*Stat3) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{5} }

type Click3 struct {
	Aid     int64 `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	Web     int32 `protobuf:"varint,2,opt,name=Web,proto3" json:"web"`
	Ios     int32 `protobuf:"varint,3,opt,name=Ios,proto3" json:"ios"`
	Android int32 `protobuf:"varint,4,opt,name=Android,proto3" json:"android"`
	H5      int32 `protobuf:"varint,5,opt,name=H5,proto3" json:"h5"`
	Outter  int32 `protobuf:"varint,6,opt,name=Outter,proto3" json:"outter"`
}

func (m *Click3) Reset()                    { *m = Click3{} }
func (m *Click3) String() string            { return proto.CompactTextString(m) }
func (*Click3) ProtoMessage()               {}
func (*Click3) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{6} }

type AidVideos3 struct {
	Aid   int64    `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	Pages []*Page3 `protobuf:"bytes,2,rep,name=Pages" json:"pages"`
}

func (m *AidVideos3) Reset()                    { *m = AidVideos3{} }
func (m *AidVideos3) String() string            { return proto.CompactTextString(m) }
func (*AidVideos3) ProtoMessage()               {}
func (*AidVideos3) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{7} }

type View3 struct {
	*Archive3 `protobuf:"bytes,1,opt,name=Archive,embedded=Archive" json:""`
	Pages     []*Page3 `protobuf:"bytes,2,rep,name=Pages" json:"pages,omitempty"`
}

func (m *View3) Reset()                    { *m = View3{} }
func (m *View3) String() string            { return proto.CompactTextString(m) }
func (*View3) ProtoMessage()               {}
func (*View3) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{8} }

type Page3 struct {
	Cid       int64     `protobuf:"varint,1,opt,name=Cid,proto3" json:"cid"`
	Page      int32     `protobuf:"varint,2,opt,name=Page,proto3" json:"page"`
	From      string    `protobuf:"bytes,3,opt,name=From,proto3" json:"from"`
	Part      string    `protobuf:"bytes,4,opt,name=Part,proto3" json:"part"`
	Duration  int64     `protobuf:"varint,5,opt,name=Duration,proto3" json:"duration"`
	Vid       string    `protobuf:"bytes,6,opt,name=Vid,proto3" json:"vid"`
	Desc      string    `protobuf:"bytes,7,opt,name=Desc,proto3" json:"description,omitempty"`
	WebLink   string    `protobuf:"bytes,8,opt,name=WebLink,proto3" json:"weblink"`
	Dimension Dimension `protobuf:"bytes,9,opt,name=Dimension" json:"dimension"`
}

func (m *Page3) Reset()                    { *m = Page3{} }
func (m *Page3) String() string            { return proto.CompactTextString(m) }
func (*Page3) ProtoMessage()               {}
func (*Page3) Descriptor() ([]byte, []int) { return fileDescriptorArchive, []int{9} }

func init() {
	proto.RegisterType((*Archive3)(nil), "archive.Archive3")
	proto.RegisterType((*StaffInfo)(nil), "archive.StaffInfo")
	proto.RegisterType((*Dimension)(nil), "archive.Dimension")
	proto.RegisterType((*Rights3)(nil), "archive.Rights3")
	proto.RegisterType((*Author3)(nil), "archive.Author3")
	proto.RegisterType((*Stat3)(nil), "api.Stat")
	proto.RegisterType((*Click3)(nil), "archive.Click3")
	proto.RegisterType((*AidVideos3)(nil), "archive.AidVideos3")
	proto.RegisterType((*View3)(nil), "archive.View3")
	proto.RegisterType((*Page3)(nil), "api.Page")
}
func (m *Archive3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Archive3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Aid))
	}
	if m.Videos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Videos))
	}
	if m.TypeID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.TypeID))
	}
	if len(m.TypeName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.TypeName)))
		i += copy(dAtA[i:], m.TypeName)
	}
	if m.Copyright != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Copyright))
	}
	if len(m.Pic) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Pic)))
		i += copy(dAtA[i:], m.Pic)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.PubDate != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.PubDate))
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Ctime))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.State != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.State))
	}
	if m.Access != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Access))
	}
	if m.Attribute != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Attribute))
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Duration != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Duration))
	}
	if m.MissionID != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.MissionID))
	}
	if m.OrderID != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.OrderID))
	}
	if len(m.RedirectURL) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.RedirectURL)))
		i += copy(dAtA[i:], m.RedirectURL)
	}
	if m.Forward != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Forward))
	}
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintArchive(dAtA, i, uint64(m.Rights.Size()))
	n1, err := m.Rights.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintArchive(dAtA, i, uint64(m.Author.Size()))
	n2, err := m.Author.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0xba
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintArchive(dAtA, i, uint64(m.Stat.Size()))
	n3, err := m.Stat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.ReportResult) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.ReportResult)))
		i += copy(dAtA[i:], m.ReportResult)
	}
	if len(m.Dynamic) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Dynamic)))
		i += copy(dAtA[i:], m.Dynamic)
	}
	if m.FirstCid != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.FirstCid))
	}
	dAtA[i] = 0xda
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintArchive(dAtA, i, uint64(m.Dimension.Size()))
	n4, err := m.Dimension.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.StaffInfo) > 0 {
		for _, msg := range m.StaffInfo {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintArchive(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StaffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaffInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Mid))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	return i, nil
}

func (m *Dimension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dimension) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Height))
	}
	if m.Rotate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Rotate))
	}
	return i, nil
}

func (m *Rights3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rights3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Bp))
	}
	if m.Elec != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Elec))
	}
	if m.Download != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Download))
	}
	if m.Movie != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Movie))
	}
	if m.Pay != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Pay))
	}
	if m.HD5 != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.HD5))
	}
	if m.NoReprint != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.NoReprint))
	}
	if m.Autoplay != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Autoplay))
	}
	if m.UGCPay != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.UGCPay))
	}
	if m.IsCooperation != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.IsCooperation))
	}
	return i, nil
}

func (m *Author3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Author3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Mid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Face) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Face)))
		i += copy(dAtA[i:], m.Face)
	}
	return i, nil
}

func (m *Stat3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stat3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Aid))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.View))
	}
	if m.Danmaku != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Danmaku))
	}
	if m.Reply != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Reply))
	}
	if m.Fav != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Fav))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Coin))
	}
	if m.Share != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Share))
	}
	if m.NowRank != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.NowRank))
	}
	if m.HisRank != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.HisRank))
	}
	if m.Like != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Like))
	}
	if m.DisLike != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.DisLike))
	}
	return i, nil
}

func (m *Click3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Click3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Aid))
	}
	if m.Web != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Web))
	}
	if m.Ios != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Ios))
	}
	if m.Android != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Android))
	}
	if m.H5 != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.H5))
	}
	if m.Outter != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Outter))
	}
	return i, nil
}

func (m *AidVideos3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AidVideos3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Aid))
	}
	if len(m.Pages) > 0 {
		for _, msg := range m.Pages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintArchive(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *View3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Archive3 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Archive3.Size()))
		n5, err := m.Archive3.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Pages) > 0 {
		for _, msg := range m.Pages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintArchive(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Page3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Cid))
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Page))
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.Part) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Part)))
		i += copy(dAtA[i:], m.Part)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintArchive(dAtA, i, uint64(m.Duration))
	}
	if len(m.Vid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Vid)))
		i += copy(dAtA[i:], m.Vid)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.WebLink) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintArchive(dAtA, i, uint64(len(m.WebLink)))
		i += copy(dAtA[i:], m.WebLink)
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintArchive(dAtA, i, uint64(m.Dimension.Size()))
	n6, err := m.Dimension.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func encodeFixed64Archive(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Archive(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintArchive(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Archive3) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovArchive(uint64(m.Aid))
	}
	if m.Videos != 0 {
		n += 1 + sovArchive(uint64(m.Videos))
	}
	if m.TypeID != 0 {
		n += 1 + sovArchive(uint64(m.TypeID))
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.Copyright != 0 {
		n += 1 + sovArchive(uint64(m.Copyright))
	}
	l = len(m.Pic)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.PubDate != 0 {
		n += 1 + sovArchive(uint64(m.PubDate))
	}
	if m.Ctime != 0 {
		n += 1 + sovArchive(uint64(m.Ctime))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovArchive(uint64(m.State))
	}
	if m.Access != 0 {
		n += 1 + sovArchive(uint64(m.Access))
	}
	if m.Attribute != 0 {
		n += 1 + sovArchive(uint64(m.Attribute))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovArchive(uint64(l))
		}
	}
	if m.Duration != 0 {
		n += 2 + sovArchive(uint64(m.Duration))
	}
	if m.MissionID != 0 {
		n += 2 + sovArchive(uint64(m.MissionID))
	}
	if m.OrderID != 0 {
		n += 2 + sovArchive(uint64(m.OrderID))
	}
	l = len(m.RedirectURL)
	if l > 0 {
		n += 2 + l + sovArchive(uint64(l))
	}
	if m.Forward != 0 {
		n += 2 + sovArchive(uint64(m.Forward))
	}
	l = m.Rights.Size()
	n += 2 + l + sovArchive(uint64(l))
	l = m.Author.Size()
	n += 2 + l + sovArchive(uint64(l))
	l = m.Stat.Size()
	n += 2 + l + sovArchive(uint64(l))
	l = len(m.ReportResult)
	if l > 0 {
		n += 2 + l + sovArchive(uint64(l))
	}
	l = len(m.Dynamic)
	if l > 0 {
		n += 2 + l + sovArchive(uint64(l))
	}
	if m.FirstCid != 0 {
		n += 2 + sovArchive(uint64(m.FirstCid))
	}
	l = m.Dimension.Size()
	n += 2 + l + sovArchive(uint64(l))
	if len(m.StaffInfo) > 0 {
		for _, e := range m.StaffInfo {
			l = e.Size()
			n += 2 + l + sovArchive(uint64(l))
		}
	}
	return n
}

func (m *StaffInfo) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovArchive(uint64(m.Mid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	return n
}

func (m *Dimension) Size() (n int) {
	var l int
	_ = l
	if m.Width != 0 {
		n += 1 + sovArchive(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovArchive(uint64(m.Height))
	}
	if m.Rotate != 0 {
		n += 1 + sovArchive(uint64(m.Rotate))
	}
	return n
}

func (m *Rights3) Size() (n int) {
	var l int
	_ = l
	if m.Bp != 0 {
		n += 1 + sovArchive(uint64(m.Bp))
	}
	if m.Elec != 0 {
		n += 1 + sovArchive(uint64(m.Elec))
	}
	if m.Download != 0 {
		n += 1 + sovArchive(uint64(m.Download))
	}
	if m.Movie != 0 {
		n += 1 + sovArchive(uint64(m.Movie))
	}
	if m.Pay != 0 {
		n += 1 + sovArchive(uint64(m.Pay))
	}
	if m.HD5 != 0 {
		n += 1 + sovArchive(uint64(m.HD5))
	}
	if m.NoReprint != 0 {
		n += 1 + sovArchive(uint64(m.NoReprint))
	}
	if m.Autoplay != 0 {
		n += 1 + sovArchive(uint64(m.Autoplay))
	}
	if m.UGCPay != 0 {
		n += 1 + sovArchive(uint64(m.UGCPay))
	}
	if m.IsCooperation != 0 {
		n += 1 + sovArchive(uint64(m.IsCooperation))
	}
	return n
}

func (m *Author3) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovArchive(uint64(m.Mid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	return n
}

func (m *Stat3) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovArchive(uint64(m.Aid))
	}
	if m.View != 0 {
		n += 1 + sovArchive(uint64(m.View))
	}
	if m.Danmaku != 0 {
		n += 1 + sovArchive(uint64(m.Danmaku))
	}
	if m.Reply != 0 {
		n += 1 + sovArchive(uint64(m.Reply))
	}
	if m.Fav != 0 {
		n += 1 + sovArchive(uint64(m.Fav))
	}
	if m.Coin != 0 {
		n += 1 + sovArchive(uint64(m.Coin))
	}
	if m.Share != 0 {
		n += 1 + sovArchive(uint64(m.Share))
	}
	if m.NowRank != 0 {
		n += 1 + sovArchive(uint64(m.NowRank))
	}
	if m.HisRank != 0 {
		n += 1 + sovArchive(uint64(m.HisRank))
	}
	if m.Like != 0 {
		n += 1 + sovArchive(uint64(m.Like))
	}
	if m.DisLike != 0 {
		n += 1 + sovArchive(uint64(m.DisLike))
	}
	return n
}

func (m *Click3) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovArchive(uint64(m.Aid))
	}
	if m.Web != 0 {
		n += 1 + sovArchive(uint64(m.Web))
	}
	if m.Ios != 0 {
		n += 1 + sovArchive(uint64(m.Ios))
	}
	if m.Android != 0 {
		n += 1 + sovArchive(uint64(m.Android))
	}
	if m.H5 != 0 {
		n += 1 + sovArchive(uint64(m.H5))
	}
	if m.Outter != 0 {
		n += 1 + sovArchive(uint64(m.Outter))
	}
	return n
}

func (m *AidVideos3) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovArchive(uint64(m.Aid))
	}
	if len(m.Pages) > 0 {
		for _, e := range m.Pages {
			l = e.Size()
			n += 1 + l + sovArchive(uint64(l))
		}
	}
	return n
}

func (m *View3) Size() (n int) {
	var l int
	_ = l
	if m.Archive3 != nil {
		l = m.Archive3.Size()
		n += 1 + l + sovArchive(uint64(l))
	}
	if len(m.Pages) > 0 {
		for _, e := range m.Pages {
			l = e.Size()
			n += 1 + l + sovArchive(uint64(l))
		}
	}
	return n
}

func (m *Page3) Size() (n int) {
	var l int
	_ = l
	if m.Cid != 0 {
		n += 1 + sovArchive(uint64(m.Cid))
	}
	if m.Page != 0 {
		n += 1 + sovArchive(uint64(m.Page))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.Part)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovArchive(uint64(m.Duration))
	}
	l = len(m.Vid)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.WebLink)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = m.Dimension.Size()
	n += 1 + l + sovArchive(uint64(l))
	return n
}

func sovArchive(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozArchive(x uint64) (n int) {
	return sovArchive(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Archive3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Archive3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Archive3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Videos", wireType)
			}
			m.Videos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Videos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Copyright", wireType)
			}
			m.Copyright = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Copyright |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubDate", wireType)
			}
			m.PubDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubDate |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			m.Access = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Access |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			m.Attribute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attribute |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissionID", wireType)
			}
			m.MissionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissionID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forward", wireType)
			}
			m.Forward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Forward |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Author.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportResult", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportResult = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dynamic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dynamic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstCid", wireType)
			}
			m.FirstCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstCid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dimension.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaffInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaffInfo = append(m.StaffInfo, &StaffInfo{})
			if err := m.StaffInfo[len(m.StaffInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dimension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dimension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dimension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate", wireType)
			}
			m.Rotate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rotate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rights3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rights3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rights3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bp", wireType)
			}
			m.Bp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elec", wireType)
			}
			m.Elec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Elec |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Download", wireType)
			}
			m.Download = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Download |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Movie", wireType)
			}
			m.Movie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Movie |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			m.Pay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HD5", wireType)
			}
			m.HD5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HD5 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoReprint", wireType)
			}
			m.NoReprint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoReprint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autoplay", wireType)
			}
			m.Autoplay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Autoplay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UGCPay", wireType)
			}
			m.UGCPay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UGCPay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCooperation", wireType)
			}
			m.IsCooperation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCooperation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Author3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Author3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Author3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stat3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stat3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stat3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Danmaku", wireType)
			}
			m.Danmaku = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Danmaku |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			m.Reply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reply |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fav", wireType)
			}
			m.Fav = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fav |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			m.Share = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Share |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowRank", wireType)
			}
			m.NowRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowRank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HisRank", wireType)
			}
			m.HisRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HisRank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Like", wireType)
			}
			m.Like = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Like |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisLike", wireType)
			}
			m.DisLike = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisLike |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Click3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Click3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Click3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Web", wireType)
			}
			m.Web = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Web |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ios", wireType)
			}
			m.Ios = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ios |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Android", wireType)
			}
			m.Android = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Android |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H5", wireType)
			}
			m.H5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H5 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outter", wireType)
			}
			m.Outter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Outter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AidVideos3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AidVideos3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AidVideos3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pages = append(m.Pages, &Page3{})
			if err := m.Pages[len(m.Pages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archive3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Archive3 == nil {
				m.Archive3 = &Archive3{}
			}
			if err := m.Archive3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pages = append(m.Pages, &Page3{})
			if err := m.Pages[len(m.Pages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Part = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dimension.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipArchive(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthArchive
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowArchive
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipArchive(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthArchive = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowArchive   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("archive.proto", fileDescriptorArchive) }

var fileDescriptorArchive = []byte{
	// 1524 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x57, 0xdd, 0x6e, 0x1b, 0x37,
	0x16, 0xb6, 0xfe, 0x35, 0xf4, 0x4f, 0x62, 0x3a, 0xb1, 0xc7, 0xb1, 0xe1, 0x31, 0xb4, 0x48, 0x60,
	0xec, 0xc6, 0x76, 0x10, 0xc3, 0x9b, 0x2c, 0xb0, 0xd8, 0x85, 0x7e, 0xd6, 0xb1, 0x81, 0x38, 0x09,
	0x18, 0xc7, 0xd9, 0x3b, 0x97, 0x9a, 0xa1, 0x25, 0xc2, 0x9a, 0xe1, 0x80, 0x43, 0x59, 0xd0, 0x9b,
	0xf4, 0x21, 0xfa, 0x08, 0x7d, 0x80, 0x5c, 0xe6, 0x01, 0x8a, 0x41, 0x93, 0xde, 0xcd, 0x0b, 0x14,
	0x28, 0x7a, 0x51, 0xf0, 0x90, 0x92, 0x46, 0x45, 0xeb, 0xde, 0x69, 0xbe, 0xef, 0x3b, 0xe4, 0x39,
	0x24, 0xcf, 0x8f, 0xd0, 0x32, 0x95, 0x7e, 0x9f, 0xdf, 0xb2, 0x83, 0x58, 0x0a, 0x25, 0x70, 0xcd,
	0x7e, 0x3e, 0xda, 0xef, 0x71, 0xd5, 0x1f, 0x76, 0x0f, 0x7c, 0x11, 0x1e, 0xf6, 0x44, 0x4f, 0x1c,
	0x02, 0xdf, 0x1d, 0x5e, 0xc3, 0x17, 0x7c, 0xc0, 0x2f, 0x63, 0xd7, 0xf8, 0x0e, 0xa1, 0x7a, 0xd3,
	0x98, 0x1e, 0xe1, 0x4d, 0x54, 0x6a, 0xf2, 0xc0, 0x2d, 0xec, 0x16, 0xf6, 0x4a, 0xad, 0x5a, 0x96,
	0x7a, 0x25, 0xca, 0x03, 0xa2, 0x31, 0xdc, 0x40, 0xd5, 0x4b, 0x1e, 0x30, 0x91, 0xb8, 0x45, 0x60,
	0x51, 0x96, 0x7a, 0xd5, 0x5b, 0x40, 0x88, 0x65, 0xb0, 0x87, 0xaa, 0x17, 0xe3, 0x98, 0x9d, 0x75,
	0xdc, 0xd2, 0x6e, 0x61, 0xaf, 0x62, 0x56, 0x50, 0x3c, 0x20, 0x16, 0xc6, 0x8f, 0x51, 0x5d, 0xff,
	0x7a, 0x43, 0x43, 0xe6, 0x96, 0x77, 0x0b, 0x7b, 0x4e, 0xcb, 0xc9, 0x52, 0xaf, 0xa2, 0x22, 0x1a,
	0x32, 0x32, 0xa5, 0xf0, 0x3f, 0x90, 0xd3, 0x16, 0xf1, 0x58, 0xf2, 0x5e, 0x5f, 0xb9, 0x15, 0x58,
	0x6a, 0x39, 0x4b, 0x3d, 0xc7, 0x9f, 0x80, 0x64, 0xc6, 0x6b, 0x9f, 0xdf, 0x71, 0xdf, 0xad, 0xc2,
	0x72, 0xb0, 0x63, 0xcc, 0x7d, 0xa2, 0x31, 0xec, 0xa1, 0xca, 0x05, 0x57, 0x03, 0xe6, 0xd6, 0x72,
	0x7b, 0x69, 0x80, 0x18, 0x1c, 0x77, 0x50, 0xed, 0xdd, 0xb0, 0xdb, 0xa1, 0x8a, 0xb9, 0x75, 0x88,
	0xea, 0xef, 0x59, 0xea, 0xd5, 0xe2, 0x61, 0x37, 0xa0, 0x8a, 0xfd, 0x92, 0x7a, 0x5b, 0x3d, 0xb1,
	0xef, 0x8b, 0x30, 0x14, 0xd1, 0xe1, 0x80, 0x77, 0x25, 0x95, 0xe3, 0x43, 0xc5, 0x43, 0x76, 0x70,
	0xc1, 0x43, 0x46, 0x26, 0xa6, 0xf8, 0x3f, 0xa8, 0xd2, 0xd6, 0xb0, 0xeb, 0xc0, 0x1a, 0x7b, 0x7a,
	0x1b, 0x5f, 0x03, 0x7f, 0xb5, 0x82, 0x31, 0xc3, 0xdb, 0xa8, 0xdc, 0x61, 0x89, 0xef, 0x22, 0xf0,
	0xb2, 0x9e, 0xa5, 0x5e, 0x39, 0x60, 0x89, 0x4f, 0x00, 0xd5, 0x41, 0xbc, 0x57, 0xda, 0xc3, 0x45,
	0x38, 0x08, 0x08, 0x22, 0xd1, 0x00, 0x31, 0x38, 0x7e, 0x8a, 0xaa, 0x4d, 0xdf, 0x67, 0x49, 0xe2,
	0x2e, 0x81, 0xe2, 0x41, 0x96, 0x7a, 0xf7, 0x29, 0x20, 0x4f, 0x45, 0xc8, 0x15, 0x0b, 0x63, 0x35,
	0x26, 0x56, 0x83, 0x8f, 0x91, 0xd3, 0x54, 0x4a, 0xf2, 0xee, 0x50, 0x31, 0x77, 0x19, 0x0c, 0x36,
	0xb2, 0xd4, 0x5b, 0xa3, 0x13, 0x30, 0x67, 0x33, 0x53, 0xe2, 0x0d, 0x54, 0xba, 0xa0, 0x3d, 0x77,
	0x05, 0x5c, 0xac, 0x64, 0xa9, 0x57, 0xd8, 0x27, 0x1a, 0xc1, 0x4f, 0x50, 0xf9, 0x82, 0xf6, 0x12,
	0xf7, 0xde, 0x6e, 0x69, 0xcf, 0x69, 0xe1, 0x2c, 0xf5, 0x56, 0x14, 0xed, 0xe5, 0x77, 0x06, 0x1e,
	0xef, 0xa1, 0x7a, 0x67, 0x28, 0xa9, 0xe2, 0x22, 0x72, 0xef, 0xc3, 0x39, 0x2d, 0x65, 0xa9, 0x57,
	0x0f, 0x2c, 0x46, 0xa6, 0x2c, 0xfe, 0x27, 0x72, 0xce, 0x79, 0x92, 0x70, 0x11, 0x9d, 0x75, 0xdc,
	0x55, 0x90, 0xba, 0x59, 0xea, 0x3d, 0x08, 0x0d, 0x78, 0xc5, 0x83, 0xbc, 0x8b, 0x53, 0x29, 0x7e,
	0x86, 0x6a, 0x6f, 0x65, 0xc0, 0xe4, 0x59, 0xc7, 0xc5, 0x60, 0xb5, 0x9e, 0xa5, 0x1e, 0x16, 0x1a,
	0x9a, 0xb7, 0x99, 0xc8, 0xf0, 0xbf, 0xd1, 0x22, 0x61, 0x01, 0x97, 0xcc, 0x57, 0x1f, 0xc8, 0x6b,
	0x77, 0x0d, 0x82, 0x7b, 0x94, 0xa5, 0xde, 0xba, 0xb4, 0xf0, 0xd5, 0x50, 0x0e, 0x72, 0x96, 0x79,
	0x39, 0x3e, 0x44, 0xb5, 0x13, 0x21, 0x47, 0x54, 0x06, 0xee, 0x03, 0xd8, 0xef, 0x61, 0x96, 0x7a,
	0xab, 0xd7, 0x06, 0xca, 0x6f, 0x67, 0x55, 0xf8, 0x25, 0xaa, 0x12, 0xfd, 0x64, 0x13, 0xf7, 0xe1,
	0x6e, 0x61, 0x6f, 0xf1, 0xf9, 0xfd, 0x83, 0x49, 0x0a, 0x1b, 0xf8, 0xa8, 0xb5, 0xf2, 0x29, 0xf5,
	0x16, 0x74, 0x62, 0xc1, 0xd3, 0x4e, 0x88, 0xd5, 0xe3, 0x17, 0xa8, 0xda, 0x1c, 0xaa, 0xbe, 0x90,
	0xee, 0xfa, 0xef, 0x2c, 0x0d, 0x7c, 0xd4, 0x5a, 0xb6, 0x96, 0x15, 0x31, 0x8a, 0x98, 0x24, 0x56,
	0x8e, 0x9f, 0xa1, 0xb2, 0x7e, 0x24, 0xee, 0x06, 0x98, 0xad, 0x4c, 0xcd, 0x34, 0x78, 0xd4, 0x5a,
	0xb2, 0x46, 0x65, 0xfd, 0x9e, 0x08, 0x28, 0xf1, 0x7f, 0xd1, 0x12, 0x61, 0xb1, 0x90, 0x8a, 0xb0,
	0x64, 0x38, 0x50, 0xae, 0x0b, 0x87, 0xb2, 0x95, 0xa5, 0xde, 0x86, 0x04, 0xfc, 0x4a, 0x02, 0x91,
	0x0b, 0x70, 0xce, 0x00, 0x3f, 0x46, 0xb5, 0xce, 0x38, 0xa2, 0x21, 0xf7, 0xdd, 0x4d, 0xb0, 0x5d,
	0xd4, 0x39, 0x15, 0x18, 0x88, 0x4c, 0x38, 0xbc, 0x8f, 0xea, 0x27, 0x5c, 0x26, 0xaa, 0xcd, 0x03,
	0xf7, 0x11, 0x1c, 0xdf, 0x6a, 0x96, 0x7a, 0xcb, 0xfe, 0xdc, 0x4d, 0x4d, 0x25, 0xf8, 0x1c, 0x39,
	0x1d, 0x1e, 0xb2, 0x48, 0xdf, 0xb5, 0xbb, 0x05, 0xd1, 0xe0, 0x69, 0x34, 0x53, 0xa6, 0xb5, 0x65,
	0x23, 0x5a, 0x0b, 0x26, 0x50, 0xfe, 0xad, 0x4c, 0x75, 0xf8, 0x05, 0x72, 0xde, 0x2b, 0x7a, 0x7d,
	0x7d, 0x16, 0x5d, 0x0b, 0x77, 0x7b, 0xb7, 0x34, 0xb7, 0xdc, 0x94, 0x99, 0x3c, 0xf4, 0x99, 0xb6,
	0xf1, 0x2a, 0x67, 0xa8, 0x4b, 0xcf, 0xf9, 0x7c, 0xb9, 0x0c, 0x75, 0xb9, 0x3c, 0xe7, 0xc1, 0xac,
	0xf4, 0x14, 0xff, 0xb8, 0xf4, 0x34, 0x54, 0x2e, 0x20, 0xad, 0xfe, 0xc8, 0x03, 0xd5, 0xb7, 0x4b,
	0x81, 0x7a, 0xa4, 0x01, 0x62, 0x70, 0x5d, 0x7d, 0x4f, 0x19, 0x94, 0xc3, 0x5c, 0xf5, 0xed, 0x03,
	0x42, 0x2c, 0xa3, 0x35, 0x44, 0x40, 0xa5, 0x28, 0xcd, 0x34, 0x12, 0x10, 0x62, 0x99, 0xc6, 0xcf,
	0x45, 0x54, 0xb3, 0x8f, 0x0d, 0xaf, 0xa3, 0x62, 0x2b, 0x86, 0x1d, 0x2b, 0xad, 0x6a, 0x96, 0x7a,
	0xc5, 0x6e, 0x4c, 0x8a, 0xad, 0x58, 0x97, 0xa3, 0xff, 0x0d, 0x98, 0x0f, 0x3b, 0x55, 0x4c, 0x39,
	0x62, 0x03, 0xe6, 0x13, 0x40, 0x21, 0x8f, 0xc5, 0x28, 0x1a, 0x08, 0x1a, 0xd8, 0x2a, 0x6f, 0xf2,
	0xd8, 0x62, 0x64, 0xca, 0xea, 0xa0, 0xce, 0xc5, 0x2d, 0x37, 0x95, 0xde, 0x16, 0xae, 0x50, 0x03,
	0xc4, 0xe0, 0x50, 0xb9, 0xe9, 0xd8, 0x16, 0x78, 0x53, 0xb9, 0xe9, 0x98, 0x68, 0x4c, 0x53, 0xa7,
	0x9d, 0x63, 0x28, 0xea, 0x96, 0xea, 0x07, 0xc7, 0x44, 0x63, 0xf8, 0x29, 0x72, 0xde, 0x08, 0xc2,
	0x62, 0xc9, 0x23, 0x05, 0x85, 0xbd, 0xd2, 0x5a, 0xc9, 0x52, 0x0f, 0x45, 0xe2, 0x4a, 0x1a, 0x94,
	0xcc, 0x04, 0xda, 0xdd, 0xe6, 0x50, 0x89, 0x78, 0x40, 0xc7, 0x50, 0xe2, 0xad, 0xbb, 0xd4, 0x62,
	0x64, 0xca, 0xe2, 0xbf, 0xa1, 0xea, 0x87, 0x57, 0x6d, 0xed, 0x90, 0x03, 0x3a, 0x78, 0xb6, 0xc3,
	0x9e, 0x7f, 0xa5, 0x9d, 0xb2, 0x14, 0x7e, 0x89, 0x96, 0xcf, 0x92, 0xb6, 0x10, 0x31, 0xb3, 0xa5,
	0x0c, 0x81, 0x16, 0xca, 0x1e, 0x4f, 0xae, 0xfc, 0x19, 0x43, 0xe6, 0x85, 0x8d, 0x6f, 0x50, 0xcd,
	0xe6, 0xea, 0x5d, 0xcf, 0x66, 0x1b, 0x95, 0xa1, 0x39, 0x16, 0x67, 0xad, 0x00, 0x7a, 0x23, 0xa0,
	0x9a, 0x3d, 0xa1, 0xbe, 0xb9, 0x5f, 0xcb, 0x5e, 0x53, 0x9f, 0x11, 0x40, 0x1b, 0xbf, 0x16, 0x4d,
	0xa7, 0xb8, 0xb3, 0x8d, 0x6f, 0xa3, 0xf2, 0x25, 0x67, 0xa3, 0xfc, 0xe5, 0xde, 0x72, 0x36, 0x22,
	0x80, 0x42, 0xee, 0xd2, 0x28, 0xa4, 0x37, 0x43, 0x7b, 0xb7, 0x26, 0x77, 0x0d, 0x44, 0x26, 0x9c,
	0xbe, 0x59, 0xc2, 0xe2, 0xc1, 0x38, 0x7f, 0xb3, 0x52, 0x03, 0xc4, 0xe0, 0x78, 0x07, 0x95, 0x4e,
	0xe8, 0xad, 0xbd, 0x59, 0x38, 0xf0, 0x6b, 0x7a, 0x2b, 0x24, 0x57, 0x8c, 0x68, 0x42, 0x7b, 0xd1,
	0x16, 0x3c, 0xb2, 0xf7, 0x0b, 0x5e, 0xf8, 0x82, 0x47, 0x04, 0x50, 0xe8, 0x78, 0x7d, 0x2a, 0x99,
	0xbd, 0x5d, 0xd3, 0xf1, 0x34, 0x40, 0x0c, 0x8e, 0x9f, 0xa0, 0xda, 0x1b, 0x31, 0x22, 0x34, 0xba,
	0xc9, 0xdf, 0x69, 0x24, 0x46, 0x57, 0x92, 0x46, 0x37, 0x64, 0x42, 0x6a, 0xdd, 0x29, 0x4f, 0x40,
	0xe7, 0xcc, 0x74, 0x7d, 0x9e, 0x58, 0x9d, 0x25, 0xb5, 0x3b, 0xaf, 0xf9, 0x0d, 0xb3, 0x97, 0x09,
	0xee, 0x0c, 0xf8, 0x0d, 0x23, 0x80, 0xc2, 0xa1, 0xf0, 0x04, 0x04, 0x8b, 0xb9, 0x43, 0xe1, 0x09,
	0x68, 0x26, 0x5c, 0xe3, 0xfb, 0x02, 0xaa, 0xb6, 0x07, 0xdc, 0xbf, 0xb9, 0xf3, 0xfc, 0x37, 0x51,
	0xe9, 0x23, 0xeb, 0xda, 0xe3, 0x07, 0x6a, 0xc4, 0xba, 0x44, 0x63, 0x9a, 0x3a, 0x13, 0x49, 0x7e,
	0x74, 0xe2, 0x22, 0x21, 0x1a, 0xd3, 0x2e, 0x34, 0xa3, 0x40, 0x0a, 0x1e, 0xd8, 0x23, 0x07, 0x17,
	0xa8, 0x81, 0xc8, 0x84, 0xd3, 0x19, 0x7d, 0x7a, 0x6c, 0x4f, 0x1d, 0x32, 0xba, 0x7f, 0x4c, 0x8a,
	0xa7, 0xc7, 0xba, 0x32, 0xbc, 0x1d, 0x2a, 0xc5, 0xa4, 0x3d, 0x70, 0xa8, 0x0c, 0x02, 0x10, 0x62,
	0x99, 0xc6, 0xff, 0x11, 0x6a, 0xf2, 0xc0, 0x0c, 0x72, 0x77, 0x46, 0x70, 0x88, 0x2a, 0xef, 0x68,
	0x8f, 0xe9, 0x39, 0xb0, 0x34, 0xd7, 0x53, 0x34, 0x7a, 0x64, 0x6e, 0x2b, 0xd6, 0x02, 0x62, 0x74,
	0x8d, 0x31, 0xaa, 0xe8, 0xc7, 0x75, 0x84, 0x8f, 0x51, 0xcd, 0x4e, 0x9a, 0xb0, 0xf0, 0xe2, 0xf3,
	0xd5, 0x59, 0x1b, 0xb3, 0x13, 0x68, 0xab, 0xfe, 0x39, 0xf5, 0x0a, 0x59, 0xea, 0x2d, 0x90, 0x89,
	0x16, 0xff, 0xeb, 0xee, 0x0d, 0xd7, 0xb2, 0xd4, 0xbb, 0x07, 0x1b, 0xe6, 0x4a, 0xbd, 0xdd, 0xfa,
	0x87, 0xa2, 0xb1, 0x85, 0x80, 0xda, 0xf3, 0x01, 0xf9, 0x3a, 0xa0, 0xb6, 0x49, 0x09, 0xad, 0xc9,
	0xa7, 0x84, 0x5e, 0x8e, 0x00, 0x0a, 0x39, 0x27, 0x45, 0x38, 0x97, 0x73, 0x52, 0x84, 0x04, 0x50,
	0x63, 0x2b, 0x95, 0x1d, 0x66, 0xad, 0xad, 0x54, 0x04, 0xd0, 0xb9, 0x99, 0xa7, 0x72, 0xe7, 0xcc,
	0xb3, 0x89, 0x4a, 0x97, 0x3c, 0xc8, 0x0f, 0xb1, 0xb7, 0xda, 0xbd, 0x4b, 0x1e, 0xe0, 0x7d, 0x3b,
	0x1d, 0x9a, 0x19, 0x76, 0x33, 0x4b, 0xbd, 0x87, 0x7a, 0x3a, 0x94, 0x3c, 0x56, 0xf3, 0xed, 0xcd,
	0x8c, 0x8b, 0x8f, 0x51, 0xed, 0x23, 0xeb, 0xbe, 0xe6, 0x36, 0x37, 0x6c, 0xfb, 0x1d, 0xb1, 0xee,
	0x80, 0xeb, 0x27, 0x6f, 0x39, 0xdc, 0xce, 0xf7, 0x53, 0xe7, 0x4f, 0xfb, 0xe9, 0xaa, 0xed, 0xa7,
	0xce, 0xb4, 0x9f, 0xe6, 0xba, 0x68, 0xcb, 0xfd, 0xf4, 0x65, 0x67, 0xe1, 0xf3, 0x97, 0x9d, 0x85,
	0x4f, 0x5f, 0x77, 0x0a, 0x9f, 0xbf, 0xee, 0x14, 0x7e, 0xfc, 0xba, 0x53, 0xf8, 0xf6, 0xa7, 0x9d,
	0x85, 0x6e, 0x15, 0xfe, 0x5c, 0x1c, 0xfd, 0x16, 0x00, 0x00, 0xff, 0xff, 0x14, 0x61, 0x4e, 0x1c,
	0xa5, 0x0c, 0x00, 0x00,
}
