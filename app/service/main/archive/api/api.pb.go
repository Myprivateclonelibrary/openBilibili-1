// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/main/archive/api/api.proto

/*
	Package api is a generated protocol buffer package.

	use {app_id}.{version} as package name

	It is generated from these files:
		app/service/main/archive/api/api.proto

	It has these top-level messages:
		NoArgRequest
		NoReply
		DescriptionRequest
		DescriptionReply
		MaxAidReply
		ArcRequest
		ArcReply
		ArcsRequest
		ArcsReply
		ViewRequest
		StatRequest
		StatReply
		StatsRequest
		StatsReply
		ViewReply
		ViewsRequest
		ViewsReply
		TypesReply
		ClickRequest
		ClickReply
		PageRequest
		PageReply
		RecommendRequest
		RecommendReply
		VideoRequest
		VideoReply
		Tp
		AidVideos
		Arc
		StaffInfo
		Dimension
		Rights
		Author
		Stat
		Click
		Page
		VideoFileInfo
		VideoFormatFileInfo
		DashItem
		ResponseDash
		BvcVideoItem
		BvcResponseMsg
		ArcCacheRequest
		ArcFieldCacheRequest
		UpVideoCacheRequest
		DelVideoCacheRequest
		SetStatRequest
*/
package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import go_common_library_time "go-common/library/time"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// NoArgReq
type NoArgRequest struct {
}

func (m *NoArgRequest) Reset()                    { *m = NoArgRequest{} }
func (m *NoArgRequest) String() string            { return proto.CompactTextString(m) }
func (*NoArgRequest) ProtoMessage()               {}
func (*NoArgRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

// NoReply
type NoReply struct {
}

func (m *NoReply) Reset()                    { *m = NoReply{} }
func (m *NoReply) String() string            { return proto.CompactTextString(m) }
func (*NoReply) ProtoMessage()               {}
func (*NoReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

type DescriptionRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
}

func (m *DescriptionRequest) Reset()                    { *m = DescriptionRequest{} }
func (m *DescriptionRequest) String() string            { return proto.CompactTextString(m) }
func (*DescriptionRequest) ProtoMessage()               {}
func (*DescriptionRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

func (m *DescriptionRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type DescriptionReply struct {
	Desc string `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *DescriptionReply) Reset()                    { *m = DescriptionReply{} }
func (m *DescriptionReply) String() string            { return proto.CompactTextString(m) }
func (*DescriptionReply) ProtoMessage()               {}
func (*DescriptionReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *DescriptionReply) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

type MaxAidReply struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
}

func (m *MaxAidReply) Reset()                    { *m = MaxAidReply{} }
func (m *MaxAidReply) String() string            { return proto.CompactTextString(m) }
func (*MaxAidReply) ProtoMessage()               {}
func (*MaxAidReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

func (m *MaxAidReply) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type ArcRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
}

func (m *ArcRequest) Reset()                    { *m = ArcRequest{} }
func (m *ArcRequest) String() string            { return proto.CompactTextString(m) }
func (*ArcRequest) ProtoMessage()               {}
func (*ArcRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *ArcRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type ArcReply struct {
	Arc *Arc `protobuf:"bytes,1,opt,name=arc" json:"arc,omitempty"`
}

func (m *ArcReply) Reset()                    { *m = ArcReply{} }
func (m *ArcReply) String() string            { return proto.CompactTextString(m) }
func (*ArcReply) ProtoMessage()               {}
func (*ArcReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

func (m *ArcReply) GetArc() *Arc {
	if m != nil {
		return m.Arc
	}
	return nil
}

type ArcsRequest struct {
	Aids []int64 `protobuf:"varint,1,rep,packed,name=aids" json:"aids,omitempty"`
}

func (m *ArcsRequest) Reset()                    { *m = ArcsRequest{} }
func (m *ArcsRequest) String() string            { return proto.CompactTextString(m) }
func (*ArcsRequest) ProtoMessage()               {}
func (*ArcsRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

func (m *ArcsRequest) GetAids() []int64 {
	if m != nil {
		return m.Aids
	}
	return nil
}

type ArcsReply struct {
	Arcs map[int64]*Arc `protobuf:"bytes,1,rep,name=arcs" json:"arcs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ArcsReply) Reset()                    { *m = ArcsReply{} }
func (m *ArcsReply) String() string            { return proto.CompactTextString(m) }
func (*ArcsReply) ProtoMessage()               {}
func (*ArcsReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

func (m *ArcsReply) GetArcs() map[int64]*Arc {
	if m != nil {
		return m.Arcs
	}
	return nil
}

type ViewRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
}

func (m *ViewRequest) Reset()                    { *m = ViewRequest{} }
func (m *ViewRequest) String() string            { return proto.CompactTextString(m) }
func (*ViewRequest) ProtoMessage()               {}
func (*ViewRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

func (m *ViewRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type StatRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
}

func (m *StatRequest) Reset()                    { *m = StatRequest{} }
func (m *StatRequest) String() string            { return proto.CompactTextString(m) }
func (*StatRequest) ProtoMessage()               {}
func (*StatRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

func (m *StatRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type StatReply struct {
	Stat *Stat `protobuf:"bytes,1,opt,name=Stat" json:"Stat,omitempty"`
}

func (m *StatReply) Reset()                    { *m = StatReply{} }
func (m *StatReply) String() string            { return proto.CompactTextString(m) }
func (*StatReply) ProtoMessage()               {}
func (*StatReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

func (m *StatReply) GetStat() *Stat {
	if m != nil {
		return m.Stat
	}
	return nil
}

type StatsRequest struct {
	Aids []int64 `protobuf:"varint,1,rep,packed,name=aids" json:"aids,omitempty"`
}

func (m *StatsRequest) Reset()                    { *m = StatsRequest{} }
func (m *StatsRequest) String() string            { return proto.CompactTextString(m) }
func (*StatsRequest) ProtoMessage()               {}
func (*StatsRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

func (m *StatsRequest) GetAids() []int64 {
	if m != nil {
		return m.Aids
	}
	return nil
}

type StatsReply struct {
	Stats map[int64]*Stat `protobuf:"bytes,1,rep,name=Stats" json:"Stats,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StatsReply) Reset()                    { *m = StatsReply{} }
func (m *StatsReply) String() string            { return proto.CompactTextString(m) }
func (*StatsReply) ProtoMessage()               {}
func (*StatsReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{13} }

func (m *StatsReply) GetStats() map[int64]*Stat {
	if m != nil {
		return m.Stats
	}
	return nil
}

type ViewReply struct {
	*Arc  `protobuf:"bytes,1,opt,name=arc,embedded=arc" json:""`
	Pages []*Page `protobuf:"bytes,2,rep,name=pages" json:"pages,omitempty"`
}

func (m *ViewReply) Reset()                    { *m = ViewReply{} }
func (m *ViewReply) String() string            { return proto.CompactTextString(m) }
func (*ViewReply) ProtoMessage()               {}
func (*ViewReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{14} }

func (m *ViewReply) GetPages() []*Page {
	if m != nil {
		return m.Pages
	}
	return nil
}

type ViewsRequest struct {
	Aids []int64 `protobuf:"varint,1,rep,packed,name=aids" json:"aids,omitempty"`
}

func (m *ViewsRequest) Reset()                    { *m = ViewsRequest{} }
func (m *ViewsRequest) String() string            { return proto.CompactTextString(m) }
func (*ViewsRequest) ProtoMessage()               {}
func (*ViewsRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{15} }

func (m *ViewsRequest) GetAids() []int64 {
	if m != nil {
		return m.Aids
	}
	return nil
}

type ViewsReply struct {
	Views map[int64]*ViewReply `protobuf:"bytes,1,rep,name=views" json:"views,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ViewsReply) Reset()                    { *m = ViewsReply{} }
func (m *ViewsReply) String() string            { return proto.CompactTextString(m) }
func (*ViewsReply) ProtoMessage()               {}
func (*ViewsReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{16} }

func (m *ViewsReply) GetViews() map[int64]*ViewReply {
	if m != nil {
		return m.Views
	}
	return nil
}

type TypesReply struct {
	Types map[int32]*Tp `protobuf:"bytes,1,rep,name=types" json:"types,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TypesReply) Reset()                    { *m = TypesReply{} }
func (m *TypesReply) String() string            { return proto.CompactTextString(m) }
func (*TypesReply) ProtoMessage()               {}
func (*TypesReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{17} }

func (m *TypesReply) GetTypes() map[int32]*Tp {
	if m != nil {
		return m.Types
	}
	return nil
}

type ClickRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
}

func (m *ClickRequest) Reset()                    { *m = ClickRequest{} }
func (m *ClickRequest) String() string            { return proto.CompactTextString(m) }
func (*ClickRequest) ProtoMessage()               {}
func (*ClickRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{18} }

func (m *ClickRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type ClickReply struct {
	Click *Click `protobuf:"bytes,1,opt,name=click" json:"click,omitempty"`
}

func (m *ClickReply) Reset()                    { *m = ClickReply{} }
func (m *ClickReply) String() string            { return proto.CompactTextString(m) }
func (*ClickReply) ProtoMessage()               {}
func (*ClickReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{19} }

func (m *ClickReply) GetClick() *Click {
	if m != nil {
		return m.Click
	}
	return nil
}

type PageRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
}

func (m *PageRequest) Reset()                    { *m = PageRequest{} }
func (m *PageRequest) String() string            { return proto.CompactTextString(m) }
func (*PageRequest) ProtoMessage()               {}
func (*PageRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{20} }

func (m *PageRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type PageReply struct {
	Pages []*Page `protobuf:"bytes,1,rep,name=pages" json:"pages,omitempty"`
}

func (m *PageReply) Reset()                    { *m = PageReply{} }
func (m *PageReply) String() string            { return proto.CompactTextString(m) }
func (*PageReply) ProtoMessage()               {}
func (*PageReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{21} }

func (m *PageReply) GetPages() []*Page {
	if m != nil {
		return m.Pages
	}
	return nil
}

type RecommendRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
}

func (m *RecommendRequest) Reset()                    { *m = RecommendRequest{} }
func (m *RecommendRequest) String() string            { return proto.CompactTextString(m) }
func (*RecommendRequest) ProtoMessage()               {}
func (*RecommendRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{22} }

func (m *RecommendRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

type RecommendReply struct {
	Arcs []*Arc `protobuf:"bytes,1,rep,name=arcs" json:"arcs,omitempty"`
}

func (m *RecommendReply) Reset()                    { *m = RecommendReply{} }
func (m *RecommendReply) String() string            { return proto.CompactTextString(m) }
func (*RecommendReply) ProtoMessage()               {}
func (*RecommendReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{23} }

func (m *RecommendReply) GetArcs() []*Arc {
	if m != nil {
		return m.Arcs
	}
	return nil
}

type VideoRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
	Cid int64 `protobuf:"varint,2,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *VideoRequest) Reset()                    { *m = VideoRequest{} }
func (m *VideoRequest) String() string            { return proto.CompactTextString(m) }
func (*VideoRequest) ProtoMessage()               {}
func (*VideoRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{24} }

func (m *VideoRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *VideoRequest) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

type VideoReply struct {
	Page *Page `protobuf:"bytes,1,opt,name=page" json:"page,omitempty"`
}

func (m *VideoReply) Reset()                    { *m = VideoReply{} }
func (m *VideoReply) String() string            { return proto.CompactTextString(m) }
func (*VideoReply) ProtoMessage()               {}
func (*VideoReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{25} }

func (m *VideoReply) GetPage() *Page {
	if m != nil {
		return m.Page
	}
	return nil
}

type Tp struct {
	// 分区id
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	// 该分区的父级id
	Pid int32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid"`
	// 该分区对应的名称
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
}

func (m *Tp) Reset()                    { *m = Tp{} }
func (m *Tp) String() string            { return proto.CompactTextString(m) }
func (*Tp) ProtoMessage()               {}
func (*Tp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{26} }

func (m *Tp) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Tp) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *Tp) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type AidVideos struct {
	Aid int64 `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	// 分P信息
	Pages []*Page `protobuf:"bytes,2,rep,name=Pages" json:"pages"`
}

func (m *AidVideos) Reset()                    { *m = AidVideos{} }
func (m *AidVideos) String() string            { return proto.CompactTextString(m) }
func (*AidVideos) ProtoMessage()               {}
func (*AidVideos) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{27} }

func (m *AidVideos) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *AidVideos) GetPages() []*Page {
	if m != nil {
		return m.Pages
	}
	return nil
}

type Arc struct {
	Aid int64 `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	// 稿件一共有多少分P
	Videos int64 `protobuf:"varint,2,opt,name=Videos,proto3" json:"videos"`
	// 分区ID
	TypeID int32 `protobuf:"varint,3,opt,name=TypeID,proto3" json:"tid"`
	// 分区名
	TypeName string `protobuf:"bytes,4,opt,name=TypeName,proto3" json:"tname"`
	// 是否转载  1=原创  2=转载 0=历史上可能遗留的脏数据
	Copyright int32 `protobuf:"varint,5,opt,name=Copyright,proto3" json:"copyright"`
	// 稿件封面图地址，绝对地址 如 http://i0.hdslb.com/bfs/xxx.jpg
	Pic string `protobuf:"bytes,6,opt,name=Pic,proto3" json:"pic"`
	// 稿件标题
	Title string `protobuf:"bytes,7,opt,name=Title,proto3" json:"title"`
	// 稿件发布时间 对外展示的标准时间  时间戳格式
	PubDate go_common_library_time.Time `protobuf:"varint,8,opt,name=PubDate,proto3,casttype=go-common/library/time.Time" json:"pubdate"`
	// 用户提交稿件的时间 一般不对外展示 时间戳格式
	Ctime go_common_library_time.Time `protobuf:"varint,9,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	// 稿件简介
	Desc string `protobuf:"bytes,10,opt,name=Desc,proto3" json:"desc"`
	// 稿件状态，>=0为前台用户可见状态，其他值详见 http://info.bilibili.co/pages/viewpage.action?pageId=3686597#id-%E7%A8%BF%E4%BB%B6%E5%AD%97%E6%AE%B5%E6%9E%9A%E4%B8%BE%E5%80%BC%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E-%E7%A8%BF%E4%BB%B6%E7%8A%B6%E6%80%81state&access
	State int32 `protobuf:"varint,11,opt,name=State,proto3" json:"state"`
	// 稿件访问属性 0=全员可见 10000=登录用户可见（极少)
	Access int32 `protobuf:"varint,12,opt,name=Access,proto3" json:"access,omitempty"`
	// 稿件属性 详见State字段的文档
	Attribute int32 `protobuf:"varint,13,opt,name=Attribute,proto3" json:"attribute,omitempty"`
	// 废弃字段
	Tag string `protobuf:"bytes,14,opt,name=Tag,proto3" json:"-"`
	// 废弃字段
	Tags []string `protobuf:"bytes,15,rep,name=Tags" json:"tags,omitempty"`
	// 稿件总时长（所有分P加起来的） 单位=秒
	Duration int64 `protobuf:"varint,16,opt,name=Duration,proto3" json:"duration"`
	// 稿件绑定的活动id
	MissionID int64 `protobuf:"varint,17,opt,name=MissionID,proto3" json:"mission_id,omitempty"`
	// 稿件绑定的商单id
	OrderID int64 `protobuf:"varint,18,opt,name=OrderID,proto3" json:"order_id,omitempty"`
	// 稿件后台设置的强制跳转地址，如果该值不为空，则必须调转到它对应的页面上
	RedirectURL string `protobuf:"bytes,19,opt,name=RedirectURL,proto3" json:"redirect_url,omitempty"`
	Forward     int64  `protobuf:"varint,20,opt,name=Forward,proto3" json:"forward,omitempty"`
	// 见Rights字段说明
	Rights Rights `protobuf:"bytes,21,opt,name=Rights" json:"rights"`
	// 稿件作者信息，详见Author字段说明
	Author Author `protobuf:"bytes,22,opt,name=Author" json:"owner"`
	// 稿件计数信息，详见Stat字段说明
	Stat         Stat   `protobuf:"bytes,23,opt,name=Stat" json:"stat"`
	ReportResult string `protobuf:"bytes,24,opt,name=ReportResult,proto3" json:"report_result,omitempty"`
	// 发布稿件时Up主设置的动态描述（仅在动态展示）
	Dynamic string `protobuf:"bytes,25,opt,name=Dynamic,proto3" json:"dynamic"`
	// 稿件第一P的cid，供秒开使用
	FirstCid int64 `protobuf:"varint,26,opt,name=FirstCid,proto3" json:"cid,omitempty"`
	// 稿件第一P的分辨率，详见Dimession字段说明
	Dimension Dimension `protobuf:"bytes,27,opt,name=Dimension" json:"dimension,omitempty"`
	// 联合投稿信息，内部使用，详见StaffInfo说明
	StaffInfo []*StaffInfo `protobuf:"bytes,28,rep,name=StaffInfo" json:"-"`
}

func (m *Arc) Reset()                    { *m = Arc{} }
func (m *Arc) String() string            { return proto.CompactTextString(m) }
func (*Arc) ProtoMessage()               {}
func (*Arc) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{28} }

func (m *Arc) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *Arc) GetVideos() int64 {
	if m != nil {
		return m.Videos
	}
	return 0
}

func (m *Arc) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *Arc) GetTypeName() string {
	if m != nil {
		return m.TypeName
	}
	return ""
}

func (m *Arc) GetCopyright() int32 {
	if m != nil {
		return m.Copyright
	}
	return 0
}

func (m *Arc) GetPic() string {
	if m != nil {
		return m.Pic
	}
	return ""
}

func (m *Arc) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Arc) GetPubDate() go_common_library_time.Time {
	if m != nil {
		return m.PubDate
	}
	return 0
}

func (m *Arc) GetCtime() go_common_library_time.Time {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *Arc) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *Arc) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *Arc) GetAccess() int32 {
	if m != nil {
		return m.Access
	}
	return 0
}

func (m *Arc) GetAttribute() int32 {
	if m != nil {
		return m.Attribute
	}
	return 0
}

func (m *Arc) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *Arc) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Arc) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Arc) GetMissionID() int64 {
	if m != nil {
		return m.MissionID
	}
	return 0
}

func (m *Arc) GetOrderID() int64 {
	if m != nil {
		return m.OrderID
	}
	return 0
}

func (m *Arc) GetRedirectURL() string {
	if m != nil {
		return m.RedirectURL
	}
	return ""
}

func (m *Arc) GetForward() int64 {
	if m != nil {
		return m.Forward
	}
	return 0
}

func (m *Arc) GetRights() Rights {
	if m != nil {
		return m.Rights
	}
	return Rights{}
}

func (m *Arc) GetAuthor() Author {
	if m != nil {
		return m.Author
	}
	return Author{}
}

func (m *Arc) GetStat() Stat {
	if m != nil {
		return m.Stat
	}
	return Stat{}
}

func (m *Arc) GetReportResult() string {
	if m != nil {
		return m.ReportResult
	}
	return ""
}

func (m *Arc) GetDynamic() string {
	if m != nil {
		return m.Dynamic
	}
	return ""
}

func (m *Arc) GetFirstCid() int64 {
	if m != nil {
		return m.FirstCid
	}
	return 0
}

func (m *Arc) GetDimension() Dimension {
	if m != nil {
		return m.Dimension
	}
	return Dimension{}
}

func (m *Arc) GetStaffInfo() []*StaffInfo {
	if m != nil {
		return m.StaffInfo
	}
	return nil
}

type StaffInfo struct {
	// 联合投稿的成员Up主id
	Mid int64 `protobuf:"varint,1,opt,name=Mid,proto3" json:"mid"`
	// 联合投稿的成员角色（如 声优、字幕）
	Title string `protobuf:"bytes,2,opt,name=Title,proto3" json:"title"`
}

func (m *StaffInfo) Reset()                    { *m = StaffInfo{} }
func (m *StaffInfo) String() string            { return proto.CompactTextString(m) }
func (*StaffInfo) ProtoMessage()               {}
func (*StaffInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{29} }

func (m *StaffInfo) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *StaffInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

// Dimension 视频分辨率
type Dimension struct {
	// 宽 如 1920
	Width int64 `protobuf:"varint,1,opt,name=Width,proto3" json:"width"`
	// 高 如 1080
	Height int64 `protobuf:"varint,2,opt,name=Height,proto3" json:"height"`
	// 是否竖屏 0=否 1=是
	Rotate int64 `protobuf:"varint,3,opt,name=Rotate,proto3" json:"rotate"`
}

func (m *Dimension) Reset()                    { *m = Dimension{} }
func (m *Dimension) String() string            { return proto.CompactTextString(m) }
func (*Dimension) ProtoMessage()               {}
func (*Dimension) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{30} }

func (m *Dimension) GetWidth() int64 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Dimension) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Dimension) GetRotate() int64 {
	if m != nil {
		return m.Rotate
	}
	return 0
}

// Rights 稿件各常用属性 0=否 1=是
type Rights struct {
	// 老版是否付费
	Bp int32 `protobuf:"varint,1,opt,name=Bp,proto3" json:"bp"`
	// 是否支持充电 （不可直接使用，网关层请求业务方后才有值）
	Elec int32 `protobuf:"varint,2,opt,name=Elec,proto3" json:"elec"`
	// 是否下载（不可直接使用，网关层请求业务方后才有值）
	Download int32 `protobuf:"varint,3,opt,name=Download,proto3" json:"download"`
	// 是否电影
	Movie int32 `protobuf:"varint,4,opt,name=Movie,proto3" json:"movie"`
	// 是否PGC付费
	Pay int32 `protobuf:"varint,5,opt,name=Pay,proto3" json:"pay"`
	// 无用
	HD5 int32 `protobuf:"varint,6,opt,name=HD5,proto3" json:"hd5"`
	// 是否允许转发
	NoReprint int32 `protobuf:"varint,7,opt,name=NoReprint,proto3" json:"no_reprint"`
	// 是否可以自动播放
	Autoplay int32 `protobuf:"varint,8,opt,name=Autoplay,proto3" json:"autoplay"`
	// 是否UGC付费
	UGCPay int32 `protobuf:"varint,9,opt,name=UGCPay,proto3" json:"ugc_pay"`
	// 是否联合投稿
	IsCooperation int32 `protobuf:"varint,10,opt,name=IsCooperation,proto3" json:"is_cooperation"`
}

func (m *Rights) Reset()                    { *m = Rights{} }
func (m *Rights) String() string            { return proto.CompactTextString(m) }
func (*Rights) ProtoMessage()               {}
func (*Rights) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{31} }

func (m *Rights) GetBp() int32 {
	if m != nil {
		return m.Bp
	}
	return 0
}

func (m *Rights) GetElec() int32 {
	if m != nil {
		return m.Elec
	}
	return 0
}

func (m *Rights) GetDownload() int32 {
	if m != nil {
		return m.Download
	}
	return 0
}

func (m *Rights) GetMovie() int32 {
	if m != nil {
		return m.Movie
	}
	return 0
}

func (m *Rights) GetPay() int32 {
	if m != nil {
		return m.Pay
	}
	return 0
}

func (m *Rights) GetHD5() int32 {
	if m != nil {
		return m.HD5
	}
	return 0
}

func (m *Rights) GetNoReprint() int32 {
	if m != nil {
		return m.NoReprint
	}
	return 0
}

func (m *Rights) GetAutoplay() int32 {
	if m != nil {
		return m.Autoplay
	}
	return 0
}

func (m *Rights) GetUGCPay() int32 {
	if m != nil {
		return m.UGCPay
	}
	return 0
}

func (m *Rights) GetIsCooperation() int32 {
	if m != nil {
		return m.IsCooperation
	}
	return 0
}

// Author 稿件作者信息
type Author struct {
	// Up主mid
	Mid int64 `protobuf:"varint,1,opt,name=Mid,proto3" json:"mid"`
	// Up主名称
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	// Up主头像地址 绝对地址
	Face string `protobuf:"bytes,3,opt,name=Face,proto3" json:"face"`
}

func (m *Author) Reset()                    { *m = Author{} }
func (m *Author) String() string            { return proto.CompactTextString(m) }
func (*Author) ProtoMessage()               {}
func (*Author) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{32} }

func (m *Author) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *Author) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Author) GetFace() string {
	if m != nil {
		return m.Face
	}
	return ""
}

// Stat 稿件的所有计数信息
type Stat struct {
	Aid int64 `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	// 播放数
	View int32 `protobuf:"varint,2,opt,name=View,proto3" json:"view"`
	// 弹幕数
	Danmaku int32 `protobuf:"varint,3,opt,name=Danmaku,proto3" json:"danmaku"`
	// 评论数
	Reply int32 `protobuf:"varint,4,opt,name=Reply,proto3" json:"reply"`
	// 收藏数
	Fav int32 `protobuf:"varint,5,opt,name=Fav,proto3" json:"favorite"`
	// 投币数
	Coin int32 `protobuf:"varint,6,opt,name=Coin,proto3" json:"coin"`
	// 分享数
	Share int32 `protobuf:"varint,7,opt,name=Share,proto3" json:"share"`
	// 当前排名
	NowRank int32 `protobuf:"varint,8,opt,name=NowRank,proto3" json:"now_rank"`
	// 历史最高排名
	HisRank int32 `protobuf:"varint,9,opt,name=HisRank,proto3" json:"his_rank"`
	// 点赞数
	Like int32 `protobuf:"varint,10,opt,name=Like,proto3" json:"like"`
	// 点踩数 已取消前台展示，现在均返回0
	DisLike int32 `protobuf:"varint,11,opt,name=DisLike,proto3" json:"dislike"`
}

func (m *Stat) Reset()                    { *m = Stat{} }
func (m *Stat) String() string            { return proto.CompactTextString(m) }
func (*Stat) ProtoMessage()               {}
func (*Stat) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{33} }

func (m *Stat) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *Stat) GetView() int32 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *Stat) GetDanmaku() int32 {
	if m != nil {
		return m.Danmaku
	}
	return 0
}

func (m *Stat) GetReply() int32 {
	if m != nil {
		return m.Reply
	}
	return 0
}

func (m *Stat) GetFav() int32 {
	if m != nil {
		return m.Fav
	}
	return 0
}

func (m *Stat) GetCoin() int32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *Stat) GetShare() int32 {
	if m != nil {
		return m.Share
	}
	return 0
}

func (m *Stat) GetNowRank() int32 {
	if m != nil {
		return m.NowRank
	}
	return 0
}

func (m *Stat) GetHisRank() int32 {
	if m != nil {
		return m.HisRank
	}
	return 0
}

func (m *Stat) GetLike() int32 {
	if m != nil {
		return m.Like
	}
	return 0
}

func (m *Stat) GetDisLike() int32 {
	if m != nil {
		return m.DisLike
	}
	return 0
}

// Click 点击数详情，老版本播放器使用
type Click struct {
	Aid int64 `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	// web端播放数
	Web int32 `protobuf:"varint,2,opt,name=Web,proto3" json:"web"`
	// iOS端播放数
	Ios int32 `protobuf:"varint,3,opt,name=Ios,proto3" json:"ios"`
	// android端播放数
	Android int32 `protobuf:"varint,4,opt,name=Android,proto3" json:"android"`
	// h5端播放数
	H5 int32 `protobuf:"varint,5,opt,name=H5,proto3" json:"h5"`
	// 站外播放数
	Outter int32 `protobuf:"varint,6,opt,name=Outter,proto3" json:"outter"`
}

func (m *Click) Reset()                    { *m = Click{} }
func (m *Click) String() string            { return proto.CompactTextString(m) }
func (*Click) ProtoMessage()               {}
func (*Click) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{34} }

func (m *Click) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *Click) GetWeb() int32 {
	if m != nil {
		return m.Web
	}
	return 0
}

func (m *Click) GetIos() int32 {
	if m != nil {
		return m.Ios
	}
	return 0
}

func (m *Click) GetAndroid() int32 {
	if m != nil {
		return m.Android
	}
	return 0
}

func (m *Click) GetH5() int32 {
	if m != nil {
		return m.H5
	}
	return 0
}

func (m *Click) GetOutter() int32 {
	if m != nil {
		return m.Outter
	}
	return 0
}

// Page 分P信息
type Page struct {
	// 视频的cid
	Cid int64 `protobuf:"varint,1,opt,name=Cid,proto3" json:"cid"`
	// 视频的序号顺序，从小到大
	Page int32 `protobuf:"varint,2,opt,name=Page,proto3" json:"page"`
	// 视频的来源，99%为vupload=B站自己的，少部分为腾讯（qq）、湖南tv(hunan)
	From string `protobuf:"bytes,3,opt,name=From,proto3" json:"from"`
	// 视频的标题
	Part string `protobuf:"bytes,4,opt,name=Part,proto3" json:"part"`
	// 视频的时长 单位=秒
	Duration int64 `protobuf:"varint,5,opt,name=Duration,proto3" json:"duration"`
	// 站外视频才有vid属性
	Vid string `protobuf:"bytes,6,opt,name=Vid,proto3" json:"vid"`
	// 视频的简介，多P视频才可填写简介
	Desc string `protobuf:"bytes,7,opt,name=Desc,proto3" json:"description,omitempty"`
	// 站外视频跳转地址
	WebLink string `protobuf:"bytes,8,opt,name=WebLink,proto3" json:"weblink"`
	// 视频分辨率信息
	Dimension Dimension `protobuf:"bytes,9,opt,name=Dimension" json:"dimension"`
}

func (m *Page) Reset()                    { *m = Page{} }
func (m *Page) String() string            { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()               {}
func (*Page) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{35} }

func (m *Page) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *Page) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *Page) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Page) GetPart() string {
	if m != nil {
		return m.Part
	}
	return ""
}

func (m *Page) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Page) GetVid() string {
	if m != nil {
		return m.Vid
	}
	return ""
}

func (m *Page) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *Page) GetWebLink() string {
	if m != nil {
		return m.WebLink
	}
	return ""
}

func (m *Page) GetDimension() Dimension {
	if m != nil {
		return m.Dimension
	}
	return Dimension{}
}

// !!!Note: only response message defined, since we put pb into http response body
type VideoFileInfo struct {
	Filesize   int64  `protobuf:"varint,1,opt,name=filesize,proto3,casttype=int64" json:"filesize"`
	Timelength int64  `protobuf:"varint,2,opt,name=timelength,proto3,casttype=int64" json:"timelength"`
	Ahead      string `protobuf:"bytes,3,opt,name=ahead,proto3" json:"ahead"`
	Vhead      string `protobuf:"bytes,4,opt,name=vhead,proto3" json:"vhead"`
}

func (m *VideoFileInfo) Reset()                    { *m = VideoFileInfo{} }
func (m *VideoFileInfo) String() string            { return proto.CompactTextString(m) }
func (*VideoFileInfo) ProtoMessage()               {}
func (*VideoFileInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{36} }

func (m *VideoFileInfo) GetFilesize() int64 {
	if m != nil {
		return m.Filesize
	}
	return 0
}

func (m *VideoFileInfo) GetTimelength() int64 {
	if m != nil {
		return m.Timelength
	}
	return 0
}

func (m *VideoFileInfo) GetAhead() string {
	if m != nil {
		return m.Ahead
	}
	return ""
}

func (m *VideoFileInfo) GetVhead() string {
	if m != nil {
		return m.Vhead
	}
	return ""
}

type VideoFormatFileInfo struct {
	Infos []*VideoFileInfo `protobuf:"bytes,1,rep,name=infos" json:"infos"`
}

func (m *VideoFormatFileInfo) Reset()                    { *m = VideoFormatFileInfo{} }
func (m *VideoFormatFileInfo) String() string            { return proto.CompactTextString(m) }
func (*VideoFormatFileInfo) ProtoMessage()               {}
func (*VideoFormatFileInfo) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{37} }

func (m *VideoFormatFileInfo) GetInfos() []*VideoFileInfo {
	if m != nil {
		return m.Infos
	}
	return nil
}

type DashItem struct {
	Id        int64  `protobuf:"varint,1,opt,name=id,proto3,casttype=int64" json:"id"`
	BaseUrl   string `protobuf:"bytes,2,opt,name=baseUrl,proto3" json:"base_url"`
	Bandwidth int64  `protobuf:"varint,3,opt,name=bandwidth,proto3,casttype=int64" json:"bandwidth"`
	Codecid   int64  `protobuf:"varint,4,opt,name=codecid,proto3,casttype=int64" json:"codecid"`
}

func (m *DashItem) Reset()                    { *m = DashItem{} }
func (m *DashItem) String() string            { return proto.CompactTextString(m) }
func (*DashItem) ProtoMessage()               {}
func (*DashItem) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{38} }

func (m *DashItem) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DashItem) GetBaseUrl() string {
	if m != nil {
		return m.BaseUrl
	}
	return ""
}

func (m *DashItem) GetBandwidth() int64 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

func (m *DashItem) GetCodecid() int64 {
	if m != nil {
		return m.Codecid
	}
	return 0
}

type ResponseDash struct {
	Video []*DashItem `protobuf:"bytes,1,rep,name=video" json:"video"`
	Audio []*DashItem `protobuf:"bytes,2,rep,name=audio" json:"audio"`
}

func (m *ResponseDash) Reset()                    { *m = ResponseDash{} }
func (m *ResponseDash) String() string            { return proto.CompactTextString(m) }
func (*ResponseDash) ProtoMessage()               {}
func (*ResponseDash) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{39} }

func (m *ResponseDash) GetVideo() []*DashItem {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *ResponseDash) GetAudio() []*DashItem {
	if m != nil {
		return m.Audio
	}
	return nil
}

type BvcVideoItem struct {
	ExpireTime         int64                           `protobuf:"varint,1,opt,name=expire_time,json=expireTime,proto3,casttype=int64" json:"expire_time"`
	Cid                int64                           `protobuf:"varint,2,opt,name=cid,proto3,casttype=int64" json:"cid"`
	SupportQuality     []int                           `protobuf:"varint,3,rep,packed,name=support_quality,json=supportQuality,casttype=int" json:"support_quality"`
	SupportFormats     []string                        `protobuf:"bytes,4,rep,name=support_formats,json=supportFormats" json:"support_formats"`
	SupportDescription []string                        `protobuf:"bytes,5,rep,name=support_description,json=supportDescription" json:"support_description"`
	Quality            int                             `protobuf:"varint,6,opt,name=quality,proto3,casttype=int" json:"quality"`
	Url                string                          `protobuf:"bytes,7,opt,name=url,proto3" json:"url"`
	FileInfo           map[uint32]*VideoFormatFileInfo `protobuf:"bytes,8,rep,name=file_info,json=fileInfo" json:"file_info" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	VideoCodecid       uint32                          `protobuf:"varint,9,opt,name=video_codecid,json=videoCodecid,proto3" json:"video_codecid"`
	VideoProject       bool                            `protobuf:"varint,10,opt,name=video_project,json=videoProject,proto3" json:"video_project"`
	Fnver              int                             `protobuf:"varint,11,opt,name=fnver,proto3,casttype=int" json:"fnver"`
	Fnval              int                             `protobuf:"varint,12,opt,name=fnval,proto3,casttype=int" json:"fnval"`
	Dash               *ResponseDash                   `protobuf:"bytes,13,opt,name=dash" json:"dash"`
}

func (m *BvcVideoItem) Reset()                    { *m = BvcVideoItem{} }
func (m *BvcVideoItem) String() string            { return proto.CompactTextString(m) }
func (*BvcVideoItem) ProtoMessage()               {}
func (*BvcVideoItem) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{40} }

func (m *BvcVideoItem) GetExpireTime() int64 {
	if m != nil {
		return m.ExpireTime
	}
	return 0
}

func (m *BvcVideoItem) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *BvcVideoItem) GetSupportQuality() []int {
	if m != nil {
		return m.SupportQuality
	}
	return nil
}

func (m *BvcVideoItem) GetSupportFormats() []string {
	if m != nil {
		return m.SupportFormats
	}
	return nil
}

func (m *BvcVideoItem) GetSupportDescription() []string {
	if m != nil {
		return m.SupportDescription
	}
	return nil
}

func (m *BvcVideoItem) GetQuality() int {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *BvcVideoItem) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *BvcVideoItem) GetFileInfo() map[uint32]*VideoFormatFileInfo {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

func (m *BvcVideoItem) GetVideoCodecid() uint32 {
	if m != nil {
		return m.VideoCodecid
	}
	return 0
}

func (m *BvcVideoItem) GetVideoProject() bool {
	if m != nil {
		return m.VideoProject
	}
	return false
}

func (m *BvcVideoItem) GetFnver() int {
	if m != nil {
		return m.Fnver
	}
	return 0
}

func (m *BvcVideoItem) GetFnval() int {
	if m != nil {
		return m.Fnval
	}
	return 0
}

func (m *BvcVideoItem) GetDash() *ResponseDash {
	if m != nil {
		return m.Dash
	}
	return nil
}

type BvcResponseMsg struct {
	Code int64                    `protobuf:"varint,1,opt,name=code,proto3,casttype=int64" json:"code"`
	Data map[uint32]*BvcVideoItem `protobuf:"bytes,2,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BvcResponseMsg) Reset()                    { *m = BvcResponseMsg{} }
func (m *BvcResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*BvcResponseMsg) ProtoMessage()               {}
func (*BvcResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{41} }

func (m *BvcResponseMsg) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *BvcResponseMsg) GetData() map[uint32]*BvcVideoItem {
	if m != nil {
		return m.Data
	}
	return nil
}

// 内部方法 请勿使用--------------------------------------------------------------------------------------------
type ArcCacheRequest struct {
	Aid    int64  `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
	Tp     string `protobuf:"bytes,2,opt,name=tp,proto3" json:"tp,omitempty"`
	OldMid int64  `protobuf:"varint,3,opt,name=OldMid,proto3" json:"OldMid,omitempty"`
}

func (m *ArcCacheRequest) Reset()                    { *m = ArcCacheRequest{} }
func (m *ArcCacheRequest) String() string            { return proto.CompactTextString(m) }
func (*ArcCacheRequest) ProtoMessage()               {}
func (*ArcCacheRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{42} }

func (m *ArcCacheRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *ArcCacheRequest) GetTp() string {
	if m != nil {
		return m.Tp
	}
	return ""
}

func (m *ArcCacheRequest) GetOldMid() int64 {
	if m != nil {
		return m.OldMid
	}
	return 0
}

type ArcFieldCacheRequest struct {
	Aid       int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
	TypeID    int32 `protobuf:"varint,2,opt,name=typeID,proto3" json:"typeID,omitempty"`
	OldTypeID int32 `protobuf:"varint,3,opt,name=oldTypeID,proto3" json:"oldTypeID,omitempty"`
}

func (m *ArcFieldCacheRequest) Reset()                    { *m = ArcFieldCacheRequest{} }
func (m *ArcFieldCacheRequest) String() string            { return proto.CompactTextString(m) }
func (*ArcFieldCacheRequest) ProtoMessage()               {}
func (*ArcFieldCacheRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{43} }

func (m *ArcFieldCacheRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *ArcFieldCacheRequest) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *ArcFieldCacheRequest) GetOldTypeID() int32 {
	if m != nil {
		return m.OldTypeID
	}
	return 0
}

type UpVideoCacheRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
	Cid int64 `protobuf:"varint,2,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *UpVideoCacheRequest) Reset()                    { *m = UpVideoCacheRequest{} }
func (m *UpVideoCacheRequest) String() string            { return proto.CompactTextString(m) }
func (*UpVideoCacheRequest) ProtoMessage()               {}
func (*UpVideoCacheRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{44} }

func (m *UpVideoCacheRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *UpVideoCacheRequest) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

type DelVideoCacheRequest struct {
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
	Cid int64 `protobuf:"varint,2,opt,name=cid,proto3" json:"cid,omitempty"`
}

func (m *DelVideoCacheRequest) Reset()                    { *m = DelVideoCacheRequest{} }
func (m *DelVideoCacheRequest) String() string            { return proto.CompactTextString(m) }
func (*DelVideoCacheRequest) ProtoMessage()               {}
func (*DelVideoCacheRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{45} }

func (m *DelVideoCacheRequest) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *DelVideoCacheRequest) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

type SetStatRequest struct {
	Stat *Stat `protobuf:"bytes,1,opt,name=stat" json:"stat,omitempty"`
}

func (m *SetStatRequest) Reset()                    { *m = SetStatRequest{} }
func (m *SetStatRequest) String() string            { return proto.CompactTextString(m) }
func (*SetStatRequest) ProtoMessage()               {}
func (*SetStatRequest) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{46} }

func (m *SetStatRequest) GetStat() *Stat {
	if m != nil {
		return m.Stat
	}
	return nil
}

func init() {
	proto.RegisterType((*NoArgRequest)(nil), "archive.service.v1.NoArgRequest")
	proto.RegisterType((*NoReply)(nil), "archive.service.v1.NoReply")
	proto.RegisterType((*DescriptionRequest)(nil), "archive.service.v1.DescriptionRequest")
	proto.RegisterType((*DescriptionReply)(nil), "archive.service.v1.DescriptionReply")
	proto.RegisterType((*MaxAidReply)(nil), "archive.service.v1.MaxAidReply")
	proto.RegisterType((*ArcRequest)(nil), "archive.service.v1.ArcRequest")
	proto.RegisterType((*ArcReply)(nil), "archive.service.v1.ArcReply")
	proto.RegisterType((*ArcsRequest)(nil), "archive.service.v1.ArcsRequest")
	proto.RegisterType((*ArcsReply)(nil), "archive.service.v1.ArcsReply")
	proto.RegisterType((*ViewRequest)(nil), "archive.service.v1.ViewRequest")
	proto.RegisterType((*StatRequest)(nil), "archive.service.v1.StatRequest")
	proto.RegisterType((*StatReply)(nil), "archive.service.v1.StatReply")
	proto.RegisterType((*StatsRequest)(nil), "archive.service.v1.StatsRequest")
	proto.RegisterType((*StatsReply)(nil), "archive.service.v1.StatsReply")
	proto.RegisterType((*ViewReply)(nil), "archive.service.v1.ViewReply")
	proto.RegisterType((*ViewsRequest)(nil), "archive.service.v1.ViewsRequest")
	proto.RegisterType((*ViewsReply)(nil), "archive.service.v1.ViewsReply")
	proto.RegisterType((*TypesReply)(nil), "archive.service.v1.TypesReply")
	proto.RegisterType((*ClickRequest)(nil), "archive.service.v1.ClickRequest")
	proto.RegisterType((*ClickReply)(nil), "archive.service.v1.ClickReply")
	proto.RegisterType((*PageRequest)(nil), "archive.service.v1.PageRequest")
	proto.RegisterType((*PageReply)(nil), "archive.service.v1.PageReply")
	proto.RegisterType((*RecommendRequest)(nil), "archive.service.v1.RecommendRequest")
	proto.RegisterType((*RecommendReply)(nil), "archive.service.v1.RecommendReply")
	proto.RegisterType((*VideoRequest)(nil), "archive.service.v1.VideoRequest")
	proto.RegisterType((*VideoReply)(nil), "archive.service.v1.VideoReply")
	proto.RegisterType((*Tp)(nil), "archive.service.v1.Tp")
	proto.RegisterType((*AidVideos)(nil), "archive.service.v1.AidVideos")
	proto.RegisterType((*Arc)(nil), "archive.service.v1.Arc")
	proto.RegisterType((*StaffInfo)(nil), "archive.service.v1.StaffInfo")
	proto.RegisterType((*Dimension)(nil), "archive.service.v1.Dimension")
	proto.RegisterType((*Rights)(nil), "archive.service.v1.Rights")
	proto.RegisterType((*Author)(nil), "archive.service.v1.Author")
	proto.RegisterType((*Stat)(nil), "archive.service.v1.Stat")
	proto.RegisterType((*Click)(nil), "archive.service.v1.Click")
	proto.RegisterType((*Page)(nil), "archive.service.v1.Page")
	proto.RegisterType((*VideoFileInfo)(nil), "archive.service.v1.VideoFileInfo")
	proto.RegisterType((*VideoFormatFileInfo)(nil), "archive.service.v1.VideoFormatFileInfo")
	proto.RegisterType((*DashItem)(nil), "archive.service.v1.DashItem")
	proto.RegisterType((*ResponseDash)(nil), "archive.service.v1.ResponseDash")
	proto.RegisterType((*BvcVideoItem)(nil), "archive.service.v1.BvcVideoItem")
	proto.RegisterType((*BvcResponseMsg)(nil), "archive.service.v1.BvcResponseMsg")
	proto.RegisterType((*ArcCacheRequest)(nil), "archive.service.v1.ArcCacheRequest")
	proto.RegisterType((*ArcFieldCacheRequest)(nil), "archive.service.v1.ArcFieldCacheRequest")
	proto.RegisterType((*UpVideoCacheRequest)(nil), "archive.service.v1.UpVideoCacheRequest")
	proto.RegisterType((*DelVideoCacheRequest)(nil), "archive.service.v1.DelVideoCacheRequest")
	proto.RegisterType((*SetStatRequest)(nil), "archive.service.v1.SetStatRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Archive service

type ArchiveClient interface {
	// Types 获取所有分区列表
	Types(ctx context.Context, in *NoArgRequest, opts ...grpc.CallOption) (*TypesReply, error)
	// 获取单个稿件信息
	Arc(ctx context.Context, in *ArcRequest, opts ...grpc.CallOption) (*ArcReply, error)
	// 批量获取稿件信息
	Arcs(ctx context.Context, in *ArcsRequest, opts ...grpc.CallOption) (*ArcsReply, error)
	// 获取单个稿件计数信息
	Stat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatReply, error)
	// 批量获取稿件计数信息
	Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsReply, error)
	// 获取单个稿件+分P信息
	View(ctx context.Context, in *ViewRequest, opts ...grpc.CallOption) (*ViewReply, error)
	// 批量获取稿件+分P信息
	Views(ctx context.Context, in *ViewsRequest, opts ...grpc.CallOption) (*ViewsReply, error)
	// 获取稿件在各平台的点击数
	Click(ctx context.Context, in *ClickRequest, opts ...grpc.CallOption) (*ClickReply, error)
	// 获取稿件的所有分P信息
	Page(ctx context.Context, in *PageRequest, opts ...grpc.CallOption) (*PageReply, error)
	// 获取Up主绑定的相关推荐 *几乎废弃
	Recommend(ctx context.Context, in *RecommendRequest, opts ...grpc.CallOption) (*RecommendReply, error)
	// 获取aid&cid对应的视频信息
	Video(ctx context.Context, in *VideoRequest, opts ...grpc.CallOption) (*VideoReply, error)
	// 获取当前最大的aid，各子业务防刷、防脏数据时使用
	MaxAid(ctx context.Context, in *NoArgRequest, opts ...grpc.CallOption) (*MaxAidReply, error)
	// 获取稿件的长简介信息
	Description(ctx context.Context, in *DescriptionRequest, opts ...grpc.CallOption) (*DescriptionReply, error)
	// 内部方法，管理稿件服务缓存，请勿使用-----------------------------------------------------------------------
	ArcFieldCache(ctx context.Context, in *ArcFieldCacheRequest, opts ...grpc.CallOption) (*NoReply, error)
	ArcCache(ctx context.Context, in *ArcCacheRequest, opts ...grpc.CallOption) (*NoReply, error)
	UpVideoCache(ctx context.Context, in *UpVideoCacheRequest, opts ...grpc.CallOption) (*NoReply, error)
	DelVideoCache(ctx context.Context, in *DelVideoCacheRequest, opts ...grpc.CallOption) (*NoReply, error)
	SetStat(ctx context.Context, in *SetStatRequest, opts ...grpc.CallOption) (*NoReply, error)
}

type archiveClient struct {
	cc *grpc.ClientConn
}

func NewArchiveClient(cc *grpc.ClientConn) ArchiveClient {
	return &archiveClient{cc}
}

func (c *archiveClient) Types(ctx context.Context, in *NoArgRequest, opts ...grpc.CallOption) (*TypesReply, error) {
	out := new(TypesReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Types", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Arc(ctx context.Context, in *ArcRequest, opts ...grpc.CallOption) (*ArcReply, error) {
	out := new(ArcReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Arc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Arcs(ctx context.Context, in *ArcsRequest, opts ...grpc.CallOption) (*ArcsReply, error) {
	out := new(ArcsReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Arcs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Stat(ctx context.Context, in *StatRequest, opts ...grpc.CallOption) (*StatReply, error) {
	out := new(StatReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Stat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsReply, error) {
	out := new(StatsReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Stats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) View(ctx context.Context, in *ViewRequest, opts ...grpc.CallOption) (*ViewReply, error) {
	out := new(ViewReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/View", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Views(ctx context.Context, in *ViewsRequest, opts ...grpc.CallOption) (*ViewsReply, error) {
	out := new(ViewsReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Views", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Click(ctx context.Context, in *ClickRequest, opts ...grpc.CallOption) (*ClickReply, error) {
	out := new(ClickReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Click", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Page(ctx context.Context, in *PageRequest, opts ...grpc.CallOption) (*PageReply, error) {
	out := new(PageReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Page", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Recommend(ctx context.Context, in *RecommendRequest, opts ...grpc.CallOption) (*RecommendReply, error) {
	out := new(RecommendReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Recommend", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Video(ctx context.Context, in *VideoRequest, opts ...grpc.CallOption) (*VideoReply, error) {
	out := new(VideoReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Video", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) MaxAid(ctx context.Context, in *NoArgRequest, opts ...grpc.CallOption) (*MaxAidReply, error) {
	out := new(MaxAidReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/MaxAid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) Description(ctx context.Context, in *DescriptionRequest, opts ...grpc.CallOption) (*DescriptionReply, error) {
	out := new(DescriptionReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/Description", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) ArcFieldCache(ctx context.Context, in *ArcFieldCacheRequest, opts ...grpc.CallOption) (*NoReply, error) {
	out := new(NoReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/ArcFieldCache", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) ArcCache(ctx context.Context, in *ArcCacheRequest, opts ...grpc.CallOption) (*NoReply, error) {
	out := new(NoReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/ArcCache", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) UpVideoCache(ctx context.Context, in *UpVideoCacheRequest, opts ...grpc.CallOption) (*NoReply, error) {
	out := new(NoReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/UpVideoCache", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) DelVideoCache(ctx context.Context, in *DelVideoCacheRequest, opts ...grpc.CallOption) (*NoReply, error) {
	out := new(NoReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/DelVideoCache", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *archiveClient) SetStat(ctx context.Context, in *SetStatRequest, opts ...grpc.CallOption) (*NoReply, error) {
	out := new(NoReply)
	err := grpc.Invoke(ctx, "/archive.service.v1.Archive/SetStat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Archive service

type ArchiveServer interface {
	// Types 获取所有分区列表
	Types(context.Context, *NoArgRequest) (*TypesReply, error)
	// 获取单个稿件信息
	Arc(context.Context, *ArcRequest) (*ArcReply, error)
	// 批量获取稿件信息
	Arcs(context.Context, *ArcsRequest) (*ArcsReply, error)
	// 获取单个稿件计数信息
	Stat(context.Context, *StatRequest) (*StatReply, error)
	// 批量获取稿件计数信息
	Stats(context.Context, *StatsRequest) (*StatsReply, error)
	// 获取单个稿件+分P信息
	View(context.Context, *ViewRequest) (*ViewReply, error)
	// 批量获取稿件+分P信息
	Views(context.Context, *ViewsRequest) (*ViewsReply, error)
	// 获取稿件在各平台的点击数
	Click(context.Context, *ClickRequest) (*ClickReply, error)
	// 获取稿件的所有分P信息
	Page(context.Context, *PageRequest) (*PageReply, error)
	// 获取Up主绑定的相关推荐 *几乎废弃
	Recommend(context.Context, *RecommendRequest) (*RecommendReply, error)
	// 获取aid&cid对应的视频信息
	Video(context.Context, *VideoRequest) (*VideoReply, error)
	// 获取当前最大的aid，各子业务防刷、防脏数据时使用
	MaxAid(context.Context, *NoArgRequest) (*MaxAidReply, error)
	// 获取稿件的长简介信息
	Description(context.Context, *DescriptionRequest) (*DescriptionReply, error)
	// 内部方法，管理稿件服务缓存，请勿使用-----------------------------------------------------------------------
	ArcFieldCache(context.Context, *ArcFieldCacheRequest) (*NoReply, error)
	ArcCache(context.Context, *ArcCacheRequest) (*NoReply, error)
	UpVideoCache(context.Context, *UpVideoCacheRequest) (*NoReply, error)
	DelVideoCache(context.Context, *DelVideoCacheRequest) (*NoReply, error)
	SetStat(context.Context, *SetStatRequest) (*NoReply, error)
}

func RegisterArchiveServer(s *grpc.Server, srv ArchiveServer) {
	s.RegisterService(&_Archive_serviceDesc, srv)
}

func _Archive_Types_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoArgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Types(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Types",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Types(ctx, req.(*NoArgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Arc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Arc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Arc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Arc(ctx, req.(*ArcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Arcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Arcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Arcs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Arcs(ctx, req.(*ArcsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Stat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Stat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Stat(ctx, req.(*StatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Stats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Stats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Stats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Stats(ctx, req.(*StatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_View_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).View(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/View",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).View(ctx, req.(*ViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Views_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Views(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Views",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Views(ctx, req.(*ViewsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Click_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Click(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Click",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Click(ctx, req.(*ClickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Page_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Page(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Page",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Page(ctx, req.(*PageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Recommend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecommendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Recommend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Recommend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Recommend(ctx, req.(*RecommendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Video_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Video(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Video",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Video(ctx, req.(*VideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_MaxAid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoArgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).MaxAid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/MaxAid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).MaxAid(ctx, req.(*NoArgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_Description_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).Description(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/Description",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).Description(ctx, req.(*DescriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_ArcFieldCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcFieldCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).ArcFieldCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/ArcFieldCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).ArcFieldCache(ctx, req.(*ArcFieldCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_ArcCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArcCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).ArcCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/ArcCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).ArcCache(ctx, req.(*ArcCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_UpVideoCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpVideoCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).UpVideoCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/UpVideoCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).UpVideoCache(ctx, req.(*UpVideoCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_DelVideoCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelVideoCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).DelVideoCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/DelVideoCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).DelVideoCache(ctx, req.(*DelVideoCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Archive_SetStat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetStatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArchiveServer).SetStat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/archive.service.v1.Archive/SetStat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArchiveServer).SetStat(ctx, req.(*SetStatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Archive_serviceDesc = grpc.ServiceDesc{
	ServiceName: "archive.service.v1.Archive",
	HandlerType: (*ArchiveServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Types",
			Handler:    _Archive_Types_Handler,
		},
		{
			MethodName: "Arc",
			Handler:    _Archive_Arc_Handler,
		},
		{
			MethodName: "Arcs",
			Handler:    _Archive_Arcs_Handler,
		},
		{
			MethodName: "Stat",
			Handler:    _Archive_Stat_Handler,
		},
		{
			MethodName: "Stats",
			Handler:    _Archive_Stats_Handler,
		},
		{
			MethodName: "View",
			Handler:    _Archive_View_Handler,
		},
		{
			MethodName: "Views",
			Handler:    _Archive_Views_Handler,
		},
		{
			MethodName: "Click",
			Handler:    _Archive_Click_Handler,
		},
		{
			MethodName: "Page",
			Handler:    _Archive_Page_Handler,
		},
		{
			MethodName: "Recommend",
			Handler:    _Archive_Recommend_Handler,
		},
		{
			MethodName: "Video",
			Handler:    _Archive_Video_Handler,
		},
		{
			MethodName: "MaxAid",
			Handler:    _Archive_MaxAid_Handler,
		},
		{
			MethodName: "Description",
			Handler:    _Archive_Description_Handler,
		},
		{
			MethodName: "ArcFieldCache",
			Handler:    _Archive_ArcFieldCache_Handler,
		},
		{
			MethodName: "ArcCache",
			Handler:    _Archive_ArcCache_Handler,
		},
		{
			MethodName: "UpVideoCache",
			Handler:    _Archive_UpVideoCache_Handler,
		},
		{
			MethodName: "DelVideoCache",
			Handler:    _Archive_DelVideoCache_Handler,
		},
		{
			MethodName: "SetStat",
			Handler:    _Archive_SetStat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/main/archive/api/api.proto",
}

func (m *NoArgRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoArgRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DescriptionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	return i, nil
}

func (m *DescriptionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Desc) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *MaxAidReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxAidReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	return i, nil
}

func (m *ArcRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	return i, nil
}

func (m *ArcReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Arc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Arc.Size()))
		n1, err := m.Arc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ArcsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Aids) > 0 {
		dAtA3 := make([]byte, len(m.Aids)*10)
		var j2 int
		for _, num1 := range m.Aids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *ArcsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Arcs) > 0 {
		for k, _ := range m.Arcs {
			dAtA[i] = 0xa
			i++
			v := m.Arcs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	return i, nil
}

func (m *ViewRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	return i, nil
}

func (m *StatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	return i, nil
}

func (m *StatReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Stat.Size()))
		n5, err := m.Stat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *StatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Aids) > 0 {
		dAtA7 := make([]byte, len(m.Aids)*10)
		var j6 int
		for _, num1 := range m.Aids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	return i, nil
}

func (m *StatsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for k, _ := range m.Stats {
			dAtA[i] = 0xa
			i++
			v := m.Stats[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	return i, nil
}

func (m *ViewReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Arc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Arc.Size()))
		n9, err := m.Arc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Pages) > 0 {
		for _, msg := range m.Pages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ViewsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Aids) > 0 {
		dAtA11 := make([]byte, len(m.Aids)*10)
		var j10 int
		for _, num1 := range m.Aids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *ViewsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Views) > 0 {
		for k, _ := range m.Views {
			dAtA[i] = 0xa
			i++
			v := m.Views[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	return i, nil
}

func (m *TypesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypesReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Types) > 0 {
		for k, _ := range m.Types {
			dAtA[i] = 0xa
			i++
			v := m.Types[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	return i, nil
}

func (m *ClickRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClickRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	return i, nil
}

func (m *ClickReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClickReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Click != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Click.Size()))
		n14, err := m.Click.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *PageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	return i, nil
}

func (m *PageReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pages) > 0 {
		for _, msg := range m.Pages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RecommendRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	return i, nil
}

func (m *RecommendReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecommendReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Arcs) > 0 {
		for _, msg := range m.Arcs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VideoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.Cid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
	}
	return i, nil
}

func (m *VideoReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Page.Size()))
		n15, err := m.Page.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *Tp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ID))
	}
	if m.Pid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *AidVideos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AidVideos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if len(m.Pages) > 0 {
		for _, msg := range m.Pages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Arc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Arc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.Videos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Videos))
	}
	if m.TypeID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TypeID))
	}
	if len(m.TypeName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TypeName)))
		i += copy(dAtA[i:], m.TypeName)
	}
	if m.Copyright != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Copyright))
	}
	if len(m.Pic) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Pic)))
		i += copy(dAtA[i:], m.Pic)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.PubDate != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PubDate))
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ctime))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.State != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.State))
	}
	if m.Access != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Access))
	}
	if m.Attribute != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Attribute))
	}
	if len(m.Tag) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Duration != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Duration))
	}
	if m.MissionID != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MissionID))
	}
	if m.OrderID != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OrderID))
	}
	if len(m.RedirectURL) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RedirectURL)))
		i += copy(dAtA[i:], m.RedirectURL)
	}
	if m.Forward != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Forward))
	}
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Rights.Size()))
	n16, err := m.Rights.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Author.Size()))
	n17, err := m.Author.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0xba
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Stat.Size()))
	n18, err := m.Stat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.ReportResult) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ReportResult)))
		i += copy(dAtA[i:], m.ReportResult)
	}
	if len(m.Dynamic) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Dynamic)))
		i += copy(dAtA[i:], m.Dynamic)
	}
	if m.FirstCid != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.FirstCid))
	}
	dAtA[i] = 0xda
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Dimension.Size()))
	n19, err := m.Dimension.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if len(m.StaffInfo) > 0 {
		for _, msg := range m.StaffInfo {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StaffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaffInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	return i, nil
}

func (m *Dimension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dimension) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Height))
	}
	if m.Rotate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rotate))
	}
	return i, nil
}

func (m *Rights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rights) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Bp))
	}
	if m.Elec != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Elec))
	}
	if m.Download != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Download))
	}
	if m.Movie != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Movie))
	}
	if m.Pay != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pay))
	}
	if m.HD5 != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HD5))
	}
	if m.NoReprint != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NoReprint))
	}
	if m.Autoplay != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Autoplay))
	}
	if m.UGCPay != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UGCPay))
	}
	if m.IsCooperation != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IsCooperation))
	}
	return i, nil
}

func (m *Author) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Author) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Face) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Face)))
		i += copy(dAtA[i:], m.Face)
	}
	return i, nil
}

func (m *Stat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.View))
	}
	if m.Danmaku != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Danmaku))
	}
	if m.Reply != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Reply))
	}
	if m.Fav != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Fav))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Coin))
	}
	if m.Share != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Share))
	}
	if m.NowRank != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NowRank))
	}
	if m.HisRank != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HisRank))
	}
	if m.Like != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Like))
	}
	if m.DisLike != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DisLike))
	}
	return i, nil
}

func (m *Click) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Click) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.Web != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Web))
	}
	if m.Ios != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ios))
	}
	if m.Android != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Android))
	}
	if m.H5 != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.H5))
	}
	if m.Outter != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Outter))
	}
	return i, nil
}

func (m *Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Page))
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.Part) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Part)))
		i += copy(dAtA[i:], m.Part)
	}
	if m.Duration != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Duration))
	}
	if len(m.Vid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Vid)))
		i += copy(dAtA[i:], m.Vid)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.WebLink) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.WebLink)))
		i += copy(dAtA[i:], m.WebLink)
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Dimension.Size()))
	n20, err := m.Dimension.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	return i, nil
}

func (m *VideoFileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoFileInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Filesize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Filesize))
	}
	if m.Timelength != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Timelength))
	}
	if len(m.Ahead) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ahead)))
		i += copy(dAtA[i:], m.Ahead)
	}
	if len(m.Vhead) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Vhead)))
		i += copy(dAtA[i:], m.Vhead)
	}
	return i, nil
}

func (m *VideoFormatFileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoFormatFileInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DashItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DashItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.BaseUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.BaseUrl)))
		i += copy(dAtA[i:], m.BaseUrl)
	}
	if m.Bandwidth != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Bandwidth))
	}
	if m.Codecid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Codecid))
	}
	return i, nil
}

func (m *ResponseDash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseDash) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Video) > 0 {
		for _, msg := range m.Video {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Audio) > 0 {
		for _, msg := range m.Audio {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BvcVideoItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BvcVideoItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExpireTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ExpireTime))
	}
	if m.Cid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
	}
	if len(m.SupportQuality) > 0 {
		dAtA22 := make([]byte, len(m.SupportQuality)*10)
		var j21 int
		for _, num := range m.SupportQuality {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	if len(m.SupportFormats) > 0 {
		for _, s := range m.SupportFormats {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SupportDescription) > 0 {
		for _, s := range m.SupportDescription {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Quality != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Quality))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.FileInfo) > 0 {
		for k, _ := range m.FileInfo {
			dAtA[i] = 0x42
			i++
			v := m.FileInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n23, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n23
			}
		}
	}
	if m.VideoCodecid != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.VideoCodecid))
	}
	if m.VideoProject {
		dAtA[i] = 0x50
		i++
		if m.VideoProject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Fnver != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Fnval))
	}
	if m.Dash != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Dash.Size()))
		n24, err := m.Dash.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *BvcResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BvcResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0x12
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n25, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n25
			}
		}
	}
	return i, nil
}

func (m *ArcCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if len(m.Tp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tp)))
		i += copy(dAtA[i:], m.Tp)
	}
	if m.OldMid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OldMid))
	}
	return i, nil
}

func (m *ArcFieldCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArcFieldCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.TypeID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TypeID))
	}
	if m.OldTypeID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.OldTypeID))
	}
	return i, nil
}

func (m *UpVideoCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpVideoCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.Cid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
	}
	return i, nil
}

func (m *DelVideoCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelVideoCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.Cid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
	}
	return i, nil
}

func (m *SetStatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetStatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stat != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Stat.Size()))
		n26, err := m.Stat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func encodeFixed64Api(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Api(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NoArgRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *NoReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DescriptionRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	return n
}

func (m *DescriptionReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *MaxAidReply) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	return n
}

func (m *ArcRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	return n
}

func (m *ArcReply) Size() (n int) {
	var l int
	_ = l
	if m.Arc != nil {
		l = m.Arc.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ArcsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Aids) > 0 {
		l = 0
		for _, e := range m.Aids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func (m *ArcsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Arcs) > 0 {
		for k, v := range m.Arcs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ViewRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	return n
}

func (m *StatRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	return n
}

func (m *StatReply) Size() (n int) {
	var l int
	_ = l
	if m.Stat != nil {
		l = m.Stat.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *StatsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Aids) > 0 {
		l = 0
		for _, e := range m.Aids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func (m *StatsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for k, v := range m.Stats {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ViewReply) Size() (n int) {
	var l int
	_ = l
	if m.Arc != nil {
		l = m.Arc.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Pages) > 0 {
		for _, e := range m.Pages {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ViewsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Aids) > 0 {
		l = 0
		for _, e := range m.Aids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func (m *ViewsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Views) > 0 {
		for k, v := range m.Views {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TypesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Types) > 0 {
		for k, v := range m.Types {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ClickRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	return n
}

func (m *ClickReply) Size() (n int) {
	var l int
	_ = l
	if m.Click != nil {
		l = m.Click.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *PageRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	return n
}

func (m *PageReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Pages) > 0 {
		for _, e := range m.Pages {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *RecommendRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	return n
}

func (m *RecommendReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Arcs) > 0 {
		for _, e := range m.Arcs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *VideoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	return n
}

func (m *VideoReply) Size() (n int) {
	var l int
	_ = l
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Tp) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovApi(uint64(m.ID))
	}
	if m.Pid != 0 {
		n += 1 + sovApi(uint64(m.Pid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *AidVideos) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if len(m.Pages) > 0 {
		for _, e := range m.Pages {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *Arc) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Videos != 0 {
		n += 1 + sovApi(uint64(m.Videos))
	}
	if m.TypeID != 0 {
		n += 1 + sovApi(uint64(m.TypeID))
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Copyright != 0 {
		n += 1 + sovApi(uint64(m.Copyright))
	}
	l = len(m.Pic)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PubDate != 0 {
		n += 1 + sovApi(uint64(m.PubDate))
	}
	if m.Ctime != 0 {
		n += 1 + sovApi(uint64(m.Ctime))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovApi(uint64(m.State))
	}
	if m.Access != 0 {
		n += 1 + sovApi(uint64(m.Access))
	}
	if m.Attribute != 0 {
		n += 1 + sovApi(uint64(m.Attribute))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Duration != 0 {
		n += 2 + sovApi(uint64(m.Duration))
	}
	if m.MissionID != 0 {
		n += 2 + sovApi(uint64(m.MissionID))
	}
	if m.OrderID != 0 {
		n += 2 + sovApi(uint64(m.OrderID))
	}
	l = len(m.RedirectURL)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.Forward != 0 {
		n += 2 + sovApi(uint64(m.Forward))
	}
	l = m.Rights.Size()
	n += 2 + l + sovApi(uint64(l))
	l = m.Author.Size()
	n += 2 + l + sovApi(uint64(l))
	l = m.Stat.Size()
	n += 2 + l + sovApi(uint64(l))
	l = len(m.ReportResult)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Dynamic)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.FirstCid != 0 {
		n += 2 + sovApi(uint64(m.FirstCid))
	}
	l = m.Dimension.Size()
	n += 2 + l + sovApi(uint64(l))
	if len(m.StaffInfo) > 0 {
		for _, e := range m.StaffInfo {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *StaffInfo) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Dimension) Size() (n int) {
	var l int
	_ = l
	if m.Width != 0 {
		n += 1 + sovApi(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovApi(uint64(m.Height))
	}
	if m.Rotate != 0 {
		n += 1 + sovApi(uint64(m.Rotate))
	}
	return n
}

func (m *Rights) Size() (n int) {
	var l int
	_ = l
	if m.Bp != 0 {
		n += 1 + sovApi(uint64(m.Bp))
	}
	if m.Elec != 0 {
		n += 1 + sovApi(uint64(m.Elec))
	}
	if m.Download != 0 {
		n += 1 + sovApi(uint64(m.Download))
	}
	if m.Movie != 0 {
		n += 1 + sovApi(uint64(m.Movie))
	}
	if m.Pay != 0 {
		n += 1 + sovApi(uint64(m.Pay))
	}
	if m.HD5 != 0 {
		n += 1 + sovApi(uint64(m.HD5))
	}
	if m.NoReprint != 0 {
		n += 1 + sovApi(uint64(m.NoReprint))
	}
	if m.Autoplay != 0 {
		n += 1 + sovApi(uint64(m.Autoplay))
	}
	if m.UGCPay != 0 {
		n += 1 + sovApi(uint64(m.UGCPay))
	}
	if m.IsCooperation != 0 {
		n += 1 + sovApi(uint64(m.IsCooperation))
	}
	return n
}

func (m *Author) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Stat) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.View != 0 {
		n += 1 + sovApi(uint64(m.View))
	}
	if m.Danmaku != 0 {
		n += 1 + sovApi(uint64(m.Danmaku))
	}
	if m.Reply != 0 {
		n += 1 + sovApi(uint64(m.Reply))
	}
	if m.Fav != 0 {
		n += 1 + sovApi(uint64(m.Fav))
	}
	if m.Coin != 0 {
		n += 1 + sovApi(uint64(m.Coin))
	}
	if m.Share != 0 {
		n += 1 + sovApi(uint64(m.Share))
	}
	if m.NowRank != 0 {
		n += 1 + sovApi(uint64(m.NowRank))
	}
	if m.HisRank != 0 {
		n += 1 + sovApi(uint64(m.HisRank))
	}
	if m.Like != 0 {
		n += 1 + sovApi(uint64(m.Like))
	}
	if m.DisLike != 0 {
		n += 1 + sovApi(uint64(m.DisLike))
	}
	return n
}

func (m *Click) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Web != 0 {
		n += 1 + sovApi(uint64(m.Web))
	}
	if m.Ios != 0 {
		n += 1 + sovApi(uint64(m.Ios))
	}
	if m.Android != 0 {
		n += 1 + sovApi(uint64(m.Android))
	}
	if m.H5 != 0 {
		n += 1 + sovApi(uint64(m.H5))
	}
	if m.Outter != 0 {
		n += 1 + sovApi(uint64(m.Outter))
	}
	return n
}

func (m *Page) Size() (n int) {
	var l int
	_ = l
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	if m.Page != 0 {
		n += 1 + sovApi(uint64(m.Page))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Part)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovApi(uint64(m.Duration))
	}
	l = len(m.Vid)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.WebLink)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = m.Dimension.Size()
	n += 1 + l + sovApi(uint64(l))
	return n
}

func (m *VideoFileInfo) Size() (n int) {
	var l int
	_ = l
	if m.Filesize != 0 {
		n += 1 + sovApi(uint64(m.Filesize))
	}
	if m.Timelength != 0 {
		n += 1 + sovApi(uint64(m.Timelength))
	}
	l = len(m.Ahead)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Vhead)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *VideoFormatFileInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *DashItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.BaseUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Bandwidth != 0 {
		n += 1 + sovApi(uint64(m.Bandwidth))
	}
	if m.Codecid != 0 {
		n += 1 + sovApi(uint64(m.Codecid))
	}
	return n
}

func (m *ResponseDash) Size() (n int) {
	var l int
	_ = l
	if len(m.Video) > 0 {
		for _, e := range m.Video {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Audio) > 0 {
		for _, e := range m.Audio {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *BvcVideoItem) Size() (n int) {
	var l int
	_ = l
	if m.ExpireTime != 0 {
		n += 1 + sovApi(uint64(m.ExpireTime))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	if len(m.SupportQuality) > 0 {
		l = 0
		for _, e := range m.SupportQuality {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.SupportFormats) > 0 {
		for _, s := range m.SupportFormats {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.SupportDescription) > 0 {
		for _, s := range m.SupportDescription {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Quality != 0 {
		n += 1 + sovApi(uint64(m.Quality))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.FileInfo) > 0 {
		for k, v := range m.FileInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.VideoCodecid != 0 {
		n += 1 + sovApi(uint64(m.VideoCodecid))
	}
	if m.VideoProject {
		n += 2
	}
	if m.Fnver != 0 {
		n += 1 + sovApi(uint64(m.Fnver))
	}
	if m.Fnval != 0 {
		n += 1 + sovApi(uint64(m.Fnval))
	}
	if m.Dash != nil {
		l = m.Dash.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *BvcResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovApi(uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ArcCacheRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	l = len(m.Tp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.OldMid != 0 {
		n += 1 + sovApi(uint64(m.OldMid))
	}
	return n
}

func (m *ArcFieldCacheRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.TypeID != 0 {
		n += 1 + sovApi(uint64(m.TypeID))
	}
	if m.OldTypeID != 0 {
		n += 1 + sovApi(uint64(m.OldTypeID))
	}
	return n
}

func (m *UpVideoCacheRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	return n
}

func (m *DelVideoCacheRequest) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	return n
}

func (m *SetStatRequest) Size() (n int) {
	var l int
	_ = l
	if m.Stat != nil {
		l = m.Stat.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NoArgRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoArgRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoArgRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxAidReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxAidReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxAidReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arc == nil {
				m.Arc = &Arc{}
			}
			if err := m.Arc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Aids = append(m.Aids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Aids = append(m.Aids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Aids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arcs == nil {
				m.Arcs = make(map[int64]*Arc)
			}
			var mapkey int64
			var mapvalue *Arc
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Arc{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Arcs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stat == nil {
				m.Stat = &Stat{}
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Aids = append(m.Aids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Aids = append(m.Aids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Aids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = make(map[int64]*Stat)
			}
			var mapkey int64
			var mapvalue *Stat
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Stat{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Stats[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arc == nil {
				m.Arc = &Arc{}
			}
			if err := m.Arc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pages = append(m.Pages, &Page{})
			if err := m.Pages[len(m.Pages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Aids = append(m.Aids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Aids = append(m.Aids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Aids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Views", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Views == nil {
				m.Views = make(map[int64]*ViewReply)
			}
			var mapkey int64
			var mapvalue *ViewReply
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ViewReply{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Views[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Types == nil {
				m.Types = make(map[int32]*Tp)
			}
			var mapkey int32
			var mapvalue *Tp
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Tp{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Types[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClickRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClickRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClickRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClickReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClickReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClickReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Click", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Click == nil {
				m.Click = &Click{}
			}
			if err := m.Click.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pages = append(m.Pages, &Page{})
			if err := m.Pages[len(m.Pages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecommendReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecommendReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecommendReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arcs = append(m.Arcs, &Arc{})
			if err := m.Arcs[len(m.Arcs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Page == nil {
				m.Page = &Page{}
			}
			if err := m.Page.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AidVideos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AidVideos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AidVideos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pages = append(m.Pages, &Page{})
			if err := m.Pages[len(m.Pages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Arc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Arc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Arc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Videos", wireType)
			}
			m.Videos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Videos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Copyright", wireType)
			}
			m.Copyright = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Copyright |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubDate", wireType)
			}
			m.PubDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubDate |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			m.Access = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Access |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			m.Attribute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attribute |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissionID", wireType)
			}
			m.MissionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissionID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forward", wireType)
			}
			m.Forward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Forward |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Author.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportResult", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportResult = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dynamic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dynamic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstCid", wireType)
			}
			m.FirstCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstCid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dimension.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaffInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaffInfo = append(m.StaffInfo, &StaffInfo{})
			if err := m.StaffInfo[len(m.StaffInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dimension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dimension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dimension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate", wireType)
			}
			m.Rotate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rotate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bp", wireType)
			}
			m.Bp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elec", wireType)
			}
			m.Elec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Elec |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Download", wireType)
			}
			m.Download = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Download |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Movie", wireType)
			}
			m.Movie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Movie |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			m.Pay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HD5", wireType)
			}
			m.HD5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HD5 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoReprint", wireType)
			}
			m.NoReprint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoReprint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autoplay", wireType)
			}
			m.Autoplay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Autoplay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UGCPay", wireType)
			}
			m.UGCPay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UGCPay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCooperation", wireType)
			}
			m.IsCooperation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCooperation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Author) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Author: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Author: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Danmaku", wireType)
			}
			m.Danmaku = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Danmaku |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			m.Reply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reply |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fav", wireType)
			}
			m.Fav = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fav |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			m.Share = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Share |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowRank", wireType)
			}
			m.NowRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowRank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HisRank", wireType)
			}
			m.HisRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HisRank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Like", wireType)
			}
			m.Like = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Like |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisLike", wireType)
			}
			m.DisLike = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisLike |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Click) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Click: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Click: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Web", wireType)
			}
			m.Web = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Web |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ios", wireType)
			}
			m.Ios = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ios |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Android", wireType)
			}
			m.Android = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Android |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H5", wireType)
			}
			m.H5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H5 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outter", wireType)
			}
			m.Outter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Outter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Part = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dimension.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoFileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoFileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoFileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filesize", wireType)
			}
			m.Filesize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filesize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timelength", wireType)
			}
			m.Timelength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timelength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ahead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ahead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vhead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vhead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoFormatFileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoFormatFileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoFormatFileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &VideoFileInfo{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DashItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DashItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DashItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			m.Bandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bandwidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codecid", wireType)
			}
			m.Codecid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Codecid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseDash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseDash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseDash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Video = append(m.Video, &DashItem{})
			if err := m.Video[len(m.Video)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audio = append(m.Audio, &DashItem{})
			if err := m.Audio[len(m.Audio)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BvcVideoItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BvcVideoItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BvcVideoItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportQuality = append(m.SupportQuality, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportQuality = append(m.SupportQuality, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportQuality", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportFormats", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportFormats = append(m.SupportFormats, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportDescription = append(m.SupportDescription, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfo == nil {
				m.FileInfo = make(map[uint32]*VideoFormatFileInfo)
			}
			var mapkey uint32
			var mapvalue *VideoFormatFileInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VideoFormatFileInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FileInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoCodecid", wireType)
			}
			m.VideoCodecid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VideoCodecid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoProject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VideoProject = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnver", wireType)
			}
			m.Fnver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnver |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fnval", wireType)
			}
			m.Fnval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fnval |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dash == nil {
				m.Dash = &ResponseDash{}
			}
			if err := m.Dash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BvcResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BvcResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BvcResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[uint32]*BvcVideoItem)
			}
			var mapkey uint32
			var mapvalue *BvcVideoItem
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BvcVideoItem{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldMid", wireType)
			}
			m.OldMid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldMid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArcFieldCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArcFieldCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArcFieldCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldTypeID", wireType)
			}
			m.OldTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldTypeID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpVideoCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpVideoCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpVideoCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelVideoCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelVideoCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelVideoCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetStatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetStatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetStatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stat == nil {
				m.Stat = &Stat{}
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app/service/main/archive/api/api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 2982 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x5a, 0xcf, 0x72, 0x1b, 0xc7,
	0xd1, 0x37, 0xfe, 0x92, 0x68, 0x12, 0x94, 0x34, 0x92, 0xa5, 0x15, 0x44, 0x6b, 0xe9, 0xb5, 0x25,
	0xcb, 0x9f, 0x29, 0xf2, 0xb3, 0x6c, 0xe9, 0xb3, 0xfc, 0xb7, 0x00, 0xc2, 0xb4, 0x68, 0x4b, 0xb2,
	0xbe, 0xb1, 0xfe, 0xc4, 0x4e, 0x55, 0x58, 0xc3, 0xdd, 0x21, 0x31, 0x21, 0x80, 0x5d, 0xef, 0x2e,
	0x40, 0x23, 0x0f, 0x90, 0x53, 0x9e, 0x20, 0x97, 0x54, 0x2e, 0x79, 0x87, 0x54, 0x2a, 0xc7, 0x54,
	0xf9, 0xe8, 0x7b, 0xaa, 0x50, 0x29, 0x1f, 0x72, 0xc0, 0x03, 0xe4, 0xe0, 0x5c, 0x52, 0xdd, 0x33,
	0x00, 0x06, 0x16, 0x16, 0x54, 0xe5, 0x20, 0x62, 0xa7, 0xe7, 0xd7, 0x3d, 0xdd, 0x3d, 0x3d, 0x3d,
	0x3d, 0x33, 0x82, 0xeb, 0x22, 0x8a, 0xb6, 0x13, 0x19, 0xf7, 0x95, 0x2f, 0xb7, 0x3b, 0x42, 0x75,
	0xb7, 0x45, 0xec, 0xb7, 0x54, 0x5f, 0x6e, 0x8b, 0x48, 0xe1, 0xbf, 0xad, 0x28, 0x0e, 0xd3, 0x90,
	0x31, 0x43, 0xde, 0x32, 0xd8, 0xad, 0xfe, 0xdb, 0xb5, 0x9b, 0x47, 0x2a, 0x6d, 0xf5, 0x0e, 0xb6,
	0xfc, 0xb0, 0xb3, 0x7d, 0x14, 0x1e, 0x85, 0xdb, 0x04, 0x3d, 0xe8, 0x1d, 0x52, 0x8b, 0x1a, 0xf4,
	0xa5, 0x45, 0x78, 0x6b, 0xb0, 0xfa, 0x30, 0xac, 0xc7, 0x47, 0x5c, 0x7e, 0xdb, 0x93, 0x49, 0xea,
	0x55, 0x60, 0xe9, 0x61, 0xc8, 0x65, 0xd4, 0x1e, 0x78, 0xd7, 0x81, 0x35, 0x65, 0xe2, 0xc7, 0x2a,
	0x4a, 0x55, 0xd8, 0x35, 0x00, 0x76, 0x16, 0x0a, 0x42, 0x05, 0x4e, 0x6e, 0x23, 0x77, 0xa3, 0xc0,
	0xf1, 0xd3, 0xbb, 0x0e, 0x67, 0x67, 0x70, 0x51, 0x7b, 0xc0, 0x18, 0x14, 0x03, 0x99, 0xf8, 0x04,
	0xab, 0x70, 0xfa, 0xf6, 0x5c, 0x58, 0x79, 0x20, 0xbe, 0xab, 0xab, 0x40, 0x43, 0x9e, 0x17, 0x74,
	0x15, 0xa0, 0x1e, 0xfb, 0xd9, 0x03, 0xdd, 0x86, 0x65, 0xea, 0x47, 0xee, 0x37, 0xa1, 0x20, 0x62,
	0x2d, 0x7f, 0xe5, 0xd6, 0xa5, 0xad, 0xe7, 0x1d, 0xb1, 0x85, 0x50, 0xc4, 0x78, 0xaf, 0xc2, 0x4a,
	0x3d, 0xf6, 0x93, 0xb1, 0x5c, 0x06, 0x45, 0xa1, 0x82, 0xc4, 0xc9, 0x6d, 0x14, 0x6e, 0x14, 0x38,
	0x7d, 0x7b, 0xbf, 0xcf, 0x41, 0x45, 0x63, 0x50, 0xf6, 0x07, 0x50, 0x14, 0xb1, 0xaf, 0x11, 0x2b,
	0xb7, 0xde, 0xc8, 0x10, 0xae, 0xc1, 0xf4, 0xf5, 0x69, 0x37, 0x8d, 0x07, 0x9c, 0x98, 0x6a, 0x8f,
	0xb4, 0x24, 0x22, 0xa1, 0x0d, 0xc7, 0x72, 0x30, 0xb6, 0xe1, 0x58, 0x0e, 0xd8, 0x4d, 0x28, 0xf5,
	0x45, 0xbb, 0x27, 0x9d, 0xfc, 0x62, 0xcd, 0x35, 0xea, 0xfd, 0xfc, 0x7b, 0x39, 0xf4, 0xdb, 0x53,
	0x25, 0x4f, 0xb2, 0xfd, 0xe2, 0xc2, 0xca, 0x57, 0xa9, 0x48, 0xb3, 0x01, 0x77, 0xa1, 0xa2, 0x01,
	0x68, 0xdd, 0x26, 0x14, 0xb1, 0x61, 0x5c, 0xe7, 0xcc, 0x53, 0x80, 0xc0, 0x84, 0xf2, 0x3c, 0x58,
	0xc5, 0xdf, 0x85, 0xde, 0xfb, 0x63, 0x0e, 0xc0, 0x80, 0x70, 0x80, 0x4f, 0xa0, 0x44, 0x2d, 0xe3,
	0xbf, 0x37, 0xb3, 0x46, 0x30, 0x0e, 0xa4, 0x4f, 0xed, 0x41, 0xcd, 0x57, 0xe3, 0x46, 0x5c, 0x96,
	0x0f, 0xb7, 0x66, 0x7d, 0x98, 0x6d, 0x82, 0xe5, 0xc4, 0x08, 0x2a, 0xda, 0x89, 0xa8, 0xe1, 0x3b,
	0x2f, 0x12, 0x3c, 0x8d, 0xe5, 0x1f, 0x86, 0x6e, 0x6e, 0x34, 0x74, 0x5f, 0xa2, 0x30, 0xc2, 0x51,
	0x23, 0x71, 0x24, 0x13, 0x27, 0x4f, 0x66, 0xcd, 0x1d, 0xf5, 0x91, 0x38, 0x92, 0x5c, 0xc3, 0xd0,
	0x73, 0x38, 0xe2, 0x42, 0xcf, 0xfd, 0x29, 0x07, 0x60, 0x40, 0xc6, 0x73, 0x7d, 0x6c, 0x2d, 0xf2,
	0xdc, 0x14, 0xae, 0x3f, 0x8d, 0xe7, 0x88, 0xaf, 0xf6, 0xcc, 0x88, 0xcb, 0xf2, 0xdc, 0x3b, 0xb3,
	0x9e, 0x7b, 0x25, 0x6b, 0x00, 0x92, 0x6f, 0xbb, 0xef, 0x0f, 0x39, 0x80, 0xc7, 0x83, 0x48, 0x4e,
	0x15, 0x4d, 0xb1, 0xb5, 0x48, 0xd1, 0x29, 0x5c, 0x7f, 0x1a, 0x45, 0x89, 0xaf, 0xf6, 0xc8, 0x88,
	0x7b, 0x4e, 0xd1, 0x92, 0x56, 0x74, 0x73, 0x56, 0xd1, 0x8b, 0x73, 0x07, 0x88, 0x6c, 0x0d, 0x37,
	0x60, 0x75, 0xa7, 0xad, 0xfc, 0xe3, 0xec, 0x55, 0xf0, 0x11, 0x80, 0x41, 0xa0, 0x09, 0xdb, 0x50,
	0xf2, 0xb1, 0x65, 0xa2, 0xe0, 0xf2, 0xbc, 0x11, 0x34, 0x5c, 0xe3, 0x70, 0x95, 0xd1, 0xf4, 0x66,
	0xca, 0xff, 0x00, 0x2a, 0x1a, 0x80, 0xe2, 0x27, 0xd1, 0x92, 0x7b, 0xb1, 0x68, 0x79, 0x1d, 0xce,
	0x72, 0xe9, 0x87, 0x9d, 0x8e, 0xec, 0x06, 0x8b, 0x4c, 0x58, 0xb3, 0x50, 0x38, 0xce, 0x5b, 0x33,
	0xb9, 0x2a, 0x33, 0x9d, 0x10, 0xc8, 0xbb, 0x85, 0x21, 0x19, 0xc8, 0x30, 0x73, 0x00, 0xa4, 0xf8,
	0x2a, 0x20, 0xaf, 0x17, 0x38, 0x7e, 0x7a, 0xef, 0x63, 0x48, 0x11, 0x8f, 0x49, 0x1e, 0xa8, 0xef,
	0xa2, 0xe4, 0x41, 0x56, 0x11, 0xca, 0x7b, 0x02, 0xf9, 0xc7, 0x11, 0xbb, 0x08, 0xf9, 0xbd, 0xa6,
	0x9e, 0xdc, 0x46, 0x79, 0x34, 0x74, 0xf3, 0x2a, 0xe0, 0xf9, 0xbd, 0x26, 0xbb, 0x0c, 0x85, 0xc8,
	0x8c, 0x55, 0x6a, 0x2c, 0x8d, 0x86, 0x2e, 0x36, 0x39, 0xfe, 0x61, 0xeb, 0x50, 0xec, 0x8a, 0x8e,
	0x74, 0x0a, 0xb8, 0x7d, 0x34, 0x96, 0x47, 0x43, 0x97, 0xda, 0x9c, 0xfe, 0x7a, 0x02, 0x2a, 0x75,
	0x15, 0x90, 0x56, 0x09, 0x4a, 0xa9, 0x8f, 0x6d, 0xd0, 0x52, 0x04, 0x4a, 0xa9, 0xab, 0x80, 0xdd,
	0x85, 0xd2, 0xa3, 0x17, 0x59, 0xb1, 0x8d, 0xca, 0x68, 0xe8, 0xea, 0x79, 0xe0, 0x9a, 0xc3, 0xfb,
	0x3b, 0x40, 0xa1, 0x1e, 0xfb, 0x8b, 0xa4, 0x7b, 0x50, 0xd6, 0x2a, 0x68, 0x6f, 0x35, 0x60, 0x34,
	0x74, 0xcb, 0x7d, 0xa2, 0x70, 0xd3, 0xc3, 0x5c, 0x28, 0x63, 0x98, 0xef, 0x35, 0xc9, 0x12, 0x63,
	0x65, 0xaa, 0x02, 0x6e, 0xc8, 0xec, 0x1a, 0x2c, 0xe3, 0xd7, 0x43, 0x34, 0xb6, 0x48, 0xc6, 0x92,
	0x2e, 0x29, 0x59, 0x3b, 0xe9, 0x62, 0x6f, 0x41, 0x65, 0x27, 0x8c, 0x06, 0xb1, 0x3a, 0x6a, 0xa5,
	0x4e, 0x89, 0x44, 0x55, 0x47, 0x43, 0xb7, 0xe2, 0x8f, 0x89, 0x7c, 0xda, 0x8f, 0x3a, 0x3f, 0x52,
	0xbe, 0x53, 0x26, 0x71, 0xc6, 0xaf, 0x3e, 0x47, 0x1a, 0x73, 0xa1, 0xf4, 0x58, 0xa5, 0x6d, 0xe9,
	0x2c, 0x59, 0x63, 0x21, 0x81, 0x6b, 0x3a, 0x6b, 0xc2, 0xd2, 0xa3, 0xde, 0x41, 0x53, 0xa4, 0xd2,
	0x59, 0x26, 0xab, 0xfe, 0x67, 0x34, 0x74, 0x97, 0xa2, 0xde, 0x41, 0x20, 0x52, 0xf9, 0xd3, 0xd0,
	0xbd, 0x72, 0x14, 0xde, 0xc4, 0xf8, 0x0b, 0xbb, 0xdb, 0x6d, 0x75, 0x10, 0x8b, 0x78, 0xb0, 0x9d,
	0xaa, 0x8e, 0xdc, 0x7a, 0xac, 0x3a, 0x92, 0x8f, 0x59, 0xd9, 0xc7, 0x50, 0xda, 0x41, 0xb2, 0x53,
	0x21, 0x19, 0x37, 0x70, 0x18, 0x1f, 0x09, 0xa7, 0x49, 0xd0, 0x6c, 0x38, 0xfd, 0x58, 0x51, 0x38,
	0x30, 0x9d, 0x7e, 0xac, 0x20, 0x38, 0x51, 0xd1, 0x08, 0xcc, 0xee, 0xd2, 0x59, 0x21, 0x47, 0x90,
	0x11, 0x09, 0x12, 0xf4, 0xfe, 0x21, 0xd9, 0x26, 0x94, 0xeb, 0xbe, 0x2f, 0x93, 0xc4, 0x59, 0x25,
	0xc4, 0x85, 0xd1, 0xd0, 0x3d, 0x2b, 0x88, 0xb2, 0x19, 0x76, 0x54, 0x2a, 0x3b, 0x51, 0x3a, 0xe0,
	0x06, 0xc3, 0x6e, 0x43, 0xa5, 0x9e, 0xa6, 0xb1, 0x3a, 0xe8, 0xa5, 0xd2, 0xa9, 0x12, 0xc3, 0xa5,
	0xd1, 0xd0, 0x3d, 0x2f, 0xc6, 0x44, 0x8b, 0x67, 0x8a, 0x64, 0x97, 0xa0, 0xf0, 0x58, 0x1c, 0x39,
	0x6b, 0xa4, 0x62, 0x69, 0x34, 0x74, 0x73, 0x37, 0x39, 0x52, 0xd8, 0x75, 0x28, 0x3e, 0x16, 0x47,
	0x89, 0x73, 0x66, 0xa3, 0x70, 0xa3, 0xd2, 0x60, 0xa3, 0xa1, 0xbb, 0x96, 0x8a, 0x23, 0x7b, 0x64,
	0xea, 0x67, 0x37, 0x60, 0xb9, 0xd9, 0x8b, 0x05, 0xd6, 0x4c, 0xce, 0x59, 0xf2, 0xd3, 0xea, 0x68,
	0xe8, 0x2e, 0x07, 0x86, 0xc6, 0x27, 0xbd, 0xec, 0x0e, 0x54, 0x1e, 0xa8, 0x24, 0x51, 0x61, 0x77,
	0xaf, 0xe9, 0x9c, 0x23, 0xa8, 0x33, 0x1a, 0xba, 0x17, 0x3a, 0x9a, 0xb8, 0xaf, 0x02, 0x5b, 0xc5,
	0x09, 0x94, 0xfd, 0x2f, 0x2c, 0x7d, 0x19, 0x07, 0x32, 0xde, 0x6b, 0x3a, 0x8c, 0xb8, 0x2e, 0x8e,
	0x86, 0x2e, 0x0b, 0x91, 0x34, 0xcb, 0x33, 0x86, 0xb1, 0x0f, 0x61, 0x85, 0xcb, 0x40, 0xc5, 0xd2,
	0x4f, 0x9f, 0xf0, 0xfb, 0xce, 0x79, 0x32, 0xae, 0x36, 0x1a, 0xba, 0x17, 0x63, 0x43, 0xde, 0xef,
	0xc5, 0x6d, 0x8b, 0xd3, 0x86, 0xb3, 0x6d, 0x58, 0xda, 0x0d, 0xe3, 0x13, 0x11, 0x07, 0xce, 0x05,
	0x1a, 0xef, 0xe5, 0xd1, 0xd0, 0x3d, 0x77, 0xa8, 0x49, 0xf6, 0x70, 0x06, 0xc5, 0x1a, 0x50, 0xe6,
	0x18, 0xb2, 0x89, 0xf3, 0x32, 0xe5, 0x93, 0xda, 0xbc, 0x15, 0xaa, 0x11, 0x8d, 0xb5, 0xef, 0x87,
	0xee, 0x4b, 0xb8, 0xc4, 0x28, 0xc8, 0x13, 0x6e, 0x38, 0x59, 0x1d, 0xca, 0xf5, 0x5e, 0xda, 0x0a,
	0x63, 0xe7, 0x62, 0xb6, 0x0c, 0x8d, 0x68, 0x54, 0x8d, 0x8c, 0x52, 0x78, 0xd2, 0x95, 0x31, 0x37,
	0x8c, 0xec, 0x7d, 0x53, 0x11, 0x5d, 0x5a, 0x5c, 0x4e, 0x34, 0x56, 0x0d, 0x7b, 0x31, 0x99, 0xd4,
	0x47, 0xec, 0x13, 0x58, 0xe5, 0x32, 0x0a, 0xe3, 0x94, 0xcb, 0xa4, 0xd7, 0x4e, 0x1d, 0x87, 0x5c,
	0x76, 0x65, 0x34, 0x74, 0x2f, 0xc5, 0x44, 0xdf, 0x8f, 0xa9, 0xc3, 0x32, 0x7f, 0x86, 0x81, 0x5d,
	0x83, 0xa5, 0xe6, 0xa0, 0x2b, 0x3a, 0xca, 0x77, 0x2e, 0x13, 0xef, 0x0a, 0xae, 0xb8, 0x40, 0x93,
	0xf8, 0xb8, 0x8f, 0xdd, 0x84, 0xe5, 0x5d, 0x15, 0x27, 0xe9, 0x8e, 0x0a, 0x9c, 0x1a, 0x39, 0xf7,
	0xdc, 0x68, 0xe8, 0x56, 0xfd, 0x99, 0x79, 0x9c, 0x40, 0xd8, 0x2f, 0xa0, 0xd2, 0x54, 0x1d, 0xd9,
	0xc5, 0x48, 0x70, 0xae, 0x64, 0x6f, 0xf6, 0x13, 0x50, 0xe3, 0x8a, 0x31, 0xee, 0x7c, 0x30, 0x26,
	0xd9, 0x41, 0x35, 0xc1, 0xb1, 0x06, 0xd5, 0x92, 0x87, 0x87, 0x7b, 0xdd, 0xc3, 0xd0, 0x59, 0xa7,
	0xc4, 0xfa, 0x4a, 0x86, 0xc7, 0x34, 0x68, 0xbc, 0x38, 0xa6, 0x6c, 0xde, 0x67, 0x96, 0x0c, 0x4c,
	0x57, 0x0f, 0x66, 0x53, 0x6c, 0x07, 0x53, 0xec, 0x03, 0x15, 0x4c, 0xd3, 0x55, 0x7e, 0x7e, 0xba,
	0xf2, 0x52, 0xcb, 0x4c, 0x44, 0x3f, 0x53, 0x41, 0xda, 0x32, 0xa2, 0x08, 0x7d, 0x82, 0x04, 0xae,
	0xe9, 0x98, 0xb1, 0xef, 0x49, 0x4a, 0xa1, 0x56, 0xc6, 0x6e, 0x11, 0x85, 0x9b, 0x1e, 0xc4, 0xf0,
	0x90, 0xb2, 0x4b, 0x61, 0x8a, 0x89, 0x89, 0xc2, 0x4d, 0x8f, 0xf7, 0xaf, 0xfc, 0x38, 0x6e, 0x71,
	0x6f, 0x6b, 0x44, 0xf6, 0xde, 0x76, 0x10, 0xf1, 0x7c, 0x23, 0xc2, 0x0c, 0xf6, 0x69, 0x5b, 0xfa,
	0x66, 0x73, 0xa3, 0x0c, 0x26, 0xdb, 0xd2, 0xe7, 0x44, 0xa5, 0xa5, 0x1f, 0x9e, 0x74, 0xdb, 0xa1,
	0x08, 0xcc, 0xc6, 0xa0, 0x97, 0xbe, 0xa1, 0xf1, 0x49, 0x2f, 0xda, 0xf4, 0x20, 0xec, 0x2b, 0xbd,
	0x39, 0x98, 0x5c, 0xd7, 0x41, 0x02, 0xd7, 0x74, 0x4a, 0xf6, 0x62, 0x60, 0xf6, 0x04, 0x9d, 0xec,
	0xc5, 0x80, 0x23, 0x0d, 0xbb, 0xee, 0x35, 0x6f, 0xd3, 0x3e, 0x60, 0xba, 0x5a, 0xc1, 0x6d, 0x8e,
	0x34, 0xb6, 0x09, 0x15, 0x3a, 0xe5, 0xc5, 0xaa, 0x9b, 0xd2, 0x5e, 0x50, 0x6a, 0xac, 0x8d, 0x86,
	0x2e, 0x74, 0xc3, 0xfd, 0x58, 0x53, 0xf9, 0x14, 0x80, 0xea, 0xd6, 0x7b, 0x69, 0x18, 0xb5, 0xc5,
	0x80, 0x76, 0x05, 0xa3, 0xae, 0x30, 0x34, 0x3e, 0xe9, 0x65, 0xaf, 0x41, 0xf9, 0xc9, 0x67, 0x3b,
	0xa8, 0x50, 0x85, 0x70, 0x14, 0xcb, 0xbd, 0x23, 0x7f, 0x1f, 0x95, 0x32, 0x5d, 0xec, 0x3d, 0xa8,
	0xee, 0x25, 0x3b, 0x61, 0x18, 0x49, 0x93, 0xfd, 0x80, 0xb0, 0x94, 0x29, 0x55, 0xb2, 0xef, 0x4f,
	0x7b, 0xf8, 0x2c, 0xd0, 0xdb, 0x1f, 0xaf, 0xf5, 0x45, 0x41, 0xb3, 0x0e, 0x45, 0xda, 0x4e, 0xf3,
	0x3f, 0xaf, 0x1d, 0x68, 0x27, 0x5d, 0x87, 0xe2, 0xae, 0xf0, 0x67, 0x2a, 0x8b, 0x43, 0xe1, 0x4b,
	0x4e, 0x54, 0xef, 0xdf, 0x79, 0x9d, 0x0a, 0x16, 0xed, 0xfb, 0xeb, 0x50, 0xc4, 0x12, 0xd9, 0x9e,
	0x5a, 0x2c, 0xbe, 0x39, 0x51, 0x69, 0x39, 0x8b, 0x6e, 0x47, 0x1c, 0xf7, 0xcc, 0xcc, 0xea, 0xe5,
	0xac, 0x49, 0x7c, 0xdc, 0x87, 0xf3, 0x4a, 0x05, 0x95, 0x3d, 0xaf, 0xb1, 0x2e, 0xba, 0x75, 0xa1,
	0x75, 0x15, 0x0a, 0xbb, 0xa2, 0x6f, 0xe6, 0x95, 0xdc, 0x7d, 0x28, 0xfa, 0x61, 0xac, 0x52, 0xc9,
	0xb1, 0x03, 0xb5, 0xd8, 0x09, 0x55, 0xd7, 0xcc, 0x2e, 0x69, 0xe1, 0x87, 0xaa, 0xcb, 0x89, 0x4a,
	0x5b, 0x64, 0x4b, 0xc4, 0xd2, 0xcc, 0xad, 0xde, 0x22, 0x91, 0xc0, 0x35, 0x9d, 0x5d, 0xc7, 0x63,
	0xfe, 0x09, 0x17, 0xdd, 0x63, 0x7b, 0x46, 0xbb, 0xe1, 0xc9, 0x7e, 0x2c, 0xba, 0xc7, 0x7c, 0xdc,
	0x89, 0xb8, 0x7b, 0x2a, 0x21, 0x5c, 0x65, 0x8a, 0x6b, 0xa9, 0xc4, 0xe0, 0x4c, 0x27, 0xaa, 0x73,
	0x5f, 0x1d, 0x4b, 0x33, 0x95, 0xa4, 0x4e, 0x5b, 0x1d, 0x4b, 0x4e, 0x54, 0x72, 0x8a, 0x4a, 0x08,
	0xb0, 0x62, 0x39, 0x45, 0x25, 0x84, 0x19, 0xf7, 0x79, 0x7f, 0xc9, 0x41, 0x89, 0x4a, 0xee, 0x45,
	0xee, 0xbf, 0x0c, 0x85, 0x67, 0xf2, 0xc0, 0xae, 0x1a, 0x4f, 0xe4, 0x01, 0x47, 0x1a, 0x76, 0xed,
	0x85, 0x89, 0x5d, 0x6a, 0xa9, 0x30, 0xe1, 0x48, 0x43, 0x0d, 0xea, 0xdd, 0x20, 0x0e, 0x55, 0x60,
	0x3c, 0x4e, 0x1a, 0x08, 0x4d, 0xe2, 0xe3, 0x3e, 0x5c, 0xce, 0xf7, 0x6e, 0x1b, 0xa7, 0xd3, 0x72,
	0x6e, 0xdd, 0xe6, 0xf9, 0x7b, 0xb7, 0x31, 0x2b, 0x7c, 0xd9, 0x4b, 0x53, 0x19, 0x1b, 0x7f, 0x53,
	0x56, 0x08, 0x89, 0xc2, 0x4d, 0x8f, 0xf7, 0xcf, 0x3c, 0x14, 0xb1, 0x78, 0x44, 0x35, 0x76, 0x66,
	0x95, 0xf7, 0x51, 0xf9, 0x1d, 0x1d, 0x3b, 0x08, 0xb1, 0x63, 0x27, 0xa2, 0x72, 0x99, 0x18, 0x31,
	0x36, 0xe3, 0xb0, 0x33, 0x13, 0x9b, 0x71, 0xd8, 0xe1, 0x44, 0xd5, 0xbc, 0x71, 0x6a, 0xca, 0x44,
	0xc3, 0x1b, 0xa7, 0x9c, 0xa8, 0x33, 0xd5, 0x44, 0x69, 0x61, 0x35, 0x71, 0x19, 0x0a, 0x4f, 0x55,
	0x60, 0x97, 0x87, 0x7d, 0x54, 0xef, 0xa9, 0x0a, 0xd8, 0x4d, 0x53, 0x77, 0xe9, 0xea, 0xf0, 0xf2,
	0x68, 0xe8, 0xbe, 0x1c, 0x4c, 0x6f, 0x76, 0xec, 0x0a, 0x86, 0x0a, 0xb1, 0x6b, 0xb0, 0xf4, 0x4c,
	0x1e, 0xdc, 0x57, 0x26, 0x88, 0xcc, 0xd6, 0x75, 0x22, 0x0f, 0xda, 0x0a, 0x63, 0xc3, 0xf4, 0xb1,
	0x87, 0xf6, 0x5e, 0x54, 0x79, 0x91, 0xbd, 0xe8, 0x9c, 0xd9, 0x8b, 0x2a, 0x93, 0xbd, 0xc8, 0xda,
	0x81, 0xbc, 0xbf, 0xe6, 0xa0, 0x4a, 0xf5, 0xf5, 0xae, 0x6a, 0x4b, 0xda, 0x42, 0xde, 0x86, 0xe5,
	0x43, 0xd5, 0x96, 0x89, 0xfa, 0x8d, 0x3e, 0x99, 0x14, 0xa9, 0xf2, 0x98, 0xd0, 0x7e, 0x1a, 0xba,
	0x25, 0xd5, 0x4d, 0xef, 0xbc, 0xcb, 0x27, 0x24, 0xf6, 0x7f, 0x00, 0x58, 0x6a, 0xb6, 0x65, 0xf7,
	0x28, 0x6d, 0xd1, 0x7c, 0x14, 0xa9, 0xec, 0xb3, 0xa8, 0x53, 0x36, 0x8b, 0x88, 0x4b, 0x4b, 0xb4,
	0xa4, 0x49, 0xdc, 0x66, 0x4f, 0x22, 0x02, 0xd7, 0x3f, 0x08, 0xe8, 0x13, 0xc0, 0xaa, 0xe7, 0xfb,
	0x1a, 0x40, 0x3f, 0xde, 0xd7, 0x70, 0x5e, 0xab, 0x1f, 0xc6, 0x1d, 0x91, 0x4e, 0x8c, 0x68, 0x40,
	0x49, 0x75, 0x0f, 0xc3, 0xf1, 0x51, 0xee, 0xd5, 0xf9, 0x67, 0x73, 0xcb, 0x6c, 0x2d, 0x9a, 0x78,
	0xb8, 0xfe, 0xf1, 0xfe, 0x9c, 0x83, 0xe5, 0xa6, 0x48, 0x5a, 0x7b, 0xa9, 0xec, 0x30, 0x17, 0xf2,
	0x26, 0x0c, 0xab, 0x8d, 0x33, 0xfa, 0xdc, 0x35, 0x35, 0x29, 0xaf, 0x02, 0x5c, 0xdc, 0x07, 0x22,
	0x91, 0x4f, 0xe2, 0xb6, 0x49, 0x96, 0x14, 0x32, 0x48, 0xc2, 0x2a, 0x8f, 0x8f, 0x3b, 0xd9, 0xbb,
	0x50, 0x39, 0x10, 0xdd, 0x80, 0xf6, 0x52, 0x32, 0xbb, 0x4a, 0x95, 0xe4, 0x94, 0x38, 0x15, 0x3b,
	0xa5, 0xb1, 0x2d, 0x58, 0xf2, 0xc3, 0x40, 0xfa, 0x66, 0xc9, 0x55, 0xa9, 0x0c, 0x1f, 0x93, 0xa6,
	0x1c, 0x63, 0x8a, 0xf7, 0xbb, 0x1c, 0x96, 0x52, 0x49, 0x14, 0x76, 0x13, 0x89, 0x36, 0xb0, 0x8f,
	0xa0, 0x44, 0xc7, 0x29, 0xe3, 0x90, 0xf5, 0xb9, 0x31, 0x63, 0x8c, 0x35, 0x6e, 0xa6, 0x83, 0xaa,
	0xfe, 0x41, 0x76, 0xd1, 0x0b, 0x54, 0x68, 0x4e, 0x7f, 0x2f, 0xc0, 0x4e, 0x70, 0xae, 0x7f, 0xbc,
	0xbf, 0x95, 0x61, 0xb5, 0xd1, 0xf7, 0xc9, 0xe3, 0xe4, 0xce, 0xbb, 0xb0, 0x22, 0xbf, 0x8b, 0x54,
	0x2c, 0xf7, 0xe9, 0x68, 0xa3, 0xe3, 0x0c, 0xeb, 0x70, 0x9b, 0x6c, 0xc5, 0x8c, 0xa6, 0xe2, 0xb1,
	0x86, 0x79, 0xd3, 0x53, 0x75, 0xb5, 0x71, 0xd6, 0x64, 0x84, 0x29, 0x14, 0x5b, 0x6c, 0x07, 0xce,
	0x24, 0xbd, 0x88, 0x2a, 0xc6, 0x6f, 0x7b, 0xa2, 0xad, 0xd2, 0x81, 0x53, 0xd8, 0x28, 0xdc, 0xa8,
	0x52, 0xf9, 0xfd, 0xf3, 0xae, 0x9f, 0x30, 0xb7, 0x75, 0x53, 0xbe, 0x66, 0xe8, 0xff, 0xaf, 0xc9,
	0xec, 0xc3, 0xa9, 0x90, 0x43, 0x8a, 0xae, 0xc4, 0x29, 0xd2, 0x31, 0xe4, 0xbc, 0x2d, 0xc4, 0x74,
	0x4d, 0xb8, 0x75, 0x20, 0x26, 0xec, 0x1e, 0x9c, 0x1f, 0x43, 0xac, 0x65, 0xef, 0x94, 0x48, 0x02,
	0x9d, 0x89, 0xe6, 0x74, 0x73, 0x66, 0x88, 0xd6, 0x1d, 0x30, 0xdb, 0x84, 0xa5, 0xb1, 0x11, 0x65,
	0x32, 0x1a, 0x37, 0xf7, 0xa5, 0x9f, 0x29, 0x3f, 0x6e, 0x63, 0x46, 0xea, 0xc5, 0x6d, 0x93, 0x75,
	0x28, 0x23, 0x61, 0xf8, 0xe1, 0x1f, 0xf6, 0x0d, 0x54, 0x70, 0xc9, 0xee, 0x63, 0x78, 0x3b, 0xcb,
	0x34, 0x91, 0x5b, 0xf3, 0x26, 0xd2, 0x9e, 0xa9, 0xad, 0xf1, 0x02, 0xa1, 0xcb, 0x25, 0x7d, 0x50,
	0x9e, 0x08, 0xd1, 0x29, 0x80, 0x16, 0xdc, 0x1d, 0xa8, 0x52, 0xa4, 0xec, 0x8f, 0xc3, 0xb4, 0x42,
	0xaa, 0x52, 0x5d, 0x3d, 0xd3, 0xc1, 0x57, 0xa9, 0xb9, 0xa3, 0x5b, 0x53, 0xbe, 0x28, 0x0e, 0x7f,
	0x2d, 0xfd, 0x94, 0x36, 0xbd, 0x65, 0x9b, 0xcf, 0x74, 0x18, 0xbe, 0x47, 0xba, 0xc5, 0xae, 0x43,
	0xe9, 0xb0, 0xdb, 0x97, 0x31, 0xed, 0x81, 0x3a, 0x0e, 0x34, 0x61, 0xec, 0x10, 0xdd, 0x32, 0x38,
	0xd1, 0xa6, 0xd3, 0xeb, 0x14, 0x27, 0xda, 0x36, 0x4e, 0xb4, 0xd9, 0xc7, 0x50, 0x0c, 0x44, 0xd2,
	0xa2, 0x33, 0xeb, 0xca, 0xad, 0x8d, 0xb9, 0x67, 0x27, 0x6b, 0x3d, 0x99, 0x73, 0xb4, 0x48, 0x5a,
	0x9c, 0xfe, 0xd6, 0x02, 0xa8, 0xce, 0x78, 0xca, 0xbe, 0x86, 0xab, 0xea, 0x6b, 0xb8, 0x8f, 0x66,
	0xaf, 0xe1, 0xde, 0xc8, 0xce, 0x49, 0x33, 0xb9, 0xcc, 0xbe, 0x97, 0x1b, 0xe6, 0x60, 0xad, 0xd1,
	0xf7, 0xc7, 0x9a, 0x3c, 0x48, 0x8e, 0xd8, 0x35, 0x28, 0xa2, 0x67, 0x4d, 0x6a, 0x3a, 0xa7, 0x6b,
	0x97, 0xc0, 0x5a, 0x3b, 0xd4, 0x64, 0x9f, 0xa3, 0x7d, 0xa9, 0x30, 0xeb, 0x77, 0x33, 0x63, 0xda,
	0x2d, 0xc1, 0x5b, 0x4d, 0x91, 0x0a, 0x3d, 0xe9, 0xc6, 0xd6, 0x54, 0x70, 0xfa, 0x5b, 0xfb, 0x1a,
	0x2a, 0x93, 0xce, 0x39, 0x76, 0xde, 0x99, 0xb5, 0x73, 0xe3, 0xb4, 0x10, 0xb3, 0x0d, 0xfc, 0x02,
	0xce, 0xd4, 0x63, 0x7f, 0x47, 0xf8, 0xad, 0xec, 0xbb, 0x41, 0xb6, 0x06, 0xf9, 0x34, 0xd2, 0x59,
	0x96, 0xe7, 0xd3, 0x88, 0x5d, 0x84, 0xf2, 0x97, 0xed, 0x00, 0x4b, 0x58, 0x3a, 0x66, 0x70, 0xd3,
	0xf2, 0x7e, 0x05, 0x17, 0xea, 0xb1, 0xbf, 0xab, 0x64, 0x3b, 0x38, 0x45, 0xe2, 0x45, 0x28, 0xa7,
	0xfa, 0x6a, 0x89, 0x8a, 0x09, 0x6e, 0x5a, 0x6c, 0x1d, 0x2a, 0x61, 0x3b, 0xb0, 0x6f, 0x9d, 0xf8,
	0x94, 0xe0, 0xdd, 0x85, 0xf3, 0x4f, 0x22, 0x32, 0xe3, 0x14, 0xf1, 0xf3, 0x2e, 0x02, 0x2f, 0x34,
	0x65, 0xfb, 0xbf, 0xe3, 0xfd, 0x18, 0xd6, 0xbe, 0x92, 0xa9, 0xfd, 0x48, 0xb1, 0x09, 0x74, 0x8a,
	0x3e, 0xfd, 0x15, 0x02, 0x51, 0xb7, 0x7e, 0xbb, 0x02, 0x4b, 0x75, 0x8d, 0x60, 0x7b, 0x50, 0xa2,
	0xab, 0x63, 0x36, 0x77, 0x96, 0xec, 0xc7, 0xac, 0xda, 0xd5, 0xc5, 0xf7, 0xd2, 0x6c, 0x47, 0x5f,
	0xf2, 0x5d, 0xcd, 0xba, 0x35, 0x35, 0x62, 0xd6, 0x33, 0xfb, 0x51, 0xc8, 0x2e, 0x14, 0xeb, 0xb1,
	0x9f, 0x30, 0x37, 0xfb, 0x9d, 0x48, 0x8b, 0x79, 0x65, 0xe1, 0x43, 0x12, 0xca, 0xa1, 0xa3, 0x87,
	0x9b, 0xe9, 0x8b, 0x45, 0x72, 0xa6, 0xef, 0x3b, 0x7b, 0xe6, 0xf9, 0x65, 0xbe, 0x7f, 0xec, 0xc7,
	0x9c, 0xf9, 0xfe, 0xb1, 0x5e, 0x72, 0x76, 0xf5, 0x51, 0x67, 0xbe, 0x4a, 0xd6, 0x9b, 0x54, 0x6d,
	0xf1, 0x43, 0x02, 0xaa, 0x44, 0xcf, 0x12, 0xf3, 0x55, 0xb2, 0x5f, 0x49, 0xe6, 0xab, 0x64, 0x3d,
	0x91, 0xec, 0x8d, 0x8f, 0x08, 0x1b, 0xd9, 0x17, 0xf6, 0x8b, 0x44, 0x59, 0x2f, 0x00, 0xbb, 0xa6,
	0x5e, 0x77, 0x33, 0x6f, 0xb1, 0x17, 0x59, 0x37, 0xbd, 0xea, 0x7f, 0x02, 0x95, 0xc9, 0xa5, 0x3c,
	0x7b, 0x7d, 0x7e, 0x1a, 0x9e, 0xbd, 0xd9, 0xaf, 0x79, 0xa7, 0xa0, 0x26, 0x4e, 0xc3, 0x42, 0x66,
	0x23, 0x33, 0xeb, 0x9e, 0xe2, 0xb4, 0xc9, 0xad, 0xfd, 0x17, 0x50, 0xd6, 0x2f, 0xaf, 0x2f, 0xb0,
	0x66, 0xe6, 0x7a, 0xc3, 0x7e, 0xb7, 0xfd, 0x25, 0xac, 0xd8, 0x5b, 0xfd, 0xf5, 0xb9, 0x75, 0xd5,
	0x73, 0xef, 0xc6, 0xb5, 0xd7, 0x4f, 0xc5, 0xa1, 0xf0, 0xa7, 0x50, 0x9d, 0xc9, 0x7f, 0xec, 0x46,
	0xc6, 0xa2, 0x79, 0x2e, 0x45, 0xd6, 0xae, 0xcc, 0x37, 0x4d, 0xcb, 0xbd, 0x4f, 0x4f, 0xc7, 0x5a,
	0xe4, 0x6b, 0x19, 0x22, 0x5f, 0x5c, 0xda, 0x63, 0x58, 0xb5, 0xb3, 0x28, 0x9b, 0xbb, 0x2f, 0xce,
	0xc9, 0xb3, 0x8b, 0xa5, 0x3e, 0x85, 0xea, 0x4c, 0x82, 0x9d, 0x6f, 0xfb, 0xbc, 0x1c, 0xbc, 0x58,
	0xee, 0xe7, 0xb0, 0x64, 0x92, 0x2f, 0x9b, 0x1b, 0x77, 0xb3, 0x99, 0x79, 0xa1, 0xac, 0xc6, 0xb9,
	0xef, 0x7f, 0xbc, 0x9a, 0xfb, 0xe1, 0xc7, 0xab, 0xb9, 0x7f, 0xfc, 0x78, 0x35, 0xf7, 0x4d, 0x41,
	0x44, 0xea, 0xa0, 0x4c, 0xff, 0x91, 0xe0, 0x9d, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xd3, 0x14,
	0xb5, 0xc5, 0xb5, 0x20, 0x00, 0x00,
}
