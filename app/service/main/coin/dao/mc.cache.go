// Code generated by $GOPATH/src/go-common/app/tool/cache/mc. DO NOT EDIT.

/*
  Package dao is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// get user coin count.
		// mc: -key=countKey
		CacheUserCoin(c context.Context, mid int64) (count float64, err error)
		// set user coin count
		// mc: -key=countKey -expire=d.mcExpire
		AddCacheUserCoin(c context.Context, mid int64, count float64) (err error)
		// mc: -key=itemCoinKey
		CacheItemCoin(c context.Context, aid int64, tp int64) (count int64, err error)
		// mc: -key=itemCoinKey -expire=d.mcExpire
		AddCacheItemCoin(c context.Context, aid int64, count int64, tp int64) (err error)
		// mc: -key=expKey -type=get
		Exp(c context.Context, mid int64) (exp int64, err error)
		// mc: -key=expKey -expire=d.expireExp
		SetTodayExpCache(c context.Context, mid int64, exp int64) (err error)
	}
*/

package dao

import (
	"context"
	"fmt"
	"strconv"

	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
)

var _ _mc

// CacheUserCoin get user coin count.
func (d *Dao) CacheUserCoin(c context.Context, id int64) (res float64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := countKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheUserCoin")
		log.Errorv(c, log.KV("CacheUserCoin", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheUserCoin")
		log.Errorv(c, log.KV("CacheUserCoin", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseFloat(v, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheUserCoin")
		log.Errorv(c, log.KV("CacheUserCoin", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = float64(r)
	return
}

// AddCacheUserCoin set user coin count
func (d *Dao) AddCacheUserCoin(c context.Context, id int64, val float64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := countKey(id)
	bs := []byte(strconv.FormatFloat(val, 'E', -1, 64))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheUserCoin")
		log.Errorv(c, log.KV("AddCacheUserCoin", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheItemCoin get data from mc
func (d *Dao) CacheItemCoin(c context.Context, id int64, tp int64) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := itemCoinKey(id, tp)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheItemCoin")
		log.Errorv(c, log.KV("CacheItemCoin", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheItemCoin")
		log.Errorv(c, log.KV("CacheItemCoin", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheItemCoin")
		log.Errorv(c, log.KV("CacheItemCoin", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheItemCoin Set data to mc
func (d *Dao) AddCacheItemCoin(c context.Context, id int64, val int64, tp int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := itemCoinKey(id, tp)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheItemCoin")
		log.Errorv(c, log.KV("AddCacheItemCoin", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// Exp get data from mc
func (d *Dao) Exp(c context.Context, id int64) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := expKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:Exp")
		log.Errorv(c, log.KV("Exp", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:Exp")
		log.Errorv(c, log.KV("Exp", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:Exp")
		log.Errorv(c, log.KV("Exp", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// SetTodayExpCache Set data to mc
func (d *Dao) SetTodayExpCache(c context.Context, id int64, val int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := expKey(id)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.expireExp, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:SetTodayExpCache")
		log.Errorv(c, log.KV("SetTodayExpCache", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
