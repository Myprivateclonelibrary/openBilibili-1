// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/main/coin/api/api.proto

/*
	Package api is a generated protocol buffer package.

	It is generated from these files:
		app/service/main/coin/api/api.proto

	It has these top-level messages:
		AddCoinReply
		AddCoinReq
		AddUserCoinExpReply
		AddUserCoinExpReq
		CoinsLogReply
		CoinsLogReq
		ItemUserCoinsReply
		ItemUserCoinsReq
		ListReply
		ListReq
		ModelArchiveUserCoins
		ModelArgModifyCoin
		ModelList
		ModelLog
		ModelRecord
		ModifyCoinsReply
		ModifyCoinsReq
		TodayExpReply
		TodayExpReq
		UpdateAddCoinReply
		UpdateAddCoinReq
		UserCoinsReply
		UserCoinsReq
*/
package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// AddCoinReply reply
type AddCoinReply struct {
}

func (m *AddCoinReply) Reset()                    { *m = AddCoinReply{} }
func (m *AddCoinReply) String() string            { return proto.CompactTextString(m) }
func (*AddCoinReply) ProtoMessage()               {}
func (*AddCoinReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

// AddCoinReq req
type AddCoinReq struct {
	// ip
	IP string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip"`
	// mid
	Mid int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"required,min=1"`
	// up 主mid
	Upmid int64 `protobuf:"varint,3,opt,name=upmid,proto3" json:"upmid,omitempty" form:"upid" validate:"required"`
	// 最大投币数
	MaxCoin int64 `protobuf:"varint,4,opt,name=max_coin,json=maxCoin,proto3" json:"max_coin,omitempty" form:"max"`
	// aid
	Aid int64 `protobuf:"varint,5,opt,name=aid,proto3" json:"aid,omitempty" form:"aid" validate:"required"`
	// 业务
	Business string `protobuf:"bytes,6,opt,name=business,proto3" json:"business,omitempty" form:"business" validate:"required"`
	// 数量
	Number int64 `protobuf:"varint,7,opt,name=number,proto3" json:"number,omitempty" form:"number" validate:"required,min=1"`
	// 稿件typeid(稿件专用)
	Typeid int32 `protobuf:"varint,8,opt,name=typeid,proto3" json:"typeid,omitempty" form:"typeid"`
	// 稿件发布时间
	PubTime int64 `protobuf:"varint,9,opt,name=pub_time,json=pubTime,proto3" json:"pub_time,omitempty" form:"pub_time"`
}

func (m *AddCoinReq) Reset()                    { *m = AddCoinReq{} }
func (m *AddCoinReq) String() string            { return proto.CompactTextString(m) }
func (*AddCoinReq) ProtoMessage()               {}
func (*AddCoinReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *AddCoinReq) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *AddCoinReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *AddCoinReq) GetUpmid() int64 {
	if m != nil {
		return m.Upmid
	}
	return 0
}

func (m *AddCoinReq) GetMaxCoin() int64 {
	if m != nil {
		return m.MaxCoin
	}
	return 0
}

func (m *AddCoinReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *AddCoinReq) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

func (m *AddCoinReq) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *AddCoinReq) GetTypeid() int32 {
	if m != nil {
		return m.Typeid
	}
	return 0
}

func (m *AddCoinReq) GetPubTime() int64 {
	if m != nil {
		return m.PubTime
	}
	return 0
}

// AddUserCoinExpReply add coin exp reply
type AddUserCoinExpReply struct {
}

func (m *AddUserCoinExpReply) Reset()                    { *m = AddUserCoinExpReply{} }
func (m *AddUserCoinExpReply) String() string            { return proto.CompactTextString(m) }
func (*AddUserCoinExpReply) ProtoMessage()               {}
func (*AddUserCoinExpReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

// AddUserCoinExpReq req
type AddUserCoinExpReq struct {
	// ip
	IP string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip"`
	// mid
	Mid int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	// business
	Business string `protobuf:"bytes,3,opt,name=business,proto3" json:"business,omitempty"`
	// number
	Number int64 `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *AddUserCoinExpReq) Reset()                    { *m = AddUserCoinExpReq{} }
func (m *AddUserCoinExpReq) String() string            { return proto.CompactTextString(m) }
func (*AddUserCoinExpReq) ProtoMessage()               {}
func (*AddUserCoinExpReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *AddUserCoinExpReq) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *AddUserCoinExpReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *AddUserCoinExpReq) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

func (m *AddUserCoinExpReq) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

// CoinsLogReply reply
type CoinsLogReply struct {
	// log
	List []*ModelLog `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *CoinsLogReply) Reset()                    { *m = CoinsLogReply{} }
func (m *CoinsLogReply) String() string            { return proto.CompactTextString(m) }
func (*CoinsLogReply) ProtoMessage()               {}
func (*CoinsLogReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

func (m *CoinsLogReply) GetList() []*ModelLog {
	if m != nil {
		return m.List
	}
	return nil
}

// CoinsLogReq req
type CoinsLogReq struct {
	// mid
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid"  validate:"required,min=1"`
	// 返回最近一周还是全部
	Recent bool `protobuf:"varint,2,opt,name=recent,proto3" json:"recent,omitempty" form:"recent"`
	// 翻译后的格式 还是原始格式
	Translate bool `protobuf:"varint,3,opt,name=translate,proto3" json:"translate,omitempty" form:"translate"`
}

func (m *CoinsLogReq) Reset()                    { *m = CoinsLogReq{} }
func (m *CoinsLogReq) String() string            { return proto.CompactTextString(m) }
func (*CoinsLogReq) ProtoMessage()               {}
func (*CoinsLogReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *CoinsLogReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *CoinsLogReq) GetRecent() bool {
	if m != nil {
		return m.Recent
	}
	return false
}

func (m *CoinsLogReq) GetTranslate() bool {
	if m != nil {
		return m.Translate
	}
	return false
}

// ItemUserCoinsReply reply
type ItemUserCoinsReply struct {
	// number
	Number int64 `protobuf:"varint,1,opt,name=number,proto3" json:"number"`
}

func (m *ItemUserCoinsReply) Reset()                    { *m = ItemUserCoinsReply{} }
func (m *ItemUserCoinsReply) String() string            { return proto.CompactTextString(m) }
func (*ItemUserCoinsReply) ProtoMessage()               {}
func (*ItemUserCoinsReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

func (m *ItemUserCoinsReply) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

// ItemUserCoinsReq req
type ItemUserCoinsReq struct {
	// mid
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid"  validate:"required"`
	// aid
	Aid int64 `protobuf:"varint,2,opt,name=aid,proto3" json:"aid,omitempty" form:"aid" validate:"required"`
	// 业务
	Business string `protobuf:"bytes,3,opt,name=business,proto3" json:"business,omitempty" form:"business" validate:"required"`
}

func (m *ItemUserCoinsReq) Reset()                    { *m = ItemUserCoinsReq{} }
func (m *ItemUserCoinsReq) String() string            { return proto.CompactTextString(m) }
func (*ItemUserCoinsReq) ProtoMessage()               {}
func (*ItemUserCoinsReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

func (m *ItemUserCoinsReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ItemUserCoinsReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *ItemUserCoinsReq) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

// ListReply reply
type ListReply struct {
	// log
	List []*ModelList `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *ListReply) Reset()                    { *m = ListReply{} }
func (m *ListReply) String() string            { return proto.CompactTextString(m) }
func (*ListReply) ProtoMessage()               {}
func (*ListReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

func (m *ListReply) GetList() []*ModelList {
	if m != nil {
		return m.List
	}
	return nil
}

// ListReq .
type ListReq struct {
	// mid
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	// business
	Business string `protobuf:"bytes,2,opt,name=business,proto3" json:"business,omitempty"`
	// 时间戳
	Ts int64 `protobuf:"varint,3,opt,name=ts,proto3" json:"ts,omitempty"`
}

func (m *ListReq) Reset()                    { *m = ListReq{} }
func (m *ListReq) String() string            { return proto.CompactTextString(m) }
func (*ListReq) ProtoMessage()               {}
func (*ListReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

func (m *ListReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ListReq) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

func (m *ListReq) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

// ModelArchiveUserCoins .
type ModelArchiveUserCoins struct {
	// number
	Number int64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *ModelArchiveUserCoins) Reset()                    { *m = ModelArchiveUserCoins{} }
func (m *ModelArchiveUserCoins) String() string            { return proto.CompactTextString(m) }
func (*ModelArchiveUserCoins) ProtoMessage()               {}
func (*ModelArchiveUserCoins) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

func (m *ModelArchiveUserCoins) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

// ModelArgModifyCoin .
type ModelArgModifyCoin struct {
	// mid
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	// count
	Count float64 `protobuf:"fixed64,2,opt,name=count,proto3" json:"count,omitempty"`
	// 原因
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// ip
	IP string `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip"`
	// 操作人
	Operator string `protobuf:"bytes,5,opt,name=operator,proto3" json:"operator,omitempty"`
	// 是否要检查余额数量 默认检查 为1则不检查
	CheckZero int32 `protobuf:"varint,6,opt,name=check_zero,json=checkZero,proto3" json:"check_zero,omitempty"`
}

func (m *ModelArgModifyCoin) Reset()                    { *m = ModelArgModifyCoin{} }
func (m *ModelArgModifyCoin) String() string            { return proto.CompactTextString(m) }
func (*ModelArgModifyCoin) ProtoMessage()               {}
func (*ModelArgModifyCoin) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

func (m *ModelArgModifyCoin) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ModelArgModifyCoin) GetCount() float64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ModelArgModifyCoin) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ModelArgModifyCoin) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *ModelArgModifyCoin) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *ModelArgModifyCoin) GetCheckZero() int32 {
	if m != nil {
		return m.CheckZero
	}
	return 0
}

// ModelList .
type ModelList struct {
	// aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
	// number
	Number int64 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
	// 时间戳
	Ts int64 `protobuf:"varint,3,opt,name=ts,proto3" json:"ts,omitempty"`
	// ip
	IP uint32 `protobuf:"varint,4,opt,name=ip,proto3" json:"ip"`
}

func (m *ModelList) Reset()                    { *m = ModelList{} }
func (m *ModelList) String() string            { return proto.CompactTextString(m) }
func (*ModelList) ProtoMessage()               {}
func (*ModelList) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

func (m *ModelList) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *ModelList) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *ModelList) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *ModelList) GetIP() uint32 {
	if m != nil {
		return m.IP
	}
	return 0
}

// ModelLog .
type ModelLog struct {
	// 修改前硬币数
	From float64 `protobuf:"fixed64,1,opt,name=from,proto3" json:"from,omitempty"`
	// 修改后硬币数
	To float64 `protobuf:"fixed64,2,opt,name=to,proto3" json:"to,omitempty"`
	// ip
	IP string `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip"`
	// 原因
	Desc string `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
	// 时间戳
	TimeStamp int64 `protobuf:"varint,5,opt,name=time_stamp,json=timeStamp,proto3" json:"time_stamp,omitempty"`
}

func (m *ModelLog) Reset()                    { *m = ModelLog{} }
func (m *ModelLog) String() string            { return proto.CompactTextString(m) }
func (*ModelLog) ProtoMessage()               {}
func (*ModelLog) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{13} }

func (m *ModelLog) GetFrom() float64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *ModelLog) GetTo() float64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *ModelLog) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *ModelLog) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *ModelLog) GetTimeStamp() int64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

// ModelRecord record
type ModelRecord struct {
	// aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
	// mid
	Mid int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	// up主id
	Up int64 `protobuf:"varint,3,opt,name=up,proto3" json:"up,omitempty"`
	// 时间戳
	Timestamp int64 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// number
	Number int64 `protobuf:"varint,5,opt,name=number,proto3" json:"number,omitempty"`
	// 业务
	Business string `protobuf:"bytes,6,opt,name=business,proto3" json:"business,omitempty"`
	// ip
	IP uint32 `protobuf:"varint,7,opt,name=ip,proto3" json:"ip"`
}

func (m *ModelRecord) Reset()                    { *m = ModelRecord{} }
func (m *ModelRecord) String() string            { return proto.CompactTextString(m) }
func (*ModelRecord) ProtoMessage()               {}
func (*ModelRecord) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{14} }

func (m *ModelRecord) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *ModelRecord) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ModelRecord) GetUp() int64 {
	if m != nil {
		return m.Up
	}
	return 0
}

func (m *ModelRecord) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ModelRecord) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *ModelRecord) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

func (m *ModelRecord) GetIP() uint32 {
	if m != nil {
		return m.IP
	}
	return 0
}

// ModifyCoinsReply reply
type ModifyCoinsReply struct {
	// result
	Result float64 `protobuf:"fixed64,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *ModifyCoinsReply) Reset()                    { *m = ModifyCoinsReply{} }
func (m *ModifyCoinsReply) String() string            { return proto.CompactTextString(m) }
func (*ModifyCoinsReply) ProtoMessage()               {}
func (*ModifyCoinsReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{15} }

func (m *ModifyCoinsReply) GetResult() float64 {
	if m != nil {
		return m.Result
	}
	return 0
}

// ModifyCoinsReq req
type ModifyCoinsReq struct {
	// mid
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"required"`
	// 变更的计数 例如10为硬币数加10
	Count float64 `protobuf:"fixed64,2,opt,name=count,proto3" json:"count,omitempty" form:"count" validate:"required"`
	// 改变的原因
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty" form:"reason" validate:"required"`
	// ip
	IP string `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip"`
	// 操作人
	Operator string `protobuf:"bytes,5,opt,name=operator,proto3" json:"operator,omitempty" form:"operator"`
	// 是否要检查余额数量 默认检查 为1则不检查
	CheckZero int32 `protobuf:"varint,6,opt,name=check_zero,json=checkZero,proto3" json:"check_zero,omitempty" form:"check_zero"`
	// 时间戳
	Ts int64 `protobuf:"varint,7,opt,name=ts,proto3" json:"ts,omitempty"`
}

func (m *ModifyCoinsReq) Reset()                    { *m = ModifyCoinsReq{} }
func (m *ModifyCoinsReq) String() string            { return proto.CompactTextString(m) }
func (*ModifyCoinsReq) ProtoMessage()               {}
func (*ModifyCoinsReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{16} }

func (m *ModifyCoinsReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ModifyCoinsReq) GetCount() float64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ModifyCoinsReq) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ModifyCoinsReq) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *ModifyCoinsReq) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *ModifyCoinsReq) GetCheckZero() int32 {
	if m != nil {
		return m.CheckZero
	}
	return 0
}

func (m *ModifyCoinsReq) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

// TodayExpReply reply
type TodayExpReply struct {
	// exp
	Exp int64 `protobuf:"varint,1,opt,name=exp,proto3" json:"exp,omitempty"`
}

func (m *TodayExpReply) Reset()                    { *m = TodayExpReply{} }
func (m *TodayExpReply) String() string            { return proto.CompactTextString(m) }
func (*TodayExpReply) ProtoMessage()               {}
func (*TodayExpReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{17} }

func (m *TodayExpReply) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

// TodayExpReq req
type TodayExpReq struct {
	// mid
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"required,min=1"`
}

func (m *TodayExpReq) Reset()                    { *m = TodayExpReq{} }
func (m *TodayExpReq) String() string            { return proto.CompactTextString(m) }
func (*TodayExpReq) ProtoMessage()               {}
func (*TodayExpReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{18} }

func (m *TodayExpReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

// UpdateAddCoinReply reply
type UpdateAddCoinReply struct {
}

func (m *UpdateAddCoinReply) Reset()                    { *m = UpdateAddCoinReply{} }
func (m *UpdateAddCoinReply) String() string            { return proto.CompactTextString(m) }
func (*UpdateAddCoinReply) ProtoMessage()               {}
func (*UpdateAddCoinReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{19} }

// UpdateAddCoinReq req
type UpdateAddCoinReq struct {
	// aid
	Aid int64 `protobuf:"varint,1,opt,name=aid,proto3" json:"aid,omitempty"`
	// mid
	Mid int64 `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	// up mid
	Up int64 `protobuf:"varint,3,opt,name=up,proto3" json:"up,omitempty"`
	// timestamp
	Timestamp int64 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// number
	Number int64 `protobuf:"varint,5,opt,name=number,proto3" json:"number,omitempty"`
	// business
	Business string `protobuf:"bytes,6,opt,name=business,proto3" json:"business,omitempty"`
	// ip
	IP   uint32 `protobuf:"varint,7,opt,name=ip,proto3" json:"ip"`
	IPV6 string `protobuf:"bytes,8,opt,name=ipv6,proto3" json:"ip_v6"`
}

func (m *UpdateAddCoinReq) Reset()                    { *m = UpdateAddCoinReq{} }
func (m *UpdateAddCoinReq) String() string            { return proto.CompactTextString(m) }
func (*UpdateAddCoinReq) ProtoMessage()               {}
func (*UpdateAddCoinReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{20} }

func (m *UpdateAddCoinReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *UpdateAddCoinReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *UpdateAddCoinReq) GetUp() int64 {
	if m != nil {
		return m.Up
	}
	return 0
}

func (m *UpdateAddCoinReq) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UpdateAddCoinReq) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *UpdateAddCoinReq) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

func (m *UpdateAddCoinReq) GetIP() uint32 {
	if m != nil {
		return m.IP
	}
	return 0
}

func (m *UpdateAddCoinReq) GetIPV6() string {
	if m != nil {
		return m.IPV6
	}
	return ""
}

// UserCoinsReply reply
type UserCoinsReply struct {
	// count
	Count float64 `protobuf:"fixed64,1,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *UserCoinsReply) Reset()                    { *m = UserCoinsReply{} }
func (m *UserCoinsReply) String() string            { return proto.CompactTextString(m) }
func (*UserCoinsReply) ProtoMessage()               {}
func (*UserCoinsReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{21} }

func (m *UserCoinsReply) GetCount() float64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// UserCoinsReq req
type UserCoinsReq struct {
	// mid
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty" form:"mid" validate:"required,min=1"`
}

func (m *UserCoinsReq) Reset()                    { *m = UserCoinsReq{} }
func (m *UserCoinsReq) String() string            { return proto.CompactTextString(m) }
func (*UserCoinsReq) ProtoMessage()               {}
func (*UserCoinsReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{22} }

func (m *UserCoinsReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func init() {
	proto.RegisterType((*AddCoinReply)(nil), "community.service.coin.v1.AddCoinReply")
	proto.RegisterType((*AddCoinReq)(nil), "community.service.coin.v1.AddCoinReq")
	proto.RegisterType((*AddUserCoinExpReply)(nil), "community.service.coin.v1.AddUserCoinExpReply")
	proto.RegisterType((*AddUserCoinExpReq)(nil), "community.service.coin.v1.AddUserCoinExpReq")
	proto.RegisterType((*CoinsLogReply)(nil), "community.service.coin.v1.CoinsLogReply")
	proto.RegisterType((*CoinsLogReq)(nil), "community.service.coin.v1.CoinsLogReq")
	proto.RegisterType((*ItemUserCoinsReply)(nil), "community.service.coin.v1.ItemUserCoinsReply")
	proto.RegisterType((*ItemUserCoinsReq)(nil), "community.service.coin.v1.ItemUserCoinsReq")
	proto.RegisterType((*ListReply)(nil), "community.service.coin.v1.ListReply")
	proto.RegisterType((*ListReq)(nil), "community.service.coin.v1.ListReq")
	proto.RegisterType((*ModelArchiveUserCoins)(nil), "community.service.coin.v1.ModelArchiveUserCoins")
	proto.RegisterType((*ModelArgModifyCoin)(nil), "community.service.coin.v1.ModelArgModifyCoin")
	proto.RegisterType((*ModelList)(nil), "community.service.coin.v1.ModelList")
	proto.RegisterType((*ModelLog)(nil), "community.service.coin.v1.ModelLog")
	proto.RegisterType((*ModelRecord)(nil), "community.service.coin.v1.ModelRecord")
	proto.RegisterType((*ModifyCoinsReply)(nil), "community.service.coin.v1.ModifyCoinsReply")
	proto.RegisterType((*ModifyCoinsReq)(nil), "community.service.coin.v1.ModifyCoinsReq")
	proto.RegisterType((*TodayExpReply)(nil), "community.service.coin.v1.TodayExpReply")
	proto.RegisterType((*TodayExpReq)(nil), "community.service.coin.v1.TodayExpReq")
	proto.RegisterType((*UpdateAddCoinReply)(nil), "community.service.coin.v1.UpdateAddCoinReply")
	proto.RegisterType((*UpdateAddCoinReq)(nil), "community.service.coin.v1.UpdateAddCoinReq")
	proto.RegisterType((*UserCoinsReply)(nil), "community.service.coin.v1.UserCoinsReply")
	proto.RegisterType((*UserCoinsReq)(nil), "community.service.coin.v1.UserCoinsReq")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Coin service

type CoinClient interface {
	// AddCoin add coin. 投币接口
	AddCoin(ctx context.Context, in *AddCoinReq, opts ...grpc.CallOption) (*AddCoinReply, error)
	// ItemUserCoins get coins added of archive. 投币数量接口
	ItemUserCoins(ctx context.Context, in *ItemUserCoinsReq, opts ...grpc.CallOption) (*ItemUserCoinsReply, error)
	// UserCoins get user coins. 用户硬币余额
	UserCoins(ctx context.Context, in *UserCoinsReq, opts ...grpc.CallOption) (*UserCoinsReply, error)
	// ModifyCoins modify user coins. 修改硬币数
	ModifyCoins(ctx context.Context, in *ModifyCoinsReq, opts ...grpc.CallOption) (*ModifyCoinsReply, error)
	// List get coin added list.投币列表
	List(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListReply, error)
	// CoinsLog coins log 投币日志
	CoinsLog(ctx context.Context, in *CoinsLogReq, opts ...grpc.CallOption) (*CoinsLogReply, error)
	// AddUserCoinExp add user coin exp for job
	AddUserCoinExp(ctx context.Context, in *AddUserCoinExpReq, opts ...grpc.CallOption) (*AddUserCoinExpReply, error)
	// UpdateAddCoin update db after add coin for job.
	UpdateAddCoin(ctx context.Context, in *UpdateAddCoinReq, opts ...grpc.CallOption) (*UpdateAddCoinReply, error)
	// TodayExp get today coin added exp. 今日投币经验
	TodayExp(ctx context.Context, in *TodayExpReq, opts ...grpc.CallOption) (*TodayExpReply, error)
}

type coinClient struct {
	cc *grpc.ClientConn
}

func NewCoinClient(cc *grpc.ClientConn) CoinClient {
	return &coinClient{cc}
}

func (c *coinClient) AddCoin(ctx context.Context, in *AddCoinReq, opts ...grpc.CallOption) (*AddCoinReply, error) {
	out := new(AddCoinReply)
	err := grpc.Invoke(ctx, "/community.service.coin.v1.Coin/AddCoin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinClient) ItemUserCoins(ctx context.Context, in *ItemUserCoinsReq, opts ...grpc.CallOption) (*ItemUserCoinsReply, error) {
	out := new(ItemUserCoinsReply)
	err := grpc.Invoke(ctx, "/community.service.coin.v1.Coin/ItemUserCoins", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinClient) UserCoins(ctx context.Context, in *UserCoinsReq, opts ...grpc.CallOption) (*UserCoinsReply, error) {
	out := new(UserCoinsReply)
	err := grpc.Invoke(ctx, "/community.service.coin.v1.Coin/UserCoins", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinClient) ModifyCoins(ctx context.Context, in *ModifyCoinsReq, opts ...grpc.CallOption) (*ModifyCoinsReply, error) {
	out := new(ModifyCoinsReply)
	err := grpc.Invoke(ctx, "/community.service.coin.v1.Coin/ModifyCoins", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinClient) List(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*ListReply, error) {
	out := new(ListReply)
	err := grpc.Invoke(ctx, "/community.service.coin.v1.Coin/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinClient) CoinsLog(ctx context.Context, in *CoinsLogReq, opts ...grpc.CallOption) (*CoinsLogReply, error) {
	out := new(CoinsLogReply)
	err := grpc.Invoke(ctx, "/community.service.coin.v1.Coin/CoinsLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinClient) AddUserCoinExp(ctx context.Context, in *AddUserCoinExpReq, opts ...grpc.CallOption) (*AddUserCoinExpReply, error) {
	out := new(AddUserCoinExpReply)
	err := grpc.Invoke(ctx, "/community.service.coin.v1.Coin/AddUserCoinExp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinClient) UpdateAddCoin(ctx context.Context, in *UpdateAddCoinReq, opts ...grpc.CallOption) (*UpdateAddCoinReply, error) {
	out := new(UpdateAddCoinReply)
	err := grpc.Invoke(ctx, "/community.service.coin.v1.Coin/UpdateAddCoin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coinClient) TodayExp(ctx context.Context, in *TodayExpReq, opts ...grpc.CallOption) (*TodayExpReply, error) {
	out := new(TodayExpReply)
	err := grpc.Invoke(ctx, "/community.service.coin.v1.Coin/TodayExp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Coin service

type CoinServer interface {
	// AddCoin add coin. 投币接口
	AddCoin(context.Context, *AddCoinReq) (*AddCoinReply, error)
	// ItemUserCoins get coins added of archive. 投币数量接口
	ItemUserCoins(context.Context, *ItemUserCoinsReq) (*ItemUserCoinsReply, error)
	// UserCoins get user coins. 用户硬币余额
	UserCoins(context.Context, *UserCoinsReq) (*UserCoinsReply, error)
	// ModifyCoins modify user coins. 修改硬币数
	ModifyCoins(context.Context, *ModifyCoinsReq) (*ModifyCoinsReply, error)
	// List get coin added list.投币列表
	List(context.Context, *ListReq) (*ListReply, error)
	// CoinsLog coins log 投币日志
	CoinsLog(context.Context, *CoinsLogReq) (*CoinsLogReply, error)
	// AddUserCoinExp add user coin exp for job
	AddUserCoinExp(context.Context, *AddUserCoinExpReq) (*AddUserCoinExpReply, error)
	// UpdateAddCoin update db after add coin for job.
	UpdateAddCoin(context.Context, *UpdateAddCoinReq) (*UpdateAddCoinReply, error)
	// TodayExp get today coin added exp. 今日投币经验
	TodayExp(context.Context, *TodayExpReq) (*TodayExpReply, error)
}

func RegisterCoinServer(s *grpc.Server, srv CoinServer) {
	s.RegisterService(&_Coin_serviceDesc, srv)
}

func _Coin_AddCoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCoinReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinServer).AddCoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.coin.v1.Coin/AddCoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinServer).AddCoin(ctx, req.(*AddCoinReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coin_ItemUserCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ItemUserCoinsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinServer).ItemUserCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.coin.v1.Coin/ItemUserCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinServer).ItemUserCoins(ctx, req.(*ItemUserCoinsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coin_UserCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCoinsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinServer).UserCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.coin.v1.Coin/UserCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinServer).UserCoins(ctx, req.(*UserCoinsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coin_ModifyCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyCoinsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinServer).ModifyCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.coin.v1.Coin/ModifyCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinServer).ModifyCoins(ctx, req.(*ModifyCoinsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coin_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.coin.v1.Coin/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinServer).List(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coin_CoinsLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoinsLogReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinServer).CoinsLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.coin.v1.Coin/CoinsLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinServer).CoinsLog(ctx, req.(*CoinsLogReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coin_AddUserCoinExp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserCoinExpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinServer).AddUserCoinExp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.coin.v1.Coin/AddUserCoinExp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinServer).AddUserCoinExp(ctx, req.(*AddUserCoinExpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coin_UpdateAddCoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAddCoinReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinServer).UpdateAddCoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.coin.v1.Coin/UpdateAddCoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinServer).UpdateAddCoin(ctx, req.(*UpdateAddCoinReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Coin_TodayExp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TodayExpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinServer).TodayExp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.coin.v1.Coin/TodayExp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinServer).TodayExp(ctx, req.(*TodayExpReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Coin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "community.service.coin.v1.Coin",
	HandlerType: (*CoinServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCoin",
			Handler:    _Coin_AddCoin_Handler,
		},
		{
			MethodName: "ItemUserCoins",
			Handler:    _Coin_ItemUserCoins_Handler,
		},
		{
			MethodName: "UserCoins",
			Handler:    _Coin_UserCoins_Handler,
		},
		{
			MethodName: "ModifyCoins",
			Handler:    _Coin_ModifyCoins_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Coin_List_Handler,
		},
		{
			MethodName: "CoinsLog",
			Handler:    _Coin_CoinsLog_Handler,
		},
		{
			MethodName: "AddUserCoinExp",
			Handler:    _Coin_AddUserCoinExp_Handler,
		},
		{
			MethodName: "UpdateAddCoin",
			Handler:    _Coin_UpdateAddCoin_Handler,
		},
		{
			MethodName: "TodayExp",
			Handler:    _Coin_TodayExp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/main/coin/api/api.proto",
}

func (m *AddCoinReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddCoinReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddCoinReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddCoinReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IP) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Upmid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Upmid))
	}
	if m.MaxCoin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaxCoin))
	}
	if m.Aid != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	if m.Number != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Number))
	}
	if m.Typeid != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Typeid))
	}
	if m.PubTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PubTime))
	}
	return i, nil
}

func (m *AddUserCoinExpReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddUserCoinExpReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddUserCoinExpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddUserCoinExpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IP) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	if m.Number != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *CoinsLogReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinsLogReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CoinsLogReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinsLogReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Recent {
		dAtA[i] = 0x10
		i++
		if m.Recent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Translate {
		dAtA[i] = 0x18
		i++
		if m.Translate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ItemUserCoinsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemUserCoinsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *ItemUserCoinsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemUserCoinsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Aid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	return i, nil
}

func (m *ListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	if m.Ts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ts))
	}
	return i, nil
}

func (m *ModelArchiveUserCoins) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelArchiveUserCoins) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *ModelArgModifyCoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelArgModifyCoin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Count != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Count))))
		i += 8
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.IP) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if len(m.Operator) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Operator)))
		i += copy(dAtA[i:], m.Operator)
	}
	if m.CheckZero != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CheckZero))
	}
	return i, nil
}

func (m *ModelList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Number))
	}
	if m.Ts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ts))
	}
	if m.IP != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IP))
	}
	return i, nil
}

func (m *ModelLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.From))))
		i += 8
	}
	if m.To != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.To))))
		i += 8
	}
	if len(m.IP) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TimeStamp))
	}
	return i, nil
}

func (m *ModelRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Up != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Up))
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
	}
	if m.Number != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Number))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	if m.IP != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IP))
	}
	return i, nil
}

func (m *ModifyCoinsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyCoinsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Result))))
		i += 8
	}
	return i, nil
}

func (m *ModifyCoinsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyCoinsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Count != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Count))))
		i += 8
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.IP) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if len(m.Operator) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Operator)))
		i += copy(dAtA[i:], m.Operator)
	}
	if m.CheckZero != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CheckZero))
	}
	if m.Ts != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ts))
	}
	return i, nil
}

func (m *TodayExpReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TodayExpReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Exp))
	}
	return i, nil
}

func (m *TodayExpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TodayExpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	return i, nil
}

func (m *UpdateAddCoinReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAddCoinReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpdateAddCoinReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAddCoinReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Aid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Up != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Up))
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Timestamp))
	}
	if m.Number != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Number))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	if m.IP != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.IP))
	}
	if len(m.IPV6) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.IPV6)))
		i += copy(dAtA[i:], m.IPV6)
	}
	return i, nil
}

func (m *UserCoinsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCoinsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Count))))
		i += 8
	}
	return i, nil
}

func (m *UserCoinsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCoinsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AddCoinReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddCoinReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Upmid != 0 {
		n += 1 + sovApi(uint64(m.Upmid))
	}
	if m.MaxCoin != 0 {
		n += 1 + sovApi(uint64(m.MaxCoin))
	}
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovApi(uint64(m.Number))
	}
	if m.Typeid != 0 {
		n += 1 + sovApi(uint64(m.Typeid))
	}
	if m.PubTime != 0 {
		n += 1 + sovApi(uint64(m.PubTime))
	}
	return n
}

func (m *AddUserCoinExpReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddUserCoinExpReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovApi(uint64(m.Number))
	}
	return n
}

func (m *CoinsLogReply) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *CoinsLogReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Recent {
		n += 2
	}
	if m.Translate {
		n += 2
	}
	return n
}

func (m *ItemUserCoinsReply) Size() (n int) {
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovApi(uint64(m.Number))
	}
	return n
}

func (m *ItemUserCoinsReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListReply) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ListReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovApi(uint64(m.Ts))
	}
	return n
}

func (m *ModelArchiveUserCoins) Size() (n int) {
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovApi(uint64(m.Number))
	}
	return n
}

func (m *ModelArgModifyCoin) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Count != 0 {
		n += 9
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CheckZero != 0 {
		n += 1 + sovApi(uint64(m.CheckZero))
	}
	return n
}

func (m *ModelList) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Number != 0 {
		n += 1 + sovApi(uint64(m.Number))
	}
	if m.Ts != 0 {
		n += 1 + sovApi(uint64(m.Ts))
	}
	if m.IP != 0 {
		n += 1 + sovApi(uint64(m.IP))
	}
	return n
}

func (m *ModelLog) Size() (n int) {
	var l int
	_ = l
	if m.From != 0 {
		n += 9
	}
	if m.To != 0 {
		n += 9
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovApi(uint64(m.TimeStamp))
	}
	return n
}

func (m *ModelRecord) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Up != 0 {
		n += 1 + sovApi(uint64(m.Up))
	}
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.Number != 0 {
		n += 1 + sovApi(uint64(m.Number))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IP != 0 {
		n += 1 + sovApi(uint64(m.IP))
	}
	return n
}

func (m *ModifyCoinsReply) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 9
	}
	return n
}

func (m *ModifyCoinsReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Count != 0 {
		n += 9
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CheckZero != 0 {
		n += 1 + sovApi(uint64(m.CheckZero))
	}
	if m.Ts != 0 {
		n += 1 + sovApi(uint64(m.Ts))
	}
	return n
}

func (m *TodayExpReply) Size() (n int) {
	var l int
	_ = l
	if m.Exp != 0 {
		n += 1 + sovApi(uint64(m.Exp))
	}
	return n
}

func (m *TodayExpReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	return n
}

func (m *UpdateAddCoinReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UpdateAddCoinReq) Size() (n int) {
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Up != 0 {
		n += 1 + sovApi(uint64(m.Up))
	}
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.Number != 0 {
		n += 1 + sovApi(uint64(m.Number))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IP != 0 {
		n += 1 + sovApi(uint64(m.IP))
	}
	l = len(m.IPV6)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *UserCoinsReply) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 9
	}
	return n
}

func (m *UserCoinsReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddCoinReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddCoinReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddCoinReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddCoinReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddCoinReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddCoinReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upmid", wireType)
			}
			m.Upmid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upmid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCoin", wireType)
			}
			m.MaxCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCoin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typeid", wireType)
			}
			m.Typeid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typeid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubTime", wireType)
			}
			m.PubTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddUserCoinExpReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddUserCoinExpReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddUserCoinExpReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddUserCoinExpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddUserCoinExpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddUserCoinExpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinsLogReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinsLogReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinsLogReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &ModelLog{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinsLogReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinsLogReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinsLogReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Recent = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Translate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Translate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemUserCoinsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemUserCoinsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemUserCoinsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemUserCoinsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemUserCoinsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemUserCoinsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &ModelList{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelArchiveUserCoins) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelArchiveUserCoins: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelArchiveUserCoins: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelArgModifyCoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelArgModifyCoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelArgModifyCoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Count = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckZero", wireType)
			}
			m.CheckZero = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckZero |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			m.IP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IP |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.From = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.To = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Up", wireType)
			}
			m.Up = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Up |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			m.IP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IP |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyCoinsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyCoinsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyCoinsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Result = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyCoinsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyCoinsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyCoinsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Count = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckZero", wireType)
			}
			m.CheckZero = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckZero |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TodayExpReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TodayExpReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TodayExpReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TodayExpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TodayExpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TodayExpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAddCoinReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAddCoinReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAddCoinReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAddCoinReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAddCoinReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAddCoinReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Up", wireType)
			}
			m.Up = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Up |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			m.IP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IP |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPV6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPV6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCoinsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCoinsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCoinsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Count = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCoinsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCoinsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCoinsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app/service/main/coin/api/api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 1271 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x06, 0x29, 0xc9, 0x92, 0xc6, 0xb1, 0x5e, 0x7b, 0x93, 0xbc, 0x50, 0x85, 0xd4, 0x74, 0xd6,
	0x76, 0x62, 0x37, 0x89, 0x84, 0xa4, 0x69, 0x9a, 0xba, 0xc8, 0x21, 0x0a, 0x82, 0xd6, 0x45, 0x02,
	0x04, 0x6c, 0x52, 0xa0, 0x41, 0x01, 0x83, 0x22, 0xd7, 0xce, 0x22, 0xa2, 0xb8, 0xe2, 0x87, 0x2a,
	0xf7, 0x52, 0xf4, 0xe7, 0xf4, 0xd0, 0x43, 0xff, 0x43, 0x0f, 0x3d, 0xf6, 0xd4, 0x5b, 0x89, 0xc2,
	0x97, 0x02, 0x39, 0xf2, 0x17, 0x14, 0xfb, 0x41, 0x89, 0x94, 0x2d, 0x5a, 0x75, 0x4f, 0x3d, 0x08,
	0xe0, 0xce, 0xce, 0xc7, 0xce, 0xb3, 0xcf, 0xcc, 0xac, 0x60, 0xd3, 0x62, 0xac, 0x13, 0x10, 0x7f,
	0x44, 0x6d, 0xd2, 0x71, 0x2d, 0x3a, 0xe8, 0xd8, 0x1e, 0x1d, 0x74, 0x2c, 0x46, 0xf9, 0xaf, 0xcd,
	0x7c, 0x2f, 0xf4, 0xd0, 0x7b, 0xb6, 0xe7, 0xba, 0xd1, 0x80, 0x86, 0xc7, 0x6d, 0xa5, 0xda, 0xe6,
	0x5a, 0xed, 0xd1, 0xdd, 0xd6, 0x9d, 0x23, 0x1a, 0xbe, 0x89, 0x7a, 0x6d, 0xdb, 0x73, 0x3b, 0x47,
	0xde, 0x91, 0xd7, 0x11, 0x16, 0xbd, 0xe8, 0x50, 0xac, 0xc4, 0x42, 0x7c, 0x49, 0x4f, 0xb8, 0x01,
	0x97, 0x1e, 0x3b, 0xce, 0x13, 0x8f, 0x0e, 0x4c, 0xc2, 0xfa, 0xc7, 0xf8, 0xaf, 0x12, 0xc0, 0x44,
	0x30, 0x44, 0xd7, 0x40, 0xa7, 0xac, 0xa9, 0x6d, 0x68, 0x3b, 0xf5, 0xee, 0xa5, 0x93, 0xd8, 0xd0,
	0xf7, 0x5f, 0xbc, 0x8b, 0x0d, 0x9d, 0x32, 0x53, 0xa7, 0x0c, 0xed, 0x41, 0xc9, 0xa5, 0x4e, 0x53,
	0xdf, 0xd0, 0x76, 0x4a, 0xdd, 0x9d, 0x24, 0x36, 0xb6, 0x0e, 0x3d, 0xdf, 0xdd, 0xc3, 0x2e, 0x75,
	0xf0, 0xc6, 0xc8, 0xea, 0x53, 0xc7, 0x0a, 0xc9, 0x1e, 0xf6, 0xc9, 0x30, 0xa2, 0x3e, 0x71, 0x6e,
	0xbb, 0x74, 0xf0, 0xe8, 0x2e, 0x36, 0xb9, 0x11, 0xfa, 0x04, 0x2a, 0x11, 0xe3, 0xd6, 0x25, 0x61,
	0xbd, 0x99, 0xc4, 0x86, 0x21, 0xad, 0x23, 0x76, 0xb6, 0x39, 0x36, 0xa5, 0x05, 0xda, 0x85, 0x9a,
	0x6b, 0x8d, 0x0f, 0x78, 0xc6, 0xcd, 0xb2, 0xb0, 0x6e, 0x24, 0xb1, 0x01, 0x2a, 0xb6, 0x35, 0xc6,
	0x66, 0xd5, 0xb5, 0xc6, 0x3c, 0x05, 0x74, 0x1f, 0x4a, 0x16, 0x75, 0x9a, 0x15, 0xa1, 0x85, 0x93,
	0xd8, 0x58, 0x97, 0x5a, 0xd6, 0xbc, 0x10, 0x5c, 0x1d, 0x3d, 0x81, 0x5a, 0x2f, 0x0a, 0xe8, 0x80,
	0x04, 0x41, 0x73, 0x49, 0xe4, 0x7e, 0x33, 0x89, 0x8d, 0x4d, 0x69, 0x9a, 0xee, 0x9c, 0x6d, 0x3f,
	0x31, 0x44, 0x4f, 0x60, 0x69, 0x10, 0xb9, 0x3d, 0xe2, 0x37, 0xab, 0x22, 0xfa, 0xad, 0x24, 0x36,
	0x6e, 0x4a, 0x17, 0x52, 0x5e, 0x04, 0x91, 0x32, 0x45, 0xbb, 0xb0, 0x14, 0x1e, 0x33, 0x42, 0x9d,
	0x66, 0x6d, 0x43, 0xdb, 0xa9, 0x74, 0xd7, 0x92, 0xd8, 0x58, 0x91, 0x4e, 0xa4, 0x1c, 0x9b, 0x4a,
	0x01, 0xb5, 0xa1, 0xc6, 0xa2, 0xde, 0x41, 0x48, 0x5d, 0xd2, 0xac, 0x8b, 0x88, 0x97, 0x93, 0xd8,
	0xf8, 0x9f, 0x54, 0x4e, 0x77, 0xb0, 0x59, 0x65, 0x51, 0xef, 0x25, 0xff, 0xba, 0x0a, 0x97, 0x1f,
	0x3b, 0xce, 0xab, 0x80, 0xf8, 0x1c, 0xa9, 0xa7, 0x63, 0x26, 0x09, 0xf0, 0x2d, 0xac, 0xcd, 0x8a,
	0xcf, 0xa3, 0xc1, 0x6a, 0x86, 0x06, 0xf2, 0x72, 0x5b, 0x19, 0x00, 0xf9, 0xfd, 0xd6, 0x33, 0xb8,
	0xfc, 0x7f, 0x82, 0x8b, 0xb8, 0xbb, 0x34, 0x55, 0xfc, 0x39, 0xac, 0xf0, 0x88, 0xc1, 0x33, 0xef,
	0x48, 0x9c, 0x04, 0x7d, 0x0c, 0xe5, 0x3e, 0x0d, 0xc2, 0xa6, 0xb6, 0x51, 0xda, 0x59, 0xbe, 0xb7,
	0xd9, 0x9e, 0xcb, 0xf9, 0xf6, 0x73, 0xcf, 0x21, 0x7d, 0x6e, 0x27, 0x0c, 0xf0, 0x8f, 0x1a, 0x2c,
	0x4f, 0x5d, 0x0d, 0xd1, 0xa7, 0xf2, 0x7c, 0x9a, 0x00, 0x65, 0x37, 0x89, 0x8d, 0xed, 0x0c, 0x4d,
	0xcf, 0xe3, 0xe9, 0x2e, 0x2c, 0xf9, 0xc4, 0x26, 0x83, 0x50, 0xe4, 0x57, 0xcb, 0xde, 0x80, 0x94,
	0x63, 0x53, 0x29, 0xa0, 0x7b, 0x50, 0x0f, 0x7d, 0x6b, 0x10, 0xf4, 0xad, 0x90, 0x88, 0xb4, 0x6b,
	0xdd, 0x2b, 0x49, 0x6c, 0xac, 0xaa, 0xfb, 0x4a, 0xb7, 0xb0, 0x39, 0x55, 0xc3, 0x0f, 0x01, 0xed,
	0x87, 0xc4, 0x4d, 0xf1, 0x0e, 0x64, 0xea, 0x78, 0x82, 0x91, 0x3c, 0x34, 0xbc, 0x8b, 0x0d, 0x25,
	0x99, 0xe0, 0xf5, 0x8b, 0x06, 0xab, 0x33, 0xa6, 0x43, 0xf4, 0x51, 0x36, 0xd5, 0x4c, 0x4d, 0xcd,
	0x4b, 0x55, 0x25, 0xa9, 0xca, 0x44, 0xbf, 0x78, 0x99, 0x94, 0x2e, 0x58, 0x26, 0xf8, 0x29, 0xd4,
	0x9f, 0xd1, 0x20, 0x94, 0x79, 0x3f, 0xcc, 0x5d, 0xf9, 0xd6, 0xb9, 0x57, 0xce, 0x0d, 0xe5, 0x9d,
	0x7f, 0x06, 0x55, 0xe9, 0x66, 0x98, 0xd2, 0x51, 0x3b, 0x9b, 0x8e, 0xfa, 0x0c, 0x1d, 0x1b, 0xa0,
	0x87, 0xf2, 0xf8, 0x25, 0x53, 0x0f, 0x03, 0xdc, 0x81, 0xab, 0xc2, 0xf7, 0x63, 0xdf, 0x7e, 0x43,
	0x47, 0x64, 0x82, 0x6e, 0x86, 0xb7, 0x5a, 0x8e, 0xb7, 0x3f, 0x69, 0x80, 0x94, 0xc5, 0xd1, 0x73,
	0xcf, 0xa1, 0x87, 0xc7, 0xa2, 0xf3, 0x9c, 0x3e, 0xc5, 0x15, 0xa8, 0xd8, 0x5e, 0xa4, 0x88, 0xa4,
	0x99, 0x72, 0xc1, 0xdd, 0xfa, 0xc4, 0x0a, 0xbc, 0x81, 0x2a, 0x14, 0xb5, 0x52, 0x25, 0x57, 0x9e,
	0x53, 0x72, 0x2d, 0xa8, 0x79, 0x8c, 0xf8, 0x56, 0xe8, 0xf9, 0xa2, 0xb9, 0xd5, 0xcd, 0xc9, 0x1a,
	0xbd, 0x0f, 0x60, 0xbf, 0x21, 0xf6, 0xdb, 0x83, 0xef, 0x88, 0xef, 0x89, 0xfe, 0x55, 0x31, 0xeb,
	0x42, 0xf2, 0x9a, 0xf8, 0x1e, 0xb6, 0xa1, 0x3e, 0x01, 0x8f, 0x9f, 0xd2, 0x9a, 0x9e, 0x92, 0x5f,
	0xea, 0x34, 0x4d, 0x3d, 0x9b, 0xe6, 0x2c, 0x4e, 0x99, 0xf3, 0xad, 0x9c, 0x3e, 0x1f, 0xfe, 0x1e,
	0x6a, 0x69, 0x51, 0x22, 0x04, 0xe5, 0x43, 0xdf, 0x73, 0x45, 0x10, 0xcd, 0x14, 0xdf, 0xc2, 0x9b,
	0xa7, 0x80, 0xd0, 0x43, 0x4f, 0x79, 0x2b, 0xcd, 0xc9, 0x16, 0x41, 0xd9, 0x21, 0x81, 0x2d, 0xd1,
	0x30, 0xc5, 0x37, 0xcf, 0x92, 0x37, 0xb4, 0x83, 0x20, 0xb4, 0x5c, 0x26, 0x1b, 0xbc, 0x59, 0xe7,
	0x92, 0x2f, 0xb9, 0x00, 0xff, 0xac, 0xc1, 0xb2, 0x38, 0x81, 0x49, 0x6c, 0xcf, 0x77, 0xce, 0x48,
	0xf4, 0x74, 0xd7, 0x6a, 0x80, 0x1e, 0xb1, 0x34, 0xc5, 0x88, 0xa1, 0x6b, 0x20, 0x1c, 0xca, 0x08,
	0xe5, 0x69, 0x04, 0x21, 0xc8, 0x00, 0x55, 0xc9, 0x01, 0xd5, 0x9a, 0x1d, 0x1e, 0x19, 0xb2, 0xc9,
	0x34, 0xab, 0x73, 0x40, 0xfb, 0x00, 0x56, 0xa7, 0x04, 0x52, 0x9d, 0x40, 0xd0, 0x23, 0x88, 0xfa,
	0xa1, 0x82, 0x4f, 0xad, 0xf0, 0xef, 0x3a, 0x34, 0x72, 0xca, 0x43, 0x5e, 0xc4, 0xd3, 0xda, 0xcf,
	0x14, 0xb1, 0x3b, 0xb7, 0x88, 0x79, 0xd2, 0x7b, 0x39, 0x56, 0x76, 0xb7, 0x92, 0xd8, 0xd8, 0x90,
	0x76, 0x42, 0x3c, 0x67, 0x10, 0x4b, 0xee, 0x3e, 0xca, 0x73, 0xb7, 0xbb, 0x9d, 0xc4, 0xc6, 0xf5,
	0xb4, 0x37, 0x72, 0xf9, 0xd9, 0xd6, 0x8b, 0x51, 0xbc, 0x33, 0x4b, 0xf1, 0xec, 0x3c, 0x4b, 0x77,
	0x70, 0x86, 0xf7, 0xf7, 0x4f, 0xf3, 0xbe, 0x7b, 0x35, 0x89, 0x8d, 0x35, 0x95, 0xce, 0x64, 0x0f,
	0x67, 0xca, 0x41, 0xf1, 0xba, 0x3a, 0xa9, 0xff, 0xeb, 0xb0, 0xf2, 0xd2, 0x73, 0xac, 0xe3, 0x74,
	0x20, 0x72, 0x9e, 0x90, 0x31, 0x4b, 0x99, 0x43, 0xc6, 0x0c, 0xef, 0xc3, 0xf2, 0x54, 0x65, 0x98,
	0xbe, 0x82, 0xb4, 0x0b, 0xbc, 0x82, 0xf0, 0x15, 0x40, 0xaf, 0x18, 0xdf, 0xcf, 0x3d, 0xc2, 0xfe,
	0xd0, 0x60, 0x75, 0x46, 0x3c, 0xfc, 0x2f, 0x30, 0x18, 0x6d, 0x43, 0x99, 0xb2, 0xd1, 0x03, 0xf1,
	0x58, 0xa9, 0x77, 0xd7, 0x4e, 0x62, 0xa3, 0xbc, 0xff, 0xe2, 0xab, 0x07, 0xef, 0x62, 0xa3, 0x42,
	0xd9, 0xc1, 0xe8, 0x81, 0x29, 0xb6, 0xf1, 0x0d, 0x68, 0xcc, 0x0c, 0xbc, 0x49, 0x6f, 0xd4, 0x32,
	0xbd, 0x11, 0x7f, 0x01, 0x97, 0x72, 0xd3, 0xed, 0x5f, 0x20, 0x7d, 0xef, 0x87, 0x2a, 0x94, 0x45,
	0x63, 0xfe, 0x1a, 0xaa, 0x0a, 0x55, 0xb4, 0x5d, 0x30, 0x60, 0xa6, 0xc8, 0xb7, 0x6e, 0x2e, 0xa2,
	0xc6, 0xb3, 0x78, 0x0b, 0x2b, 0xb9, 0x89, 0x8c, 0x6e, 0x15, 0x58, 0xce, 0xce, 0xee, 0xd6, 0x9d,
	0xc5, 0x95, 0x79, 0xb0, 0x03, 0xa8, 0x4f, 0x03, 0x15, 0x1d, 0x31, 0x17, 0x64, 0x77, 0x31, 0x45,
	0x1e, 0x80, 0x88, 0x0e, 0x9a, 0x76, 0x18, 0xb4, 0x5b, 0x3c, 0x8d, 0x33, 0x9d, 0xa8, 0x75, 0x6b,
	0x51, 0x55, 0x1e, 0xe6, 0x05, 0x94, 0xc5, 0x28, 0xc2, 0x05, 0x46, 0x6a, 0xb4, 0xb7, 0xb6, 0xce,
	0xd5, 0xe1, 0x1e, 0xbf, 0x81, 0x5a, 0xfa, 0xfc, 0x43, 0x37, 0x0a, 0x2c, 0x32, 0x6f, 0xc4, 0xd6,
	0xce, 0x42, 0x7a, 0xdc, 0xfb, 0x00, 0x1a, 0xf9, 0x07, 0x32, 0xba, 0x5d, 0xcc, 0x8f, 0xfc, 0x5b,
	0xba, 0xd5, 0xfe, 0x07, 0xda, 0x8a, 0x54, 0xb9, 0x5e, 0x50, 0x48, 0xaa, 0xd9, 0xae, 0x51, 0x48,
	0xaa, 0xd3, 0x9d, 0x87, 0x43, 0x97, 0xb6, 0xb6, 0x42, 0xe8, 0x32, 0xfd, 0xaf, 0x10, 0xba, 0x5c,
	0x2b, 0xed, 0xae, 0xfd, 0x7a, 0xb2, 0xae, 0xfd, 0x76, 0xb2, 0xae, 0xfd, 0x79, 0xb2, 0xae, 0xbd,
	0x2e, 0x59, 0x8c, 0xf6, 0x96, 0xc4, 0xdf, 0xd0, 0x0f, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x83,
	0x5b, 0xed, 0x67, 0xf7, 0x0e, 0x00, 0x00,
}
