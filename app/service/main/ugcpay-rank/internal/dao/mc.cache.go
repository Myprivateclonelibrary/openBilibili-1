// Code generated by $GOPATH/src/go-common/app/tool/cache/mc. DO NOT EDIT.

/*
  Package dao is a generated mc cache package.
  It is generated from:
  type _mc interface {
		//mc: -key=elecUPRankKey -type=get
		CacheElecUPRank(c context.Context, mid int64) (*model.ElecUPRank, error)
		//mc: -key=elecUPRankKey -expire=conf.Conf.CacheTTL.ElecUPRankTTL
		AddCacheElecUPRank(c context.Context, mid int64, value *model.ElecUPRank) error
		//mc: -key=elecUPRankKey
		DelCacheElecUPRank(c context.Context, mid int64) error

		//mc: -key=elecAVRankKey -type=get
		CacheElecAVRank(c context.Context, avID int64) (*model.ElecAVRank, error)
		//mc: -key=elecAVRankKey -expire=conf.Conf.CacheTTL.ElecAVRankTTL
		AddCacheElecAVRank(c context.Context, avID int64, value *model.ElecAVRank) error
		//mc: -key=elecAVRankKey
		DelCacheElecAVRank(c context.Context, avID int64) error

		//mc: -key=elecPrepUPRankKey -type=get
		CacheElecPrepUPRank(c context.Context, mid int64) (*model.ElecPrepUPRank, error)
		//mc: -key=elecPrepUPRankKey -expire=conf.Conf.CacheTTL.ElecPrepUPRankTTL
		AddCacheElecPrepUPRank(c context.Context, mid int64, value *model.ElecPrepUPRank) error
		//mc: -key=elecPrepUPRankKey
		DelCacheElecPrepUPRank(c context.Context, mid int64) error

		//mc: -key=elecPrepAVRankKey -type=get
		CacheElecPrepAVRank(c context.Context, avID int64) (*model.ElecPrepAVRank, error)
		//mc: -key=elecPrepAVRankKey -expire=conf.Conf.CacheTTL.ElecPrepAVRankTTL
		AddCacheElecPrepAVRank(c context.Context, avID int64, value *model.ElecPrepAVRank) error
		//mc: -key=elecPrepAVRankKey
		DelCacheElecPrepAVRank(c context.Context, avID int64) error
	}
*/

package dao

import (
	"context"
	"fmt"

	"go-common/app/service/main/ugcpay-rank/internal/conf"
	"go-common/app/service/main/ugcpay-rank/internal/model"
	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
)

var _ _mc

// CacheElecUPRank get data from mc
func (d *Dao) CacheElecUPRank(c context.Context, upMID int64, ver int64) (res *model.RankElecUPProto, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecUPRankKey(upMID, ver)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheElecUPRank")
		log.Errorv(c, log.KV("CacheElecUPRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.RankElecUPProto{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheElecUPRank")
		log.Errorv(c, log.KV("CacheElecUPRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// SetCacheElecUPRank Set data to mc
func (d *Dao) SetCacheElecUPRank(c context.Context, upMID, ver int64, val *model.RankElecUPProto) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecUPRankKey(upMID, ver)
	item := &memcache.Item{Key: key, Object: val, Expiration: conf.Conf.CacheTTL.ElecUPRankTTL, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:SetCacheElecUPRank")
		log.Errorv(c, log.KV("SetCacheElecUPRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheElecUPRank delete data from mc
func (d *Dao) DelCacheElecUPRank(c context.Context, upMID, ver int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecUPRankKey(upMID, ver)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheElecUPRank")
		log.Errorv(c, log.KV("DelCacheElecUPRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheElecAVRank get data from mc
func (d *Dao) CacheElecAVRank(c context.Context, avID, ver int64) (res *model.RankElecAVProto, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecAVRankKey(avID, ver)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheElecAVRank")
		log.Errorv(c, log.KV("CacheElecAVRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.RankElecAVProto{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheElecAVRank")
		log.Errorv(c, log.KV("CacheElecAVRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// SetCacheElecAVRank Set data to mc
func (d *Dao) SetCacheElecAVRank(c context.Context, avID, ver int64, val *model.RankElecAVProto) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecAVRankKey(avID, ver)
	item := &memcache.Item{Key: key, Object: val, Expiration: conf.Conf.CacheTTL.ElecAVRankTTL, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:SetCacheElecAVRank")
		log.Errorv(c, log.KV("SetCacheElecAVRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheElecAVRank delete data from mc
func (d *Dao) DelCacheElecAVRank(c context.Context, avID, ver int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecAVRankKey(avID, ver)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheElecAVRank")
		log.Errorv(c, log.KV("DelCacheElecAVRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheElecPrepUPRank get data from mc
func (d *Dao) CacheElecPrepUPRank(c context.Context, upMID, ver int64) (res *model.RankElecPrepUPProto, item *memcache.Item, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecPrepUPRankKey(upMID, ver)
	item, err = conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheElecPrepUPRank")
		log.Errorv(c, log.KV("CacheElecPrepUPRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.RankElecPrepUPProto{}
	err = conn.Scan(item, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheElecPrepUPRank")
		log.Errorv(c, log.KV("CacheElecPrepUPRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// SetCacheElecPrepUPRank Set data to mc
func (d *Dao) SetCacheElecPrepUPRank(c context.Context, upMID, ver int64, val *model.RankElecPrepUPProto) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecPrepUPRankKey(upMID, ver)
	item := &memcache.Item{Key: key, Object: val, Expiration: conf.Conf.CacheTTL.ElecPrepUPRankTTL, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:SetCacheElecPrepUPRank")
		log.Errorv(c, log.KV("SetCacheElecPrepUPRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheElecPrepUPRank delete data from mc
func (d *Dao) DelCacheElecPrepUPRank(c context.Context, upMID, ver int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecPrepUPRankKey(upMID, ver)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheElecPrepUPRank")
		log.Errorv(c, log.KV("DelCacheElecPrepUPRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheElecPrepAVRank get data from mc
func (d *Dao) CacheElecPrepAVRank(c context.Context, avID, ver int64) (res *model.RankElecPrepAVProto, item *memcache.Item, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecPrepAVRankKey(avID, ver)
	item, err = conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheElecPrepAVRank")
		log.Errorv(c, log.KV("CacheElecPrepAVRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.RankElecPrepAVProto{}
	err = conn.Scan(item, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheElecPrepAVRank")
		log.Errorv(c, log.KV("CacheElecPrepAVRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// SetCacheElecPrepAVRank Set data to mc
func (d *Dao) SetCacheElecPrepAVRank(c context.Context, avID, ver int64, val *model.RankElecPrepAVProto) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecPrepAVRankKey(avID, ver)
	item := &memcache.Item{Key: key, Object: val, Expiration: conf.Conf.CacheTTL.ElecPrepAVRankTTL, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:SetCacheElecPrepAVRank")
		log.Errorv(c, log.KV("SetCacheElecPrepAVRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheElecPrepAVRank delete data from mc
func (d *Dao) DelCacheElecPrepAVRank(c context.Context, avID, ver int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecPrepAVRankKey(avID, ver)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheElecPrepAVRank")
		log.Errorv(c, log.KV("DelCacheElecPrepAVRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheElecPrepAVRank Set data to mc
func (d *Dao) AddCacheElecPrepAVRank(c context.Context, avID, ver int64, val *model.RankElecPrepAVProto) (ok bool, err error) {
	ok = true
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecPrepAVRankKey(avID, ver)
	item := &memcache.Item{Key: key, Object: val, Expiration: conf.Conf.CacheTTL.ElecPrepAVRankTTL, Flags: memcache.FlagProtobuf}
	if err = conn.Add(item); err != nil {
		if err == memcache.ErrNotStored {
			ok = false
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:AddCacheElecPrepAVRank")
		log.Errorv(c, log.KV("AddCacheElecPrepAVRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheElecPrepUPRank Set data to mc
func (d *Dao) AddCacheElecPrepUPRank(c context.Context, upMID, ver int64, val *model.RankElecPrepUPProto) (ok bool, err error) {
	ok = true
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := elecPrepUPRankKey(upMID, ver)
	item := &memcache.Item{Key: key, Object: val, Expiration: conf.Conf.CacheTTL.ElecPrepUPRankTTL, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		if err == memcache.ErrNotStored {
			ok = false
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:AddCacheElecPrepUPRank")
		log.Errorv(c, log.KV("AddCacheElecPrepUPRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
