// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/main/ugcpay/api/grpc/v1/api.proto

/*
	Package v1 is a generated protocol buffer package.

	It is generated from these files:
		app/service/main/ugcpay/api/grpc/v1/api.proto

	It has these top-level messages:
		EmptyStruct
		AssetRegisterReq
		AssetQueryReq
		AssetQueryResp
		AssetRelationReq
		AssetRelationResp
		AssetRelationDetailReq
		AssetRelationDetailResp
		TradeCreateReq
		TradeCreateResp
		TradeOrderReq
		TradeOrderResp
		IncomeUserAssetOverviewReq
		IncomeUserAssetOverviewResp
		IncomeUserAssetListReq
		IncomeUserAssetListResp
		IncomeUserAsset
		Page
*/
package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// EmptyStruct，填充返回值
type EmptyStruct struct {
}

func (m *EmptyStruct) Reset()                    { *m = EmptyStruct{} }
func (m *EmptyStruct) String() string            { return proto.CompactTextString(m) }
func (*EmptyStruct) ProtoMessage()               {}
func (*EmptyStruct) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

type AssetRegisterReq struct {
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	// oid 内容ID
	Oid int64 `protobuf:"varint,2,opt,name=oid,proto3" json:"oid,omitempty"`
	// otype 内容类型
	Otype string `protobuf:"bytes,3,opt,name=otype,proto3" json:"otype,omitempty"`
	// currency 货币类型
	Currency string `protobuf:"bytes,4,opt,name=currency,proto3" json:"currency,omitempty"`
	// price 注册价格(分)
	Price int64 `protobuf:"varint,5,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *AssetRegisterReq) Reset()                    { *m = AssetRegisterReq{} }
func (m *AssetRegisterReq) String() string            { return proto.CompactTextString(m) }
func (*AssetRegisterReq) ProtoMessage()               {}
func (*AssetRegisterReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *AssetRegisterReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *AssetRegisterReq) GetOid() int64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

func (m *AssetRegisterReq) GetOtype() string {
	if m != nil {
		return m.Otype
	}
	return ""
}

func (m *AssetRegisterReq) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *AssetRegisterReq) GetPrice() int64 {
	if m != nil {
		return m.Price
	}
	return 0
}

type AssetQueryReq struct {
	// oid 内容ID
	Oid int64 `protobuf:"varint,1,opt,name=oid,proto3" json:"oid,omitempty"`
	// otype 内容类型
	Otype string `protobuf:"bytes,2,opt,name=otype,proto3" json:"otype,omitempty"`
	// currency 货币类型
	Currency string `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (m *AssetQueryReq) Reset()                    { *m = AssetQueryReq{} }
func (m *AssetQueryReq) String() string            { return proto.CompactTextString(m) }
func (*AssetQueryReq) ProtoMessage()               {}
func (*AssetQueryReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

func (m *AssetQueryReq) GetOid() int64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

func (m *AssetQueryReq) GetOtype() string {
	if m != nil {
		return m.Otype
	}
	return ""
}

func (m *AssetQueryReq) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type AssetQueryResp struct {
	// price 内容注册价格(分)
	Price int64 `protobuf:"varint,1,opt,name=price,proto3" json:"price,omitempty"`
	// platform_price 平台价格(分)
	PlatformPrice map[string]int64 `protobuf:"bytes,2,rep,name=platform_price,json=platformPrice" json:"platform_price,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *AssetQueryResp) Reset()                    { *m = AssetQueryResp{} }
func (m *AssetQueryResp) String() string            { return proto.CompactTextString(m) }
func (*AssetQueryResp) ProtoMessage()               {}
func (*AssetQueryResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *AssetQueryResp) GetPrice() int64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *AssetQueryResp) GetPlatformPrice() map[string]int64 {
	if m != nil {
		return m.PlatformPrice
	}
	return nil
}

type AssetRelationReq struct {
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	// oid 内容ID
	Oid int64 `protobuf:"varint,2,opt,name=oid,proto3" json:"oid,omitempty"`
	// otype 内容类型
	Otype string `protobuf:"bytes,3,opt,name=otype,proto3" json:"otype,omitempty"`
}

func (m *AssetRelationReq) Reset()                    { *m = AssetRelationReq{} }
func (m *AssetRelationReq) String() string            { return proto.CompactTextString(m) }
func (*AssetRelationReq) ProtoMessage()               {}
func (*AssetRelationReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

func (m *AssetRelationReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *AssetRelationReq) GetOid() int64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

func (m *AssetRelationReq) GetOtype() string {
	if m != nil {
		return m.Otype
	}
	return ""
}

type AssetRelationResp struct {
	// state 关系状态
	State string `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *AssetRelationResp) Reset()                    { *m = AssetRelationResp{} }
func (m *AssetRelationResp) String() string            { return proto.CompactTextString(m) }
func (*AssetRelationResp) ProtoMessage()               {}
func (*AssetRelationResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *AssetRelationResp) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

type AssetRelationDetailReq struct {
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	// oid 内容ID
	Oid int64 `protobuf:"varint,2,opt,name=oid,proto3" json:"oid,omitempty"`
	// otype 内容类型
	Otype string `protobuf:"bytes,3,opt,name=otype,proto3" json:"otype,omitempty"`
	// currency 货币类型
	Currency string `protobuf:"bytes,4,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (m *AssetRelationDetailReq) Reset()                    { *m = AssetRelationDetailReq{} }
func (m *AssetRelationDetailReq) String() string            { return proto.CompactTextString(m) }
func (*AssetRelationDetailReq) ProtoMessage()               {}
func (*AssetRelationDetailReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

func (m *AssetRelationDetailReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *AssetRelationDetailReq) GetOid() int64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

func (m *AssetRelationDetailReq) GetOtype() string {
	if m != nil {
		return m.Otype
	}
	return ""
}

func (m *AssetRelationDetailReq) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type AssetRelationDetailResp struct {
	// relation_state 关系状态
	RelationState string `protobuf:"bytes,1,opt,name=relation_state,json=relationState,proto3" json:"relation_state,omitempty"`
	// asset_price 内容注册价格(分)
	AssetPrice int64 `protobuf:"varint,2,opt,name=asset_price,json=assetPrice,proto3" json:"asset_price,omitempty"`
	// asset_platform_price 平台价格(分)
	AssetPlatformPrice map[string]int64 `protobuf:"bytes,3,rep,name=asset_platform_price,json=assetPlatformPrice" json:"asset_platform_price,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *AssetRelationDetailResp) Reset()                    { *m = AssetRelationDetailResp{} }
func (m *AssetRelationDetailResp) String() string            { return proto.CompactTextString(m) }
func (*AssetRelationDetailResp) ProtoMessage()               {}
func (*AssetRelationDetailResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

func (m *AssetRelationDetailResp) GetRelationState() string {
	if m != nil {
		return m.RelationState
	}
	return ""
}

func (m *AssetRelationDetailResp) GetAssetPrice() int64 {
	if m != nil {
		return m.AssetPrice
	}
	return 0
}

func (m *AssetRelationDetailResp) GetAssetPlatformPrice() map[string]int64 {
	if m != nil {
		return m.AssetPlatformPrice
	}
	return nil
}

type TradeCreateReq struct {
	// platform 支付平台
	Platform string `protobuf:"bytes,1,opt,name=platform,proto3" json:"platform,omitempty"`
	Mid      int64  `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	// oid 内容ID
	Oid int64 `protobuf:"varint,3,opt,name=oid,proto3" json:"oid,omitempty"`
	// otype 内容类型
	Otype string `protobuf:"bytes,4,opt,name=otype,proto3" json:"otype,omitempty"`
	// currency 货币类型
	Currency string `protobuf:"bytes,5,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (m *TradeCreateReq) Reset()                    { *m = TradeCreateReq{} }
func (m *TradeCreateReq) String() string            { return proto.CompactTextString(m) }
func (*TradeCreateReq) ProtoMessage()               {}
func (*TradeCreateReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

func (m *TradeCreateReq) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *TradeCreateReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *TradeCreateReq) GetOid() int64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

func (m *TradeCreateReq) GetOtype() string {
	if m != nil {
		return m.Otype
	}
	return ""
}

func (m *TradeCreateReq) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type TradeCreateResp struct {
	// order_id 订单ID
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	// pay_data 支付平台参数
	PayData string `protobuf:"bytes,2,opt,name=pay_data,json=payData,proto3" json:"pay_data,omitempty"`
}

func (m *TradeCreateResp) Reset()                    { *m = TradeCreateResp{} }
func (m *TradeCreateResp) String() string            { return proto.CompactTextString(m) }
func (*TradeCreateResp) ProtoMessage()               {}
func (*TradeCreateResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

func (m *TradeCreateResp) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *TradeCreateResp) GetPayData() string {
	if m != nil {
		return m.PayData
	}
	return ""
}

type TradeOrderReq struct {
	// id 订单号
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *TradeOrderReq) Reset()                    { *m = TradeOrderReq{} }
func (m *TradeOrderReq) String() string            { return proto.CompactTextString(m) }
func (*TradeOrderReq) ProtoMessage()               {}
func (*TradeOrderReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

func (m *TradeOrderReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type TradeOrderResp struct {
	// order_id 订单号
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Mid     int64  `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	// biz 业务渠道
	Biz string `protobuf:"bytes,3,opt,name=biz,proto3" json:"biz,omitempty"`
	// platform 支付平台
	Platform string `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform,omitempty"`
	Oid      int64  `protobuf:"varint,5,opt,name=oid,proto3" json:"oid,omitempty"`
	Otype    string `protobuf:"bytes,6,opt,name=otype,proto3" json:"otype,omitempty"`
	// fee 支付费用
	Fee int64 `protobuf:"varint,7,opt,name=fee,proto3" json:"fee,omitempty"`
	// currency 货币类型
	Currency string `protobuf:"bytes,8,opt,name=currency,proto3" json:"currency,omitempty"`
	// pay_id 支付平台支付ID
	PayId string `protobuf:"bytes,9,opt,name=pay_id,json=payId,proto3" json:"pay_id,omitempty"`
	// state 订单状态
	State  string `protobuf:"bytes,10,opt,name=state,proto3" json:"state,omitempty"`
	Reason string `protobuf:"bytes,11,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *TradeOrderResp) Reset()                    { *m = TradeOrderResp{} }
func (m *TradeOrderResp) String() string            { return proto.CompactTextString(m) }
func (*TradeOrderResp) ProtoMessage()               {}
func (*TradeOrderResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

func (m *TradeOrderResp) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *TradeOrderResp) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *TradeOrderResp) GetBiz() string {
	if m != nil {
		return m.Biz
	}
	return ""
}

func (m *TradeOrderResp) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *TradeOrderResp) GetOid() int64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

func (m *TradeOrderResp) GetOtype() string {
	if m != nil {
		return m.Otype
	}
	return ""
}

func (m *TradeOrderResp) GetFee() int64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *TradeOrderResp) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *TradeOrderResp) GetPayId() string {
	if m != nil {
		return m.PayId
	}
	return ""
}

func (m *TradeOrderResp) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *TradeOrderResp) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type IncomeUserAssetOverviewReq struct {
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
}

func (m *IncomeUserAssetOverviewReq) Reset()                    { *m = IncomeUserAssetOverviewReq{} }
func (m *IncomeUserAssetOverviewReq) String() string            { return proto.CompactTextString(m) }
func (*IncomeUserAssetOverviewReq) ProtoMessage()               {}
func (*IncomeUserAssetOverviewReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

func (m *IncomeUserAssetOverviewReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

type IncomeUserAssetOverviewResp struct {
	// total 累计收入
	Total int64 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	// total_buy_times 累计购买次数
	TotalBuyTimes int64 `protobuf:"varint,2,opt,name=total_buy_times,json=totalBuyTimes,proto3" json:"total_buy_times,omitempty"`
	// month_new 新增月收入（待结算）
	MonthNew int64 `protobuf:"varint,3,opt,name=month_new,json=monthNew,proto3" json:"month_new,omitempty"`
	// day_new 新增日收入（待结算）
	DayNew int64 `protobuf:"varint,4,opt,name=day_new,json=dayNew,proto3" json:"day_new,omitempty"`
}

func (m *IncomeUserAssetOverviewResp) Reset()                    { *m = IncomeUserAssetOverviewResp{} }
func (m *IncomeUserAssetOverviewResp) String() string            { return proto.CompactTextString(m) }
func (*IncomeUserAssetOverviewResp) ProtoMessage()               {}
func (*IncomeUserAssetOverviewResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{13} }

func (m *IncomeUserAssetOverviewResp) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *IncomeUserAssetOverviewResp) GetTotalBuyTimes() int64 {
	if m != nil {
		return m.TotalBuyTimes
	}
	return 0
}

func (m *IncomeUserAssetOverviewResp) GetMonthNew() int64 {
	if m != nil {
		return m.MonthNew
	}
	return 0
}

func (m *IncomeUserAssetOverviewResp) GetDayNew() int64 {
	if m != nil {
		return m.DayNew
	}
	return 0
}

type IncomeUserAssetListReq struct {
	Mid int64 `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	// ver 月版本号，如:201809
	Ver int64 `protobuf:"varint,2,opt,name=ver,proto3" json:"ver,omitempty"`
	Ps  int64 `protobuf:"varint,3,opt,name=ps,proto3" json:"ps,omitempty"`
	Pn  int64 `protobuf:"varint,4,opt,name=pn,proto3" json:"pn,omitempty"`
}

func (m *IncomeUserAssetListReq) Reset()                    { *m = IncomeUserAssetListReq{} }
func (m *IncomeUserAssetListReq) String() string            { return proto.CompactTextString(m) }
func (*IncomeUserAssetListReq) ProtoMessage()               {}
func (*IncomeUserAssetListReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{14} }

func (m *IncomeUserAssetListReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *IncomeUserAssetListReq) GetVer() int64 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *IncomeUserAssetListReq) GetPs() int64 {
	if m != nil {
		return m.Ps
	}
	return 0
}

func (m *IncomeUserAssetListReq) GetPn() int64 {
	if m != nil {
		return m.Pn
	}
	return 0
}

type IncomeUserAssetListResp struct {
	// list 内容维度月收入信息
	List []*IncomeUserAsset `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
	Page *Page              `protobuf:"bytes,2,opt,name=page" json:"page,omitempty"`
}

func (m *IncomeUserAssetListResp) Reset()                    { *m = IncomeUserAssetListResp{} }
func (m *IncomeUserAssetListResp) String() string            { return proto.CompactTextString(m) }
func (*IncomeUserAssetListResp) ProtoMessage()               {}
func (*IncomeUserAssetListResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{15} }

func (m *IncomeUserAssetListResp) GetList() []*IncomeUserAsset {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *IncomeUserAssetListResp) GetPage() *Page {
	if m != nil {
		return m.Page
	}
	return nil
}

type IncomeUserAsset struct {
	Oid           int64  `protobuf:"varint,1,opt,name=oid,proto3" json:"oid,omitempty"`
	Otype         string `protobuf:"bytes,2,opt,name=otype,proto3" json:"otype,omitempty"`
	Currency      string `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency,omitempty"`
	Price         int64  `protobuf:"varint,4,opt,name=price,proto3" json:"price,omitempty"`
	TotalBuyTimes int64  `protobuf:"varint,5,opt,name=total_buy_times,json=totalBuyTimes,proto3" json:"total_buy_times,omitempty"`
	NewBuyTimes   int64  `protobuf:"varint,6,opt,name=new_buy_times,json=newBuyTimes,proto3" json:"new_buy_times,omitempty"`
	TotalErrTimes int64  `protobuf:"varint,7,opt,name=total_err_times,json=totalErrTimes,proto3" json:"total_err_times,omitempty"`
	NewErrTimes   int64  `protobuf:"varint,8,opt,name=new_err_times,json=newErrTimes,proto3" json:"new_err_times,omitempty"`
}

func (m *IncomeUserAsset) Reset()                    { *m = IncomeUserAsset{} }
func (m *IncomeUserAsset) String() string            { return proto.CompactTextString(m) }
func (*IncomeUserAsset) ProtoMessage()               {}
func (*IncomeUserAsset) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{16} }

func (m *IncomeUserAsset) GetOid() int64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

func (m *IncomeUserAsset) GetOtype() string {
	if m != nil {
		return m.Otype
	}
	return ""
}

func (m *IncomeUserAsset) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *IncomeUserAsset) GetPrice() int64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *IncomeUserAsset) GetTotalBuyTimes() int64 {
	if m != nil {
		return m.TotalBuyTimes
	}
	return 0
}

func (m *IncomeUserAsset) GetNewBuyTimes() int64 {
	if m != nil {
		return m.NewBuyTimes
	}
	return 0
}

func (m *IncomeUserAsset) GetTotalErrTimes() int64 {
	if m != nil {
		return m.TotalErrTimes
	}
	return 0
}

func (m *IncomeUserAsset) GetNewErrTimes() int64 {
	if m != nil {
		return m.NewErrTimes
	}
	return 0
}

type Page struct {
	Num   int64 `protobuf:"varint,1,opt,name=Num,proto3" json:"Num,omitempty"`
	Size_ int64 `protobuf:"varint,2,opt,name=Size,proto3" json:"Size,omitempty"`
	Total int64 `protobuf:"varint,3,opt,name=Total,proto3" json:"Total,omitempty"`
}

func (m *Page) Reset()                    { *m = Page{} }
func (m *Page) String() string            { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()               {}
func (*Page) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{17} }

func (m *Page) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *Page) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Page) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func init() {
	proto.RegisterType((*EmptyStruct)(nil), "ugcpay.service.v1.EmptyStruct")
	proto.RegisterType((*AssetRegisterReq)(nil), "ugcpay.service.v1.AssetRegisterReq")
	proto.RegisterType((*AssetQueryReq)(nil), "ugcpay.service.v1.AssetQueryReq")
	proto.RegisterType((*AssetQueryResp)(nil), "ugcpay.service.v1.AssetQueryResp")
	proto.RegisterType((*AssetRelationReq)(nil), "ugcpay.service.v1.AssetRelationReq")
	proto.RegisterType((*AssetRelationResp)(nil), "ugcpay.service.v1.AssetRelationResp")
	proto.RegisterType((*AssetRelationDetailReq)(nil), "ugcpay.service.v1.AssetRelationDetailReq")
	proto.RegisterType((*AssetRelationDetailResp)(nil), "ugcpay.service.v1.AssetRelationDetailResp")
	proto.RegisterType((*TradeCreateReq)(nil), "ugcpay.service.v1.TradeCreateReq")
	proto.RegisterType((*TradeCreateResp)(nil), "ugcpay.service.v1.TradeCreateResp")
	proto.RegisterType((*TradeOrderReq)(nil), "ugcpay.service.v1.TradeOrderReq")
	proto.RegisterType((*TradeOrderResp)(nil), "ugcpay.service.v1.TradeOrderResp")
	proto.RegisterType((*IncomeUserAssetOverviewReq)(nil), "ugcpay.service.v1.IncomeUserAssetOverviewReq")
	proto.RegisterType((*IncomeUserAssetOverviewResp)(nil), "ugcpay.service.v1.IncomeUserAssetOverviewResp")
	proto.RegisterType((*IncomeUserAssetListReq)(nil), "ugcpay.service.v1.IncomeUserAssetListReq")
	proto.RegisterType((*IncomeUserAssetListResp)(nil), "ugcpay.service.v1.IncomeUserAssetListResp")
	proto.RegisterType((*IncomeUserAsset)(nil), "ugcpay.service.v1.IncomeUserAsset")
	proto.RegisterType((*Page)(nil), "ugcpay.service.v1.Page")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for UGCPay service

type UGCPayClient interface {
	// AssetRegister 内容注册
	AssetRegister(ctx context.Context, in *AssetRegisterReq, opts ...grpc.CallOption) (*EmptyStruct, error)
	// AssetQuery 内容查询
	AssetQuery(ctx context.Context, in *AssetQueryReq, opts ...grpc.CallOption) (*AssetQueryResp, error)
	// AssetRelation 内容关系查询
	AssetRelation(ctx context.Context, in *AssetRelationReq, opts ...grpc.CallOption) (*AssetRelationResp, error)
	// AssetRelationDetail 内容关系详情
	AssetRelationDetail(ctx context.Context, in *AssetRelationDetailReq, opts ...grpc.CallOption) (*AssetRelationDetailResp, error)
	// TradeCreate 支付创建
	TradeCreate(ctx context.Context, in *TradeCreateReq, opts ...grpc.CallOption) (*TradeCreateResp, error)
	// TradeQuery 支付查询
	TradeQuery(ctx context.Context, in *TradeOrderReq, opts ...grpc.CallOption) (*TradeOrderResp, error)
	// TradeCancel 支付取消
	TradeCancel(ctx context.Context, in *TradeOrderReq, opts ...grpc.CallOption) (*EmptyStruct, error)
	// TradeConfirm 支付确认（请求支付平台）
	TradeConfirm(ctx context.Context, in *TradeOrderReq, opts ...grpc.CallOption) (*TradeOrderResp, error)
	// TradeRefund 支付退款（原路返回）
	TradeRefund(ctx context.Context, in *TradeOrderReq, opts ...grpc.CallOption) (*EmptyStruct, error)
	// IncomeUserAssetOverview 用户收入总览
	IncomeUserAssetOverview(ctx context.Context, in *IncomeUserAssetOverviewReq, opts ...grpc.CallOption) (*IncomeUserAssetOverviewResp, error)
	// IncomeUserAssetList 用户资产维度收入
	IncomeUserAssetList(ctx context.Context, in *IncomeUserAssetListReq, opts ...grpc.CallOption) (*IncomeUserAssetListResp, error)
}

type uGCPayClient struct {
	cc *grpc.ClientConn
}

func NewUGCPayClient(cc *grpc.ClientConn) UGCPayClient {
	return &uGCPayClient{cc}
}

func (c *uGCPayClient) AssetRegister(ctx context.Context, in *AssetRegisterReq, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/AssetRegister", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) AssetQuery(ctx context.Context, in *AssetQueryReq, opts ...grpc.CallOption) (*AssetQueryResp, error) {
	out := new(AssetQueryResp)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/AssetQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) AssetRelation(ctx context.Context, in *AssetRelationReq, opts ...grpc.CallOption) (*AssetRelationResp, error) {
	out := new(AssetRelationResp)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/AssetRelation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) AssetRelationDetail(ctx context.Context, in *AssetRelationDetailReq, opts ...grpc.CallOption) (*AssetRelationDetailResp, error) {
	out := new(AssetRelationDetailResp)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/AssetRelationDetail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) TradeCreate(ctx context.Context, in *TradeCreateReq, opts ...grpc.CallOption) (*TradeCreateResp, error) {
	out := new(TradeCreateResp)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/TradeCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) TradeQuery(ctx context.Context, in *TradeOrderReq, opts ...grpc.CallOption) (*TradeOrderResp, error) {
	out := new(TradeOrderResp)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/TradeQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) TradeCancel(ctx context.Context, in *TradeOrderReq, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/TradeCancel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) TradeConfirm(ctx context.Context, in *TradeOrderReq, opts ...grpc.CallOption) (*TradeOrderResp, error) {
	out := new(TradeOrderResp)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/TradeConfirm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) TradeRefund(ctx context.Context, in *TradeOrderReq, opts ...grpc.CallOption) (*EmptyStruct, error) {
	out := new(EmptyStruct)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/TradeRefund", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) IncomeUserAssetOverview(ctx context.Context, in *IncomeUserAssetOverviewReq, opts ...grpc.CallOption) (*IncomeUserAssetOverviewResp, error) {
	out := new(IncomeUserAssetOverviewResp)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/IncomeUserAssetOverview", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uGCPayClient) IncomeUserAssetList(ctx context.Context, in *IncomeUserAssetListReq, opts ...grpc.CallOption) (*IncomeUserAssetListResp, error) {
	out := new(IncomeUserAssetListResp)
	err := grpc.Invoke(ctx, "/ugcpay.service.v1.UGCPay/IncomeUserAssetList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UGCPay service

type UGCPayServer interface {
	// AssetRegister 内容注册
	AssetRegister(context.Context, *AssetRegisterReq) (*EmptyStruct, error)
	// AssetQuery 内容查询
	AssetQuery(context.Context, *AssetQueryReq) (*AssetQueryResp, error)
	// AssetRelation 内容关系查询
	AssetRelation(context.Context, *AssetRelationReq) (*AssetRelationResp, error)
	// AssetRelationDetail 内容关系详情
	AssetRelationDetail(context.Context, *AssetRelationDetailReq) (*AssetRelationDetailResp, error)
	// TradeCreate 支付创建
	TradeCreate(context.Context, *TradeCreateReq) (*TradeCreateResp, error)
	// TradeQuery 支付查询
	TradeQuery(context.Context, *TradeOrderReq) (*TradeOrderResp, error)
	// TradeCancel 支付取消
	TradeCancel(context.Context, *TradeOrderReq) (*EmptyStruct, error)
	// TradeConfirm 支付确认（请求支付平台）
	TradeConfirm(context.Context, *TradeOrderReq) (*TradeOrderResp, error)
	// TradeRefund 支付退款（原路返回）
	TradeRefund(context.Context, *TradeOrderReq) (*EmptyStruct, error)
	// IncomeUserAssetOverview 用户收入总览
	IncomeUserAssetOverview(context.Context, *IncomeUserAssetOverviewReq) (*IncomeUserAssetOverviewResp, error)
	// IncomeUserAssetList 用户资产维度收入
	IncomeUserAssetList(context.Context, *IncomeUserAssetListReq) (*IncomeUserAssetListResp, error)
}

func RegisterUGCPayServer(s *grpc.Server, srv UGCPayServer) {
	s.RegisterService(&_UGCPay_serviceDesc, srv)
}

func _UGCPay_AssetRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetRegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).AssetRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/AssetRegister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).AssetRegister(ctx, req.(*AssetRegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_AssetQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).AssetQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/AssetQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).AssetQuery(ctx, req.(*AssetQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_AssetRelation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetRelationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).AssetRelation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/AssetRelation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).AssetRelation(ctx, req.(*AssetRelationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_AssetRelationDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetRelationDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).AssetRelationDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/AssetRelationDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).AssetRelationDetail(ctx, req.(*AssetRelationDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_TradeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).TradeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/TradeCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).TradeCreate(ctx, req.(*TradeCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_TradeQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeOrderReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).TradeQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/TradeQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).TradeQuery(ctx, req.(*TradeOrderReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_TradeCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeOrderReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).TradeCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/TradeCancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).TradeCancel(ctx, req.(*TradeOrderReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_TradeConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeOrderReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).TradeConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/TradeConfirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).TradeConfirm(ctx, req.(*TradeOrderReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_TradeRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TradeOrderReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).TradeRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/TradeRefund",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).TradeRefund(ctx, req.(*TradeOrderReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_IncomeUserAssetOverview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncomeUserAssetOverviewReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).IncomeUserAssetOverview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/IncomeUserAssetOverview",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).IncomeUserAssetOverview(ctx, req.(*IncomeUserAssetOverviewReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UGCPay_IncomeUserAssetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncomeUserAssetListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UGCPayServer).IncomeUserAssetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ugcpay.service.v1.UGCPay/IncomeUserAssetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UGCPayServer).IncomeUserAssetList(ctx, req.(*IncomeUserAssetListReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _UGCPay_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ugcpay.service.v1.UGCPay",
	HandlerType: (*UGCPayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AssetRegister",
			Handler:    _UGCPay_AssetRegister_Handler,
		},
		{
			MethodName: "AssetQuery",
			Handler:    _UGCPay_AssetQuery_Handler,
		},
		{
			MethodName: "AssetRelation",
			Handler:    _UGCPay_AssetRelation_Handler,
		},
		{
			MethodName: "AssetRelationDetail",
			Handler:    _UGCPay_AssetRelationDetail_Handler,
		},
		{
			MethodName: "TradeCreate",
			Handler:    _UGCPay_TradeCreate_Handler,
		},
		{
			MethodName: "TradeQuery",
			Handler:    _UGCPay_TradeQuery_Handler,
		},
		{
			MethodName: "TradeCancel",
			Handler:    _UGCPay_TradeCancel_Handler,
		},
		{
			MethodName: "TradeConfirm",
			Handler:    _UGCPay_TradeConfirm_Handler,
		},
		{
			MethodName: "TradeRefund",
			Handler:    _UGCPay_TradeRefund_Handler,
		},
		{
			MethodName: "IncomeUserAssetOverview",
			Handler:    _UGCPay_IncomeUserAssetOverview_Handler,
		},
		{
			MethodName: "IncomeUserAssetList",
			Handler:    _UGCPay_IncomeUserAssetList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/main/ugcpay/api/grpc/v1/api.proto",
}

func (m *EmptyStruct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyStruct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AssetRegisterReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetRegisterReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Oid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
	}
	if len(m.Otype) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Otype)))
		i += copy(dAtA[i:], m.Otype)
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.Price != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Price))
	}
	return i, nil
}

func (m *AssetQueryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetQueryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Oid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
	}
	if len(m.Otype) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Otype)))
		i += copy(dAtA[i:], m.Otype)
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	return i, nil
}

func (m *AssetQueryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetQueryResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Price != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Price))
	}
	if len(m.PlatformPrice) > 0 {
		for k, _ := range m.PlatformPrice {
			dAtA[i] = 0x12
			i++
			v := m.PlatformPrice[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + sovApi(uint64(v))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintApi(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *AssetRelationReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetRelationReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Oid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
	}
	if len(m.Otype) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Otype)))
		i += copy(dAtA[i:], m.Otype)
	}
	return i, nil
}

func (m *AssetRelationResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetRelationResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	return i, nil
}

func (m *AssetRelationDetailReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetRelationDetailReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Oid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
	}
	if len(m.Otype) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Otype)))
		i += copy(dAtA[i:], m.Otype)
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	return i, nil
}

func (m *AssetRelationDetailResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetRelationDetailResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RelationState) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.RelationState)))
		i += copy(dAtA[i:], m.RelationState)
	}
	if m.AssetPrice != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AssetPrice))
	}
	if len(m.AssetPlatformPrice) > 0 {
		for k, _ := range m.AssetPlatformPrice {
			dAtA[i] = 0x1a
			i++
			v := m.AssetPlatformPrice[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + sovApi(uint64(v))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintApi(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *TradeCreateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeCreateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Platform) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Oid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
	}
	if len(m.Otype) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Otype)))
		i += copy(dAtA[i:], m.Otype)
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	return i, nil
}

func (m *TradeCreateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeCreateResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	if len(m.PayData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PayData)))
		i += copy(dAtA[i:], m.PayData)
	}
	return i, nil
}

func (m *TradeOrderReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeOrderReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *TradeOrderResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeOrderResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Biz) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Biz)))
		i += copy(dAtA[i:], m.Biz)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.Oid != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
	}
	if len(m.Otype) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Otype)))
		i += copy(dAtA[i:], m.Otype)
	}
	if m.Fee != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Fee))
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if len(m.PayId) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.PayId)))
		i += copy(dAtA[i:], m.PayId)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *IncomeUserAssetOverviewReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomeUserAssetOverviewReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	return i, nil
}

func (m *IncomeUserAssetOverviewResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomeUserAssetOverviewResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
	}
	if m.TotalBuyTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TotalBuyTimes))
	}
	if m.MonthNew != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MonthNew))
	}
	if m.DayNew != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DayNew))
	}
	return i, nil
}

func (m *IncomeUserAssetListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomeUserAssetListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Ver != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ver))
	}
	if m.Ps != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
	}
	if m.Pn != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pn))
	}
	return i, nil
}

func (m *IncomeUserAssetListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomeUserAssetListResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Page != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Page.Size()))
		n1, err := m.Page.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *IncomeUserAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomeUserAsset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Oid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
	}
	if len(m.Otype) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Otype)))
		i += copy(dAtA[i:], m.Otype)
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	if m.Price != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Price))
	}
	if m.TotalBuyTimes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TotalBuyTimes))
	}
	if m.NewBuyTimes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NewBuyTimes))
	}
	if m.TotalErrTimes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TotalErrTimes))
	}
	if m.NewErrTimes != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NewErrTimes))
	}
	return i, nil
}

func (m *Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Size_))
	}
	if m.Total != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Total))
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EmptyStruct) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AssetRegisterReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	l = len(m.Otype)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovApi(uint64(m.Price))
	}
	return n
}

func (m *AssetQueryReq) Size() (n int) {
	var l int
	_ = l
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	l = len(m.Otype)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *AssetQueryResp) Size() (n int) {
	var l int
	_ = l
	if m.Price != 0 {
		n += 1 + sovApi(uint64(m.Price))
	}
	if len(m.PlatformPrice) > 0 {
		for k, v := range m.PlatformPrice {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AssetRelationReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	l = len(m.Otype)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *AssetRelationResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *AssetRelationDetailReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	l = len(m.Otype)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *AssetRelationDetailResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.RelationState)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AssetPrice != 0 {
		n += 1 + sovApi(uint64(m.AssetPrice))
	}
	if len(m.AssetPlatformPrice) > 0 {
		for k, v := range m.AssetPlatformPrice {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TradeCreateReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	l = len(m.Otype)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *TradeCreateResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PayData)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *TradeOrderReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *TradeOrderResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Biz)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	l = len(m.Otype)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Fee != 0 {
		n += 1 + sovApi(uint64(m.Fee))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.PayId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *IncomeUserAssetOverviewReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	return n
}

func (m *IncomeUserAssetOverviewResp) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	if m.TotalBuyTimes != 0 {
		n += 1 + sovApi(uint64(m.TotalBuyTimes))
	}
	if m.MonthNew != 0 {
		n += 1 + sovApi(uint64(m.MonthNew))
	}
	if m.DayNew != 0 {
		n += 1 + sovApi(uint64(m.DayNew))
	}
	return n
}

func (m *IncomeUserAssetListReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Ver != 0 {
		n += 1 + sovApi(uint64(m.Ver))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	if m.Pn != 0 {
		n += 1 + sovApi(uint64(m.Pn))
	}
	return n
}

func (m *IncomeUserAssetListResp) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *IncomeUserAsset) Size() (n int) {
	var l int
	_ = l
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	l = len(m.Otype)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovApi(uint64(m.Price))
	}
	if m.TotalBuyTimes != 0 {
		n += 1 + sovApi(uint64(m.TotalBuyTimes))
	}
	if m.NewBuyTimes != 0 {
		n += 1 + sovApi(uint64(m.NewBuyTimes))
	}
	if m.TotalErrTimes != 0 {
		n += 1 + sovApi(uint64(m.TotalErrTimes))
	}
	if m.NewErrTimes != 0 {
		n += 1 + sovApi(uint64(m.NewErrTimes))
	}
	return n
}

func (m *Page) Size() (n int) {
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	if m.Size_ != 0 {
		n += 1 + sovApi(uint64(m.Size_))
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EmptyStruct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyStruct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyStruct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetRegisterReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetRegisterReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetRegisterReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Otype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetQueryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetQueryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetQueryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Otype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetQueryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetQueryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetQueryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlatformPrice == nil {
				m.PlatformPrice = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PlatformPrice[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetRelationReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetRelationReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetRelationReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Otype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetRelationResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetRelationResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetRelationResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetRelationDetailReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetRelationDetailReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetRelationDetailReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Otype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetRelationDetailResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetRelationDetailResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetRelationDetailResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelationState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetPrice", wireType)
			}
			m.AssetPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetPrice |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetPlatformPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetPlatformPrice == nil {
				m.AssetPlatformPrice = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AssetPlatformPrice[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeCreateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeCreateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeCreateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Otype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeCreateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeCreateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeCreateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeOrderReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeOrderReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeOrderReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeOrderResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeOrderResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeOrderResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Biz", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Biz = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Otype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			m.Fee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomeUserAssetOverviewReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomeUserAssetOverviewReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomeUserAssetOverviewReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomeUserAssetOverviewResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomeUserAssetOverviewResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomeUserAssetOverviewResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBuyTimes", wireType)
			}
			m.TotalBuyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBuyTimes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthNew", wireType)
			}
			m.MonthNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonthNew |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DayNew", wireType)
			}
			m.DayNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DayNew |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomeUserAssetListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomeUserAssetListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomeUserAssetListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomeUserAssetListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomeUserAssetListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomeUserAssetListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &IncomeUserAsset{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Page == nil {
				m.Page = &Page{}
			}
			if err := m.Page.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomeUserAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomeUserAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomeUserAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Otype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBuyTimes", wireType)
			}
			m.TotalBuyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBuyTimes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBuyTimes", wireType)
			}
			m.NewBuyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewBuyTimes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalErrTimes", wireType)
			}
			m.TotalErrTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalErrTimes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewErrTimes", wireType)
			}
			m.NewErrTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewErrTimes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app/service/main/ugcpay/api/grpc/v1/api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 1075 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x86, 0x64, 0xc7, 0x71, 0x8e, 0x67, 0x37, 0xe5, 0xba, 0xc4, 0x53, 0x81, 0x34, 0xd5, 0x7e,
	0x90, 0x6e, 0x88, 0x8d, 0x64, 0xc3, 0x30, 0xec, 0x6a, 0x4b, 0x1b, 0x14, 0x01, 0x8a, 0x24, 0x95,
	0xdd, 0x9b, 0x6e, 0x80, 0x41, 0x4b, 0xb4, 0x2b, 0xcc, 0x92, 0x18, 0x8a, 0xb2, 0xa7, 0x5e, 0xf4,
	0x62, 0x05, 0x76, 0xbf, 0x17, 0xd8, 0xdb, 0x0c, 0xd8, 0xe5, 0x1e, 0x61, 0xc8, 0x93, 0x0c, 0xa4,
	0x28, 0x59, 0xb2, 0xe5, 0x3a, 0x43, 0xb3, 0x3b, 0x9e, 0xc3, 0x8f, 0xe7, 0xff, 0x47, 0x82, 0x43,
	0x4c, 0x69, 0x37, 0x24, 0x6c, 0xea, 0xda, 0xa4, 0xeb, 0x61, 0xd7, 0xef, 0x46, 0x63, 0x9b, 0xe2,
	0xb8, 0x8b, 0xa9, 0xdb, 0x1d, 0x33, 0x6a, 0x77, 0xa7, 0x47, 0xe2, 0xdc, 0xa1, 0x2c, 0xe0, 0x01,
	0xba, 0x9b, 0xdc, 0x76, 0xd4, 0x8b, 0xce, 0xf4, 0xc8, 0x38, 0x1c, 0xbb, 0xfc, 0x55, 0x34, 0xec,
	0xd8, 0x81, 0xd7, 0x1d, 0x07, 0xe3, 0xa0, 0x2b, 0x91, 0xc3, 0x68, 0x24, 0x29, 0x49, 0xc8, 0x53,
	0x22, 0xc1, 0x6c, 0x42, 0xe3, 0xd4, 0xa3, 0x3c, 0xee, 0x71, 0x16, 0xd9, 0xdc, 0x7c, 0x03, 0xdb,
	0x3f, 0x84, 0x21, 0xe1, 0x16, 0x19, 0xbb, 0x21, 0x27, 0xcc, 0x22, 0x57, 0x68, 0x1b, 0x2a, 0x9e,
	0xeb, 0xb4, 0xb5, 0x7d, 0xed, 0xa0, 0x62, 0x89, 0xa3, 0xe0, 0x04, 0xae, 0xd3, 0xd6, 0x13, 0x4e,
	0xe0, 0x3a, 0xe8, 0x1e, 0x6c, 0x04, 0x3c, 0xa6, 0xa4, 0x5d, 0xd9, 0xd7, 0x0e, 0xb6, 0xac, 0x84,
	0x40, 0x06, 0xd4, 0xed, 0x88, 0x31, 0xe2, 0xdb, 0x71, 0xbb, 0x2a, 0x2f, 0x32, 0x5a, 0xbc, 0xa0,
	0xcc, 0xb5, 0x49, 0x7b, 0x43, 0x4a, 0x49, 0x08, 0xb3, 0x07, 0x4d, 0xa9, 0xff, 0x79, 0x44, 0x58,
	0xac, 0x94, 0x07, 0x73, 0xe5, 0x05, 0x55, 0xfa, 0x2a, 0x55, 0x95, 0xa2, 0x2a, 0xf3, 0x4f, 0x0d,
	0x5a, 0x79, 0xa9, 0x21, 0x9d, 0x6b, 0xd7, 0x72, 0xda, 0xd1, 0x8f, 0xd0, 0xa2, 0x13, 0xcc, 0x47,
	0x01, 0xf3, 0x06, 0xc9, 0xb5, 0xbe, 0x5f, 0x39, 0x68, 0x1c, 0x7f, 0xdd, 0x59, 0x8a, 0x73, 0xa7,
	0x28, 0xb0, 0x73, 0xa9, 0xde, 0x5d, 0x8a, 0x67, 0xa7, 0x3e, 0x67, 0xb1, 0xd5, 0xa4, 0x79, 0x9e,
	0xf1, 0x3d, 0xa0, 0x65, 0x90, 0xf0, 0xef, 0x67, 0x12, 0x4b, 0x33, 0xb6, 0x2c, 0x71, 0x14, 0xa6,
	0x4d, 0xf1, 0x24, 0x22, 0x2a, 0xbc, 0x09, 0xf1, 0x9d, 0xfe, 0xad, 0x66, 0x3e, 0xcb, 0x92, 0x33,
	0xc1, 0xdc, 0x0d, 0xfc, 0xf7, 0x4a, 0x8e, 0xf9, 0x08, 0xee, 0x2e, 0x48, 0x4b, 0xe2, 0x12, 0x72,
	0xcc, 0x89, 0x32, 0x28, 0x21, 0x4c, 0x1f, 0x76, 0x0a, 0xd0, 0x27, 0x84, 0x63, 0x77, 0xf2, 0xbf,
	0xd5, 0x86, 0xf9, 0x87, 0x0e, 0xbb, 0xa5, 0x0a, 0x43, 0x8a, 0x3e, 0x83, 0x16, 0x53, 0xdc, 0x41,
	0xde, 0xd4, 0x66, 0xca, 0xed, 0x09, 0x26, 0x7a, 0x00, 0x0d, 0x2c, 0x24, 0x64, 0x79, 0x14, 0xe6,
	0x80, 0x64, 0xc9, 0xe8, 0x23, 0x0e, 0xf7, 0x14, 0xa0, 0x98, 0xf1, 0x8a, 0xcc, 0xf8, 0xc9, 0xaa,
	0x8c, 0x2f, 0x5b, 0x94, 0xf0, 0x4b, 0xf2, 0x8f, 0xf0, 0xd2, 0x85, 0x71, 0xaa, 0x1c, 0x7b, 0xcf,
	0x4a, 0xf8, 0x55, 0x83, 0x56, 0x9f, 0x61, 0x87, 0x3c, 0x66, 0x04, 0x73, 0x22, 0x32, 0x61, 0x40,
	0x3d, 0xf5, 0x44, 0xc9, 0xc8, 0xe8, 0x34, 0x4b, 0xfa, 0x52, 0x96, 0x2a, 0x25, 0x59, 0xaa, 0xae,
	0xca, 0xd2, 0xc6, 0x42, 0x96, 0x9e, 0xc2, 0x9d, 0x82, 0x0d, 0x21, 0x45, 0x1f, 0x43, 0x3d, 0x60,
	0x0e, 0x61, 0x03, 0x55, 0x13, 0x5b, 0xd6, 0xa6, 0xa4, 0xcf, 0x1c, 0x71, 0x45, 0x71, 0x3c, 0x70,
	0x30, 0xc7, 0xaa, 0x73, 0x37, 0x29, 0x8e, 0x9f, 0x60, 0x8e, 0xcd, 0x07, 0xd0, 0x94, 0x82, 0x2e,
	0x04, 0x54, 0xf8, 0xd2, 0x02, 0x3d, 0x13, 0xa0, 0xbb, 0x8e, 0xf9, 0x9b, 0xae, 0xdc, 0x55, 0x88,
	0x77, 0x6b, 0x2a, 0xf5, 0x76, 0xe8, 0xbe, 0x56, 0xf5, 0x27, 0x8e, 0x85, 0x68, 0x55, 0x97, 0xa3,
	0x25, 0x62, 0xb3, 0x51, 0x12, 0x9b, 0x5a, 0x3e, 0x36, 0xdb, 0x50, 0x19, 0x11, 0xd2, 0xde, 0x4c,
	0x70, 0x23, 0x52, 0x8c, 0x56, 0x7d, 0x61, 0xde, 0x7d, 0x04, 0x35, 0xe1, 0xbf, 0xeb, 0xb4, 0xb7,
	0x12, 0x21, 0x14, 0xc7, 0x67, 0xce, 0xbc, 0xe1, 0x20, 0xd7, 0x70, 0x68, 0x07, 0x6a, 0x8c, 0xe0,
	0x30, 0xf0, 0xdb, 0x0d, 0xc9, 0x56, 0x94, 0xd9, 0x01, 0xe3, 0xcc, 0xb7, 0x03, 0x8f, 0xbc, 0x08,
	0x09, 0x93, 0x85, 0x74, 0x31, 0x15, 0x05, 0x4a, 0x66, 0xa5, 0xcd, 0x68, 0xfe, 0xae, 0xc1, 0xfd,
	0x95, 0x0f, 0x92, 0x76, 0xe7, 0x01, 0xc7, 0x93, 0x74, 0x0c, 0x4a, 0x02, 0x7d, 0x0e, 0x77, 0xe4,
	0x61, 0x30, 0x8c, 0xe2, 0x01, 0x77, 0x3d, 0x12, 0xaa, 0x60, 0x36, 0x25, 0xfb, 0x24, 0x8a, 0xfb,
	0x82, 0x89, 0xee, 0xc3, 0x96, 0x17, 0xf8, 0xfc, 0xd5, 0xc0, 0x27, 0x33, 0x55, 0x4a, 0x75, 0xc9,
	0x38, 0x27, 0x33, 0xb4, 0x0b, 0x9b, 0x0e, 0x8e, 0xe5, 0x55, 0x55, 0x5e, 0xd5, 0x1c, 0x1c, 0x9f,
	0x93, 0x99, 0xf9, 0x13, 0xec, 0x2c, 0x98, 0xf4, 0xcc, 0x0d, 0xf9, 0xca, 0x61, 0x32, 0x25, 0x2c,
	0x4d, 0xe5, 0x94, 0x30, 0x51, 0x1a, 0x34, 0x54, 0xca, 0x74, 0x1a, 0x4a, 0xda, 0x57, 0x1a, 0x74,
	0xea, 0x9b, 0x6f, 0x60, 0xb7, 0x54, 0x7a, 0x48, 0xd1, 0x37, 0x50, 0x9d, 0xb8, 0x21, 0x6f, 0x6b,
	0xb2, 0xc3, 0xcd, 0x92, 0x0e, 0x5f, 0x78, 0x69, 0x49, 0x3c, 0xfa, 0x12, 0xaa, 0x14, 0x8f, 0x93,
	0x2e, 0x6c, 0x1c, 0xef, 0x96, 0xbc, 0xbb, 0xc4, 0x63, 0x62, 0x49, 0x90, 0xf9, 0x56, 0x87, 0x3b,
	0x0b, 0x62, 0x6e, 0x63, 0x87, 0xcd, 0x17, 0x56, 0x35, 0xbf, 0xb0, 0x4a, 0x32, 0xb5, 0x51, 0x96,
	0x29, 0x13, 0x9a, 0x3e, 0x99, 0xe5, 0x50, 0x35, 0x89, 0x6a, 0xf8, 0x64, 0x96, 0x61, 0x32, 0x59,
	0x84, 0x31, 0x85, 0xda, 0xcc, 0xc9, 0x3a, 0x65, 0xac, 0x20, 0x6b, 0x8e, 0xaa, 0x67, 0xb2, 0x52,
	0x8c, 0x79, 0x02, 0x55, 0x11, 0x13, 0xe1, 0xf9, 0x79, 0xe4, 0xa5, 0x9e, 0x9f, 0x47, 0x1e, 0x42,
	0x50, 0xed, 0xb9, 0xaf, 0xd3, 0x91, 0x26, 0xcf, 0xc2, 0xb7, 0xbe, 0xac, 0xc2, 0x24, 0xad, 0x09,
	0x71, 0xfc, 0xb6, 0x0e, 0xb5, 0x17, 0x4f, 0x1f, 0x5f, 0xe2, 0x18, 0xf5, 0xd5, 0x57, 0x41, 0xfa,
	0x55, 0x82, 0x3e, 0x59, 0x3d, 0x9e, 0xb3, 0xef, 0x16, 0x63, 0xaf, 0x04, 0x94, 0xfb, 0xd6, 0x41,
	0xcf, 0x01, 0xe6, 0x4b, 0x1c, 0xed, 0xaf, 0xd9, 0xf1, 0x57, 0xc6, 0xc3, 0xb5, 0x5f, 0x01, 0xe8,
	0x65, 0x66, 0x68, 0xb2, 0x25, 0xde, 0x65, 0x68, 0xb6, 0xc3, 0x8d, 0x4f, 0xd7, 0x83, 0x42, 0x8a,
	0x26, 0xf0, 0x61, 0xc9, 0x06, 0x42, 0x8f, 0x6e, 0xba, 0xa9, 0xae, 0x8c, 0x2f, 0x6e, 0xbe, 0xd4,
	0x50, 0x1f, 0x1a, 0xb9, 0xe1, 0x8e, 0xca, 0x7c, 0x2f, 0x2e, 0x20, 0xc3, 0x5c, 0x07, 0x09, 0xa9,
	0x08, 0xb9, 0x64, 0xad, 0x0e, 0x79, 0x61, 0x11, 0x18, 0x0f, 0xd7, 0x20, 0x42, 0x8a, 0x2e, 0x52,
	0x43, 0xb1, 0x6f, 0x93, 0xc9, 0x0d, 0x64, 0xae, 0x2b, 0x8b, 0x1e, 0x7c, 0x90, 0x08, 0x0c, 0xfc,
	0x91, 0xcb, 0xbc, 0xdb, 0xb5, 0xd2, 0x22, 0xa3, 0xc8, 0x77, 0x6e, 0xc1, 0xca, 0x5f, 0x96, 0xe6,
	0x5c, 0x3a, 0xd8, 0xd1, 0xe1, 0xfa, 0xc9, 0x96, 0xdb, 0x1a, 0x46, 0xe7, 0xbf, 0xc0, 0x93, 0x3a,
	0x2c, 0x99, 0xb0, 0xa5, 0x75, 0x58, 0x3e, 0xe7, 0x4b, 0xeb, 0x70, 0xc5, 0xd0, 0x3e, 0xd9, 0xfe,
	0xeb, 0x7a, 0x4f, 0xfb, 0xfb, 0x7a, 0x4f, 0xfb, 0xe7, 0x7a, 0x4f, 0x7b, 0xa9, 0x4f, 0x8f, 0x86,
	0x35, 0xf9, 0xe3, 0xf2, 0xd5, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x78, 0xd0, 0x1b, 0xde, 0x2b,
	0x0d, 0x00, 0x00,
}
