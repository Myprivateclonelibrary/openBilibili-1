// Code generated by $GOPATH/src/go-common/app/tool/cache/gen. DO NOT EDIT.

/*
  Package up is a generated cache proxy package.
  It is generated from:
  type _cache interface {
		//cache: -nullcache=&model.Up{ID:-1} -check_null_code=$!=nil&&$.ID==-1
		Up(c context.Context, mid int64) (up *model.Up, err error)
		//cache: -nullcache=&model.UpSwitch{ID:-1} -check_null_code=$!=nil&&$.ID==-1
		UpSwitch(c context.Context, mid int64) (up *model.UpSwitch, err error)
		//cache: -nullcache=&model.UpInfoActiveReply{ID:-1} -check_null_code=$!=nil&&$.ID==-1
		UpInfoActive(c context.Context, mid int64) (up *model.UpInfoActiveReply, err error)
		// cache: -batch=100 -max_group=1 -batch_err=break -nullcache=&model.UpInfoActiveReply{ID:-1} -check_null_code=$!=nil&&$.ID==-1
		UpsInfoActive(c context.Context, mids []int64) (res map[int64]*model.UpInfoActiveReply, err error)
	}
*/

package up

import (
	"context"
	"sync"

	"go-common/app/service/main/up/model"
	"go-common/library/stat/prom"
	"go-common/library/sync/errgroup"
)

var _ _cache

// Up get data from cache if miss will call source method, then add to cache.
func (d *Dao) Up(c context.Context, id int64) (res *model.Up, err error) {
	addCache := true
	res, err = d.CacheUp(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		prom.CacheHit.Incr("Up")
		return
	}
	prom.CacheMiss.Incr("Up")
	res, err = d.RawUp(c, id)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &model.Up{ID: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUp(c, id, miss)
	})
	return
}

// UpSwitch get data from cache if miss will call source method, then add to cache.
func (d *Dao) UpSwitch(c context.Context, id int64) (res *model.UpSwitch, err error) {
	addCache := true
	res, err = d.CacheUpSwitch(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		prom.CacheHit.Incr("UpSwitch")
		return
	}
	prom.CacheMiss.Incr("UpSwitch")
	res, err = d.RawUpSwitch(c, id)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &model.UpSwitch{ID: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUpSwitch(c, id, miss)
	})
	return
}

// UpInfoActive get data from cache if miss will call source method, then add to cache.
func (d *Dao) UpInfoActive(c context.Context, id int64) (res *model.UpInfoActiveReply, err error) {
	addCache := true
	res, err = d.CacheUpInfoActive(c, id)
	if err != nil {
		addCache = false
		err = nil
	}
	defer func() {
		if res != nil && res.ID == -1 {
			res = nil
		}
	}()
	if res != nil {
		prom.CacheHit.Incr("UpInfoActive")
		return
	}
	prom.CacheMiss.Incr("UpInfoActive")
	res, err = d.RawUpInfoActive(c, id)
	if err != nil {
		return
	}
	miss := res
	if miss == nil {
		miss = &model.UpInfoActiveReply{ID: -1}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUpInfoActive(c, id, miss)
	})
	return
}

// UpsInfoActive get data from cache if miss will call source method, then add to cache.
func (d *Dao) UpsInfoActive(c context.Context, keys []int64) (res map[int64]*model.UpInfoActiveReply, err error) {
	if len(keys) == 0 {
		return
	}
	addCache := true
	if res, err = d.CacheUpsInfoActive(c, keys); err != nil {
		addCache = false
		res = nil
		err = nil
	}
	var miss []int64
	for _, key := range keys {
		if (res == nil) || (res[key] == nil) {
			miss = append(miss, key)
		}
	}
	prom.CacheHit.Add("UpsInfoActive", int64(len(keys)-len(miss)))
	for k, v := range res {
		if v != nil && v.ID == -1 {
			delete(res, k)
		}
	}
	missLen := len(miss)
	if missLen == 0 {
		return
	}
	missData := make(map[int64]*model.UpInfoActiveReply, missLen)
	prom.CacheMiss.Add("UpsInfoActive", int64(missLen))
	var mutex sync.Mutex
	group, ctx := errgroup.WithContext(c)
	if missLen > 1 {
		group.GOMAXPROCS(1)
	}
	var run = func(ms []int64) {
		group.Go(func() (err error) {
			data, err := d.RawUpsInfoActive(ctx, ms)
			mutex.Lock()
			for k, v := range data {
				missData[k] = v
			}
			mutex.Unlock()
			return
		})
	}
	var (
		i int
		n = missLen / 100
	)
	for i = 0; i < n; i++ {
		run(miss[i*n : (i+1)*n])
	}
	if len(miss[i*n:]) > 0 {
		run(miss[i*n:])
	}
	err = group.Wait()
	if res == nil {
		res = make(map[int64]*model.UpInfoActiveReply, len(keys))
	}
	for k, v := range missData {
		res[k] = v
	}
	if err != nil {
		return
	}
	for _, key := range miss {
		if res[key] == nil {
			missData[key] = &model.UpInfoActiveReply{ID: -1}
		}
	}
	if !addCache {
		return
	}
	d.cache.Do(c, func(c context.Context) {
		d.AddCacheUpsInfoActive(c, missData)
	})
	return
}
