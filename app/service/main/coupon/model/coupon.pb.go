// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: coupon.proto

/*
	Package model is a generated protocol buffer package.

	It is generated from these files:
		coupon.proto

	It has these top-level messages:
		CouponInfo
		PointInfoList
		CouponBalanceInfo
		CouponBalanceList
		CouponAllowanceInfo
		CouponAllowanceList
*/
package model

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import go_common_library_time "go-common/library/time"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CouponInfo struct {
	ID          int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"_"`
	CouponToken string                      `protobuf:"bytes,2,opt,name=CouponToken,proto3" json:"coupon_token"`
	Mid         int64                       `protobuf:"varint,3,opt,name=Mid,proto3" json:"mid"`
	State       int64                       `protobuf:"varint,4,opt,name=State,proto3" json:"state"`
	StartTime   int64                       `protobuf:"varint,5,opt,name=StartTime,proto3" json:"start_time"`
	ExpireTime  int64                       `protobuf:"varint,6,opt,name=ExpireTime,proto3" json:"expire_time"`
	Origin      int64                       `protobuf:"varint,7,opt,name=Origin,proto3" json:"origin"`
	CouponType  int64                       `protobuf:"varint,8,opt,name=CouponType,proto3" json:"coupon_type"`
	OrderNO     string                      `protobuf:"bytes,9,opt,name=OrderNO,proto3" json:"order_no"`
	Ver         int64                       `protobuf:"varint,10,opt,name=Ver,proto3" json:"ver"`
	Oid         int64                       `protobuf:"varint,11,opt,name=Oid,proto3" json:"oid"`
	Remark      string                      `protobuf:"bytes,12,opt,name=Remark,proto3" json:"remark"`
	UseVer      int64                       `protobuf:"varint,13,opt,name=UseVer,proto3" json:"use_ver"`
	CTime       go_common_library_time.Time `protobuf:"varint,14,opt,name=CTime,proto3,casttype=go-common/library/time.Time" json:"-"`
	MTime       go_common_library_time.Time `protobuf:"varint,15,opt,name=MTime,proto3,casttype=go-common/library/time.Time" json:"-"`
	BatchToken  string                      `protobuf:"bytes,16,opt,name=BatchToken,proto3" json:"batch_token"`
}

func (m *CouponInfo) Reset()                    { *m = CouponInfo{} }
func (m *CouponInfo) String() string            { return proto.CompactTextString(m) }
func (*CouponInfo) ProtoMessage()               {}
func (*CouponInfo) Descriptor() ([]byte, []int) { return fileDescriptorCoupon, []int{0} }

type PointInfoList struct {
	PointInfoList []*CouponInfo `protobuf:"bytes,1,rep,name=pointInfoList" json:"pointInfoList,omitempty"`
}

func (m *PointInfoList) Reset()                    { *m = PointInfoList{} }
func (m *PointInfoList) String() string            { return proto.CompactTextString(m) }
func (*PointInfoList) ProtoMessage()               {}
func (*PointInfoList) Descriptor() ([]byte, []int) { return fileDescriptorCoupon, []int{1} }

type CouponBalanceInfo struct {
	ID         int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"_"`
	BatchToken string                      `protobuf:"bytes,2,opt,name=BatchToken,proto3" json:"batch_token"`
	Mid        int64                       `protobuf:"varint,3,opt,name=Mid,proto3" json:"mid"`
	Balance    int64                       `protobuf:"varint,4,opt,name=Balance,proto3" json:"balance"`
	StartTime  int64                       `protobuf:"varint,5,opt,name=StartTime,proto3" json:"start_time"`
	ExpireTime int64                       `protobuf:"varint,6,opt,name=ExpireTime,proto3" json:"expire_time"`
	Origin     int64                       `protobuf:"varint,7,opt,name=Origin,proto3" json:"origin"`
	CouponType int64                       `protobuf:"varint,8,opt,name=CouponType,proto3" json:"coupon_type"`
	Ver        int64                       `protobuf:"varint,9,opt,name=Ver,proto3" json:"ver"`
	CTime      go_common_library_time.Time `protobuf:"varint,10,opt,name=CTime,proto3,casttype=go-common/library/time.Time" json:"-"`
	MTime      go_common_library_time.Time `protobuf:"varint,11,opt,name=MTime,proto3,casttype=go-common/library/time.Time" json:"-"`
}

func (m *CouponBalanceInfo) Reset()                    { *m = CouponBalanceInfo{} }
func (m *CouponBalanceInfo) String() string            { return proto.CompactTextString(m) }
func (*CouponBalanceInfo) ProtoMessage()               {}
func (*CouponBalanceInfo) Descriptor() ([]byte, []int) { return fileDescriptorCoupon, []int{2} }

type CouponBalanceList struct {
	CouponBalanceList []*CouponBalanceInfo `protobuf:"bytes,1,rep,name=couponBalanceList" json:"couponBalanceList,omitempty"`
}

func (m *CouponBalanceList) Reset()                    { *m = CouponBalanceList{} }
func (m *CouponBalanceList) String() string            { return proto.CompactTextString(m) }
func (*CouponBalanceList) ProtoMessage()               {}
func (*CouponBalanceList) Descriptor() ([]byte, []int) { return fileDescriptorCoupon, []int{3} }

type CouponAllowanceInfo struct {
	ID          int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"_"`
	CouponToken string                      `protobuf:"bytes,2,opt,name=CouponToken,proto3" json:"coupon_token"`
	Mid         int64                       `protobuf:"varint,3,opt,name=Mid,proto3" json:"mid"`
	State       int32                       `protobuf:"varint,4,opt,name=State,proto3" json:"state"`
	StartTime   int64                       `protobuf:"varint,5,opt,name=StartTime,proto3" json:"start_time"`
	ExpireTime  int64                       `protobuf:"varint,6,opt,name=ExpireTime,proto3" json:"expire_time"`
	Origin      int64                       `protobuf:"varint,7,opt,name=Origin,proto3" json:"origin"`
	OrderNO     string                      `protobuf:"bytes,8,opt,name=OrderNO,proto3" json:"order_no"`
	Ver         int64                       `protobuf:"varint,9,opt,name=Ver,proto3" json:"ver"`
	Remark      string                      `protobuf:"bytes,10,opt,name=Remark,proto3" json:"remark"`
	CTime       go_common_library_time.Time `protobuf:"varint,11,opt,name=CTime,proto3,casttype=go-common/library/time.Time" json:"-"`
	MTime       go_common_library_time.Time `protobuf:"varint,12,opt,name=MTime,proto3,casttype=go-common/library/time.Time" json:"-"`
	BatchToken  string                      `protobuf:"bytes,13,opt,name=BatchToken,proto3" json:"batch_token"`
	Amount      float64                     `protobuf:"fixed64,14,opt,name=Amount,proto3" json:"amount"`
	FullAmount  float64                     `protobuf:"fixed64,15,opt,name=FullAmount,proto3" json:"full_amount"`
	AppID       int64                       `protobuf:"varint,16,opt,name=AppID,proto3" json:"app_id"`
}

func (m *CouponAllowanceInfo) Reset()                    { *m = CouponAllowanceInfo{} }
func (m *CouponAllowanceInfo) String() string            { return proto.CompactTextString(m) }
func (*CouponAllowanceInfo) ProtoMessage()               {}
func (*CouponAllowanceInfo) Descriptor() ([]byte, []int) { return fileDescriptorCoupon, []int{4} }

type CouponAllowanceList struct {
	CouponAllowanceList []*CouponAllowanceInfo `protobuf:"bytes,1,rep,name=couponAllowanceList" json:"couponAllowanceList,omitempty"`
}

func (m *CouponAllowanceList) Reset()                    { *m = CouponAllowanceList{} }
func (m *CouponAllowanceList) String() string            { return proto.CompactTextString(m) }
func (*CouponAllowanceList) ProtoMessage()               {}
func (*CouponAllowanceList) Descriptor() ([]byte, []int) { return fileDescriptorCoupon, []int{5} }

func init() {
	proto.RegisterType((*CouponInfo)(nil), "model.CouponInfo")
	proto.RegisterType((*PointInfoList)(nil), "model.PointInfoList")
	proto.RegisterType((*CouponBalanceInfo)(nil), "model.CouponBalanceInfo")
	proto.RegisterType((*CouponBalanceList)(nil), "model.CouponBalanceList")
	proto.RegisterType((*CouponAllowanceInfo)(nil), "model.CouponAllowanceInfo")
	proto.RegisterType((*CouponAllowanceList)(nil), "model.CouponAllowanceList")
}
func (m *CouponInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CouponInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.ID))
	}
	if len(m.CouponToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(len(m.CouponToken)))
		i += copy(dAtA[i:], m.CouponToken)
	}
	if m.Mid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Mid))
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.State))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.StartTime))
	}
	if m.ExpireTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.ExpireTime))
	}
	if m.Origin != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Origin))
	}
	if m.CouponType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.CouponType))
	}
	if len(m.OrderNO) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(len(m.OrderNO)))
		i += copy(dAtA[i:], m.OrderNO)
	}
	if m.Ver != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Ver))
	}
	if m.Oid != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Oid))
	}
	if len(m.Remark) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(len(m.Remark)))
		i += copy(dAtA[i:], m.Remark)
	}
	if m.UseVer != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.UseVer))
	}
	if m.CTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.CTime))
	}
	if m.MTime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.MTime))
	}
	if len(m.BatchToken) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(len(m.BatchToken)))
		i += copy(dAtA[i:], m.BatchToken)
	}
	return i, nil
}

func (m *PointInfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PointInfoList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PointInfoList) > 0 {
		for _, msg := range m.PointInfoList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoupon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CouponBalanceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CouponBalanceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.ID))
	}
	if len(m.BatchToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(len(m.BatchToken)))
		i += copy(dAtA[i:], m.BatchToken)
	}
	if m.Mid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Mid))
	}
	if m.Balance != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Balance))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.StartTime))
	}
	if m.ExpireTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.ExpireTime))
	}
	if m.Origin != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Origin))
	}
	if m.CouponType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.CouponType))
	}
	if m.Ver != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Ver))
	}
	if m.CTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.CTime))
	}
	if m.MTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.MTime))
	}
	return i, nil
}

func (m *CouponBalanceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CouponBalanceList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CouponBalanceList) > 0 {
		for _, msg := range m.CouponBalanceList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoupon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CouponAllowanceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CouponAllowanceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.ID))
	}
	if len(m.CouponToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(len(m.CouponToken)))
		i += copy(dAtA[i:], m.CouponToken)
	}
	if m.Mid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Mid))
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.State))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.StartTime))
	}
	if m.ExpireTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.ExpireTime))
	}
	if m.Origin != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Origin))
	}
	if len(m.OrderNO) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(len(m.OrderNO)))
		i += copy(dAtA[i:], m.OrderNO)
	}
	if m.Ver != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.Ver))
	}
	if len(m.Remark) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(len(m.Remark)))
		i += copy(dAtA[i:], m.Remark)
	}
	if m.CTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.CTime))
	}
	if m.MTime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.MTime))
	}
	if len(m.BatchToken) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(len(m.BatchToken)))
		i += copy(dAtA[i:], m.BatchToken)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x71
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i += 8
	}
	if m.FullAmount != 0 {
		dAtA[i] = 0x79
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FullAmount))))
		i += 8
	}
	if m.AppID != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCoupon(dAtA, i, uint64(m.AppID))
	}
	return i, nil
}

func (m *CouponAllowanceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CouponAllowanceList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CouponAllowanceList) > 0 {
		for _, msg := range m.CouponAllowanceList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoupon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintCoupon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CouponInfo) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovCoupon(uint64(m.ID))
	}
	l = len(m.CouponToken)
	if l > 0 {
		n += 1 + l + sovCoupon(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovCoupon(uint64(m.Mid))
	}
	if m.State != 0 {
		n += 1 + sovCoupon(uint64(m.State))
	}
	if m.StartTime != 0 {
		n += 1 + sovCoupon(uint64(m.StartTime))
	}
	if m.ExpireTime != 0 {
		n += 1 + sovCoupon(uint64(m.ExpireTime))
	}
	if m.Origin != 0 {
		n += 1 + sovCoupon(uint64(m.Origin))
	}
	if m.CouponType != 0 {
		n += 1 + sovCoupon(uint64(m.CouponType))
	}
	l = len(m.OrderNO)
	if l > 0 {
		n += 1 + l + sovCoupon(uint64(l))
	}
	if m.Ver != 0 {
		n += 1 + sovCoupon(uint64(m.Ver))
	}
	if m.Oid != 0 {
		n += 1 + sovCoupon(uint64(m.Oid))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovCoupon(uint64(l))
	}
	if m.UseVer != 0 {
		n += 1 + sovCoupon(uint64(m.UseVer))
	}
	if m.CTime != 0 {
		n += 1 + sovCoupon(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovCoupon(uint64(m.MTime))
	}
	l = len(m.BatchToken)
	if l > 0 {
		n += 2 + l + sovCoupon(uint64(l))
	}
	return n
}

func (m *PointInfoList) Size() (n int) {
	var l int
	_ = l
	if len(m.PointInfoList) > 0 {
		for _, e := range m.PointInfoList {
			l = e.Size()
			n += 1 + l + sovCoupon(uint64(l))
		}
	}
	return n
}

func (m *CouponBalanceInfo) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovCoupon(uint64(m.ID))
	}
	l = len(m.BatchToken)
	if l > 0 {
		n += 1 + l + sovCoupon(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovCoupon(uint64(m.Mid))
	}
	if m.Balance != 0 {
		n += 1 + sovCoupon(uint64(m.Balance))
	}
	if m.StartTime != 0 {
		n += 1 + sovCoupon(uint64(m.StartTime))
	}
	if m.ExpireTime != 0 {
		n += 1 + sovCoupon(uint64(m.ExpireTime))
	}
	if m.Origin != 0 {
		n += 1 + sovCoupon(uint64(m.Origin))
	}
	if m.CouponType != 0 {
		n += 1 + sovCoupon(uint64(m.CouponType))
	}
	if m.Ver != 0 {
		n += 1 + sovCoupon(uint64(m.Ver))
	}
	if m.CTime != 0 {
		n += 1 + sovCoupon(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovCoupon(uint64(m.MTime))
	}
	return n
}

func (m *CouponBalanceList) Size() (n int) {
	var l int
	_ = l
	if len(m.CouponBalanceList) > 0 {
		for _, e := range m.CouponBalanceList {
			l = e.Size()
			n += 1 + l + sovCoupon(uint64(l))
		}
	}
	return n
}

func (m *CouponAllowanceInfo) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovCoupon(uint64(m.ID))
	}
	l = len(m.CouponToken)
	if l > 0 {
		n += 1 + l + sovCoupon(uint64(l))
	}
	if m.Mid != 0 {
		n += 1 + sovCoupon(uint64(m.Mid))
	}
	if m.State != 0 {
		n += 1 + sovCoupon(uint64(m.State))
	}
	if m.StartTime != 0 {
		n += 1 + sovCoupon(uint64(m.StartTime))
	}
	if m.ExpireTime != 0 {
		n += 1 + sovCoupon(uint64(m.ExpireTime))
	}
	if m.Origin != 0 {
		n += 1 + sovCoupon(uint64(m.Origin))
	}
	l = len(m.OrderNO)
	if l > 0 {
		n += 1 + l + sovCoupon(uint64(l))
	}
	if m.Ver != 0 {
		n += 1 + sovCoupon(uint64(m.Ver))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovCoupon(uint64(l))
	}
	if m.CTime != 0 {
		n += 1 + sovCoupon(uint64(m.CTime))
	}
	if m.MTime != 0 {
		n += 1 + sovCoupon(uint64(m.MTime))
	}
	l = len(m.BatchToken)
	if l > 0 {
		n += 1 + l + sovCoupon(uint64(l))
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.FullAmount != 0 {
		n += 9
	}
	if m.AppID != 0 {
		n += 2 + sovCoupon(uint64(m.AppID))
	}
	return n
}

func (m *CouponAllowanceList) Size() (n int) {
	var l int
	_ = l
	if len(m.CouponAllowanceList) > 0 {
		for _, e := range m.CouponAllowanceList {
			l = e.Size()
			n += 1 + l + sovCoupon(uint64(l))
		}
	}
	return n
}

func sovCoupon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCoupon(x uint64) (n int) {
	return sovCoupon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CouponInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoupon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CouponInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CouponInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CouponToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CouponToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			m.Origin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Origin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CouponType", wireType)
			}
			m.CouponType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CouponType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderNO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderNO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseVer", wireType)
			}
			m.UseVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseVer |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoupon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoupon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PointInfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoupon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PointInfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PointInfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointInfoList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PointInfoList = append(m.PointInfoList, &CouponInfo{})
			if err := m.PointInfoList[len(m.PointInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoupon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoupon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CouponBalanceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoupon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CouponBalanceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CouponBalanceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			m.Origin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Origin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CouponType", wireType)
			}
			m.CouponType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CouponType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoupon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoupon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CouponBalanceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoupon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CouponBalanceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CouponBalanceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CouponBalanceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CouponBalanceList = append(m.CouponBalanceList, &CouponBalanceInfo{})
			if err := m.CouponBalanceList[len(m.CouponBalanceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoupon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoupon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CouponAllowanceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoupon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CouponAllowanceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CouponAllowanceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CouponToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CouponToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			m.ExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			m.Origin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Origin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderNO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderNO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			m.CTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MTime", wireType)
			}
			m.MTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MTime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FullAmount = float64(math.Float64frombits(v))
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			m.AppID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoupon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoupon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CouponAllowanceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoupon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CouponAllowanceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CouponAllowanceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CouponAllowanceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoupon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CouponAllowanceList = append(m.CouponAllowanceList, &CouponAllowanceInfo{})
			if err := m.CouponAllowanceList[len(m.CouponAllowanceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoupon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoupon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoupon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoupon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoupon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCoupon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCoupon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCoupon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCoupon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoupon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("coupon.proto", fileDescriptorCoupon) }

var fileDescriptorCoupon = []byte{
	// 726 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x96, 0xcd, 0x4e, 0xdb, 0x4e,
	0x14, 0xc5, 0x71, 0xf2, 0x77, 0x42, 0x6e, 0x12, 0x3e, 0x8c, 0xfe, 0xd2, 0x94, 0x4a, 0x71, 0xe4,
	0x7e, 0x88, 0x45, 0x49, 0x24, 0xba, 0xa8, 0xd4, 0x1d, 0x81, 0xa2, 0x46, 0x82, 0xa6, 0x1a, 0x68,
	0x37, 0x5d, 0x44, 0x8e, 0x33, 0x84, 0x11, 0xb6, 0xc7, 0x72, 0x9c, 0xb6, 0x3c, 0x49, 0xfb, 0x04,
	0x7d, 0x16, 0x96, 0x3c, 0x81, 0x55, 0x68, 0x57, 0x7e, 0x84, 0xae, 0xaa, 0xb9, 0x9e, 0x10, 0x07,
	0x28, 0x14, 0xa1, 0x4a, 0xed, 0x2e, 0x3e, 0xe7, 0xcc, 0xf5, 0xcc, 0x9d, 0x9f, 0xaf, 0x02, 0x15,
	0x47, 0x8c, 0x02, 0xe1, 0x37, 0x82, 0x50, 0x44, 0xc2, 0xd0, 0x3d, 0xd1, 0x67, 0xee, 0xf2, 0xea,
	0x80, 0x47, 0x07, 0xa3, 0x5e, 0xc3, 0x11, 0x5e, 0x73, 0x20, 0x06, 0xa2, 0x89, 0x6e, 0x6f, 0xb4,
	0x8f, 0x4f, 0xf8, 0x80, 0xbf, 0xd2, 0x55, 0xd6, 0x27, 0x1d, 0x60, 0x03, 0xcb, 0xb4, 0xfd, 0x7d,
	0x61, 0xfc, 0x0f, 0xb9, 0xf6, 0x26, 0xd1, 0xea, 0xda, 0x4a, 0xbe, 0xa5, 0x27, 0xb1, 0xa9, 0x75,
	0x69, 0xae, 0xbd, 0x69, 0xac, 0x41, 0x39, 0x0d, 0xed, 0x89, 0x43, 0xe6, 0x93, 0x5c, 0x5d, 0x5b,
	0x29, 0xb5, 0x16, 0x92, 0xd8, 0x54, 0x5b, 0xe8, 0x46, 0x52, 0xa7, 0xd9, 0x90, 0x71, 0x0f, 0xf2,
	0x3b, 0xbc, 0x4f, 0xf2, 0x58, 0xab, 0x98, 0xc4, 0x66, 0xde, 0xe3, 0x7d, 0x2a, 0x35, 0xc3, 0x04,
	0x7d, 0x37, 0xb2, 0x23, 0x46, 0xfe, 0x43, 0xb3, 0x94, 0xc4, 0xa6, 0x3e, 0x94, 0x02, 0x4d, 0x75,
	0xe3, 0x09, 0x94, 0x76, 0x23, 0x3b, 0x8c, 0xf6, 0xb8, 0xc7, 0x88, 0x8e, 0xa1, 0xb9, 0x24, 0x36,
	0x61, 0x28, 0xc5, 0x6e, 0xc4, 0x3d, 0x46, 0x27, 0x01, 0xa3, 0x09, 0xf0, 0xe2, 0x63, 0xc0, 0x43,
	0x86, 0xf1, 0x02, 0xc6, 0xe7, 0x93, 0xd8, 0x2c, 0x33, 0x54, 0xd3, 0x7c, 0x26, 0x62, 0x58, 0x50,
	0xe8, 0x84, 0x7c, 0xc0, 0x7d, 0x52, 0xc4, 0x30, 0x24, 0xb1, 0x59, 0x10, 0xa8, 0x50, 0xe5, 0xc8,
	0xa2, 0xea, 0x34, 0x47, 0x01, 0x23, 0xb3, 0x93, 0xa2, 0xe3, 0x13, 0x1f, 0x05, 0x8c, 0x66, 0x22,
	0xc6, 0x63, 0x28, 0x76, 0xc2, 0x3e, 0x0b, 0x5f, 0x75, 0x48, 0x09, 0xfb, 0x53, 0x49, 0x62, 0x73,
	0x56, 0x48, 0xa9, 0xeb, 0x0b, 0x3a, 0x36, 0x65, 0x5f, 0xde, 0xb2, 0x90, 0xc0, 0xa4, 0x2f, 0xef,
	0x59, 0x48, 0xa5, 0x26, 0xad, 0x0e, 0xef, 0x93, 0xf2, 0xc4, 0x12, 0xb2, 0x65, 0x1d, 0xde, 0x97,
	0x5b, 0xa6, 0xcc, 0xb3, 0xc3, 0x43, 0x52, 0xc1, 0xe2, 0xb8, 0xe5, 0x10, 0x15, 0xaa, 0x1c, 0xe3,
	0x01, 0x14, 0xde, 0x0c, 0x99, 0x2c, 0x5e, 0xc5, 0x0a, 0xe5, 0x24, 0x36, 0x8b, 0xa3, 0x21, 0xeb,
	0xca, 0x17, 0x28, 0xcb, 0x78, 0x0e, 0xfa, 0x06, 0xf6, 0x69, 0x0e, 0x33, 0x0f, 0xe5, 0x25, 0xaf,
	0xfe, 0x88, 0xcd, 0xfb, 0x03, 0xb1, 0xea, 0x08, 0xcf, 0x13, 0x7e, 0xd3, 0xe5, 0xbd, 0xd0, 0x0e,
	0x8f, 0x9a, 0xb2, 0x6f, 0x0d, 0x99, 0xa5, 0xe9, 0x12, 0xb9, 0x76, 0x07, 0xd7, 0xce, 0xdf, 0x66,
	0xed, 0xce, 0xf8, 0x92, 0x5a, 0x76, 0xe4, 0x1c, 0xa4, 0x04, 0x2d, 0xe0, 0x21, 0xb0, 0x9f, 0x3d,
	0xa9, 0x2a, 0x80, 0x32, 0x11, 0xeb, 0x25, 0x54, 0x5f, 0x0b, 0xee, 0x47, 0x92, 0xcb, 0x6d, 0x3e,
	0x8c, 0x8c, 0x67, 0x50, 0x0d, 0xb2, 0x02, 0xd1, 0xea, 0xf9, 0x95, 0xf2, 0xda, 0x62, 0x03, 0xc1,
	0x6f, 0x4c, 0x28, 0xa6, 0xd3, 0x39, 0xeb, 0x7b, 0x1e, 0x16, 0x53, 0xb7, 0x65, 0xbb, 0xb6, 0xef,
	0xb0, 0xeb, 0x50, 0x9f, 0xde, 0x67, 0xee, 0xc6, 0x7d, 0x5e, 0xc7, 0xf9, 0x23, 0x28, 0xaa, 0x37,
	0x2a, 0xd2, 0xf1, 0x46, 0x7a, 0xa9, 0x44, 0xc7, 0xde, 0x3f, 0x49, 0xbb, 0xa2, 0xb8, 0x74, 0x05,
	0xc5, 0xe7, 0x84, 0xc1, 0x1d, 0x08, 0x2b, 0xdf, 0x9a, 0x30, 0xeb, 0xdd, 0x85, 0x5b, 0x46, 0x68,
	0xb6, 0x60, 0xd1, 0xb9, 0x28, 0x2a, 0x70, 0xc8, 0x14, 0x38, 0x19, 0x34, 0xe8, 0xe5, 0x25, 0xd6,
	0x17, 0x1d, 0x96, 0xd2, 0xe0, 0xba, 0xeb, 0x8a, 0x0f, 0x37, 0x51, 0xf4, 0x27, 0x07, 0xa6, 0xfe,
	0x77, 0x0e, 0xcc, 0xcc, 0xfc, 0x9b, 0xfd, 0x8d, 0xf9, 0x77, 0x15, 0x39, 0x93, 0x21, 0x07, 0xbf,
	0x1c, 0x72, 0xe7, 0x74, 0x95, 0xef, 0x40, 0x57, 0xe5, 0xae, 0xf3, 0xab, 0x7a, 0xf3, 0x5c, 0xb0,
	0xa0, 0xb0, 0xee, 0x89, 0x91, 0x1f, 0xe1, 0xa4, 0xd5, 0xd2, 0xc3, 0xd8, 0xa8, 0x50, 0xe5, 0xc8,
	0xa2, 0x5b, 0x23, 0xd7, 0x55, 0xb9, 0x79, 0xcc, 0x61, 0xd1, 0xfd, 0x91, 0xeb, 0x76, 0x55, 0x38,
	0x13, 0x31, 0xea, 0xa0, 0xaf, 0x07, 0x41, 0x7b, 0x13, 0x07, 0xa8, 0xba, 0x07, 0x3b, 0x08, 0xba,
	0xbc, 0x4f, 0x53, 0xc3, 0x72, 0x2e, 0x71, 0x8a, 0xdf, 0xc1, 0x36, 0x2c, 0x39, 0x97, 0x65, 0xf5,
	0x25, 0x2c, 0x4f, 0x7d, 0x09, 0x53, 0x80, 0xd3, 0xab, 0x96, 0xb5, 0xc8, 0xf1, 0x69, 0x6d, 0xe6,
	0xe4, 0xb4, 0x36, 0x73, 0x7c, 0x56, 0xd3, 0x4e, 0xce, 0x6a, 0xda, 0xd7, 0xb3, 0x9a, 0xf6, 0xf9,
	0x5b, 0x6d, 0xa6, 0x57, 0xc0, 0xbf, 0x15, 0x4f, 0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0x6f, 0xb8,
	0xbe, 0xdd, 0x9c, 0x08, 0x00, 0x00,
}
