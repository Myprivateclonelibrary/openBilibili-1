// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: wallet.proto

/*
	Package model is a generated protocol buffer package.

	It is generated from these files:
		wallet.proto

	It has these top-level messages:
		RechargeOrPayParam
		ExchangeParam
		Melonseed
		Detail
		DetailWithSnapShot
		McDetail
		CoinStreamRecord
		CoinExchangeRecord
		RecordCoinStreamItem
		BasicParam
		MelonseedResp
		MelonseedWithMetalResp
		DetailResp
		DetailWithMetalResp
		TidResp
		QueryResp
		MetalData
		WalletChangeMsg
*/
package model

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RechargeOrPayParam struct {
	Uid           int64  `protobuf:"varint,1,opt,name=Uid,proto3" json:"uid"`
	CoinType      string `protobuf:"bytes,2,opt,name=CoinType,proto3" json:"coin_type"`
	CoinNum       int64  `protobuf:"varint,3,opt,name=CoinNum,proto3" json:"coin_num"`
	ExtendTid     string `protobuf:"bytes,4,opt,name=ExtendTid,proto3" json:"extend_tid"`
	Timestamp     int64  `protobuf:"varint,5,opt,name=Timestamp,proto3" json:"timestamp"`
	TransactionId string `protobuf:"bytes,6,opt,name=TransactionId,proto3" json:"transaction_id"`
	BizCode       string `protobuf:"bytes,7,opt,name=BizCode,proto3" json:"biz_code"`
	Area          int64  `protobuf:"varint,8,opt,name=Area,proto3" json:"area"`
	Source        string `protobuf:"bytes,9,opt,name=Source,proto3" json:"source"`
	MetaData      string `protobuf:"bytes,10,opt,name=MetaData,proto3" json:"metadata"`
	BizSource     string `protobuf:"bytes,11,opt,name=BizSource,proto3" json:"biz_source"`
	Reason        int64  `protobuf:"varint,12,opt,name=Reason,proto3" json:"biz_reason"`
	Version       int64  `protobuf:"varint,13,opt,name=Version,proto3" json:"version"`
	Platform      string `protobuf:"bytes,14,opt,name=Platform,proto3" json:"platform"`
}

func (m *RechargeOrPayParam) Reset()                    { *m = RechargeOrPayParam{} }
func (m *RechargeOrPayParam) String() string            { return proto.CompactTextString(m) }
func (*RechargeOrPayParam) ProtoMessage()               {}
func (*RechargeOrPayParam) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{0} }

func (m *RechargeOrPayParam) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RechargeOrPayParam) GetCoinType() string {
	if m != nil {
		return m.CoinType
	}
	return ""
}

func (m *RechargeOrPayParam) GetCoinNum() int64 {
	if m != nil {
		return m.CoinNum
	}
	return 0
}

func (m *RechargeOrPayParam) GetExtendTid() string {
	if m != nil {
		return m.ExtendTid
	}
	return ""
}

func (m *RechargeOrPayParam) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RechargeOrPayParam) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *RechargeOrPayParam) GetBizCode() string {
	if m != nil {
		return m.BizCode
	}
	return ""
}

func (m *RechargeOrPayParam) GetArea() int64 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *RechargeOrPayParam) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *RechargeOrPayParam) GetMetaData() string {
	if m != nil {
		return m.MetaData
	}
	return ""
}

func (m *RechargeOrPayParam) GetBizSource() string {
	if m != nil {
		return m.BizSource
	}
	return ""
}

func (m *RechargeOrPayParam) GetReason() int64 {
	if m != nil {
		return m.Reason
	}
	return 0
}

func (m *RechargeOrPayParam) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *RechargeOrPayParam) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

type ExchangeParam struct {
	Uid           int64  `protobuf:"varint,1,opt,name=Uid,proto3" json:"uid"`
	SrcCoinType   string `protobuf:"bytes,2,opt,name=SrcCoinType,proto3" json:"src_coin_type"`
	SrcCoinNum    int64  `protobuf:"varint,3,opt,name=SrcCoinNum,proto3" json:"src_coin_num"`
	DestCoinType  string `protobuf:"bytes,4,opt,name=DestCoinType,proto3" json:"dest_coin_type"`
	DestCoinNum   int64  `protobuf:"varint,5,opt,name=DestCoinNum,proto3" json:"dest_coin_num"`
	ExtendTid     string `protobuf:"bytes,6,opt,name=ExtendTid,proto3" json:"extend_tid"`
	Timestamp     int64  `protobuf:"varint,7,opt,name=Timestamp,proto3" json:"timestamp"`
	TransactionId string `protobuf:"bytes,8,opt,name=TransactionId,proto3" json:"transaction_id"`
	BizCode       string `protobuf:"bytes,9,opt,name=BizCode,proto3" json:"biz_code"`
	Area          int64  `protobuf:"varint,10,opt,name=Area,proto3" json:"area"`
	Source        string `protobuf:"bytes,11,opt,name=Source,proto3" json:"source"`
	MetaData      string `protobuf:"bytes,12,opt,name=MetaData,proto3" json:"metadata"`
	BizSource     string `protobuf:"bytes,13,opt,name=BizSource,proto3" json:"biz_source"`
	Reason        int64  `protobuf:"varint,14,opt,name=Reason,proto3" json:"biz_reason"`
	Version       int64  `protobuf:"varint,15,opt,name=Version,proto3" json:"version"`
	Platform      string `protobuf:"bytes,16,opt,name=Platform,proto3" json:"platform"`
}

func (m *ExchangeParam) Reset()                    { *m = ExchangeParam{} }
func (m *ExchangeParam) String() string            { return proto.CompactTextString(m) }
func (*ExchangeParam) ProtoMessage()               {}
func (*ExchangeParam) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{1} }

func (m *ExchangeParam) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ExchangeParam) GetSrcCoinType() string {
	if m != nil {
		return m.SrcCoinType
	}
	return ""
}

func (m *ExchangeParam) GetSrcCoinNum() int64 {
	if m != nil {
		return m.SrcCoinNum
	}
	return 0
}

func (m *ExchangeParam) GetDestCoinType() string {
	if m != nil {
		return m.DestCoinType
	}
	return ""
}

func (m *ExchangeParam) GetDestCoinNum() int64 {
	if m != nil {
		return m.DestCoinNum
	}
	return 0
}

func (m *ExchangeParam) GetExtendTid() string {
	if m != nil {
		return m.ExtendTid
	}
	return ""
}

func (m *ExchangeParam) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ExchangeParam) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *ExchangeParam) GetBizCode() string {
	if m != nil {
		return m.BizCode
	}
	return ""
}

func (m *ExchangeParam) GetArea() int64 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *ExchangeParam) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *ExchangeParam) GetMetaData() string {
	if m != nil {
		return m.MetaData
	}
	return ""
}

func (m *ExchangeParam) GetBizSource() string {
	if m != nil {
		return m.BizSource
	}
	return ""
}

func (m *ExchangeParam) GetReason() int64 {
	if m != nil {
		return m.Reason
	}
	return 0
}

func (m *ExchangeParam) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ExchangeParam) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

type Melonseed struct {
	Uid     int64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"uid"`
	Gold    int64 `protobuf:"varint,2,opt,name=Gold,proto3" json:"gold"`
	IapGold int64 `protobuf:"varint,3,opt,name=IapGold,proto3" json:"iap_gold"`
	Silver  int64 `protobuf:"varint,4,opt,name=Silver,proto3" json:"silver"`
}

func (m *Melonseed) Reset()                    { *m = Melonseed{} }
func (m *Melonseed) String() string            { return proto.CompactTextString(m) }
func (*Melonseed) ProtoMessage()               {}
func (*Melonseed) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{2} }

func (m *Melonseed) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Melonseed) GetGold() int64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *Melonseed) GetIapGold() int64 {
	if m != nil {
		return m.IapGold
	}
	return 0
}

func (m *Melonseed) GetSilver() int64 {
	if m != nil {
		return m.Silver
	}
	return 0
}

type Detail struct {
	Uid             int64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"uid"`
	Gold            int64 `protobuf:"varint,2,opt,name=Gold,proto3" json:"gold"`
	IapGold         int64 `protobuf:"varint,3,opt,name=IapGold,proto3" json:"iap_gold"`
	Silver          int64 `protobuf:"varint,4,opt,name=Silver,proto3" json:"silver"`
	GoldRechargeCnt int64 `protobuf:"varint,5,opt,name=GoldRechargeCnt,proto3" json:"gold_recharge_cnt"`
	GoldPayCnt      int64 `protobuf:"varint,6,opt,name=GoldPayCnt,proto3" json:"gold_pay_cnt"`
	SilverPayCnt    int64 `protobuf:"varint,7,opt,name=SilverPayCnt,proto3" json:"silver_pay_cnt"`
	CostBase        int64 `protobuf:"varint,8,opt,name=CostBase,proto3" json:"cost_base"`
}

func (m *Detail) Reset()                    { *m = Detail{} }
func (m *Detail) String() string            { return proto.CompactTextString(m) }
func (*Detail) ProtoMessage()               {}
func (*Detail) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{3} }

func (m *Detail) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Detail) GetGold() int64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *Detail) GetIapGold() int64 {
	if m != nil {
		return m.IapGold
	}
	return 0
}

func (m *Detail) GetSilver() int64 {
	if m != nil {
		return m.Silver
	}
	return 0
}

func (m *Detail) GetGoldRechargeCnt() int64 {
	if m != nil {
		return m.GoldRechargeCnt
	}
	return 0
}

func (m *Detail) GetGoldPayCnt() int64 {
	if m != nil {
		return m.GoldPayCnt
	}
	return 0
}

func (m *Detail) GetSilverPayCnt() int64 {
	if m != nil {
		return m.SilverPayCnt
	}
	return 0
}

func (m *Detail) GetCostBase() int64 {
	if m != nil {
		return m.CostBase
	}
	return 0
}

type DetailWithSnapShot struct {
	Uid             int64  `protobuf:"varint,1,opt,name=Uid,proto3" json:"uid"`
	Gold            int64  `protobuf:"varint,2,opt,name=Gold,proto3" json:"gold"`
	IapGold         int64  `protobuf:"varint,3,opt,name=IapGold,proto3" json:"iap_gold"`
	Silver          int64  `protobuf:"varint,4,opt,name=Silver,proto3" json:"silver"`
	GoldRechargeCnt int64  `protobuf:"varint,5,opt,name=GoldRechargeCnt,proto3" json:"gold_recharge_cnt"`
	GoldPayCnt      int64  `protobuf:"varint,6,opt,name=GoldPayCnt,proto3" json:"gold_pay_cnt"`
	SilverPayCnt    int64  `protobuf:"varint,7,opt,name=SilverPayCnt,proto3" json:"silver_pay_cnt"`
	CostBase        int64  `protobuf:"varint,8,opt,name=CostBase,proto3" json:"cost_base"`
	SnapShotTime    string `protobuf:"bytes,9,opt,name=SnapShotTime,proto3" json:"snapshot_time"`
	SnapShotGold    int64  `protobuf:"varint,10,opt,name=SnapShotGold,proto3" json:"snapshot_gold"`
	SnapShotIapGold int64  `protobuf:"varint,11,opt,name=SnapShotIapGold,proto3" json:"snapshot_iap_gold"`
	SnapShotSilver  int64  `protobuf:"varint,12,opt,name=SnapShotSilver,proto3" json:"snapshot_silver"`
	Reserved1       int64  `protobuf:"varint,13,opt,name=Reserved1,proto3" json:"reserved1"`
	Reserved2       string `protobuf:"bytes,14,opt,name=Reserved2,proto3" json:"reserved2"`
}

func (m *DetailWithSnapShot) Reset()                    { *m = DetailWithSnapShot{} }
func (m *DetailWithSnapShot) String() string            { return proto.CompactTextString(m) }
func (*DetailWithSnapShot) ProtoMessage()               {}
func (*DetailWithSnapShot) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{4} }

func (m *DetailWithSnapShot) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DetailWithSnapShot) GetGold() int64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *DetailWithSnapShot) GetIapGold() int64 {
	if m != nil {
		return m.IapGold
	}
	return 0
}

func (m *DetailWithSnapShot) GetSilver() int64 {
	if m != nil {
		return m.Silver
	}
	return 0
}

func (m *DetailWithSnapShot) GetGoldRechargeCnt() int64 {
	if m != nil {
		return m.GoldRechargeCnt
	}
	return 0
}

func (m *DetailWithSnapShot) GetGoldPayCnt() int64 {
	if m != nil {
		return m.GoldPayCnt
	}
	return 0
}

func (m *DetailWithSnapShot) GetSilverPayCnt() int64 {
	if m != nil {
		return m.SilverPayCnt
	}
	return 0
}

func (m *DetailWithSnapShot) GetCostBase() int64 {
	if m != nil {
		return m.CostBase
	}
	return 0
}

func (m *DetailWithSnapShot) GetSnapShotTime() string {
	if m != nil {
		return m.SnapShotTime
	}
	return ""
}

func (m *DetailWithSnapShot) GetSnapShotGold() int64 {
	if m != nil {
		return m.SnapShotGold
	}
	return 0
}

func (m *DetailWithSnapShot) GetSnapShotIapGold() int64 {
	if m != nil {
		return m.SnapShotIapGold
	}
	return 0
}

func (m *DetailWithSnapShot) GetSnapShotSilver() int64 {
	if m != nil {
		return m.SnapShotSilver
	}
	return 0
}

func (m *DetailWithSnapShot) GetReserved1() int64 {
	if m != nil {
		return m.Reserved1
	}
	return 0
}

func (m *DetailWithSnapShot) GetReserved2() string {
	if m != nil {
		return m.Reserved2
	}
	return ""
}

type McDetail struct {
	Detail  *Detail `protobuf:"bytes,1,opt,name=Detail" json:"detail"`
	Exist   bool    `protobuf:"varint,2,opt,name=Exist,proto3" json:"exist"`
	Version int32   `protobuf:"varint,3,opt,name=Version,proto3" json:"version"`
}

func (m *McDetail) Reset()                    { *m = McDetail{} }
func (m *McDetail) String() string            { return proto.CompactTextString(m) }
func (*McDetail) ProtoMessage()               {}
func (*McDetail) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{5} }

func (m *McDetail) GetDetail() *Detail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func (m *McDetail) GetExist() bool {
	if m != nil {
		return m.Exist
	}
	return false
}

func (m *McDetail) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type CoinStreamRecord struct {
	Uid           int64  `protobuf:"varint,1,opt,name=Uid,proto3" json:"uid"`
	TransactionId string `protobuf:"bytes,2,opt,name=TransactionId,proto3" json:"transaction_id"`
	ExtendTid     string `protobuf:"bytes,3,opt,name=ExtendTid,proto3" json:"extend_tid"`
	CoinType      int32  `protobuf:"varint,4,opt,name=CoinType,proto3" json:"coin_type"`
	DeltaCoinNum  int64  `protobuf:"varint,5,opt,name=DeltaCoinNum,proto3" json:"delta_coin_num"`
	OrgCoinNum    int64  `protobuf:"varint,6,opt,name=OrgCoinNum,proto3" json:"org_coin_num"`
	OpResult      int32  `protobuf:"varint,7,opt,name=OpResult,proto3" json:"op_result"`
	OpReason      int32  `protobuf:"varint,8,opt,name=OpReason,proto3" json:"op_reason"`
	OpType        int32  `protobuf:"varint,9,opt,name=OpType,proto3" json:"op_type"`
	OpTime        int64  `protobuf:"varint,10,opt,name=OpTime,proto3" json:"op_time"`
	BizCode       string `protobuf:"bytes,11,opt,name=BizCode,proto3" json:"biz_code"`
	Area          int64  `protobuf:"varint,12,opt,name=area,proto3" json:"area"`
	Source        string `protobuf:"bytes,13,opt,name=Source,proto3" json:"source"`
	MetaData      string `protobuf:"bytes,14,opt,name=MetaData,proto3" json:"metadata"`
	BizSource     string `protobuf:"bytes,15,opt,name=BizSource,proto3" json:"biz_source"`
	Platform      int32  `protobuf:"varint,16,opt,name=Platform,proto3" json:"platform"`
	Reserved1     int64  `protobuf:"varint,17,opt,name=Reserved1,proto3" json:"reserved1"`
	Version       int64  `protobuf:"varint,18,opt,name=Version,proto3" json:"reserved5"`
}

func (m *CoinStreamRecord) Reset()                    { *m = CoinStreamRecord{} }
func (m *CoinStreamRecord) String() string            { return proto.CompactTextString(m) }
func (*CoinStreamRecord) ProtoMessage()               {}
func (*CoinStreamRecord) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{6} }

func (m *CoinStreamRecord) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *CoinStreamRecord) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *CoinStreamRecord) GetExtendTid() string {
	if m != nil {
		return m.ExtendTid
	}
	return ""
}

func (m *CoinStreamRecord) GetCoinType() int32 {
	if m != nil {
		return m.CoinType
	}
	return 0
}

func (m *CoinStreamRecord) GetDeltaCoinNum() int64 {
	if m != nil {
		return m.DeltaCoinNum
	}
	return 0
}

func (m *CoinStreamRecord) GetOrgCoinNum() int64 {
	if m != nil {
		return m.OrgCoinNum
	}
	return 0
}

func (m *CoinStreamRecord) GetOpResult() int32 {
	if m != nil {
		return m.OpResult
	}
	return 0
}

func (m *CoinStreamRecord) GetOpReason() int32 {
	if m != nil {
		return m.OpReason
	}
	return 0
}

func (m *CoinStreamRecord) GetOpType() int32 {
	if m != nil {
		return m.OpType
	}
	return 0
}

func (m *CoinStreamRecord) GetOpTime() int64 {
	if m != nil {
		return m.OpTime
	}
	return 0
}

func (m *CoinStreamRecord) GetBizCode() string {
	if m != nil {
		return m.BizCode
	}
	return ""
}

func (m *CoinStreamRecord) GetArea() int64 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *CoinStreamRecord) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *CoinStreamRecord) GetMetaData() string {
	if m != nil {
		return m.MetaData
	}
	return ""
}

func (m *CoinStreamRecord) GetBizSource() string {
	if m != nil {
		return m.BizSource
	}
	return ""
}

func (m *CoinStreamRecord) GetPlatform() int32 {
	if m != nil {
		return m.Platform
	}
	return 0
}

func (m *CoinStreamRecord) GetReserved1() int64 {
	if m != nil {
		return m.Reserved1
	}
	return 0
}

func (m *CoinStreamRecord) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type CoinExchangeRecord struct {
	Uid           int64  `protobuf:"varint,1,opt,name=Uid,proto3" json:"uid"`
	TransactionId string `protobuf:"bytes,2,opt,name=TransactionId,proto3" json:"transaction_id"`
	SrcType       int32  `protobuf:"varint,3,opt,name=SrcType,proto3" json:"src_type"`
	SrcNum        int32  `protobuf:"varint,4,opt,name=SrcNum,proto3" json:"src_num"`
	DestType      int32  `protobuf:"varint,5,opt,name=DestType,proto3" json:"dest_type"`
	DestNum       int32  `protobuf:"varint,6,opt,name=DestNum,proto3" json:"dest_num"`
	Status        int32  `protobuf:"varint,7,opt,name=Status,proto3" json:"status"`
	ExchangeTime  int64  `protobuf:"varint,8,opt,name=ExchangeTime,proto3" json:"exchange_time"`
}

func (m *CoinExchangeRecord) Reset()                    { *m = CoinExchangeRecord{} }
func (m *CoinExchangeRecord) String() string            { return proto.CompactTextString(m) }
func (*CoinExchangeRecord) ProtoMessage()               {}
func (*CoinExchangeRecord) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{7} }

func (m *CoinExchangeRecord) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *CoinExchangeRecord) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *CoinExchangeRecord) GetSrcType() int32 {
	if m != nil {
		return m.SrcType
	}
	return 0
}

func (m *CoinExchangeRecord) GetSrcNum() int32 {
	if m != nil {
		return m.SrcNum
	}
	return 0
}

func (m *CoinExchangeRecord) GetDestType() int32 {
	if m != nil {
		return m.DestType
	}
	return 0
}

func (m *CoinExchangeRecord) GetDestNum() int32 {
	if m != nil {
		return m.DestNum
	}
	return 0
}

func (m *CoinExchangeRecord) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CoinExchangeRecord) GetExchangeTime() int64 {
	if m != nil {
		return m.ExchangeTime
	}
	return 0
}

type RecordCoinStreamItem struct {
	TransactionId string `protobuf:"bytes,1,opt,name=TransactionId,proto3" json:"transaction_id"`
	ExtendTid     string `protobuf:"bytes,2,opt,name=ExtendTid,proto3" json:"extend_tid"`
	CoinType      string `protobuf:"bytes,3,opt,name=CoinType,proto3" json:"coin_type"`
	CoinNum       int64  `protobuf:"varint,4,opt,name=CoinNum,proto3" json:"coin_num"`
	OrgCoinNum    int64  `protobuf:"varint,5,opt,name=OrgCoinNum,proto3" json:"left_coins"`
	Type          string `protobuf:"bytes,6,opt,name=Type,proto3" json:"type"`
	Timestamp     int64  `protobuf:"varint,7,opt,name=Timestamp,proto3" json:"timestamp"`
	Reserved1     int64  `protobuf:"varint,8,opt,name=Reserved1,proto3" json:"biz_reason"`
}

func (m *RecordCoinStreamItem) Reset()                    { *m = RecordCoinStreamItem{} }
func (m *RecordCoinStreamItem) String() string            { return proto.CompactTextString(m) }
func (*RecordCoinStreamItem) ProtoMessage()               {}
func (*RecordCoinStreamItem) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{8} }

func (m *RecordCoinStreamItem) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *RecordCoinStreamItem) GetExtendTid() string {
	if m != nil {
		return m.ExtendTid
	}
	return ""
}

func (m *RecordCoinStreamItem) GetCoinType() string {
	if m != nil {
		return m.CoinType
	}
	return ""
}

func (m *RecordCoinStreamItem) GetCoinNum() int64 {
	if m != nil {
		return m.CoinNum
	}
	return 0
}

func (m *RecordCoinStreamItem) GetOrgCoinNum() int64 {
	if m != nil {
		return m.OrgCoinNum
	}
	return 0
}

func (m *RecordCoinStreamItem) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *RecordCoinStreamItem) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RecordCoinStreamItem) GetReserved1() int64 {
	if m != nil {
		return m.Reserved1
	}
	return 0
}

type BasicParam struct {
	TransactionId string `protobuf:"bytes,1,opt,name=TransactionId,proto3" json:"transaction_id"`
	BizCode       string `protobuf:"bytes,2,opt,name=BizCode,proto3" json:"biz_code"`
	Area          int64  `protobuf:"varint,3,opt,name=area,proto3" json:"area"`
	Source        string `protobuf:"bytes,4,opt,name=Source,proto3" json:"source"`
	MetaData      string `protobuf:"bytes,5,opt,name=MetaData,proto3" json:"metadata"`
	BizSource     string `protobuf:"bytes,6,opt,name=BizSource,proto3" json:"biz_source"`
	Reason        int64  `protobuf:"varint,7,opt,name=Reason,proto3" json:"biz_reason"`
	Version       int64  `protobuf:"varint,8,opt,name=Version,proto3" json:"version"`
}

func (m *BasicParam) Reset()                    { *m = BasicParam{} }
func (m *BasicParam) String() string            { return proto.CompactTextString(m) }
func (*BasicParam) ProtoMessage()               {}
func (*BasicParam) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{9} }

func (m *BasicParam) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *BasicParam) GetBizCode() string {
	if m != nil {
		return m.BizCode
	}
	return ""
}

func (m *BasicParam) GetArea() int64 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *BasicParam) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *BasicParam) GetMetaData() string {
	if m != nil {
		return m.MetaData
	}
	return ""
}

func (m *BasicParam) GetBizSource() string {
	if m != nil {
		return m.BizSource
	}
	return ""
}

func (m *BasicParam) GetReason() int64 {
	if m != nil {
		return m.Reason
	}
	return 0
}

func (m *BasicParam) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type MelonseedResp struct {
	Gold   string `protobuf:"bytes,1,opt,name=Gold,proto3" json:"gold"`
	Silver string `protobuf:"bytes,2,opt,name=Silver,proto3" json:"silver"`
}

func (m *MelonseedResp) Reset()                    { *m = MelonseedResp{} }
func (m *MelonseedResp) String() string            { return proto.CompactTextString(m) }
func (*MelonseedResp) ProtoMessage()               {}
func (*MelonseedResp) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{10} }

func (m *MelonseedResp) GetGold() string {
	if m != nil {
		return m.Gold
	}
	return ""
}

func (m *MelonseedResp) GetSilver() string {
	if m != nil {
		return m.Silver
	}
	return ""
}

type MelonseedWithMetalResp struct {
	Gold   string `protobuf:"bytes,1,opt,name=Gold,proto3" json:"gold"`
	Silver string `protobuf:"bytes,2,opt,name=Silver,proto3" json:"silver"`
	Metal  string `protobuf:"bytes,3,opt,name=Metal,proto3" json:"metal"`
}

func (m *MelonseedWithMetalResp) Reset()                    { *m = MelonseedWithMetalResp{} }
func (m *MelonseedWithMetalResp) String() string            { return proto.CompactTextString(m) }
func (*MelonseedWithMetalResp) ProtoMessage()               {}
func (*MelonseedWithMetalResp) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{11} }

func (m *MelonseedWithMetalResp) GetGold() string {
	if m != nil {
		return m.Gold
	}
	return ""
}

func (m *MelonseedWithMetalResp) GetSilver() string {
	if m != nil {
		return m.Silver
	}
	return ""
}

func (m *MelonseedWithMetalResp) GetMetal() string {
	if m != nil {
		return m.Metal
	}
	return ""
}

type DetailResp struct {
	Gold            string `protobuf:"bytes,1,opt,name=Gold,proto3" json:"gold"`
	Silver          string `protobuf:"bytes,2,opt,name=Silver,proto3" json:"silver"`
	GoldRechargeCnt string `protobuf:"bytes,5,opt,name=GoldRechargeCnt,proto3" json:"gold_recharge_cnt"`
	GoldPayCnt      string `protobuf:"bytes,6,opt,name=GoldPayCnt,proto3" json:"gold_pay_cnt"`
	SilverPayCnt    string `protobuf:"bytes,7,opt,name=SilverPayCnt,proto3" json:"silver_pay_cnt"`
	CostBase        int64  `protobuf:"varint,8,opt,name=CostBase,proto3" json:"cost_base"`
}

func (m *DetailResp) Reset()                    { *m = DetailResp{} }
func (m *DetailResp) String() string            { return proto.CompactTextString(m) }
func (*DetailResp) ProtoMessage()               {}
func (*DetailResp) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{12} }

func (m *DetailResp) GetGold() string {
	if m != nil {
		return m.Gold
	}
	return ""
}

func (m *DetailResp) GetSilver() string {
	if m != nil {
		return m.Silver
	}
	return ""
}

func (m *DetailResp) GetGoldRechargeCnt() string {
	if m != nil {
		return m.GoldRechargeCnt
	}
	return ""
}

func (m *DetailResp) GetGoldPayCnt() string {
	if m != nil {
		return m.GoldPayCnt
	}
	return ""
}

func (m *DetailResp) GetSilverPayCnt() string {
	if m != nil {
		return m.SilverPayCnt
	}
	return ""
}

func (m *DetailResp) GetCostBase() int64 {
	if m != nil {
		return m.CostBase
	}
	return 0
}

type DetailWithMetalResp struct {
	Gold            string `protobuf:"bytes,1,opt,name=Gold,proto3" json:"gold"`
	Silver          string `protobuf:"bytes,2,opt,name=Silver,proto3" json:"silver"`
	GoldRechargeCnt string `protobuf:"bytes,5,opt,name=GoldRechargeCnt,proto3" json:"gold_recharge_cnt"`
	GoldPayCnt      string `protobuf:"bytes,6,opt,name=GoldPayCnt,proto3" json:"gold_pay_cnt"`
	SilverPayCnt    string `protobuf:"bytes,7,opt,name=SilverPayCnt,proto3" json:"silver_pay_cnt"`
	Metal           string `protobuf:"bytes,8,opt,name=Metal,proto3" json:"metal"`
	CostBase        int64  `protobuf:"varint,9,opt,name=CostBase,proto3" json:"cost_base"`
}

func (m *DetailWithMetalResp) Reset()                    { *m = DetailWithMetalResp{} }
func (m *DetailWithMetalResp) String() string            { return proto.CompactTextString(m) }
func (*DetailWithMetalResp) ProtoMessage()               {}
func (*DetailWithMetalResp) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{13} }

func (m *DetailWithMetalResp) GetGold() string {
	if m != nil {
		return m.Gold
	}
	return ""
}

func (m *DetailWithMetalResp) GetSilver() string {
	if m != nil {
		return m.Silver
	}
	return ""
}

func (m *DetailWithMetalResp) GetGoldRechargeCnt() string {
	if m != nil {
		return m.GoldRechargeCnt
	}
	return ""
}

func (m *DetailWithMetalResp) GetGoldPayCnt() string {
	if m != nil {
		return m.GoldPayCnt
	}
	return ""
}

func (m *DetailWithMetalResp) GetSilverPayCnt() string {
	if m != nil {
		return m.SilverPayCnt
	}
	return ""
}

func (m *DetailWithMetalResp) GetMetal() string {
	if m != nil {
		return m.Metal
	}
	return ""
}

func (m *DetailWithMetalResp) GetCostBase() int64 {
	if m != nil {
		return m.CostBase
	}
	return 0
}

type TidResp struct {
	TransactionId string `protobuf:"bytes,1,opt,name=TransactionId,proto3" json:"transaction_id"`
}

func (m *TidResp) Reset()                    { *m = TidResp{} }
func (m *TidResp) String() string            { return proto.CompactTextString(m) }
func (*TidResp) ProtoMessage()               {}
func (*TidResp) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{14} }

func (m *TidResp) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

type QueryResp struct {
	Status int32 `protobuf:"varint,1,opt,name=Status,proto3" json:"status"`
}

func (m *QueryResp) Reset()                    { *m = QueryResp{} }
func (m *QueryResp) String() string            { return proto.CompactTextString(m) }
func (*QueryResp) ProtoMessage()               {}
func (*QueryResp) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{15} }

func (m *QueryResp) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type MetalData struct {
	Count float64 `protobuf:"fixed64,1,opt,name=Count,proto3" json:"count"`
}

func (m *MetalData) Reset()                    { *m = MetalData{} }
func (m *MetalData) String() string            { return proto.CompactTextString(m) }
func (*MetalData) ProtoMessage()               {}
func (*MetalData) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{16} }

func (m *MetalData) GetCount() float64 {
	if m != nil {
		return m.Count
	}
	return 0
}

type WalletChangeMsg struct {
	Action          string `protobuf:"bytes,1,opt,name=Action,proto3" json:"action"`
	Uid             int64  `protobuf:"varint,2,opt,name=Uid,proto3" json:"uid"`
	CoinType        string `protobuf:"bytes,3,opt,name=CoinType,proto3" json:"coin_type"`
	Platfrom        string `protobuf:"bytes,4,opt,name=Platfrom,proto3" json:"platform"`
	Number          int64  `protobuf:"varint,5,opt,name=Number,proto3" json:"number"`
	Gold            int64  `protobuf:"varint,6,opt,name=Gold,proto3" json:"gold"`
	Silver          int64  `protobuf:"varint,7,opt,name=Silver,proto3" json:"silver"`
	GoldRechargeCnt int64  `protobuf:"varint,8,opt,name=GoldRechargeCnt,proto3" json:"gold_recharge_cnt"`
	GoldPayCnt      int64  `protobuf:"varint,9,opt,name=GoldPayCnt,proto3" json:"gold_pay_cnt"`
	SilverPayCnt    int64  `protobuf:"varint,10,opt,name=SilverPayCnt,proto3" json:"silver_pay_cnt"`
	DestCoinType    string `protobuf:"bytes,11,opt,name=DestCoinType,proto3" json:"dest_coin_type"`
	DestNumber      int64  `protobuf:"varint,12,opt,name=DestNumber,proto3" json:"dest_number"`
	CostBase        int64  `protobuf:"varint,13,opt,name=CostBase,proto3" json:"cost_base"`
}

func (m *WalletChangeMsg) Reset()                    { *m = WalletChangeMsg{} }
func (m *WalletChangeMsg) String() string            { return proto.CompactTextString(m) }
func (*WalletChangeMsg) ProtoMessage()               {}
func (*WalletChangeMsg) Descriptor() ([]byte, []int) { return fileDescriptorWallet, []int{17} }

func (m *WalletChangeMsg) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *WalletChangeMsg) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *WalletChangeMsg) GetCoinType() string {
	if m != nil {
		return m.CoinType
	}
	return ""
}

func (m *WalletChangeMsg) GetPlatfrom() string {
	if m != nil {
		return m.Platfrom
	}
	return ""
}

func (m *WalletChangeMsg) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *WalletChangeMsg) GetGold() int64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *WalletChangeMsg) GetSilver() int64 {
	if m != nil {
		return m.Silver
	}
	return 0
}

func (m *WalletChangeMsg) GetGoldRechargeCnt() int64 {
	if m != nil {
		return m.GoldRechargeCnt
	}
	return 0
}

func (m *WalletChangeMsg) GetGoldPayCnt() int64 {
	if m != nil {
		return m.GoldPayCnt
	}
	return 0
}

func (m *WalletChangeMsg) GetSilverPayCnt() int64 {
	if m != nil {
		return m.SilverPayCnt
	}
	return 0
}

func (m *WalletChangeMsg) GetDestCoinType() string {
	if m != nil {
		return m.DestCoinType
	}
	return ""
}

func (m *WalletChangeMsg) GetDestNumber() int64 {
	if m != nil {
		return m.DestNumber
	}
	return 0
}

func (m *WalletChangeMsg) GetCostBase() int64 {
	if m != nil {
		return m.CostBase
	}
	return 0
}

func init() {
	proto.RegisterType((*RechargeOrPayParam)(nil), "model.RechargeOrPayParam")
	proto.RegisterType((*ExchangeParam)(nil), "model.ExchangeParam")
	proto.RegisterType((*Melonseed)(nil), "model.Melonseed")
	proto.RegisterType((*Detail)(nil), "model.Detail")
	proto.RegisterType((*DetailWithSnapShot)(nil), "model.DetailWithSnapShot")
	proto.RegisterType((*McDetail)(nil), "model.McDetail")
	proto.RegisterType((*CoinStreamRecord)(nil), "model.CoinStreamRecord")
	proto.RegisterType((*CoinExchangeRecord)(nil), "model.CoinExchangeRecord")
	proto.RegisterType((*RecordCoinStreamItem)(nil), "model.RecordCoinStreamItem")
	proto.RegisterType((*BasicParam)(nil), "model.BasicParam")
	proto.RegisterType((*MelonseedResp)(nil), "model.MelonseedResp")
	proto.RegisterType((*MelonseedWithMetalResp)(nil), "model.MelonseedWithMetalResp")
	proto.RegisterType((*DetailResp)(nil), "model.DetailResp")
	proto.RegisterType((*DetailWithMetalResp)(nil), "model.DetailWithMetalResp")
	proto.RegisterType((*TidResp)(nil), "model.TidResp")
	proto.RegisterType((*QueryResp)(nil), "model.QueryResp")
	proto.RegisterType((*MetalData)(nil), "model.MetalData")
	proto.RegisterType((*WalletChangeMsg)(nil), "model.WalletChangeMsg")
}
func (m *RechargeOrPayParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeOrPayParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Uid))
	}
	if len(m.CoinType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.CoinType)))
		i += copy(dAtA[i:], m.CoinType)
	}
	if m.CoinNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.CoinNum))
	}
	if len(m.ExtendTid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.ExtendTid)))
		i += copy(dAtA[i:], m.ExtendTid)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.TransactionId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TransactionId)))
		i += copy(dAtA[i:], m.TransactionId)
	}
	if len(m.BizCode) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.BizCode)))
		i += copy(dAtA[i:], m.BizCode)
	}
	if m.Area != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Area))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.MetaData) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.MetaData)))
		i += copy(dAtA[i:], m.MetaData)
	}
	if len(m.BizSource) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.BizSource)))
		i += copy(dAtA[i:], m.BizSource)
	}
	if m.Reason != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Reason))
	}
	if m.Version != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Version))
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	return i, nil
}

func (m *ExchangeParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Uid))
	}
	if len(m.SrcCoinType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.SrcCoinType)))
		i += copy(dAtA[i:], m.SrcCoinType)
	}
	if m.SrcCoinNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.SrcCoinNum))
	}
	if len(m.DestCoinType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.DestCoinType)))
		i += copy(dAtA[i:], m.DestCoinType)
	}
	if m.DestCoinNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.DestCoinNum))
	}
	if len(m.ExtendTid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.ExtendTid)))
		i += copy(dAtA[i:], m.ExtendTid)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.TransactionId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TransactionId)))
		i += copy(dAtA[i:], m.TransactionId)
	}
	if len(m.BizCode) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.BizCode)))
		i += copy(dAtA[i:], m.BizCode)
	}
	if m.Area != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Area))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.MetaData) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.MetaData)))
		i += copy(dAtA[i:], m.MetaData)
	}
	if len(m.BizSource) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.BizSource)))
		i += copy(dAtA[i:], m.BizSource)
	}
	if m.Reason != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Reason))
	}
	if m.Version != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Version))
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	return i, nil
}

func (m *Melonseed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Melonseed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Uid))
	}
	if m.Gold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Gold))
	}
	if m.IapGold != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.IapGold))
	}
	if m.Silver != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Silver))
	}
	return i, nil
}

func (m *Detail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Detail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Uid))
	}
	if m.Gold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Gold))
	}
	if m.IapGold != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.IapGold))
	}
	if m.Silver != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Silver))
	}
	if m.GoldRechargeCnt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.GoldRechargeCnt))
	}
	if m.GoldPayCnt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.GoldPayCnt))
	}
	if m.SilverPayCnt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.SilverPayCnt))
	}
	if m.CostBase != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.CostBase))
	}
	return i, nil
}

func (m *DetailWithSnapShot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetailWithSnapShot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Uid))
	}
	if m.Gold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Gold))
	}
	if m.IapGold != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.IapGold))
	}
	if m.Silver != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Silver))
	}
	if m.GoldRechargeCnt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.GoldRechargeCnt))
	}
	if m.GoldPayCnt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.GoldPayCnt))
	}
	if m.SilverPayCnt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.SilverPayCnt))
	}
	if m.CostBase != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.CostBase))
	}
	if len(m.SnapShotTime) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.SnapShotTime)))
		i += copy(dAtA[i:], m.SnapShotTime)
	}
	if m.SnapShotGold != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.SnapShotGold))
	}
	if m.SnapShotIapGold != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.SnapShotIapGold))
	}
	if m.SnapShotSilver != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.SnapShotSilver))
	}
	if m.Reserved1 != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Reserved1))
	}
	if len(m.Reserved2) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Reserved2)))
		i += copy(dAtA[i:], m.Reserved2)
	}
	return i, nil
}

func (m *McDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *McDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Detail != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Detail.Size()))
		n1, err := m.Detail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Exist {
		dAtA[i] = 0x10
		i++
		if m.Exist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *CoinStreamRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinStreamRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Uid))
	}
	if len(m.TransactionId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TransactionId)))
		i += copy(dAtA[i:], m.TransactionId)
	}
	if len(m.ExtendTid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.ExtendTid)))
		i += copy(dAtA[i:], m.ExtendTid)
	}
	if m.CoinType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.CoinType))
	}
	if m.DeltaCoinNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.DeltaCoinNum))
	}
	if m.OrgCoinNum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.OrgCoinNum))
	}
	if m.OpResult != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.OpResult))
	}
	if m.OpReason != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.OpReason))
	}
	if m.OpType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.OpType))
	}
	if m.OpTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.OpTime))
	}
	if len(m.BizCode) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.BizCode)))
		i += copy(dAtA[i:], m.BizCode)
	}
	if m.Area != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Area))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.MetaData) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.MetaData)))
		i += copy(dAtA[i:], m.MetaData)
	}
	if len(m.BizSource) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.BizSource)))
		i += copy(dAtA[i:], m.BizSource)
	}
	if m.Platform != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Platform))
	}
	if m.Reserved1 != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Reserved1))
	}
	if m.Version != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *CoinExchangeRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinExchangeRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Uid))
	}
	if len(m.TransactionId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TransactionId)))
		i += copy(dAtA[i:], m.TransactionId)
	}
	if m.SrcType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.SrcType))
	}
	if m.SrcNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.SrcNum))
	}
	if m.DestType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.DestType))
	}
	if m.DestNum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.DestNum))
	}
	if m.Status != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Status))
	}
	if m.ExchangeTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.ExchangeTime))
	}
	return i, nil
}

func (m *RecordCoinStreamItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordCoinStreamItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TransactionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TransactionId)))
		i += copy(dAtA[i:], m.TransactionId)
	}
	if len(m.ExtendTid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.ExtendTid)))
		i += copy(dAtA[i:], m.ExtendTid)
	}
	if len(m.CoinType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.CoinType)))
		i += copy(dAtA[i:], m.CoinType)
	}
	if m.CoinNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.CoinNum))
	}
	if m.OrgCoinNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.OrgCoinNum))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Timestamp))
	}
	if m.Reserved1 != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Reserved1))
	}
	return i, nil
}

func (m *BasicParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TransactionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TransactionId)))
		i += copy(dAtA[i:], m.TransactionId)
	}
	if len(m.BizCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.BizCode)))
		i += copy(dAtA[i:], m.BizCode)
	}
	if m.Area != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Area))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.MetaData) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.MetaData)))
		i += copy(dAtA[i:], m.MetaData)
	}
	if len(m.BizSource) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.BizSource)))
		i += copy(dAtA[i:], m.BizSource)
	}
	if m.Reason != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Reason))
	}
	if m.Version != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *MelonseedResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MelonseedResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Gold) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Gold)))
		i += copy(dAtA[i:], m.Gold)
	}
	if len(m.Silver) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Silver)))
		i += copy(dAtA[i:], m.Silver)
	}
	return i, nil
}

func (m *MelonseedWithMetalResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MelonseedWithMetalResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Gold) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Gold)))
		i += copy(dAtA[i:], m.Gold)
	}
	if len(m.Silver) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Silver)))
		i += copy(dAtA[i:], m.Silver)
	}
	if len(m.Metal) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Metal)))
		i += copy(dAtA[i:], m.Metal)
	}
	return i, nil
}

func (m *DetailResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetailResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Gold) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Gold)))
		i += copy(dAtA[i:], m.Gold)
	}
	if len(m.Silver) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Silver)))
		i += copy(dAtA[i:], m.Silver)
	}
	if len(m.GoldRechargeCnt) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.GoldRechargeCnt)))
		i += copy(dAtA[i:], m.GoldRechargeCnt)
	}
	if len(m.GoldPayCnt) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.GoldPayCnt)))
		i += copy(dAtA[i:], m.GoldPayCnt)
	}
	if len(m.SilverPayCnt) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.SilverPayCnt)))
		i += copy(dAtA[i:], m.SilverPayCnt)
	}
	if m.CostBase != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.CostBase))
	}
	return i, nil
}

func (m *DetailWithMetalResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetailWithMetalResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Gold) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Gold)))
		i += copy(dAtA[i:], m.Gold)
	}
	if len(m.Silver) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Silver)))
		i += copy(dAtA[i:], m.Silver)
	}
	if len(m.GoldRechargeCnt) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.GoldRechargeCnt)))
		i += copy(dAtA[i:], m.GoldRechargeCnt)
	}
	if len(m.GoldPayCnt) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.GoldPayCnt)))
		i += copy(dAtA[i:], m.GoldPayCnt)
	}
	if len(m.SilverPayCnt) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.SilverPayCnt)))
		i += copy(dAtA[i:], m.SilverPayCnt)
	}
	if len(m.Metal) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Metal)))
		i += copy(dAtA[i:], m.Metal)
	}
	if m.CostBase != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.CostBase))
	}
	return i, nil
}

func (m *TidResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TidResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TransactionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TransactionId)))
		i += copy(dAtA[i:], m.TransactionId)
	}
	return i, nil
}

func (m *QueryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *MetalData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetalData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Count))))
		i += 8
	}
	return i, nil
}

func (m *WalletChangeMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletChangeMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Action) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Uid))
	}
	if len(m.CoinType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.CoinType)))
		i += copy(dAtA[i:], m.CoinType)
	}
	if len(m.Platfrom) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Platfrom)))
		i += copy(dAtA[i:], m.Platfrom)
	}
	if m.Number != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Number))
	}
	if m.Gold != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Gold))
	}
	if m.Silver != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.Silver))
	}
	if m.GoldRechargeCnt != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.GoldRechargeCnt))
	}
	if m.GoldPayCnt != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.GoldPayCnt))
	}
	if m.SilverPayCnt != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.SilverPayCnt))
	}
	if len(m.DestCoinType) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWallet(dAtA, i, uint64(len(m.DestCoinType)))
		i += copy(dAtA[i:], m.DestCoinType)
	}
	if m.DestNumber != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.DestNumber))
	}
	if m.CostBase != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintWallet(dAtA, i, uint64(m.CostBase))
	}
	return i, nil
}

func encodeVarintWallet(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RechargeOrPayParam) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovWallet(uint64(m.Uid))
	}
	l = len(m.CoinType)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.CoinNum != 0 {
		n += 1 + sovWallet(uint64(m.CoinNum))
	}
	l = len(m.ExtendTid)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovWallet(uint64(m.Timestamp))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.BizCode)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Area != 0 {
		n += 1 + sovWallet(uint64(m.Area))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.MetaData)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.BizSource)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovWallet(uint64(m.Reason))
	}
	if m.Version != 0 {
		n += 1 + sovWallet(uint64(m.Version))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	return n
}

func (m *ExchangeParam) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovWallet(uint64(m.Uid))
	}
	l = len(m.SrcCoinType)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.SrcCoinNum != 0 {
		n += 1 + sovWallet(uint64(m.SrcCoinNum))
	}
	l = len(m.DestCoinType)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.DestCoinNum != 0 {
		n += 1 + sovWallet(uint64(m.DestCoinNum))
	}
	l = len(m.ExtendTid)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovWallet(uint64(m.Timestamp))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.BizCode)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Area != 0 {
		n += 1 + sovWallet(uint64(m.Area))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.MetaData)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.BizSource)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovWallet(uint64(m.Reason))
	}
	if m.Version != 0 {
		n += 1 + sovWallet(uint64(m.Version))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 2 + l + sovWallet(uint64(l))
	}
	return n
}

func (m *Melonseed) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovWallet(uint64(m.Uid))
	}
	if m.Gold != 0 {
		n += 1 + sovWallet(uint64(m.Gold))
	}
	if m.IapGold != 0 {
		n += 1 + sovWallet(uint64(m.IapGold))
	}
	if m.Silver != 0 {
		n += 1 + sovWallet(uint64(m.Silver))
	}
	return n
}

func (m *Detail) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovWallet(uint64(m.Uid))
	}
	if m.Gold != 0 {
		n += 1 + sovWallet(uint64(m.Gold))
	}
	if m.IapGold != 0 {
		n += 1 + sovWallet(uint64(m.IapGold))
	}
	if m.Silver != 0 {
		n += 1 + sovWallet(uint64(m.Silver))
	}
	if m.GoldRechargeCnt != 0 {
		n += 1 + sovWallet(uint64(m.GoldRechargeCnt))
	}
	if m.GoldPayCnt != 0 {
		n += 1 + sovWallet(uint64(m.GoldPayCnt))
	}
	if m.SilverPayCnt != 0 {
		n += 1 + sovWallet(uint64(m.SilverPayCnt))
	}
	if m.CostBase != 0 {
		n += 1 + sovWallet(uint64(m.CostBase))
	}
	return n
}

func (m *DetailWithSnapShot) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovWallet(uint64(m.Uid))
	}
	if m.Gold != 0 {
		n += 1 + sovWallet(uint64(m.Gold))
	}
	if m.IapGold != 0 {
		n += 1 + sovWallet(uint64(m.IapGold))
	}
	if m.Silver != 0 {
		n += 1 + sovWallet(uint64(m.Silver))
	}
	if m.GoldRechargeCnt != 0 {
		n += 1 + sovWallet(uint64(m.GoldRechargeCnt))
	}
	if m.GoldPayCnt != 0 {
		n += 1 + sovWallet(uint64(m.GoldPayCnt))
	}
	if m.SilverPayCnt != 0 {
		n += 1 + sovWallet(uint64(m.SilverPayCnt))
	}
	if m.CostBase != 0 {
		n += 1 + sovWallet(uint64(m.CostBase))
	}
	l = len(m.SnapShotTime)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.SnapShotGold != 0 {
		n += 1 + sovWallet(uint64(m.SnapShotGold))
	}
	if m.SnapShotIapGold != 0 {
		n += 1 + sovWallet(uint64(m.SnapShotIapGold))
	}
	if m.SnapShotSilver != 0 {
		n += 1 + sovWallet(uint64(m.SnapShotSilver))
	}
	if m.Reserved1 != 0 {
		n += 1 + sovWallet(uint64(m.Reserved1))
	}
	l = len(m.Reserved2)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	return n
}

func (m *McDetail) Size() (n int) {
	var l int
	_ = l
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Exist {
		n += 2
	}
	if m.Version != 0 {
		n += 1 + sovWallet(uint64(m.Version))
	}
	return n
}

func (m *CoinStreamRecord) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovWallet(uint64(m.Uid))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.ExtendTid)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.CoinType != 0 {
		n += 1 + sovWallet(uint64(m.CoinType))
	}
	if m.DeltaCoinNum != 0 {
		n += 1 + sovWallet(uint64(m.DeltaCoinNum))
	}
	if m.OrgCoinNum != 0 {
		n += 1 + sovWallet(uint64(m.OrgCoinNum))
	}
	if m.OpResult != 0 {
		n += 1 + sovWallet(uint64(m.OpResult))
	}
	if m.OpReason != 0 {
		n += 1 + sovWallet(uint64(m.OpReason))
	}
	if m.OpType != 0 {
		n += 1 + sovWallet(uint64(m.OpType))
	}
	if m.OpTime != 0 {
		n += 1 + sovWallet(uint64(m.OpTime))
	}
	l = len(m.BizCode)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Area != 0 {
		n += 1 + sovWallet(uint64(m.Area))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.MetaData)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.BizSource)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Platform != 0 {
		n += 2 + sovWallet(uint64(m.Platform))
	}
	if m.Reserved1 != 0 {
		n += 2 + sovWallet(uint64(m.Reserved1))
	}
	if m.Version != 0 {
		n += 2 + sovWallet(uint64(m.Version))
	}
	return n
}

func (m *CoinExchangeRecord) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovWallet(uint64(m.Uid))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.SrcType != 0 {
		n += 1 + sovWallet(uint64(m.SrcType))
	}
	if m.SrcNum != 0 {
		n += 1 + sovWallet(uint64(m.SrcNum))
	}
	if m.DestType != 0 {
		n += 1 + sovWallet(uint64(m.DestType))
	}
	if m.DestNum != 0 {
		n += 1 + sovWallet(uint64(m.DestNum))
	}
	if m.Status != 0 {
		n += 1 + sovWallet(uint64(m.Status))
	}
	if m.ExchangeTime != 0 {
		n += 1 + sovWallet(uint64(m.ExchangeTime))
	}
	return n
}

func (m *RecordCoinStreamItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.ExtendTid)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.CoinType)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.CoinNum != 0 {
		n += 1 + sovWallet(uint64(m.CoinNum))
	}
	if m.OrgCoinNum != 0 {
		n += 1 + sovWallet(uint64(m.OrgCoinNum))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovWallet(uint64(m.Timestamp))
	}
	if m.Reserved1 != 0 {
		n += 1 + sovWallet(uint64(m.Reserved1))
	}
	return n
}

func (m *BasicParam) Size() (n int) {
	var l int
	_ = l
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.BizCode)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Area != 0 {
		n += 1 + sovWallet(uint64(m.Area))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.MetaData)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.BizSource)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovWallet(uint64(m.Reason))
	}
	if m.Version != 0 {
		n += 1 + sovWallet(uint64(m.Version))
	}
	return n
}

func (m *MelonseedResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Gold)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.Silver)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	return n
}

func (m *MelonseedWithMetalResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Gold)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.Silver)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.Metal)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	return n
}

func (m *DetailResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Gold)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.Silver)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.GoldRechargeCnt)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.GoldPayCnt)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.SilverPayCnt)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.CostBase != 0 {
		n += 1 + sovWallet(uint64(m.CostBase))
	}
	return n
}

func (m *DetailWithMetalResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Gold)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.Silver)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.GoldRechargeCnt)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.GoldPayCnt)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.SilverPayCnt)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.Metal)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.CostBase != 0 {
		n += 1 + sovWallet(uint64(m.CostBase))
	}
	return n
}

func (m *TidResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	return n
}

func (m *QueryResp) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovWallet(uint64(m.Status))
	}
	return n
}

func (m *MetalData) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 9
	}
	return n
}

func (m *WalletChangeMsg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovWallet(uint64(m.Uid))
	}
	l = len(m.CoinType)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.Platfrom)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovWallet(uint64(m.Number))
	}
	if m.Gold != 0 {
		n += 1 + sovWallet(uint64(m.Gold))
	}
	if m.Silver != 0 {
		n += 1 + sovWallet(uint64(m.Silver))
	}
	if m.GoldRechargeCnt != 0 {
		n += 1 + sovWallet(uint64(m.GoldRechargeCnt))
	}
	if m.GoldPayCnt != 0 {
		n += 1 + sovWallet(uint64(m.GoldPayCnt))
	}
	if m.SilverPayCnt != 0 {
		n += 1 + sovWallet(uint64(m.SilverPayCnt))
	}
	l = len(m.DestCoinType)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.DestNumber != 0 {
		n += 1 + sovWallet(uint64(m.DestNumber))
	}
	if m.CostBase != 0 {
		n += 1 + sovWallet(uint64(m.CostBase))
	}
	return n
}

func sovWallet(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWallet(x uint64) (n int) {
	return sovWallet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RechargeOrPayParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeOrPayParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeOrPayParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinNum", wireType)
			}
			m.CoinNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendTid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendTid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcCoinType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcCoinType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcCoinNum", wireType)
			}
			m.SrcCoinNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcCoinNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestCoinType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestCoinType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestCoinNum", wireType)
			}
			m.DestCoinNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestCoinNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendTid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendTid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Melonseed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Melonseed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Melonseed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IapGold", wireType)
			}
			m.IapGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IapGold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silver", wireType)
			}
			m.Silver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Silver |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Detail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IapGold", wireType)
			}
			m.IapGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IapGold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silver", wireType)
			}
			m.Silver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Silver |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldRechargeCnt", wireType)
			}
			m.GoldRechargeCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldRechargeCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldPayCnt", wireType)
			}
			m.GoldPayCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldPayCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SilverPayCnt", wireType)
			}
			m.SilverPayCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SilverPayCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostBase", wireType)
			}
			m.CostBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostBase |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetailWithSnapShot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetailWithSnapShot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetailWithSnapShot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IapGold", wireType)
			}
			m.IapGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IapGold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silver", wireType)
			}
			m.Silver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Silver |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldRechargeCnt", wireType)
			}
			m.GoldRechargeCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldRechargeCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldPayCnt", wireType)
			}
			m.GoldPayCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldPayCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SilverPayCnt", wireType)
			}
			m.SilverPayCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SilverPayCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostBase", wireType)
			}
			m.CostBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostBase |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapShotTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapShotTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapShotGold", wireType)
			}
			m.SnapShotGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapShotGold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapShotIapGold", wireType)
			}
			m.SnapShotIapGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapShotIapGold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapShotSilver", wireType)
			}
			m.SnapShotSilver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapShotSilver |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *McDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: McDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: McDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &Detail{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exist = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinStreamRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinStreamRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinStreamRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendTid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendTid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			m.CoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaCoinNum", wireType)
			}
			m.DeltaCoinNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeltaCoinNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgCoinNum", wireType)
			}
			m.OrgCoinNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgCoinNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpResult", wireType)
			}
			m.OpResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpResult |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpReason", wireType)
			}
			m.OpReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpReason |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpType", wireType)
			}
			m.OpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpTime", wireType)
			}
			m.OpTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			m.Platform = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Platform |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinExchangeRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinExchangeRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinExchangeRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcType", wireType)
			}
			m.SrcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcNum", wireType)
			}
			m.SrcNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestType", wireType)
			}
			m.DestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestNum", wireType)
			}
			m.DestNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeTime", wireType)
			}
			m.ExchangeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExchangeTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordCoinStreamItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordCoinStreamItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordCoinStreamItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendTid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendTid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinNum", wireType)
			}
			m.CoinNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgCoinNum", wireType)
			}
			m.OrgCoinNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgCoinNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MelonseedResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MelonseedResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MelonseedResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Silver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MelonseedWithMetalResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MelonseedWithMetalResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MelonseedWithMetalResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Silver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetailResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetailResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetailResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Silver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldRechargeCnt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoldRechargeCnt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldPayCnt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoldPayCnt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SilverPayCnt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SilverPayCnt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostBase", wireType)
			}
			m.CostBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostBase |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetailWithMetalResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetailWithMetalResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetailWithMetalResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Silver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldRechargeCnt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoldRechargeCnt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldPayCnt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoldPayCnt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SilverPayCnt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SilverPayCnt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostBase", wireType)
			}
			m.CostBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostBase |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TidResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TidResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TidResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetalData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetalData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetalData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Count = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletChangeMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletChangeMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletChangeMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platfrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platfrom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silver", wireType)
			}
			m.Silver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Silver |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldRechargeCnt", wireType)
			}
			m.GoldRechargeCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldRechargeCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldPayCnt", wireType)
			}
			m.GoldPayCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldPayCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SilverPayCnt", wireType)
			}
			m.SilverPayCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SilverPayCnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestCoinType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestCoinType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestNumber", wireType)
			}
			m.DestNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestNumber |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostBase", wireType)
			}
			m.CostBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostBase |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWallet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthWallet
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWallet
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWallet(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWallet = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWallet   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("wallet.proto", fileDescriptorWallet) }

var fileDescriptorWallet = []byte{
	// 1592 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcf, 0x6e, 0x1c, 0x45,
	0x13, 0xff, 0xf6, 0xff, 0x4e, 0xaf, 0xd7, 0x76, 0x26, 0xdf, 0xf7, 0x69, 0x41, 0x91, 0x27, 0x1a,
	0x44, 0x08, 0x22, 0xd8, 0xc4, 0x51, 0x10, 0x12, 0x07, 0x94, 0x75, 0x22, 0x94, 0x83, 0x63, 0xa7,
	0x6d, 0xc8, 0x71, 0xd5, 0x9e, 0xe9, 0xac, 0x47, 0x9a, 0x7f, 0xea, 0xe9, 0x0d, 0x71, 0x38, 0x73,
	0xe3, 0xc0, 0x91, 0x07, 0xe0, 0x15, 0x78, 0x07, 0xc4, 0x21, 0x42, 0x5c, 0xb8, 0x8d, 0x50, 0xc2,
	0x69, 0x1e, 0x81, 0x13, 0xea, 0xea, 0x9e, 0xe9, 0x99, 0x8d, 0xed, 0x1d, 0x3b, 0x8e, 0x04, 0x12,
	0xb7, 0x99, 0xaa, 0xea, 0xee, 0x9a, 0xea, 0x5f, 0x55, 0xfd, 0x6a, 0xd0, 0xd2, 0x57, 0xc4, 0xf7,
	0x29, 0x5f, 0x8f, 0x59, 0xc4, 0x23, 0xb3, 0x13, 0x44, 0x2e, 0xf5, 0xdf, 0xfe, 0x70, 0xea, 0xf1,
	0xc3, 0xd9, 0xc1, 0xba, 0x13, 0x05, 0x1b, 0xd3, 0x68, 0x1a, 0x6d, 0x80, 0xf6, 0x60, 0xf6, 0x18,
	0xde, 0xe0, 0x05, 0x9e, 0xe4, 0x2a, 0xfb, 0xd7, 0x36, 0x32, 0x31, 0x75, 0x0e, 0x09, 0x9b, 0xd2,
	0x1d, 0xb6, 0x4b, 0x8e, 0x76, 0x09, 0x23, 0x81, 0xf9, 0x16, 0x6a, 0x7d, 0xe1, 0xb9, 0xa3, 0xc6,
	0xd5, 0xc6, 0xf5, 0xd6, 0xb8, 0x97, 0xa5, 0x56, 0x6b, 0xe6, 0xb9, 0x58, 0xc8, 0xcc, 0xf7, 0x51,
	0x7f, 0x2b, 0xf2, 0xc2, 0xfd, 0xa3, 0x98, 0x8e, 0x9a, 0x57, 0x1b, 0xd7, 0x8d, 0xf1, 0x30, 0x4b,
	0x2d, 0xc3, 0x89, 0xbc, 0x70, 0xc2, 0x8f, 0x62, 0x8a, 0x0b, 0xb5, 0x79, 0x0d, 0xf5, 0xc4, 0xf3,
	0x83, 0x59, 0x30, 0x6a, 0xc1, 0x4e, 0x4b, 0x59, 0x6a, 0xf5, 0xc1, 0x32, 0x9c, 0x05, 0x38, 0x57,
	0x9a, 0x37, 0x90, 0x71, 0xef, 0x29, 0xa7, 0xa1, 0xbb, 0xef, 0xb9, 0xa3, 0x36, 0xec, 0xb9, 0x9c,
	0xa5, 0x16, 0xa2, 0x20, 0x9c, 0x70, 0xcf, 0xc5, 0xda, 0xc0, 0xfc, 0x00, 0x19, 0xfb, 0x5e, 0x40,
	0x13, 0x4e, 0x82, 0x78, 0xd4, 0x81, 0x7d, 0xc1, 0x03, 0x9e, 0x0b, 0xb1, 0xd6, 0x9b, 0x9f, 0xa0,
	0xe1, 0x3e, 0x23, 0x61, 0x42, 0x1c, 0xee, 0x45, 0xe1, 0x7d, 0x77, 0xd4, 0x85, 0xed, 0xcd, 0x2c,
	0xb5, 0x96, 0xb9, 0x56, 0x4c, 0x3c, 0x17, 0x57, 0x0d, 0x85, 0xf3, 0x63, 0xef, 0xd9, 0x56, 0xe4,
	0xd2, 0x51, 0x0f, 0xd6, 0x80, 0xf3, 0x07, 0xde, 0xb3, 0x89, 0x13, 0xb9, 0x14, 0xe7, 0x4a, 0xf3,
	0x0a, 0x6a, 0xdf, 0x61, 0x94, 0x8c, 0xfa, 0xe0, 0x49, 0x3f, 0x4b, 0xad, 0x36, 0x61, 0x94, 0x60,
	0x90, 0x9a, 0x36, 0xea, 0xee, 0x45, 0x33, 0xe6, 0xd0, 0x91, 0x01, 0x9b, 0xa0, 0x2c, 0xb5, 0xba,
	0x09, 0x48, 0xb0, 0xd2, 0x98, 0xd7, 0x51, 0x7f, 0x9b, 0x72, 0x72, 0x97, 0x70, 0x32, 0x42, 0xfa,
	0xa8, 0x80, 0x72, 0xe2, 0x12, 0x4e, 0x70, 0xa1, 0x15, 0x81, 0x1a, 0x7b, 0xcf, 0xd4, 0x86, 0x03,
	0x1d, 0x28, 0xe1, 0x95, 0xda, 0x54, 0x1b, 0x98, 0xd7, 0x50, 0x17, 0x53, 0x92, 0x44, 0xe1, 0x68,
	0x09, 0x7c, 0x2b, 0x4c, 0x19, 0x48, 0xb1, 0xd2, 0x9a, 0xef, 0xa2, 0xde, 0x97, 0x94, 0x25, 0x5e,
	0x14, 0x8e, 0x86, 0x60, 0x38, 0xc8, 0x52, 0xab, 0xf7, 0x44, 0x8a, 0x70, 0xae, 0x13, 0x6e, 0xee,
	0xfa, 0x84, 0x3f, 0x8e, 0x58, 0x30, 0x5a, 0xd6, 0x6e, 0xc6, 0x4a, 0x86, 0x0b, 0xad, 0xfd, 0xbc,
	0x83, 0x86, 0xf7, 0x9e, 0x3a, 0x87, 0x24, 0x9c, 0xd2, 0x85, 0x78, 0xba, 0x85, 0x06, 0x7b, 0xcc,
	0x99, 0x83, 0xd4, 0xa5, 0x2c, 0xb5, 0x86, 0x09, 0x73, 0x26, 0x1a, 0x56, 0x65, 0x2b, 0xf3, 0x23,
	0x84, 0xd4, 0xab, 0x06, 0xd7, 0x6a, 0x96, 0x5a, 0x4b, 0xc5, 0x1a, 0x01, 0xb0, 0x92, 0x8d, 0xf9,
	0x31, 0x5a, 0xba, 0x4b, 0x13, 0x5e, 0x9c, 0xd3, 0xd6, 0x38, 0x70, 0x69, 0xc2, 0x4b, 0x07, 0x55,
	0xec, 0x84, 0x7b, 0xf9, 0xbb, 0x38, 0x4a, 0xe2, 0x0d, 0xdc, 0xd3, 0xcb, 0xc4, 0x59, 0x65, 0xab,
	0x2a, 0xa0, 0xbb, 0x67, 0x02, 0x74, 0xef, 0xac, 0x80, 0xee, 0x9f, 0x03, 0xd0, 0x46, 0x1d, 0x40,
	0xa3, 0x05, 0x80, 0x1e, 0xd4, 0x02, 0xf4, 0x52, 0x7d, 0x40, 0x0f, 0xeb, 0x03, 0x7a, 0xb9, 0x2e,
	0xa0, 0x57, 0x6a, 0x02, 0x7a, 0xf5, 0x54, 0x40, 0x7f, 0xd7, 0x40, 0xc6, 0x36, 0xf5, 0xa3, 0x30,
	0xa1, 0xd4, 0x3d, 0x0d, 0xcc, 0x57, 0x50, 0xfb, 0xf3, 0xc8, 0x77, 0x01, 0xc5, 0x2a, 0x76, 0xd3,
	0xc8, 0x77, 0x31, 0x48, 0xc5, 0x0d, 0xdc, 0x27, 0x31, 0x18, 0x94, 0xea, 0xa1, 0x47, 0xe2, 0x09,
	0x18, 0xe5, 0x4a, 0x88, 0xb1, 0xe7, 0x3f, 0xa1, 0x0c, 0x50, 0xda, 0x52, 0x31, 0x06, 0x09, 0x56,
	0x1a, 0xfb, 0x65, 0x13, 0x75, 0xef, 0x52, 0x4e, 0x3c, 0xff, 0x6f, 0xe1, 0x8f, 0xf9, 0x19, 0x5a,
	0x11, 0xb6, 0x79, 0x2f, 0xd9, 0x0a, 0xb9, 0xca, 0x95, 0xff, 0x65, 0xa9, 0x75, 0x49, 0xec, 0x37,
	0x61, 0x4a, 0x37, 0x71, 0x42, 0x8e, 0xe7, 0xad, 0x45, 0x4a, 0x0b, 0xd1, 0x2e, 0x39, 0x12, 0x6b,
	0xbb, 0x3a, 0xa5, 0x61, 0x6d, 0x4c, 0x8e, 0x60, 0x59, 0xc9, 0x46, 0xa4, 0xb4, 0x3c, 0x5c, 0xad,
	0x91, 0xa9, 0x03, 0x99, 0x20, 0x9d, 0x2b, 0x56, 0x55, 0xec, 0x64, 0x07, 0x4b, 0xf8, 0x98, 0x24,
	0x54, 0x55, 0x6d, 0xd5, 0xc1, 0x12, 0x3e, 0x39, 0x20, 0x09, 0x74, 0x30, 0xa9, 0xb6, 0x7f, 0xec,
	0x20, 0x53, 0x46, 0xf9, 0x91, 0xc7, 0x0f, 0xf7, 0x42, 0x12, 0xef, 0x1d, 0x46, 0xfc, 0xdf, 0x88,
	0xbf, 0xb1, 0x88, 0x9b, 0xb7, 0xd1, 0x52, 0x1e, 0x66, 0x51, 0xf4, 0x54, 0xa9, 0x92, 0xfd, 0x20,
	0x24, 0x71, 0x72, 0x18, 0xf1, 0x89, 0x28, 0x8c, 0xb8, 0x62, 0x56, 0x5e, 0x06, 0xd1, 0x45, 0xba,
	0x4e, 0x17, 0xcb, 0x20, 0xc4, 0x15, 0x33, 0x11, 0xc3, 0xfc, 0x3d, 0xbf, 0x97, 0x81, 0x8e, 0x61,
	0xb1, 0xb2, 0xb8, 0xa0, 0x79, 0x6b, 0xf3, 0x53, 0xb4, 0x9c, 0x8b, 0xd4, 0x85, 0xc9, 0x5e, 0x7b,
	0x39, 0x4b, 0xad, 0x95, 0x62, 0xbd, 0xba, 0xb9, 0x39, 0x53, 0x51, 0xf8, 0x31, 0x4d, 0x28, 0x7b,
	0x42, 0xdd, 0x9b, 0xaa, 0xf5, 0x42, 0x5c, 0x58, 0x2e, 0xc4, 0x5a, 0x5f, 0x36, 0xde, 0x54, 0xfd,
	0xb7, 0x62, 0xbc, 0xa9, 0x8d, 0x37, 0xed, 0x6f, 0x1a, 0xa8, 0xbf, 0xed, 0xa8, 0xfa, 0x70, 0x33,
	0xaf, 0x14, 0x00, 0xd8, 0xc1, 0xe6, 0x70, 0x1d, 0xa8, 0xe2, 0xba, 0x14, 0x4a, 0x6c, 0xb9, 0xf0,
	0x8c, 0xf3, 0x92, 0x62, 0xa1, 0xce, 0xbd, 0xa7, 0x5e, 0xc2, 0x01, 0xc6, 0xfd, 0xb1, 0x91, 0xa5,
	0x56, 0x87, 0x0a, 0x01, 0x96, 0xf2, 0x72, 0x89, 0x15, 0x40, 0xee, 0x1c, 0x5f, 0x62, 0xed, 0x6f,
	0xbb, 0x68, 0x55, 0x34, 0xc5, 0x3d, 0xce, 0x28, 0x09, 0x30, 0x75, 0x22, 0x76, 0x6a, 0xfd, 0x7c,
	0xa5, 0xbb, 0x35, 0xeb, 0x76, 0xb7, 0x4a, 0xcb, 0x6d, 0x2d, 0x6a, 0xb9, 0x65, 0x12, 0xdb, 0x06,
	0xff, 0x4f, 0x24, 0xb1, 0x40, 0x1c, 0x7c, 0x4e, 0xaa, 0x0c, 0x40, 0x11, 0x07, 0x9f, 0x13, 0x4d,
	0x01, 0x2a, 0x76, 0x22, 0xbb, 0x76, 0xd8, 0x34, 0x5f, 0x55, 0xca, 0xae, 0x88, 0x4d, 0x4b, 0x14,
	0x45, 0xdb, 0x08, 0xa7, 0x76, 0x62, 0x4c, 0x93, 0x99, 0x2f, 0x33, 0x4b, 0x39, 0x15, 0xc5, 0x13,
	0x06, 0x42, 0x5c, 0xa8, 0x73, 0x53, 0xe8, 0x85, 0xfd, 0x39, 0x53, 0x68, 0x85, 0x85, 0xda, 0x7c,
	0x07, 0x75, 0x77, 0x62, 0xf8, 0x50, 0x43, 0x5f, 0x54, 0x14, 0xcb, 0xcf, 0x54, 0x2a, 0x65, 0x24,
	0xf2, 0x0d, 0xe9, 0x86, 0x29, 0x8c, 0x44, 0xa6, 0x29, 0x55, 0x99, 0x40, 0x0c, 0x16, 0x10, 0x08,
	0x41, 0x18, 0x54, 0x26, 0x94, 0x08, 0x04, 0xa9, 0x12, 0x88, 0x61, 0x2d, 0x02, 0xb1, 0x5c, 0x9f,
	0x40, 0xac, 0x2c, 0x22, 0x10, 0xf3, 0x1d, 0xbf, 0x73, 0x52, 0xc7, 0xaf, 0xa6, 0xe6, 0xa5, 0x05,
	0xa9, 0xf9, 0x9e, 0x4e, 0x06, 0xf3, 0x55, 0xd3, 0xdb, 0x3a, 0x1d, 0xfe, 0x68, 0x22, 0x53, 0xdc,
	0x76, 0x4e, 0x8e, 0xdf, 0x64, 0x42, 0x5c, 0x43, 0xbd, 0x3d, 0xe6, 0xc0, 0xc5, 0xb7, 0xf4, 0xa7,
	0x0a, 0x7e, 0x0c, 0x37, 0x9f, 0x2b, 0xc5, 0xd5, 0xef, 0x31, 0x47, 0x60, 0xb4, 0xad, 0xf1, 0x21,
	0xcc, 0x04, 0x3c, 0x95, 0x4a, 0xe0, 0x4d, 0xf0, 0x5b, 0xd8, 0xad, 0xa3, 0xf1, 0x06, 0x14, 0x58,
	0xe6, 0x4b, 0xae, 0x16, 0xe7, 0x8a, 0xe7, 0x1c, 0xf4, 0xea, 0x5c, 0xb0, 0x84, 0xa1, 0x4f, 0x29,
	0x01, 0x07, 0x9c, 0xf0, 0x59, 0xa2, 0xb0, 0x2e, 0x71, 0x00, 0x12, 0xac, 0x34, 0xa2, 0xaa, 0xe7,
	0xa1, 0x02, 0x70, 0xf6, 0x75, 0x55, 0xa7, 0x4a, 0xae, 0x9a, 0x41, 0xd9, 0xcc, 0xfe, 0xb3, 0x89,
	0xfe, 0x2b, 0x43, 0xab, 0x6b, 0xcf, 0x7d, 0x4e, 0x83, 0x57, 0xa3, 0xd9, 0x38, 0x57, 0x79, 0x69,
	0x9e, 0xa5, 0xbc, 0xb4, 0x6a, 0xcf, 0xc8, 0xed, 0xd3, 0x66, 0xe4, 0xf5, 0x4a, 0x39, 0xe9, 0x68,
	0xfe, 0xeb, 0xd3, 0xc7, 0x72, 0x0c, 0x49, 0x2a, 0xc5, 0xe4, 0x0a, 0x6a, 0xc3, 0xf1, 0x72, 0xfa,
	0x80, 0x24, 0x84, 0x93, 0x41, 0x7a, 0xb6, 0x91, 0xe3, 0x46, 0x39, 0x17, 0xfa, 0xc7, 0x32, 0x6f,
	0x6d, 0x60, 0xff, 0xd6, 0x44, 0x68, 0x4c, 0x12, 0xcf, 0x91, 0x93, 0xdf, 0xf9, 0x43, 0x5e, 0x2a,
	0x37, 0xcd, 0x3a, 0xe5, 0xa6, 0xb5, 0xa0, 0xdc, 0xb4, 0x6b, 0x95, 0x9b, 0x4e, 0xfd, 0x72, 0xd3,
	0xad, 0x3f, 0xaf, 0xf4, 0xea, 0xce, 0x2b, 0xfd, 0x93, 0xe7, 0x15, 0xfb, 0x21, 0x1a, 0x16, 0x43,
	0x08, 0xa6, 0x49, 0x5c, 0x70, 0xcd, 0x86, 0xbe, 0xe3, 0x12, 0xd7, 0xd4, 0x1c, 0xb2, 0x59, 0xfa,
	0xf2, 0xea, 0x14, 0xf1, 0x35, 0xfa, 0x7f, 0xb1, 0xa5, 0x60, 0xb8, 0xe2, 0x43, 0xfd, 0x8b, 0xd9,
	0x5b, 0x70, 0x08, 0xd8, 0x4e, 0x65, 0x00, 0x70, 0x88, 0x00, 0xf6, 0x97, 0x72, 0xfb, 0x87, 0x26,
	0x42, 0x92, 0x6f, 0x5c, 0xd0, 0x89, 0x27, 0x30, 0x62, 0xe3, 0x35, 0x18, 0xb1, 0x71, 0x0e, 0x46,
	0x6c, 0x5c, 0xec, 0x0c, 0xf2, 0xbc, 0x89, 0x2e, 0xeb, 0x19, 0xe4, 0x22, 0x6f, 0xe8, 0x1f, 0x14,
	0xaf, 0x02, 0x4c, 0xfd, 0xe3, 0xc1, 0x54, 0x09, 0xa8, 0x71, 0x7a, 0x40, 0xb7, 0x50, 0x6f, 0xdf,
	0x93, 0x19, 0x74, 0xee, 0xea, 0x64, 0x6f, 0x20, 0xe3, 0xe1, 0x8c, 0xb2, 0x23, 0xd8, 0x46, 0xf7,
	0xb2, 0xc6, 0x49, 0xbd, 0xcc, 0xbe, 0x81, 0x0c, 0xf0, 0x14, 0xea, 0x88, 0x85, 0x3a, 0x5b, 0xd1,
	0x2c, 0xe4, 0x60, 0xdf, 0x90, 0x9f, 0xe3, 0x08, 0x01, 0x96, 0x72, 0xfb, 0xe7, 0x36, 0x5a, 0x79,
	0x04, 0xbf, 0x77, 0xb7, 0xa0, 0xaf, 0x6d, 0x27, 0x53, 0x71, 0xca, 0x1d, 0x38, 0x5e, 0x79, 0x09,
	0xa7, 0x48, 0x87, 0xb0, 0xd2, 0xe4, 0x54, 0xa2, 0xb9, 0xe0, 0xc7, 0xed, 0x82, 0xa6, 0x94, 0xf3,
	0x24, 0x16, 0x05, 0xaa, 0x6c, 0x1e, 0xc7, 0x93, 0x58, 0x04, 0x5d, 0xfc, 0xc1, 0x2c, 0x38, 0xa0,
	0x4c, 0xb5, 0x24, 0xf0, 0x29, 0x04, 0x09, 0x56, 0x9a, 0x02, 0xa8, 0xdd, 0x63, 0x47, 0x62, 0x0d,
	0xd4, 0xde, 0x59, 0x46, 0xdd, 0xfe, 0x6b, 0x8c, 0xba, 0xc6, 0x39, 0x46, 0x5d, 0x54, 0x73, 0xd4,
	0x9d, 0xff, 0xcf, 0x38, 0xa8, 0xf9, 0x9f, 0x71, 0x43, 0xd4, 0x42, 0x60, 0x46, 0x07, 0xc5, 0x10,
	0xb9, 0x92, 0xa5, 0xd6, 0x20, 0x67, 0x4e, 0x22, 0xa2, 0x25, 0x93, 0x0a, 0xe0, 0x87, 0xa7, 0x02,
	0x7e, 0xbc, 0xfa, 0xd3, 0x8b, 0xb5, 0xc6, 0x2f, 0x2f, 0xd6, 0x1a, 0xbf, 0xbf, 0x58, 0x6b, 0x7c,
	0xff, 0x72, 0xed, 0x3f, 0x07, 0x5d, 0xf8, 0xfb, 0x7f, 0xeb, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x60, 0xa8, 0xba, 0x97, 0x43, 0x18, 0x00, 0x00,
}
