// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/http/v1/titans.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type EasyGetReq struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" form:"id"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty" form:"page"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EasyGetReq) Reset()         { *m = EasyGetReq{} }
func (m *EasyGetReq) String() string { return proto.CompactTextString(m) }
func (*EasyGetReq) ProtoMessage()    {}
func (*EasyGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{0}
}
func (m *EasyGetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EasyGetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EasyGetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EasyGetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EasyGetReq.Merge(dst, src)
}
func (m *EasyGetReq) XXX_Size() int {
	return m.Size()
}
func (m *EasyGetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_EasyGetReq.DiscardUnknown(m)
}

var xxx_messageInfo_EasyGetReq proto.InternalMessageInfo

func (m *EasyGetReq) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EasyGetReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type EasyGetResp struct {
	List                 []*EasyList `protobuf:"bytes,1,rep,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *EasyGetResp) Reset()         { *m = EasyGetResp{} }
func (m *EasyGetResp) String() string { return proto.CompactTextString(m) }
func (*EasyGetResp) ProtoMessage()    {}
func (*EasyGetResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{1}
}
func (m *EasyGetResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EasyGetResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EasyGetResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EasyGetResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EasyGetResp.Merge(dst, src)
}
func (m *EasyGetResp) XXX_Size() int {
	return m.Size()
}
func (m *EasyGetResp) XXX_DiscardUnknown() {
	xxx_messageInfo_EasyGetResp.DiscardUnknown(m)
}

var xxx_messageInfo_EasyGetResp proto.InternalMessageInfo

func (m *EasyGetResp) GetList() []*EasyList {
	if m != nil {
		return m.List
	}
	return nil
}

type EasyList struct {
	TreeName             string   `protobuf:"bytes,1,opt,name=tree_name,json=treeName,proto3" json:"tree_name"`
	TreePath             string   `protobuf:"bytes,2,opt,name=tree_path,json=treePath,proto3" json:"tree_path"`
	TreeId               int64    `protobuf:"varint,3,opt,name=tree_id,json=treeId,proto3" json:"tree_id"`
	Keyword              string   `protobuf:"bytes,4,opt,name=keyword,proto3" json:"keyword"`
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EasyList) Reset()         { *m = EasyList{} }
func (m *EasyList) String() string { return proto.CompactTextString(m) }
func (*EasyList) ProtoMessage()    {}
func (*EasyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{2}
}
func (m *EasyList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EasyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EasyList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EasyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EasyList.Merge(dst, src)
}
func (m *EasyList) XXX_Size() int {
	return m.Size()
}
func (m *EasyList) XXX_DiscardUnknown() {
	xxx_messageInfo_EasyList.DiscardUnknown(m)
}

var xxx_messageInfo_EasyList proto.InternalMessageInfo

func (m *EasyList) GetTreeName() string {
	if m != nil {
		return m.TreeName
	}
	return ""
}

func (m *EasyList) GetTreePath() string {
	if m != nil {
		return m.TreePath
	}
	return ""
}

func (m *EasyList) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *EasyList) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *EasyList) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type EasySetReq struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" form:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EasySetReq) Reset()         { *m = EasySetReq{} }
func (m *EasySetReq) String() string { return proto.CompactTextString(m) }
func (*EasySetReq) ProtoMessage()    {}
func (*EasySetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{3}
}
func (m *EasySetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EasySetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EasySetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EasySetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EasySetReq.Merge(dst, src)
}
func (m *EasySetReq) XXX_Size() int {
	return m.Size()
}
func (m *EasySetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_EasySetReq.DiscardUnknown(m)
}

var xxx_messageInfo_EasySetReq proto.InternalMessageInfo

func (m *EasySetReq) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type EasySetResp struct {
	EId                  int64    `protobuf:"varint,1,opt,name=eId,proto3" json:"eId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EasySetResp) Reset()         { *m = EasySetResp{} }
func (m *EasySetResp) String() string { return proto.CompactTextString(m) }
func (*EasySetResp) ProtoMessage()    {}
func (*EasySetResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{4}
}
func (m *EasySetResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EasySetResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EasySetResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EasySetResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EasySetResp.Merge(dst, src)
}
func (m *EasySetResp) XXX_Size() int {
	return m.Size()
}
func (m *EasySetResp) XXX_DiscardUnknown() {
	xxx_messageInfo_EasySetResp.DiscardUnknown(m)
}

var xxx_messageInfo_EasySetResp proto.InternalMessageInfo

func (m *EasySetResp) GetEId() int64 {
	if m != nil {
		return m.EId
	}
	return 0
}

type TreeAppsReq struct {
	Node                 string   `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty" form:"node"`
	Team                 string   `protobuf:"bytes,2,opt,name=team,proto3" json:"team,omitempty" form:"team"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TreeAppsReq) Reset()         { *m = TreeAppsReq{} }
func (m *TreeAppsReq) String() string { return proto.CompactTextString(m) }
func (*TreeAppsReq) ProtoMessage()    {}
func (*TreeAppsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{5}
}
func (m *TreeAppsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TreeAppsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TreeAppsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TreeAppsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TreeAppsReq.Merge(dst, src)
}
func (m *TreeAppsReq) XXX_Size() int {
	return m.Size()
}
func (m *TreeAppsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TreeAppsReq.DiscardUnknown(m)
}

var xxx_messageInfo_TreeAppsReq proto.InternalMessageInfo

func (m *TreeAppsReq) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *TreeAppsReq) GetTeam() string {
	if m != nil {
		return m.Team
	}
	return ""
}

type TreeAppsResp struct {
	List                 []*Node  `protobuf:"bytes,1,rep,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TreeAppsResp) Reset()         { *m = TreeAppsResp{} }
func (m *TreeAppsResp) String() string { return proto.CompactTextString(m) }
func (*TreeAppsResp) ProtoMessage()    {}
func (*TreeAppsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{6}
}
func (m *TreeAppsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TreeAppsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TreeAppsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TreeAppsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TreeAppsResp.Merge(dst, src)
}
func (m *TreeAppsResp) XXX_Size() int {
	return m.Size()
}
func (m *TreeAppsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TreeAppsResp.DiscardUnknown(m)
}

var xxx_messageInfo_TreeAppsResp proto.InternalMessageInfo

func (m *TreeAppsResp) GetList() []*Node {
	if m != nil {
		return m.List
	}
	return nil
}

type Node struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path"`
	TreeId               int64    `protobuf:"varint,3,opt,name=tree_id,json=treeId,proto3" json:"tree_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{7}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(dst, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Node) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

type MultiConfigReq struct {
	Values               string   `protobuf:"bytes,1,opt,name=values,proto3" json:"values,omitempty" form:"values"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MultiConfigReq) Reset()         { *m = MultiConfigReq{} }
func (m *MultiConfigReq) String() string { return proto.CompactTextString(m) }
func (*MultiConfigReq) ProtoMessage()    {}
func (*MultiConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{8}
}
func (m *MultiConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiConfigReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MultiConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiConfigReq.Merge(dst, src)
}
func (m *MultiConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *MultiConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_MultiConfigReq proto.InternalMessageInfo

func (m *MultiConfigReq) GetValues() string {
	if m != nil {
		return m.Values
	}
	return ""
}

type MultiConfigResp struct {
	List                 map[int64]*MChild `protobuf:"bytes,1,rep,name=list,proto3" json:"list" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MultiConfigResp) Reset()         { *m = MultiConfigResp{} }
func (m *MultiConfigResp) String() string { return proto.CompactTextString(m) }
func (*MultiConfigResp) ProtoMessage()    {}
func (*MultiConfigResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{9}
}
func (m *MultiConfigResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiConfigResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiConfigResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MultiConfigResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiConfigResp.Merge(dst, src)
}
func (m *MultiConfigResp) XXX_Size() int {
	return m.Size()
}
func (m *MultiConfigResp) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiConfigResp.DiscardUnknown(m)
}

var xxx_messageInfo_MultiConfigResp proto.InternalMessageInfo

func (m *MultiConfigResp) GetList() map[int64]*MChild {
	if m != nil {
		return m.List
	}
	return nil
}

type MChild struct {
	Keys                 map[string]string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MChild) Reset()         { *m = MChild{} }
func (m *MChild) String() string { return proto.CompactTextString(m) }
func (*MChild) ProtoMessage()    {}
func (*MChild) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{10}
}
func (m *MChild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MChild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MChild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MChild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MChild.Merge(dst, src)
}
func (m *MChild) XXX_Size() int {
	return m.Size()
}
func (m *MChild) XXX_DiscardUnknown() {
	xxx_messageInfo_MChild.DiscardUnknown(m)
}

var xxx_messageInfo_MChild proto.InternalMessageInfo

func (m *MChild) GetKeys() map[string]string {
	if m != nil {
		return m.Keys
	}
	return nil
}

type ServiceConfigReq struct {
	TreeId               int64    `protobuf:"varint,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty" form:"tree_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceConfigReq) Reset()         { *m = ServiceConfigReq{} }
func (m *ServiceConfigReq) String() string { return proto.CompactTextString(m) }
func (*ServiceConfigReq) ProtoMessage()    {}
func (*ServiceConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{11}
}
func (m *ServiceConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceConfigReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServiceConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceConfigReq.Merge(dst, src)
}
func (m *ServiceConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *ServiceConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceConfigReq proto.InternalMessageInfo

func (m *ServiceConfigReq) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

type ServiceConfigResp struct {
	List                 map[string]string `protobuf:"bytes,1,rep,name=list,proto3" json:"list" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ServiceConfigResp) Reset()         { *m = ServiceConfigResp{} }
func (m *ServiceConfigResp) String() string { return proto.CompactTextString(m) }
func (*ServiceConfigResp) ProtoMessage()    {}
func (*ServiceConfigResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{12}
}
func (m *ServiceConfigResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceConfigResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceConfigResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServiceConfigResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceConfigResp.Merge(dst, src)
}
func (m *ServiceConfigResp) XXX_Size() int {
	return m.Size()
}
func (m *ServiceConfigResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceConfigResp.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceConfigResp proto.InternalMessageInfo

func (m *ServiceConfigResp) GetList() map[string]string {
	if m != nil {
		return m.List
	}
	return nil
}

type SetReq struct {
	TreeName             string   `protobuf:"bytes,1,opt,name=tree_name,json=treeName,proto3" json:"tree_name,omitempty" form:"tree_name" required`
	TreePath             string   `protobuf:"bytes,2,opt,name=tree_path,json=treePath,proto3" json:"tree_path,omitempty" form:"tree_path"`
	TreeId               int64    `protobuf:"varint,3,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty" form:"tree_id" required`
	Service              string   `protobuf:"bytes,4,opt,name=service,proto3" json:"service,omitempty" form:"service"`
	Keyword              string   `protobuf:"bytes,5,opt,name=keyword,proto3" json:"keyword,omitempty" form:"keyword"`
	Template             int64    `protobuf:"varint,6,opt,name=template,proto3" json:"template,omitempty" form:"template"`
	Name                 string   `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Value                string   `protobuf:"bytes,8,opt,name=value,proto3" json:"value,omitempty" form:"value"`
	Status               int64    `protobuf:"varint,9,opt,name=status,proto3" json:"status,omitempty" form:"status"`
	Id                   int64    `protobuf:"varint,10,opt,name=id,proto3" json:"id,omitempty" form:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetReq) Reset()         { *m = SetReq{} }
func (m *SetReq) String() string { return proto.CompactTextString(m) }
func (*SetReq) ProtoMessage()    {}
func (*SetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{13}
}
func (m *SetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetReq.Merge(dst, src)
}
func (m *SetReq) XXX_Size() int {
	return m.Size()
}
func (m *SetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetReq proto.InternalMessageInfo

func (m *SetReq) GetTreeName() string {
	if m != nil {
		return m.TreeName
	}
	return ""
}

func (m *SetReq) GetTreePath() string {
	if m != nil {
		return m.TreePath
	}
	return ""
}

func (m *SetReq) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *SetReq) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *SetReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *SetReq) GetTemplate() int64 {
	if m != nil {
		return m.Template
	}
	return 0
}

func (m *SetReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *SetReq) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *SetReq) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type SetResp struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetResp) Reset()         { *m = SetResp{} }
func (m *SetResp) String() string { return proto.CompactTextString(m) }
func (*SetResp) ProtoMessage()    {}
func (*SetResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{14}
}
func (m *SetResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetResp.Merge(dst, src)
}
func (m *SetResp) XXX_Size() int {
	return m.Size()
}
func (m *SetResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetResp.DiscardUnknown(m)
}

var xxx_messageInfo_SetResp proto.InternalMessageInfo

func (m *SetResp) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type ServiceListReq struct {
	TreeName             string   `protobuf:"bytes,1,opt,name=tree_name,json=treeName,proto3" json:"tree_name,omitempty" form:"tree_name" required`
	TreeId               int64    `protobuf:"varint,2,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty" form:"tree_id"`
	Service              string   `protobuf:"bytes,3,opt,name=service,proto3" json:"service,omitempty" form:"service"`
	Keyword              string   `protobuf:"bytes,4,opt,name=keyword,proto3" json:"keyword,omitempty" form:"keyword"`
	Page                 int64    `protobuf:"varint,5,opt,name=page,proto3" json:"page,omitempty" form:"page"`
	PageSize             int64    `protobuf:"varint,6,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty" form:"page_size"`
	Name                 string   `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty" form:"name"`
	Status               int64    `protobuf:"varint,8,opt,name=status,proto3" json:"status,omitempty" form:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceListReq) Reset()         { *m = ServiceListReq{} }
func (m *ServiceListReq) String() string { return proto.CompactTextString(m) }
func (*ServiceListReq) ProtoMessage()    {}
func (*ServiceListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{15}
}
func (m *ServiceListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServiceListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceListReq.Merge(dst, src)
}
func (m *ServiceListReq) XXX_Size() int {
	return m.Size()
}
func (m *ServiceListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceListReq.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceListReq proto.InternalMessageInfo

func (m *ServiceListReq) GetTreeName() string {
	if m != nil {
		return m.TreeName
	}
	return ""
}

func (m *ServiceListReq) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *ServiceListReq) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *ServiceListReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *ServiceListReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ServiceListReq) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ServiceListReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ServiceListReq) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

type ServiceListResp struct {
	List                 []*MList `protobuf:"bytes,1,rep,name=list,proto3" json:"list"`
	TotalNum             int64    `protobuf:"varint,2,opt,name=total_num,json=totalNum,proto3" json:"total_num"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServiceListResp) Reset()         { *m = ServiceListResp{} }
func (m *ServiceListResp) String() string { return proto.CompactTextString(m) }
func (*ServiceListResp) ProtoMessage()    {}
func (*ServiceListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{16}
}
func (m *ServiceListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ServiceListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceListResp.Merge(dst, src)
}
func (m *ServiceListResp) XXX_Size() int {
	return m.Size()
}
func (m *ServiceListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceListResp.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceListResp proto.InternalMessageInfo

func (m *ServiceListResp) GetList() []*MList {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *ServiceListResp) GetTotalNum() int64 {
	if m != nil {
		return m.TotalNum
	}
	return 0
}

type MList struct {
	// Id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// tree_name
	TreeName string `protobuf:"bytes,2,opt,name=tree_name,json=treeName,proto3" json:"tree_name"`
	TreePath string `protobuf:"bytes,3,opt,name=tree_path,json=treePath,proto3" json:"tree_path"`
	TreeId   int64  `protobuf:"varint,4,opt,name=tree_id,json=treeId,proto3" json:"tree_id"`
	Service  string `protobuf:"bytes,5,opt,name=service,proto3" json:"service"`
	// 索引名称
	Template int64  `protobuf:"varint,6,opt,name=template,proto3" json:"template"`
	Keyword  string `protobuf:"bytes,7,opt,name=keyword,proto3" json:"keyword"`
	// 配置值
	Value string `protobuf:"bytes,8,opt,name=value,proto3" json:"value"`
	// 配置解释
	Name string `protobuf:"bytes,9,opt,name=name,proto3" json:"name"`
	// 创建时间
	Ctime string `protobuf:"bytes,10,opt,name=ctime,proto3" json:"ctime"`
	// 最近更新时间
	Mtime string `protobuf:"bytes,11,opt,name=mtime,proto3" json:"mtime"`
	// 状态
	Status               int64    `protobuf:"varint,12,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MList) Reset()         { *m = MList{} }
func (m *MList) String() string { return proto.CompactTextString(m) }
func (*MList) ProtoMessage()    {}
func (*MList) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{17}
}
func (m *MList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MList.Merge(dst, src)
}
func (m *MList) XXX_Size() int {
	return m.Size()
}
func (m *MList) XXX_DiscardUnknown() {
	xxx_messageInfo_MList.DiscardUnknown(m)
}

var xxx_messageInfo_MList proto.InternalMessageInfo

func (m *MList) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MList) GetTreeName() string {
	if m != nil {
		return m.TreeName
	}
	return ""
}

func (m *MList) GetTreePath() string {
	if m != nil {
		return m.TreePath
	}
	return ""
}

func (m *MList) GetTreeId() int64 {
	if m != nil {
		return m.TreeId
	}
	return 0
}

func (m *MList) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *MList) GetTemplate() int64 {
	if m != nil {
		return m.Template
	}
	return 0
}

func (m *MList) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *MList) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *MList) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MList) GetCtime() string {
	if m != nil {
		return m.Ctime
	}
	return ""
}

func (m *MList) GetMtime() string {
	if m != nil {
		return m.Mtime
	}
	return ""
}

func (m *MList) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

type TreeIdsReq struct {
	TreeName             string   `protobuf:"bytes,1,opt,name=tree_name,json=treeName,proto3" json:"tree_name,omitempty" form:"tree_name" required`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TreeIdsReq) Reset()         { *m = TreeIdsReq{} }
func (m *TreeIdsReq) String() string { return proto.CompactTextString(m) }
func (*TreeIdsReq) ProtoMessage()    {}
func (*TreeIdsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{18}
}
func (m *TreeIdsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TreeIdsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TreeIdsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TreeIdsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TreeIdsReq.Merge(dst, src)
}
func (m *TreeIdsReq) XXX_Size() int {
	return m.Size()
}
func (m *TreeIdsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TreeIdsReq.DiscardUnknown(m)
}

var xxx_messageInfo_TreeIdsReq proto.InternalMessageInfo

func (m *TreeIdsReq) GetTreeName() string {
	if m != nil {
		return m.TreeName
	}
	return ""
}

type TreeIdsResp struct {
	List                 []int64  `protobuf:"varint,1,rep,packed,name=list,proto3" json:"list"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TreeIdsResp) Reset()         { *m = TreeIdsResp{} }
func (m *TreeIdsResp) String() string { return proto.CompactTextString(m) }
func (*TreeIdsResp) ProtoMessage()    {}
func (*TreeIdsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_titans_15fefb4fcfd9247b, []int{19}
}
func (m *TreeIdsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TreeIdsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TreeIdsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TreeIdsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TreeIdsResp.Merge(dst, src)
}
func (m *TreeIdsResp) XXX_Size() int {
	return m.Size()
}
func (m *TreeIdsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TreeIdsResp.DiscardUnknown(m)
}

var xxx_messageInfo_TreeIdsResp proto.InternalMessageInfo

func (m *TreeIdsResp) GetList() []int64 {
	if m != nil {
		return m.List
	}
	return nil
}

func init() {
	proto.RegisterType((*EasyGetReq)(nil), "live.resource.v1.EasyGetReq")
	proto.RegisterType((*EasyGetResp)(nil), "live.resource.v1.EasyGetResp")
	proto.RegisterType((*EasyList)(nil), "live.resource.v1.EasyList")
	proto.RegisterType((*EasySetReq)(nil), "live.resource.v1.EasySetReq")
	proto.RegisterType((*EasySetResp)(nil), "live.resource.v1.EasySetResp")
	proto.RegisterType((*TreeAppsReq)(nil), "live.resource.v1.TreeAppsReq")
	proto.RegisterType((*TreeAppsResp)(nil), "live.resource.v1.TreeAppsResp")
	proto.RegisterType((*Node)(nil), "live.resource.v1.Node")
	proto.RegisterType((*MultiConfigReq)(nil), "live.resource.v1.MultiConfigReq")
	proto.RegisterType((*MultiConfigResp)(nil), "live.resource.v1.MultiConfigResp")
	proto.RegisterMapType((map[int64]*MChild)(nil), "live.resource.v1.MultiConfigResp.ListEntry")
	proto.RegisterType((*MChild)(nil), "live.resource.v1.mChild")
	proto.RegisterMapType((map[string]string)(nil), "live.resource.v1.mChild.KeysEntry")
	proto.RegisterType((*ServiceConfigReq)(nil), "live.resource.v1.ServiceConfigReq")
	proto.RegisterType((*ServiceConfigResp)(nil), "live.resource.v1.ServiceConfigResp")
	proto.RegisterMapType((map[string]string)(nil), "live.resource.v1.ServiceConfigResp.ListEntry")
	proto.RegisterType((*SetReq)(nil), "live.resource.v1.SetReq")
	proto.RegisterType((*SetResp)(nil), "live.resource.v1.SetResp")
	proto.RegisterType((*ServiceListReq)(nil), "live.resource.v1.ServiceListReq")
	proto.RegisterType((*ServiceListResp)(nil), "live.resource.v1.ServiceListResp")
	proto.RegisterType((*MList)(nil), "live.resource.v1.mList")
	proto.RegisterType((*TreeIdsReq)(nil), "live.resource.v1.TreeIdsReq")
	proto.RegisterType((*TreeIdsResp)(nil), "live.resource.v1.TreeIdsResp")
}
func (m *EasyGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EasyGetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Id))
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EasyGetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EasyGetResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTitans(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EasyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EasyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TreeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.TreeName)))
		i += copy(dAtA[i:], m.TreeName)
	}
	if len(m.TreePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.TreePath)))
		i += copy(dAtA[i:], m.TreePath)
	}
	if m.TreeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.TreeId))
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EasySetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EasySetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EasySetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EasySetResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.EId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TreeAppsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeAppsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Node) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.Team) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Team)))
		i += copy(dAtA[i:], m.Team)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TreeAppsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeAppsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTitans(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.TreeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.TreeId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MultiConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiConfigReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Values)))
		i += copy(dAtA[i:], m.Values)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MultiConfigResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiConfigResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for k, _ := range m.List {
			dAtA[i] = 0xa
			i++
			v := m.List[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTitans(uint64(msgSize))
			}
			mapSize := 1 + sovTitans(uint64(k)) + msgSize
			i = encodeVarintTitans(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTitans(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTitans(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MChild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for k, _ := range m.Keys {
			dAtA[i] = 0xa
			i++
			v := m.Keys[k]
			mapSize := 1 + len(k) + sovTitans(uint64(len(k))) + 1 + len(v) + sovTitans(uint64(len(v)))
			i = encodeVarintTitans(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTitans(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTitans(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServiceConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConfigReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.TreeId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServiceConfigResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConfigResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for k, _ := range m.List {
			dAtA[i] = 0xa
			i++
			v := m.List[k]
			mapSize := 1 + len(k) + sovTitans(uint64(len(k))) + 1 + len(v) + sovTitans(uint64(len(v)))
			i = encodeVarintTitans(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTitans(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintTitans(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TreeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.TreeName)))
		i += copy(dAtA[i:], m.TreeName)
	}
	if len(m.TreePath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.TreePath)))
		i += copy(dAtA[i:], m.TreePath)
	}
	if m.TreeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.TreeId))
	}
	if len(m.Service) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Service)))
		i += copy(dAtA[i:], m.Service)
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if m.Template != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Template))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Status != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Status))
	}
	if m.Id != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServiceListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TreeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.TreeName)))
		i += copy(dAtA[i:], m.TreeName)
	}
	if m.TreeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.TreeId))
	}
	if len(m.Service) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Service)))
		i += copy(dAtA[i:], m.Service)
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if m.Page != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Page))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.PageSize))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Status != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServiceListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceListResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTitans(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.TotalNum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Id))
	}
	if len(m.TreeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.TreeName)))
		i += copy(dAtA[i:], m.TreeName)
	}
	if len(m.TreePath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.TreePath)))
		i += copy(dAtA[i:], m.TreePath)
	}
	if m.TreeId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.TreeId))
	}
	if len(m.Service) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Service)))
		i += copy(dAtA[i:], m.Service)
	}
	if m.Template != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Template))
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Ctime) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Ctime)))
		i += copy(dAtA[i:], m.Ctime)
	}
	if len(m.Mtime) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.Mtime)))
		i += copy(dAtA[i:], m.Mtime)
	}
	if m.Status != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTitans(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TreeIdsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeIdsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TreeName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTitans(dAtA, i, uint64(len(m.TreeName)))
		i += copy(dAtA[i:], m.TreeName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TreeIdsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeIdsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		dAtA3 := make([]byte, len(m.List)*10)
		var j2 int
		for _, num1 := range m.List {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTitans(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintTitans(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EasyGetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTitans(uint64(m.Id))
	}
	if m.Page != 0 {
		n += 1 + sovTitans(uint64(m.Page))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EasyGetResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovTitans(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EasyList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TreeName)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.TreePath)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.TreeId != 0 {
		n += 1 + sovTitans(uint64(m.TreeId))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EasySetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTitans(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EasySetResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EId != 0 {
		n += 1 + sovTitans(uint64(m.EId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TreeAppsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Team)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TreeAppsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovTitans(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.TreeId != 0 {
		n += 1 + sovTitans(uint64(m.TreeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Values)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiConfigResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for k, v := range m.List {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTitans(uint64(l))
			}
			mapEntrySize := 1 + sovTitans(uint64(k)) + l
			n += mapEntrySize + 1 + sovTitans(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for k, v := range m.Keys {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTitans(uint64(len(k))) + 1 + len(v) + sovTitans(uint64(len(v)))
			n += mapEntrySize + 1 + sovTitans(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TreeId != 0 {
		n += 1 + sovTitans(uint64(m.TreeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceConfigResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for k, v := range m.List {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTitans(uint64(len(k))) + 1 + len(v) + sovTitans(uint64(len(v)))
			n += mapEntrySize + 1 + sovTitans(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TreeName)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.TreePath)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.TreeId != 0 {
		n += 1 + sovTitans(uint64(m.TreeId))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.Template != 0 {
		n += 1 + sovTitans(uint64(m.Template))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTitans(uint64(m.Status))
	}
	if m.Id != 0 {
		n += 1 + sovTitans(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTitans(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TreeName)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.TreeId != 0 {
		n += 1 + sovTitans(uint64(m.TreeId))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovTitans(uint64(m.Page))
	}
	if m.PageSize != 0 {
		n += 1 + sovTitans(uint64(m.PageSize))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTitans(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovTitans(uint64(l))
		}
	}
	if m.TotalNum != 0 {
		n += 1 + sovTitans(uint64(m.TotalNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTitans(uint64(m.Id))
	}
	l = len(m.TreeName)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.TreePath)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.TreeId != 0 {
		n += 1 + sovTitans(uint64(m.TreeId))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.Template != 0 {
		n += 1 + sovTitans(uint64(m.Template))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Ctime)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	l = len(m.Mtime)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTitans(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TreeIdsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TreeName)
	if l > 0 {
		n += 1 + l + sovTitans(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TreeIdsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		l = 0
		for _, e := range m.List {
			l += sovTitans(uint64(e))
		}
		n += 1 + sovTitans(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTitans(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTitans(x uint64) (n int) {
	return sovTitans(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EasyGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EasyGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EasyGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EasyGetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EasyGetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EasyGetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &EasyList{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EasyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EasyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EasyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EasySetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EasySetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EasySetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EasySetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EasySetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EasySetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EId", wireType)
			}
			m.EId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeAppsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeAppsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeAppsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Team = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeAppsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeAppsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeAppsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Node{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiConfigResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiConfigResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiConfigResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = make(map[int64]*MChild)
			}
			var mapkey int64
			var mapvalue *MChild
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTitans
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTitans
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTitans
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTitans
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTitans
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MChild{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTitans(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTitans
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.List[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Keys == nil {
				m.Keys = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTitans
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTitans
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTitans
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTitans
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTitans
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTitans(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTitans
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Keys[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceConfigResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConfigResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConfigResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTitans
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTitans
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTitans
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTitans
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTitans
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTitans(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTitans
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.List[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			m.Template = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Template |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &MList{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNum", wireType)
			}
			m.TotalNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: mList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: mList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeId", wireType)
			}
			m.TreeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			m.Template = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Template |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ctime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeIdsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeIdsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeIdsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTitans
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeIdsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeIdsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeIdsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTitans
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.List = append(m.List, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTitans
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTitans
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.List) == 0 {
					m.List = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTitans
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.List = append(m.List, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTitans(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTitans
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTitans(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTitans
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTitans
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTitans
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTitans
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTitans(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTitans = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTitans   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api/http/v1/titans.proto", fileDescriptor_titans_15fefb4fcfd9247b) }

var fileDescriptor_titans_15fefb4fcfd9247b = []byte{
	// 1200 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xd7, 0xfa, 0xbf, 0x9f, 0xd3, 0xc4, 0x1d, 0xa2, 0xd6, 0x31, 0x49, 0x36, 0x9d, 0x00, 0x0a,
	0x84, 0xda, 0x4a, 0x28, 0x6a, 0x15, 0x0e, 0x40, 0x4a, 0x15, 0xd2, 0x42, 0x54, 0x36, 0x15, 0x48,
	0x70, 0x88, 0x36, 0xf1, 0xc4, 0x5e, 0xc5, 0xeb, 0xdd, 0x78, 0xc6, 0x46, 0xee, 0x95, 0x4f, 0xc1,
	0xa7, 0xe0, 0xce, 0x07, 0x40, 0x5c, 0x90, 0xe0, 0x0b, 0xac, 0x50, 0x8e, 0x3e, 0xfa, 0x8e, 0x84,
	0xe6, 0xed, 0xec, 0x7a, 0xfc, 0x3f, 0x55, 0x2f, 0xeb, 0xf1, 0x7b, 0xbf, 0x99, 0x7d, 0xef, 0xf7,
	0xfe, 0xcc, 0x5b, 0x28, 0xd9, 0xbe, 0x53, 0x6d, 0x08, 0xe1, 0x57, 0xbb, 0x7b, 0x55, 0xe1, 0x08,
	0xbb, 0xc5, 0x2b, 0x7e, 0xdb, 0x13, 0x1e, 0x29, 0x36, 0x9d, 0x2e, 0xab, 0xb4, 0x19, 0xf7, 0x3a,
	0xed, 0x0b, 0x56, 0xe9, 0xee, 0x95, 0x1f, 0xd6, 0x1d, 0xd1, 0xe8, 0x9c, 0x57, 0x2e, 0x3c, 0xb7,
	0x5a, 0xf7, 0xea, 0x5e, 0x15, 0x81, 0xe7, 0x9d, 0x4b, 0xfc, 0x87, 0x7f, 0x70, 0x15, 0x1e, 0x40,
	0x5f, 0x02, 0x3c, 0xb3, 0x79, 0xef, 0x88, 0x09, 0x8b, 0x5d, 0x93, 0x0d, 0x48, 0x38, 0xb5, 0x92,
	0xb1, 0x65, 0xec, 0x24, 0x0f, 0xef, 0x0c, 0x02, 0x33, 0x7f, 0xe9, 0xb5, 0xdd, 0x03, 0xea, 0xd4,
	0xa8, 0x95, 0x70, 0x6a, 0x64, 0x1b, 0x52, 0xbe, 0x5d, 0x67, 0xa5, 0x04, 0x02, 0x56, 0x06, 0x81,
	0x59, 0x08, 0x01, 0x52, 0x4a, 0x2d, 0x54, 0xd2, 0x23, 0x28, 0xc4, 0x27, 0x72, 0x9f, 0x3c, 0x81,
	0x54, 0xd3, 0xe1, 0xa2, 0x64, 0x6c, 0x25, 0x77, 0x0a, 0xfb, 0xe5, 0xca, 0xb8, 0xc1, 0x15, 0x09,
	0xfe, 0xc6, 0xe1, 0xe2, 0x30, 0xd7, 0x0f, 0x4c, 0xc4, 0x5a, 0xf8, 0xa4, 0x7f, 0x19, 0x90, 0x8b,
	0x94, 0xe4, 0x23, 0xc8, 0x8b, 0x36, 0x63, 0x67, 0x2d, 0xdb, 0x65, 0x68, 0x60, 0xfe, 0xf0, 0x4e,
	0x3f, 0x30, 0x87, 0x42, 0x2b, 0x27, 0x97, 0x27, 0xb6, 0xcb, 0x62, 0xac, 0x6f, 0x8b, 0x06, 0xda,
	0xaa, 0x63, 0xa5, 0x30, 0xc4, 0xbe, 0xb4, 0x45, 0x83, 0xbc, 0x07, 0x59, 0x14, 0x3b, 0xb5, 0x52,
	0x12, 0xbd, 0x2a, 0xf4, 0x03, 0x33, 0x12, 0x59, 0x19, 0xb9, 0x38, 0xae, 0x91, 0xf7, 0x21, 0x7b,
	0xc5, 0x7a, 0x3f, 0x7b, 0xed, 0x5a, 0x29, 0x85, 0xe7, 0x21, 0x4a, 0x89, 0xac, 0x68, 0x41, 0xd6,
	0x21, 0x85, 0xf6, 0xa5, 0x11, 0x83, 0xfe, 0xa0, 0x69, 0xf8, 0xa4, 0xbb, 0x21, 0xd5, 0xa7, 0xb7,
	0xa1, 0x9a, 0xee, 0x84, 0x2c, 0x9e, 0x2a, 0x16, 0xd7, 0x20, 0xc9, 0x8e, 0x23, 0x78, 0xb6, 0x1f,
	0x98, 0xf2, 0xaf, 0x25, 0x1f, 0xf4, 0x07, 0x28, 0xbc, 0x6a, 0x33, 0xf6, 0xa5, 0xef, 0x73, 0x79,
	0xee, 0x36, 0xa4, 0x5a, 0x5e, 0x2d, 0xe2, 0x48, 0x8b, 0x91, 0x94, 0x52, 0x0b, 0x95, 0x12, 0x24,
	0x98, 0xed, 0x2a, 0x72, 0x34, 0x90, 0x94, 0x52, 0x0b, 0x95, 0xf4, 0x2b, 0x58, 0x1a, 0x1e, 0xcc,
	0x7d, 0xf2, 0x68, 0x24, 0x92, 0xf7, 0x26, 0x23, 0x79, 0xe2, 0xd5, 0xd8, 0x44, 0x14, 0x1b, 0x90,
	0x92, 0xf2, 0x98, 0x1b, 0x63, 0x1a, 0x37, 0x52, 0xab, 0x45, 0x0b, 0xb5, 0x18, 0x28, 0x7c, 0xde,
	0x2e, 0x48, 0xf4, 0x33, 0x58, 0xfe, 0xb6, 0xd3, 0x14, 0xce, 0x53, 0xaf, 0x75, 0xe9, 0xd4, 0x25,
	0x17, 0x1f, 0x42, 0xa6, 0x6b, 0x37, 0x3b, 0x8c, 0xab, 0xb7, 0xde, 0x1d, 0x04, 0xe6, 0x9d, 0xd0,
	0xd1, 0x50, 0x4e, 0x2d, 0x05, 0xa0, 0xbf, 0x19, 0xb0, 0x32, 0xb2, 0x9b, 0xfb, 0xe4, 0x78, 0xc4,
	0xe1, 0xdd, 0x49, 0x87, 0xc7, 0x36, 0x54, 0x64, 0xa6, 0x3e, 0x6b, 0x89, 0x76, 0x6f, 0x9c, 0x85,
	0xf2, 0x77, 0x90, 0x8f, 0x95, 0xa4, 0x08, 0xc9, 0x2b, 0xd6, 0x0b, 0x83, 0x69, 0xc9, 0x25, 0xa9,
	0x40, 0x1a, 0xed, 0x40, 0xff, 0x0b, 0xfb, 0xa5, 0xc9, 0x57, 0xb9, 0x4f, 0x1b, 0x4e, 0xb3, 0x66,
	0x85, 0xb0, 0x83, 0xc4, 0x13, 0x83, 0xfe, 0x62, 0x40, 0x26, 0x94, 0x92, 0x2f, 0x20, 0x75, 0xc5,
	0x7a, 0x5c, 0x19, 0x4a, 0x67, 0xed, 0xae, 0xbc, 0x60, 0x3d, 0xae, 0xd9, 0x27, 0xf7, 0x58, 0xf8,
	0x2c, 0x3f, 0x86, 0x7c, 0xac, 0xd4, 0xed, 0xcb, 0x87, 0xf6, 0xad, 0xea, 0xf6, 0xe5, 0x75, 0x2b,
	0x3e, 0x87, 0xe2, 0x29, 0x6b, 0x77, 0x9d, 0x0b, 0x36, 0xa4, 0x7d, 0x77, 0x18, 0xae, 0x30, 0x61,
	0xc9, 0x20, 0x30, 0x97, 0x55, 0x82, 0x85, 0x0a, 0x1a, 0x47, 0xed, 0x57, 0x03, 0xee, 0x8e, 0x9d,
	0xc0, 0x7d, 0xf2, 0x62, 0x84, 0xfa, 0x87, 0x93, 0x1e, 0x4d, 0x6c, 0x99, 0x43, 0xfe, 0xe3, 0x19,
	0xe4, 0x2f, 0x74, 0xee, 0x9f, 0x24, 0x64, 0x54, 0xb9, 0x1e, 0x4c, 0xf6, 0x9f, 0x8d, 0x41, 0x60,
	0xae, 0x69, 0x5e, 0x61, 0x91, 0x6f, 0xb5, 0xd9, 0x75, 0xc7, 0x69, 0xb3, 0x9a, 0xd6, 0x8f, 0xf6,
	0x26, 0xfb, 0xd1, 0xea, 0x20, 0x30, 0x8b, 0xda, 0x5e, 0xa9, 0xa2, 0x5a, 0x5b, 0x7a, 0x34, 0x9e,
	0xf1, 0xef, 0x0e, 0x02, 0xf3, 0xfe, 0x28, 0x85, 0xc3, 0x57, 0x45, 0x6d, 0xea, 0x63, 0xc8, 0xf2,
	0x90, 0x17, 0xd5, 0xa6, 0x34, 0xe2, 0x95, 0x82, 0x5a, 0x11, 0x44, 0xa2, 0xa3, 0xa6, 0x96, 0x1e,
	0x47, 0x2b, 0x05, 0x1d, 0xf6, 0xb6, 0x2a, 0xe4, 0x04, 0x73, 0xfd, 0xa6, 0x2d, 0x58, 0x29, 0x83,
	0x26, 0xbd, 0x33, 0x08, 0xcc, 0x95, 0xa8, 0x6d, 0x84, 0x1a, 0xe9, 0x82, 0x5a, 0x62, 0x23, 0x92,
	0x64, 0x65, 0x27, 0x1a, 0x91, 0xe4, 0x49, 0xd5, 0xfd, 0x07, 0x11, 0xf7, 0x39, 0x44, 0x15, 0x07,
	0x81, 0xb9, 0xa4, 0x15, 0x28, 0x55, 0xd1, 0x90, 0x95, 0xcc, 0x85, 0x2d, 0x3a, 0xbc, 0x94, 0xc7,
	0x77, 0x6b, 0x95, 0x1c, 0xca, 0xa9, 0xa5, 0x00, 0xaa, 0xb1, 0xc2, 0xac, 0xc6, 0xfa, 0x00, 0xb2,
	0x51, 0x53, 0xbd, 0xa7, 0xb5, 0xe0, 0x4c, 0x3f, 0x30, 0x13, 0x4e, 0x0d, 0x21, 0xff, 0x25, 0x60,
	0x59, 0xe5, 0x97, 0xcc, 0x9b, 0xb7, 0x0d, 0xbf, 0x56, 0x0e, 0x89, 0x45, 0xe5, 0xa0, 0x87, 0x30,
	0xf9, 0x46, 0x21, 0x4c, 0x2d, 0x0e, 0x61, 0x74, 0x7d, 0xa7, 0xe7, 0x5c, 0xdf, 0x32, 0x59, 0xe5,
	0xef, 0x19, 0x77, 0x5e, 0x47, 0x81, 0xd6, 0x92, 0x35, 0x56, 0x51, 0x2b, 0x27, 0xd7, 0xa7, 0xce,
	0xeb, 0x5b, 0x46, 0x7a, 0x18, 0xc1, 0xdc, 0x82, 0x08, 0x52, 0x01, 0x2b, 0x23, 0xf4, 0x73, 0x9f,
	0x7c, 0x3a, 0xd2, 0x0f, 0xee, 0x4f, 0xe9, 0x70, 0xd3, 0x46, 0x08, 0x9c, 0x04, 0x3c, 0x61, 0x37,
	0xcf, 0x5a, 0x1d, 0x57, 0x91, 0x1f, 0x4e, 0x02, 0x91, 0xd0, 0xca, 0xe1, 0xf2, 0xa4, 0xe3, 0xd2,
	0xdf, 0x93, 0x90, 0xc6, 0x53, 0x66, 0xe5, 0xc5, 0xe8, 0x0c, 0x92, 0x78, 0x83, 0x19, 0x24, 0x79,
	0xeb, 0x19, 0x24, 0x35, 0x77, 0x06, 0x89, 0x32, 0x23, 0x3d, 0x9c, 0x41, 0x94, 0x68, 0x98, 0x12,
	0x3b, 0x13, 0x75, 0xba, 0xd4, 0x0f, 0xcc, 0x58, 0xa6, 0x15, 0xa8, 0x36, 0xd4, 0x64, 0xe7, 0x0c,
	0x35, 0xe6, 0x68, 0x89, 0xe6, 0xfb, 0x81, 0x19, 0x0a, 0xa2, 0xda, 0x8c, 0x6e, 0xf6, 0xfc, 0xd4,
	0x9b, 0xdd, 0x84, 0xf4, 0x85, 0x70, 0x5c, 0x86, 0x15, 0xa9, 0xb6, 0xa3, 0xc0, 0x0a, 0x7f, 0x24,
	0xc0, 0x45, 0x40, 0x61, 0x08, 0x70, 0x43, 0x00, 0xfe, 0x10, 0x1a, 0x67, 0xce, 0x12, 0xfa, 0x03,
	0xfd, 0xc0, 0x54, 0x92, 0x38, 0x65, 0xbe, 0x06, 0x78, 0x85, 0x34, 0xf1, 0xb7, 0xac, 0x56, 0xba,
	0x1b, 0x8e, 0x53, 0x78, 0x12, 0xf7, 0xa5, 0x73, 0x71, 0xe2, 0x25, 0xc7, 0xf3, 0x6b, 0xff, 0x8f,
	0x14, 0x64, 0xc2, 0x79, 0x9c, 0x7c, 0x0f, 0x2b, 0x75, 0x26, 0xb4, 0x89, 0x80, 0x93, 0xad, 0x05,
	0x13, 0xc3, 0x75, 0xf9, 0xc1, 0xc2, 0x99, 0x82, 0xfc, 0x04, 0xc5, 0x3a, 0x13, 0x23, 0xd7, 0x1d,
	0xa1, 0x0b, 0xef, 0xc3, 0xeb, 0xf2, 0xf6, 0x2d, 0xee, 0x4c, 0x72, 0x04, 0x45, 0x3e, 0x7e, 0x78,
	0x69, 0xda, 0x46, 0xd9, 0x04, 0xcb, 0x6b, 0x33, 0x34, 0x68, 0xe5, 0xea, 0xb8, 0x95, 0x58, 0x4a,
	0x5b, 0x33, 0xad, 0x50, 0x9d, 0x75, 0x1a, 0x05, 0xe3, 0xc5, 0x7f, 0x0c, 0x50, 0x67, 0x42, 0x45,
	0x85, 0xac, 0x4f, 0x6e, 0x18, 0x86, 0xbe, 0xbc, 0x31, 0x47, 0xcb, 0x7d, 0xf2, 0x1c, 0x0a, 0x75,
	0x26, 0xe2, 0xaf, 0x8a, 0xf5, 0xe9, 0x9f, 0x23, 0xe1, 0xd7, 0xd0, 0xb4, 0xb3, 0xf4, 0x2f, 0x9b,
	0xe7, 0x50, 0xe0, 0x8b, 0xcf, 0x3a, 0x9d, 0x7b, 0x96, 0xe2, 0xef, 0xb0, 0xf8, 0xe7, 0xcd, 0xa6,
	0xf1, 0xf7, 0xcd, 0xa6, 0xf1, 0xef, 0xcd, 0xa6, 0xf1, 0x63, 0xa2, 0xbb, 0x77, 0x9e, 0xc1, 0xef,
	0xb3, 0x4f, 0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xb9, 0x67, 0xfc, 0xcc, 0xfc, 0x0d, 0x00, 0x00,
}
