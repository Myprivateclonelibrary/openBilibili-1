// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/live/xuser/api/grpc/v1/exp.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type AddUserExpReq struct {
	UserInfo             *UserExpChunk `protobuf:"bytes,1,opt,name=userInfo" json:"userInfo,omitempty" form:"userInfo" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AddUserExpReq) Reset()         { *m = AddUserExpReq{} }
func (m *AddUserExpReq) String() string { return proto.CompactTextString(m) }
func (*AddUserExpReq) ProtoMessage()    {}
func (*AddUserExpReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_exp_57cf1a328d2a0c19, []int{0}
}
func (m *AddUserExpReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddUserExpReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddUserExpReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AddUserExpReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddUserExpReq.Merge(dst, src)
}
func (m *AddUserExpReq) XXX_Size() int {
	return m.Size()
}
func (m *AddUserExpReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddUserExpReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddUserExpReq proto.InternalMessageInfo

func (m *AddUserExpReq) GetUserInfo() *UserExpChunk {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

type UserExpChunk struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid" validate:"gt=0,required"`
	ReqBiz               int64    `protobuf:"varint,2,opt,name=req_biz,json=reqBiz,proto3" json:"req_biz,omitempty" form:"req_biz" validate:"required"`
	Type                 int64    `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty" form:"type" validate:"gt=0,required"`
	Num                  int64    `protobuf:"varint,4,opt,name=num,proto3" json:"num,omitempty" form:"num" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserExpChunk) Reset()         { *m = UserExpChunk{} }
func (m *UserExpChunk) String() string { return proto.CompactTextString(m) }
func (*UserExpChunk) ProtoMessage()    {}
func (*UserExpChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_exp_57cf1a328d2a0c19, []int{1}
}
func (m *UserExpChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserExpChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserExpChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserExpChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserExpChunk.Merge(dst, src)
}
func (m *UserExpChunk) XXX_Size() int {
	return m.Size()
}
func (m *UserExpChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_UserExpChunk.DiscardUnknown(m)
}

var xxx_messageInfo_UserExpChunk proto.InternalMessageInfo

func (m *UserExpChunk) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UserExpChunk) GetReqBiz() int64 {
	if m != nil {
		return m.ReqBiz
	}
	return 0
}

func (m *UserExpChunk) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *UserExpChunk) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

type AddUserExpResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddUserExpResp) Reset()         { *m = AddUserExpResp{} }
func (m *AddUserExpResp) String() string { return proto.CompactTextString(m) }
func (*AddUserExpResp) ProtoMessage()    {}
func (*AddUserExpResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_exp_57cf1a328d2a0c19, []int{2}
}
func (m *AddUserExpResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddUserExpResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddUserExpResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AddUserExpResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddUserExpResp.Merge(dst, src)
}
func (m *AddUserExpResp) XXX_Size() int {
	return m.Size()
}
func (m *AddUserExpResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AddUserExpResp.DiscardUnknown(m)
}

var xxx_messageInfo_AddUserExpResp proto.InternalMessageInfo

// GetUserExpReq 请求
type GetUserExpReq struct {
	Uids                 []int64  `protobuf:"varint,1,rep,packed,name=uids" json:"uids,omitempty" form:"uids" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserExpReq) Reset()         { *m = GetUserExpReq{} }
func (m *GetUserExpReq) String() string { return proto.CompactTextString(m) }
func (*GetUserExpReq) ProtoMessage()    {}
func (*GetUserExpReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_exp_57cf1a328d2a0c19, []int{3}
}
func (m *GetUserExpReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserExpReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserExpReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetUserExpReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserExpReq.Merge(dst, src)
}
func (m *GetUserExpReq) XXX_Size() int {
	return m.Size()
}
func (m *GetUserExpReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserExpReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserExpReq proto.InternalMessageInfo

func (m *GetUserExpReq) GetUids() []int64 {
	if m != nil {
		return m.Uids
	}
	return nil
}

// GetUserExpResp 响应
type GetUserExpResp struct {
	Data                 map[int64]*LevelInfo `protobuf:"bytes,1,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GetUserExpResp) Reset()         { *m = GetUserExpResp{} }
func (m *GetUserExpResp) String() string { return proto.CompactTextString(m) }
func (*GetUserExpResp) ProtoMessage()    {}
func (*GetUserExpResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_exp_57cf1a328d2a0c19, []int{4}
}
func (m *GetUserExpResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserExpResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserExpResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetUserExpResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserExpResp.Merge(dst, src)
}
func (m *GetUserExpResp) XXX_Size() int {
	return m.Size()
}
func (m *GetUserExpResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserExpResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserExpResp proto.InternalMessageInfo

func (m *GetUserExpResp) GetData() map[int64]*LevelInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type LevelInfo struct {
	Uid                  int64            `protobuf:"varint,1,opt,name=uid,proto3" json:"uid"`
	UserLevel            *UserLevelInfo   `protobuf:"bytes,2,opt,name=userLevel" json:"userLevel"`
	AnchorLevel          *AnchorLevelInfo `protobuf:"bytes,3,opt,name=anchorLevel" json:"anchorLevel"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LevelInfo) Reset()         { *m = LevelInfo{} }
func (m *LevelInfo) String() string { return proto.CompactTextString(m) }
func (*LevelInfo) ProtoMessage()    {}
func (*LevelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_exp_57cf1a328d2a0c19, []int{5}
}
func (m *LevelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LevelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LevelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LevelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LevelInfo.Merge(dst, src)
}
func (m *LevelInfo) XXX_Size() int {
	return m.Size()
}
func (m *LevelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LevelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LevelInfo proto.InternalMessageInfo

func (m *LevelInfo) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *LevelInfo) GetUserLevel() *UserLevelInfo {
	if m != nil {
		return m.UserLevel
	}
	return nil
}

func (m *LevelInfo) GetAnchorLevel() *AnchorLevelInfo {
	if m != nil {
		return m.AnchorLevel
	}
	return nil
}

type UserLevelInfo struct {
	// 当前用户等级
	Level int64 `protobuf:"varint,1,opt,name=level,proto3" json:"level"`
	// 下一等级
	NextLevel int64 `protobuf:"varint,2,opt,name=nextLevel,proto3" json:"nextLevel"`
	// 当前等级对应的经验
	UserExpLeft int64 `protobuf:"varint,3,opt,name=userExpLeft,proto3" json:"userExpLeft"`
	// 下一等级对应的经验
	UserExpRight int64 `protobuf:"varint,4,opt,name=userExpRight,proto3" json:"userExpRight"`
	// 用户当前经验
	UserExp int64 `protobuf:"varint,5,opt,name=userExp,proto3" json:"userExp"`
	// 升级到下一等级对应的经验
	UserExpNextLevel int64 `protobuf:"varint,6,opt,name=userExpNextLevel,proto3" json:"userExpNextLevel"`
	// 当前等级颜色
	Color int64 `protobuf:"varint,7,opt,name=color,proto3" json:"color"`
	// 下一等级左侧对应的经验
	UserExpNextLeft int64 `protobuf:"varint,8,opt,name=userExpNextLeft,proto3" json:"userExpNextLeft"`
	// 下一等级右侧对应的经验
	UserExpNextRight     int64    `protobuf:"varint,9,opt,name=userExpNextRight,proto3" json:"userExpNextRight"`
	IsLevelTop           int64    `protobuf:"varint,10,opt,name=isLevelTop,proto3" json:"isLevelTop"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserLevelInfo) Reset()         { *m = UserLevelInfo{} }
func (m *UserLevelInfo) String() string { return proto.CompactTextString(m) }
func (*UserLevelInfo) ProtoMessage()    {}
func (*UserLevelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_exp_57cf1a328d2a0c19, []int{6}
}
func (m *UserLevelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserLevelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserLevelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserLevelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserLevelInfo.Merge(dst, src)
}
func (m *UserLevelInfo) XXX_Size() int {
	return m.Size()
}
func (m *UserLevelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UserLevelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UserLevelInfo proto.InternalMessageInfo

func (m *UserLevelInfo) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *UserLevelInfo) GetNextLevel() int64 {
	if m != nil {
		return m.NextLevel
	}
	return 0
}

func (m *UserLevelInfo) GetUserExpLeft() int64 {
	if m != nil {
		return m.UserExpLeft
	}
	return 0
}

func (m *UserLevelInfo) GetUserExpRight() int64 {
	if m != nil {
		return m.UserExpRight
	}
	return 0
}

func (m *UserLevelInfo) GetUserExp() int64 {
	if m != nil {
		return m.UserExp
	}
	return 0
}

func (m *UserLevelInfo) GetUserExpNextLevel() int64 {
	if m != nil {
		return m.UserExpNextLevel
	}
	return 0
}

func (m *UserLevelInfo) GetColor() int64 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *UserLevelInfo) GetUserExpNextLeft() int64 {
	if m != nil {
		return m.UserExpNextLeft
	}
	return 0
}

func (m *UserLevelInfo) GetUserExpNextRight() int64 {
	if m != nil {
		return m.UserExpNextRight
	}
	return 0
}

func (m *UserLevelInfo) GetIsLevelTop() int64 {
	if m != nil {
		return m.IsLevelTop
	}
	return 0
}

type AnchorLevelInfo struct {
	// 当前用户等级
	Level int64 `protobuf:"varint,1,opt,name=level,proto3" json:"level"`
	// 下一等级
	NextLevel int64 `protobuf:"varint,2,opt,name=nextLevel,proto3" json:"nextLevel"`
	// 当前等级对应的经验
	UserExpLeft int64 `protobuf:"varint,3,opt,name=userExpLeft,proto3" json:"userExpLeft"`
	// 下一等级对应的经验
	UserExpRight int64 `protobuf:"varint,4,opt,name=userExpRight,proto3" json:"userExpRight"`
	// 用户当前经验
	UserExp int64 `protobuf:"varint,5,opt,name=userExp,proto3" json:"userExp"`
	// 升级到下一等级对应的经验
	UserExpNextLevel int64 `protobuf:"varint,6,opt,name=userExpNextLevel,proto3" json:"userExpNextLevel"`
	// 当前等级颜色
	Color int64 `protobuf:"varint,7,opt,name=color,proto3" json:"color"`
	// 下一等级左侧对应的经验
	UserExpNextLeft int64 `protobuf:"varint,8,opt,name=userExpNextLeft,proto3" json:"userExpNextLeft"`
	// 下一等级右侧对应的经验
	UserExpNextRight int64 `protobuf:"varint,9,opt,name=userExpNextRight,proto3" json:"userExpNextRight"`
	// 主播积分,userExp/100
	AnchorScore          int64    `protobuf:"varint,10,opt,name=anchorScore,proto3" json:"anchorScore"`
	IsLevelTop           int64    `protobuf:"varint,11,opt,name=isLevelTop,proto3" json:"isLevelTop"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnchorLevelInfo) Reset()         { *m = AnchorLevelInfo{} }
func (m *AnchorLevelInfo) String() string { return proto.CompactTextString(m) }
func (*AnchorLevelInfo) ProtoMessage()    {}
func (*AnchorLevelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_exp_57cf1a328d2a0c19, []int{7}
}
func (m *AnchorLevelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorLevelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorLevelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorLevelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorLevelInfo.Merge(dst, src)
}
func (m *AnchorLevelInfo) XXX_Size() int {
	return m.Size()
}
func (m *AnchorLevelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorLevelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorLevelInfo proto.InternalMessageInfo

func (m *AnchorLevelInfo) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *AnchorLevelInfo) GetNextLevel() int64 {
	if m != nil {
		return m.NextLevel
	}
	return 0
}

func (m *AnchorLevelInfo) GetUserExpLeft() int64 {
	if m != nil {
		return m.UserExpLeft
	}
	return 0
}

func (m *AnchorLevelInfo) GetUserExpRight() int64 {
	if m != nil {
		return m.UserExpRight
	}
	return 0
}

func (m *AnchorLevelInfo) GetUserExp() int64 {
	if m != nil {
		return m.UserExp
	}
	return 0
}

func (m *AnchorLevelInfo) GetUserExpNextLevel() int64 {
	if m != nil {
		return m.UserExpNextLevel
	}
	return 0
}

func (m *AnchorLevelInfo) GetColor() int64 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *AnchorLevelInfo) GetUserExpNextLeft() int64 {
	if m != nil {
		return m.UserExpNextLeft
	}
	return 0
}

func (m *AnchorLevelInfo) GetUserExpNextRight() int64 {
	if m != nil {
		return m.UserExpNextRight
	}
	return 0
}

func (m *AnchorLevelInfo) GetAnchorScore() int64 {
	if m != nil {
		return m.AnchorScore
	}
	return 0
}

func (m *AnchorLevelInfo) GetIsLevelTop() int64 {
	if m != nil {
		return m.IsLevelTop
	}
	return 0
}

func init() {
	proto.RegisterType((*AddUserExpReq)(nil), "live.xuser.v1.AddUserExpReq")
	proto.RegisterType((*UserExpChunk)(nil), "live.xuser.v1.UserExpChunk")
	proto.RegisterType((*AddUserExpResp)(nil), "live.xuser.v1.AddUserExpResp")
	proto.RegisterType((*GetUserExpReq)(nil), "live.xuser.v1.GetUserExpReq")
	proto.RegisterType((*GetUserExpResp)(nil), "live.xuser.v1.GetUserExpResp")
	proto.RegisterMapType((map[int64]*LevelInfo)(nil), "live.xuser.v1.GetUserExpResp.DataEntry")
	proto.RegisterType((*LevelInfo)(nil), "live.xuser.v1.LevelInfo")
	proto.RegisterType((*UserLevelInfo)(nil), "live.xuser.v1.UserLevelInfo")
	proto.RegisterType((*AnchorLevelInfo)(nil), "live.xuser.v1.AnchorLevelInfo")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UserExpClient is the client API for UserExp service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UserExpClient interface {
	// GetUserExpMulti 获取用户经验与等级信息,支持批量
	GetUserExp(ctx context.Context, in *GetUserExpReq, opts ...grpc.CallOption) (*GetUserExpResp, error)
	// AddUserExp 增加用户经验,不支持批量
	AddUserExp(ctx context.Context, in *AddUserExpReq, opts ...grpc.CallOption) (*AddUserExpResp, error)
}

type userExpClient struct {
	cc *grpc.ClientConn
}

func NewUserExpClient(cc *grpc.ClientConn) UserExpClient {
	return &userExpClient{cc}
}

func (c *userExpClient) GetUserExp(ctx context.Context, in *GetUserExpReq, opts ...grpc.CallOption) (*GetUserExpResp, error) {
	out := new(GetUserExpResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.UserExp/GetUserExp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userExpClient) AddUserExp(ctx context.Context, in *AddUserExpReq, opts ...grpc.CallOption) (*AddUserExpResp, error) {
	out := new(AddUserExpResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.UserExp/AddUserExp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserExpServer is the server API for UserExp service.
type UserExpServer interface {
	// GetUserExpMulti 获取用户经验与等级信息,支持批量
	GetUserExp(context.Context, *GetUserExpReq) (*GetUserExpResp, error)
	// AddUserExp 增加用户经验,不支持批量
	AddUserExp(context.Context, *AddUserExpReq) (*AddUserExpResp, error)
}

func RegisterUserExpServer(s *grpc.Server, srv UserExpServer) {
	s.RegisterService(&_UserExp_serviceDesc, srv)
}

func _UserExp_GetUserExp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserExpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserExpServer).GetUserExp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.UserExp/GetUserExp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserExpServer).GetUserExp(ctx, req.(*GetUserExpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserExp_AddUserExp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserExpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserExpServer).AddUserExp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.UserExp/AddUserExp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserExpServer).AddUserExp(ctx, req.(*AddUserExpReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserExp_serviceDesc = grpc.ServiceDesc{
	ServiceName: "live.xuser.v1.UserExp",
	HandlerType: (*UserExpServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserExp",
			Handler:    _UserExp_GetUserExp_Handler,
		},
		{
			MethodName: "AddUserExp",
			Handler:    _UserExp_AddUserExp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/live/xuser/api/grpc/v1/exp.proto",
}

func (m *AddUserExpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddUserExpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserInfo.Size()))
		n1, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UserExpChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserExpChunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.Uid))
	}
	if m.ReqBiz != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.ReqBiz))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.Type))
	}
	if m.Num != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddUserExpResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddUserExpResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetUserExpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserExpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		dAtA3 := make([]byte, len(m.Uids)*10)
		var j2 int
		for _, num1 := range m.Uids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintExp(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetUserExpResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserExpResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovExp(uint64(msgSize))
			}
			mapSize := 1 + sovExp(uint64(k)) + msgSize
			i = encodeVarintExp(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintExp(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintExp(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LevelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LevelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.Uid))
	}
	if m.UserLevel != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserLevel.Size()))
		n5, err := m.UserLevel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.AnchorLevel != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.AnchorLevel.Size()))
		n6, err := m.AnchorLevel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UserLevelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserLevelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.Level))
	}
	if m.NextLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.NextLevel))
	}
	if m.UserExpLeft != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpLeft))
	}
	if m.UserExpRight != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpRight))
	}
	if m.UserExp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExp))
	}
	if m.UserExpNextLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpNextLevel))
	}
	if m.Color != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.Color))
	}
	if m.UserExpNextLeft != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpNextLeft))
	}
	if m.UserExpNextRight != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpNextRight))
	}
	if m.IsLevelTop != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.IsLevelTop))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorLevelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorLevelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.Level))
	}
	if m.NextLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.NextLevel))
	}
	if m.UserExpLeft != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpLeft))
	}
	if m.UserExpRight != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpRight))
	}
	if m.UserExp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExp))
	}
	if m.UserExpNextLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpNextLevel))
	}
	if m.Color != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.Color))
	}
	if m.UserExpNextLeft != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpNextLeft))
	}
	if m.UserExpNextRight != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.UserExpNextRight))
	}
	if m.AnchorScore != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.AnchorScore))
	}
	if m.IsLevelTop != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintExp(dAtA, i, uint64(m.IsLevelTop))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintExp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AddUserExpReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovExp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserExpChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovExp(uint64(m.Uid))
	}
	if m.ReqBiz != 0 {
		n += 1 + sovExp(uint64(m.ReqBiz))
	}
	if m.Type != 0 {
		n += 1 + sovExp(uint64(m.Type))
	}
	if m.Num != 0 {
		n += 1 + sovExp(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddUserExpResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUserExpReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovExp(uint64(e))
		}
		n += 1 + sovExp(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUserExpResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovExp(uint64(l))
			}
			mapEntrySize := 1 + sovExp(uint64(k)) + l
			n += mapEntrySize + 1 + sovExp(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LevelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovExp(uint64(m.Uid))
	}
	if m.UserLevel != nil {
		l = m.UserLevel.Size()
		n += 1 + l + sovExp(uint64(l))
	}
	if m.AnchorLevel != nil {
		l = m.AnchorLevel.Size()
		n += 1 + l + sovExp(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserLevelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovExp(uint64(m.Level))
	}
	if m.NextLevel != 0 {
		n += 1 + sovExp(uint64(m.NextLevel))
	}
	if m.UserExpLeft != 0 {
		n += 1 + sovExp(uint64(m.UserExpLeft))
	}
	if m.UserExpRight != 0 {
		n += 1 + sovExp(uint64(m.UserExpRight))
	}
	if m.UserExp != 0 {
		n += 1 + sovExp(uint64(m.UserExp))
	}
	if m.UserExpNextLevel != 0 {
		n += 1 + sovExp(uint64(m.UserExpNextLevel))
	}
	if m.Color != 0 {
		n += 1 + sovExp(uint64(m.Color))
	}
	if m.UserExpNextLeft != 0 {
		n += 1 + sovExp(uint64(m.UserExpNextLeft))
	}
	if m.UserExpNextRight != 0 {
		n += 1 + sovExp(uint64(m.UserExpNextRight))
	}
	if m.IsLevelTop != 0 {
		n += 1 + sovExp(uint64(m.IsLevelTop))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorLevelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovExp(uint64(m.Level))
	}
	if m.NextLevel != 0 {
		n += 1 + sovExp(uint64(m.NextLevel))
	}
	if m.UserExpLeft != 0 {
		n += 1 + sovExp(uint64(m.UserExpLeft))
	}
	if m.UserExpRight != 0 {
		n += 1 + sovExp(uint64(m.UserExpRight))
	}
	if m.UserExp != 0 {
		n += 1 + sovExp(uint64(m.UserExp))
	}
	if m.UserExpNextLevel != 0 {
		n += 1 + sovExp(uint64(m.UserExpNextLevel))
	}
	if m.Color != 0 {
		n += 1 + sovExp(uint64(m.Color))
	}
	if m.UserExpNextLeft != 0 {
		n += 1 + sovExp(uint64(m.UserExpNextLeft))
	}
	if m.UserExpNextRight != 0 {
		n += 1 + sovExp(uint64(m.UserExpNextRight))
	}
	if m.AnchorScore != 0 {
		n += 1 + sovExp(uint64(m.AnchorScore))
	}
	if m.IsLevelTop != 0 {
		n += 1 + sovExp(uint64(m.IsLevelTop))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozExp(x uint64) (n int) {
	return sovExp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddUserExpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddUserExpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddUserExpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &UserExpChunk{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserExpChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserExpChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserExpChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqBiz", wireType)
			}
			m.ReqBiz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqBiz |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddUserExpResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddUserExpResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddUserExpResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserExpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserExpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserExpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthExp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserExpResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserExpResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserExpResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int64]*LevelInfo)
			}
			var mapkey int64
			var mapvalue *LevelInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExp
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthExp
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &LevelInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthExp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LevelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LevelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LevelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserLevel == nil {
				m.UserLevel = &UserLevelInfo{}
			}
			if err := m.UserLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnchorLevel == nil {
				m.AnchorLevel = &AnchorLevelInfo{}
			}
			if err := m.AnchorLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserLevelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserLevelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserLevelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLevel", wireType)
			}
			m.NextLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextLevel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpLeft", wireType)
			}
			m.UserExpLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpLeft |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpRight", wireType)
			}
			m.UserExpRight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpRight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExp", wireType)
			}
			m.UserExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpNextLevel", wireType)
			}
			m.UserExpNextLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpNextLevel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpNextLeft", wireType)
			}
			m.UserExpNextLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpNextLeft |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpNextRight", wireType)
			}
			m.UserExpNextRight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpNextRight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLevelTop", wireType)
			}
			m.IsLevelTop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsLevelTop |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorLevelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorLevelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorLevelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLevel", wireType)
			}
			m.NextLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextLevel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpLeft", wireType)
			}
			m.UserExpLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpLeft |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpRight", wireType)
			}
			m.UserExpRight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpRight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExp", wireType)
			}
			m.UserExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpNextLevel", wireType)
			}
			m.UserExpNextLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpNextLevel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpNextLeft", wireType)
			}
			m.UserExpNextLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpNextLeft |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserExpNextRight", wireType)
			}
			m.UserExpNextRight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserExpNextRight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorScore", wireType)
			}
			m.AnchorScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorScore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLevelTop", wireType)
			}
			m.IsLevelTop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsLevelTop |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthExp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExp   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/live/xuser/api/grpc/v1/exp.proto", fileDescriptor_exp_57cf1a328d2a0c19)
}

var fileDescriptor_exp_57cf1a328d2a0c19 = []byte{
	// 767 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0xcf, 0x6e, 0xd3, 0x4c,
	0x10, 0x97, 0x93, 0xb4, 0x69, 0x26, 0x4d, 0x1b, 0xed, 0xf7, 0x1d, 0xfc, 0xf5, 0x2b, 0xd9, 0xca,
	0xfc, 0x69, 0x25, 0x8a, 0x4d, 0x02, 0x07, 0xa8, 0x5a, 0x41, 0x03, 0x15, 0xaa, 0x54, 0x90, 0xba,
	0xc0, 0x85, 0x0b, 0x38, 0xf1, 0x26, 0xb1, 0x9a, 0xc4, 0x8e, 0x63, 0x5b, 0x69, 0x6f, 0x88, 0x07,
	0xe1, 0xce, 0x03, 0xf0, 0x04, 0x1c, 0x38, 0xf2, 0x04, 0x16, 0xea, 0xd1, 0xc7, 0x3e, 0x01, 0xf2,
	0xae, 0x13, 0xaf, 0x9d, 0x2a, 0x9c, 0x91, 0xb8, 0xc4, 0x33, 0xbf, 0x99, 0xdf, 0x6f, 0xc7, 0x3b,
	0xa3, 0x71, 0x60, 0x57, 0xb7, 0x6d, 0x6d, 0x4c, 0x1d, 0xdf, 0x6c, 0x53, 0xad, 0x6f, 0xfa, 0x54,
	0x9b, 0x78, 0x63, 0xea, 0x68, 0xba, 0x6d, 0x6a, 0x5d, 0xc7, 0x6e, 0x6b, 0x7e, 0x5d, 0xa3, 0x13,
	0x5b, 0xb5, 0x1d, 0xcb, 0xb5, 0x50, 0x25, 0xca, 0x50, 0x59, 0x86, 0xea, 0xd7, 0x37, 0xee, 0x75,
	0x4d, 0xb7, 0xe7, 0xb5, 0xd4, 0xb6, 0x35, 0xd0, 0xba, 0x56, 0xd7, 0xd2, 0x58, 0x56, 0xcb, 0xeb,
	0x30, 0x8f, 0x39, 0xcc, 0xe2, 0x6c, 0x65, 0x04, 0x95, 0x43, 0xc3, 0x78, 0x3b, 0xa6, 0xce, 0xd1,
	0xc4, 0x26, 0x74, 0x84, 0x3e, 0xc0, 0x4a, 0x24, 0x75, 0x3c, 0xec, 0x58, 0xb2, 0xb4, 0x25, 0xed,
	0x94, 0x1b, 0xff, 0xab, 0xa9, 0x13, 0xd4, 0x38, 0xf9, 0x59, 0xcf, 0x1b, 0x9e, 0x35, 0xb7, 0xaf,
	0x02, 0x7c, 0xb3, 0x63, 0x39, 0x83, 0x3d, 0x65, 0x4a, 0x53, 0xb6, 0x7c, 0xbd, 0x6f, 0x1a, 0xba,
	0x4b, 0xf7, 0x14, 0x87, 0x8e, 0x3c, 0xd3, 0xa1, 0x86, 0x42, 0x66, 0xaa, 0xca, 0xa7, 0x1c, 0xac,
	0x8a, 0x1a, 0xe8, 0x31, 0xe4, 0x3d, 0xd3, 0x60, 0xa7, 0xe5, 0x53, 0x82, 0xa6, 0x21, 0x6a, 0x75,
	0xdd, 0x83, 0xfb, 0xbb, 0x89, 0x60, 0xc4, 0x41, 0x4f, 0xa0, 0xe8, 0xd0, 0xd1, 0xfb, 0x96, 0x79,
	0x21, 0xe7, 0x18, 0xfd, 0xce, 0x55, 0x80, 0x15, 0x4e, 0x8f, 0x03, 0xd7, 0x97, 0xb3, 0xec, 0xd0,
	0x51, 0xd3, 0xbc, 0x40, 0xfb, 0x50, 0x70, 0xcf, 0x6d, 0x2a, 0xe7, 0x19, 0x7b, 0xe7, 0x2a, 0xc0,
	0xb7, 0x38, 0x3b, 0x42, 0x17, 0x9c, 0xce, 0x58, 0x51, 0xe5, 0x43, 0x6f, 0x20, 0x17, 0xb2, 0x95,
	0x0f, 0xbd, 0xc1, 0xa2, 0xca, 0xa3, 0x70, 0x15, 0xd6, 0xc4, 0x8b, 0x1f, 0xdb, 0xca, 0x4b, 0xa8,
	0xbc, 0xa0, 0xae, 0xd0, 0x8a, 0x7d, 0x28, 0x78, 0xa6, 0x31, 0x96, 0xa5, 0xad, 0x7c, 0xba, 0xb6,
	0x08, 0x5d, 0x54, 0x1b, 0x8b, 0x7f, 0x91, 0x60, 0x4d, 0xd4, 0x1b, 0xdb, 0xe8, 0x08, 0x0a, 0x86,
	0xee, 0xea, 0x4c, 0xb0, 0xdc, 0xd8, 0xce, 0xf4, 0x35, 0x9d, 0xac, 0x3e, 0xd7, 0x5d, 0xfd, 0x68,
	0xe8, 0x3a, 0xe7, 0xcd, 0x95, 0x30, 0xc0, 0x8c, 0x48, 0xd8, 0xef, 0xc6, 0x29, 0x94, 0x66, 0x41,
	0x54, 0x85, 0xfc, 0x19, 0x3d, 0xe7, 0xcd, 0x23, 0x91, 0x89, 0x54, 0x58, 0xf2, 0xf5, 0xbe, 0x47,
	0x59, 0x47, 0xca, 0x0d, 0x39, 0x73, 0xcc, 0x09, 0xf5, 0x69, 0x3f, 0x1a, 0x04, 0xc2, 0xd3, 0xf6,
	0x72, 0x8f, 0x24, 0xe5, 0x9b, 0x04, 0xa5, 0x59, 0x00, 0xfd, 0x27, 0x0e, 0x44, 0x31, 0x0c, 0x70,
	0xe4, 0xf2, 0x86, 0x1f, 0x43, 0x29, 0x12, 0x62, 0xb9, 0xf1, 0x01, 0x9b, 0xd7, 0xcc, 0xe7, 0x4c,
	0xab, 0x59, 0x09, 0x03, 0x9c, 0x50, 0x48, 0x62, 0xa2, 0x53, 0x28, 0xeb, 0xc3, 0x76, 0xcf, 0x8a,
	0xc5, 0xf2, 0x4c, 0xac, 0x96, 0x11, 0x3b, 0x4c, 0x32, 0x98, 0xdc, 0x7a, 0x18, 0x60, 0x91, 0x46,
	0x44, 0x47, 0xf9, 0x58, 0x80, 0x4a, 0xea, 0x78, 0x84, 0x61, 0xa9, 0xcf, 0xe4, 0xf9, 0xcb, 0x94,
	0xc2, 0x00, 0x73, 0x80, 0xf0, 0x07, 0xba, 0x0b, 0xa5, 0x21, 0x9d, 0xb8, 0xc9, 0x0b, 0xe5, 0x79,
	0xc9, 0x33, 0x90, 0x24, 0x26, 0xaa, 0x43, 0xd9, 0xe3, 0x2d, 0x3a, 0xa1, 0x1d, 0x37, 0x1e, 0x5a,
	0x56, 0x92, 0x00, 0x13, 0xd1, 0x41, 0x0f, 0x61, 0x35, 0x76, 0x89, 0xd9, 0xed, 0xb9, 0xf1, 0xac,
	0x56, 0xc3, 0x00, 0xa7, 0x70, 0x92, 0xf2, 0xd0, 0x6d, 0x28, 0xc6, 0xbe, 0xbc, 0xc4, 0x08, 0xe5,
	0x30, 0xc0, 0x53, 0x88, 0x4c, 0x0d, 0xf4, 0x14, 0xaa, 0xb1, 0xf9, 0x6a, 0xf6, 0x0e, 0xcb, 0x2c,
	0xff, 0xdf, 0x30, 0xc0, 0x73, 0x31, 0x32, 0x87, 0x44, 0xf7, 0xd3, 0xb6, 0xfa, 0x96, 0x23, 0x17,
	0x93, 0xfb, 0x61, 0x00, 0xe1, 0x0f, 0x74, 0x00, 0xeb, 0x29, 0x52, 0xc7, 0x95, 0x57, 0x58, 0xea,
	0x3f, 0x61, 0x80, 0xb3, 0x21, 0x92, 0x05, 0x32, 0x15, 0xf2, 0x2b, 0x28, 0x5d, 0x5b, 0x21, 0xbf,
	0x86, 0x39, 0x04, 0xa9, 0x00, 0xe6, 0x98, 0x15, 0xfb, 0xc6, 0xb2, 0x65, 0x60, 0xdc, 0xb5, 0x30,
	0xc0, 0x02, 0x4a, 0x04, 0x5b, 0xf9, 0x5a, 0x80, 0xf5, 0xcc, 0xd4, 0xfc, 0x9d, 0x82, 0x3f, 0x7e,
	0x0a, 0xea, 0xd3, 0x65, 0xf1, 0xba, 0x6d, 0x39, 0x34, 0x1e, 0x03, 0x61, 0x19, 0x30, 0x98, 0x88,
	0x4e, 0x66, 0x70, 0xca, 0xbf, 0x1b, 0x9c, 0xc6, 0x67, 0x09, 0x8a, 0xf1, 0x02, 0x46, 0xc7, 0x00,
	0xc9, 0x3a, 0x46, 0x9b, 0x0b, 0x36, 0xf5, 0x68, 0xe3, 0xc6, 0xc2, 0x3d, 0x1e, 0x49, 0x25, 0x1f,
	0x9a, 0x39, 0xa9, 0xd4, 0xc7, 0x7f, 0x4e, 0x2a, 0xfd, 0x85, 0x6a, 0x56, 0xbf, 0x5f, 0xd6, 0xa4,
	0x1f, 0x97, 0x35, 0xe9, 0xe7, 0x65, 0x4d, 0x7a, 0x97, 0xf3, 0xeb, 0xad, 0x65, 0xf6, 0x2f, 0xe2,
	0xc1, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x59, 0x18, 0xa3, 0x2e, 0xb3, 0x08, 0x00, 0x00,
}
