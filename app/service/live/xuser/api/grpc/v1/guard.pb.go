// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/live/xuser/api/grpc/v1/guard.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import grpc1 "go-common/app/service/live/xuser/api/grpc"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GuardBuyReq struct {
	OrderId              string         `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty" validate:"required"`
	Uid                  int64          `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	Ruid                 int64          `protobuf:"varint,3,opt,name=ruid,proto3" json:"ruid,omitempty" validate:"gt=0,required"`
	GuardLevel           int            `protobuf:"varint,4,opt,name=guard_level,json=guardLevel,proto3,casttype=int" json:"guard_level,omitempty" validate:"gt=0,required"`
	Num                  int            `protobuf:"varint,5,opt,name=num,proto3,casttype=int" json:"num,omitempty" validate:"gt=0,required"`
	Platform             grpc1.Platform `protobuf:"varint,6,opt,name=platform,proto3,enum=live.xuser.Platform" json:"platform,omitempty" validate:"required"`
	Source               string         `protobuf:"bytes,7,opt,name=source,proto3" json:"source,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GuardBuyReq) Reset()         { *m = GuardBuyReq{} }
func (m *GuardBuyReq) String() string { return proto.CompactTextString(m) }
func (*GuardBuyReq) ProtoMessage()    {}
func (*GuardBuyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{0}
}
func (m *GuardBuyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuardBuyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuardBuyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GuardBuyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuardBuyReq.Merge(dst, src)
}
func (m *GuardBuyReq) XXX_Size() int {
	return m.Size()
}
func (m *GuardBuyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GuardBuyReq.DiscardUnknown(m)
}

var xxx_messageInfo_GuardBuyReq proto.InternalMessageInfo

func (m *GuardBuyReq) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *GuardBuyReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GuardBuyReq) GetRuid() int64 {
	if m != nil {
		return m.Ruid
	}
	return 0
}

func (m *GuardBuyReq) GetGuardLevel() int {
	if m != nil {
		return m.GuardLevel
	}
	return 0
}

func (m *GuardBuyReq) GetNum() int {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *GuardBuyReq) GetPlatform() grpc1.Platform {
	if m != nil {
		return m.Platform
	}
	return grpc1.Platform_UNKNOWN
}

func (m *GuardBuyReq) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type GuardBuyReply struct {
	Status               int      `protobuf:"varint,1,opt,name=status,proto3,casttype=int" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuardBuyReply) Reset()         { *m = GuardBuyReply{} }
func (m *GuardBuyReply) String() string { return proto.CompactTextString(m) }
func (*GuardBuyReply) ProtoMessage()    {}
func (*GuardBuyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{1}
}
func (m *GuardBuyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuardBuyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuardBuyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GuardBuyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuardBuyReply.Merge(dst, src)
}
func (m *GuardBuyReply) XXX_Size() int {
	return m.Size()
}
func (m *GuardBuyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GuardBuyReply.DiscardUnknown(m)
}

var xxx_messageInfo_GuardBuyReply proto.InternalMessageInfo

func (m *GuardBuyReply) GetStatus() int {
	if m != nil {
		return m.Status
	}
	return 0
}

// GetByUidTargetIdReq 1:1请求
type ClearUIDCacheReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid" validate:"gt=0,required"`
	MagicKey             string   `protobuf:"bytes,2,opt,name=magic_key,json=magicKey,proto3" json:"magic_key,omitempty" form:"magic_key" validate:"alpha,required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClearUIDCacheReq) Reset()         { *m = ClearUIDCacheReq{} }
func (m *ClearUIDCacheReq) String() string { return proto.CompactTextString(m) }
func (*ClearUIDCacheReq) ProtoMessage()    {}
func (*ClearUIDCacheReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{2}
}
func (m *ClearUIDCacheReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearUIDCacheReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearUIDCacheReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClearUIDCacheReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearUIDCacheReq.Merge(dst, src)
}
func (m *ClearUIDCacheReq) XXX_Size() int {
	return m.Size()
}
func (m *ClearUIDCacheReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearUIDCacheReq.DiscardUnknown(m)
}

var xxx_messageInfo_ClearUIDCacheReq proto.InternalMessageInfo

func (m *ClearUIDCacheReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ClearUIDCacheReq) GetMagicKey() string {
	if m != nil {
		return m.MagicKey
	}
	return ""
}

type ClearUIDCacheResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClearUIDCacheResp) Reset()         { *m = ClearUIDCacheResp{} }
func (m *ClearUIDCacheResp) String() string { return proto.CompactTextString(m) }
func (*ClearUIDCacheResp) ProtoMessage()    {}
func (*ClearUIDCacheResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{3}
}
func (m *ClearUIDCacheResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearUIDCacheResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearUIDCacheResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClearUIDCacheResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearUIDCacheResp.Merge(dst, src)
}
func (m *ClearUIDCacheResp) XXX_Size() int {
	return m.Size()
}
func (m *ClearUIDCacheResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearUIDCacheResp.DiscardUnknown(m)
}

var xxx_messageInfo_ClearUIDCacheResp proto.InternalMessageInfo

// GetByUidTargetIdReq 1:1请求
type GetByUidTargetIdReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid" validate:"gt=0,required"`
	TargetId             int64    `protobuf:"varint,2,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty" form:"target_id" validate:"required"`
	SortType             int64    `protobuf:"varint,3,opt,name=sort_type,json=sortType,proto3" json:"sort_type,omitempty" form:"sort_type" validate:"gte=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetByUidTargetIdReq) Reset()         { *m = GetByUidTargetIdReq{} }
func (m *GetByUidTargetIdReq) String() string { return proto.CompactTextString(m) }
func (*GetByUidTargetIdReq) ProtoMessage()    {}
func (*GetByUidTargetIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{4}
}
func (m *GetByUidTargetIdReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByUidTargetIdReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByUidTargetIdReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByUidTargetIdReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByUidTargetIdReq.Merge(dst, src)
}
func (m *GetByUidTargetIdReq) XXX_Size() int {
	return m.Size()
}
func (m *GetByUidTargetIdReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByUidTargetIdReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetByUidTargetIdReq proto.InternalMessageInfo

func (m *GetByUidTargetIdReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetByUidTargetIdReq) GetTargetId() int64 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *GetByUidTargetIdReq) GetSortType() int64 {
	if m != nil {
		return m.SortType
	}
	return 0
}

type GetByUidTargetIdResp struct {
	Data                 map[int64]*DaHangHaiInfo `protobuf:"bytes,1,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetByUidTargetIdResp) Reset()         { *m = GetByUidTargetIdResp{} }
func (m *GetByUidTargetIdResp) String() string { return proto.CompactTextString(m) }
func (*GetByUidTargetIdResp) ProtoMessage()    {}
func (*GetByUidTargetIdResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{5}
}
func (m *GetByUidTargetIdResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByUidTargetIdResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByUidTargetIdResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByUidTargetIdResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByUidTargetIdResp.Merge(dst, src)
}
func (m *GetByUidTargetIdResp) XXX_Size() int {
	return m.Size()
}
func (m *GetByUidTargetIdResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByUidTargetIdResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetByUidTargetIdResp proto.InternalMessageInfo

func (m *GetByUidTargetIdResp) GetData() map[int64]*DaHangHaiInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type AllDaHangHaiInfo struct {
	GuardInfo            map[int64]*DaHangHaiInfo `protobuf:"bytes,1,rep,name=guardInfo" json:"guardInfo,omitempty" validate:"required" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *AllDaHangHaiInfo) Reset()         { *m = AllDaHangHaiInfo{} }
func (m *AllDaHangHaiInfo) String() string { return proto.CompactTextString(m) }
func (*AllDaHangHaiInfo) ProtoMessage()    {}
func (*AllDaHangHaiInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{6}
}
func (m *AllDaHangHaiInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllDaHangHaiInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllDaHangHaiInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AllDaHangHaiInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllDaHangHaiInfo.Merge(dst, src)
}
func (m *AllDaHangHaiInfo) XXX_Size() int {
	return m.Size()
}
func (m *AllDaHangHaiInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AllDaHangHaiInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AllDaHangHaiInfo proto.InternalMessageInfo

func (m *AllDaHangHaiInfo) GetGuardInfo() map[int64]*DaHangHaiInfo {
	if m != nil {
		return m.GuardInfo
	}
	return nil
}

type FilterDaHangHaiInfo struct {
	GuardInfo            map[int64]*DaHangHaiInfo `protobuf:"bytes,1,rep,name=guardInfo" json:"guardInfo,omitempty" validate:"required" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *FilterDaHangHaiInfo) Reset()         { *m = FilterDaHangHaiInfo{} }
func (m *FilterDaHangHaiInfo) String() string { return proto.CompactTextString(m) }
func (*FilterDaHangHaiInfo) ProtoMessage()    {}
func (*FilterDaHangHaiInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{7}
}
func (m *FilterDaHangHaiInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FilterDaHangHaiInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FilterDaHangHaiInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FilterDaHangHaiInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FilterDaHangHaiInfo.Merge(dst, src)
}
func (m *FilterDaHangHaiInfo) XXX_Size() int {
	return m.Size()
}
func (m *FilterDaHangHaiInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FilterDaHangHaiInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FilterDaHangHaiInfo proto.InternalMessageInfo

func (m *FilterDaHangHaiInfo) GetGuardInfo() map[int64]*DaHangHaiInfo {
	if m != nil {
		return m.GuardInfo
	}
	return nil
}

type DaHangHaiInfo struct {
	// 主键
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// uid
	Uid int64 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid"`
	// target_id
	TargetId int64 `protobuf:"varint,3,opt,name=target_id,json=targetId,proto3" json:"target_id"`
	// 守护类型 1为总督，2为提督，3为舰长
	PrivilegeType int64 `protobuf:"varint,4,opt,name=privilege_type,json=privilegeType,proto3" json:"privilege_type"`
	// start_time
	StartTime string `protobuf:"bytes,5,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	// expired_time
	ExpiredTime string `protobuf:"bytes,6,opt,name=expired_time,json=expiredTime,proto3" json:"expired_time"`
	// ctime
	Ctime string `protobuf:"bytes,7,opt,name=ctime,proto3" json:"ctime"`
	// utime
	Utime                string   `protobuf:"bytes,8,opt,name=utime,proto3" json:"utime"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DaHangHaiInfo) Reset()         { *m = DaHangHaiInfo{} }
func (m *DaHangHaiInfo) String() string { return proto.CompactTextString(m) }
func (*DaHangHaiInfo) ProtoMessage()    {}
func (*DaHangHaiInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{8}
}
func (m *DaHangHaiInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaHangHaiInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaHangHaiInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DaHangHaiInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaHangHaiInfo.Merge(dst, src)
}
func (m *DaHangHaiInfo) XXX_Size() int {
	return m.Size()
}
func (m *DaHangHaiInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DaHangHaiInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DaHangHaiInfo proto.InternalMessageInfo

func (m *DaHangHaiInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DaHangHaiInfo) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DaHangHaiInfo) GetTargetId() int64 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *DaHangHaiInfo) GetPrivilegeType() int64 {
	if m != nil {
		return m.PrivilegeType
	}
	return 0
}

func (m *DaHangHaiInfo) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *DaHangHaiInfo) GetExpiredTime() string {
	if m != nil {
		return m.ExpiredTime
	}
	return ""
}

func (m *DaHangHaiInfo) GetCtime() string {
	if m != nil {
		return m.Ctime
	}
	return ""
}

func (m *DaHangHaiInfo) GetUtime() string {
	if m != nil {
		return m.Utime
	}
	return ""
}

type DaHangHaiInfoList struct {
	List                 []*DaHangHaiInfo `protobuf:"bytes,1,rep,name=list" json:"list"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DaHangHaiInfoList) Reset()         { *m = DaHangHaiInfoList{} }
func (m *DaHangHaiInfoList) String() string { return proto.CompactTextString(m) }
func (*DaHangHaiInfoList) ProtoMessage()    {}
func (*DaHangHaiInfoList) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{9}
}
func (m *DaHangHaiInfoList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaHangHaiInfoList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DaHangHaiInfoList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DaHangHaiInfoList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaHangHaiInfoList.Merge(dst, src)
}
func (m *DaHangHaiInfoList) XXX_Size() int {
	return m.Size()
}
func (m *DaHangHaiInfoList) XXX_DiscardUnknown() {
	xxx_messageInfo_DaHangHaiInfoList.DiscardUnknown(m)
}

var xxx_messageInfo_DaHangHaiInfoList proto.InternalMessageInfo

func (m *DaHangHaiInfoList) GetList() []*DaHangHaiInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type GetByUidTargetIdsReq struct {
	Uid                  int64        `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid" validate:"gt=0,required"`
	TargetIDs            []*TargetIds `protobuf:"bytes,2,rep,name=targetIDs" json:"targetIDs,omitempty" form:"targetIDs" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetByUidTargetIdsReq) Reset()         { *m = GetByUidTargetIdsReq{} }
func (m *GetByUidTargetIdsReq) String() string { return proto.CompactTextString(m) }
func (*GetByUidTargetIdsReq) ProtoMessage()    {}
func (*GetByUidTargetIdsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{10}
}
func (m *GetByUidTargetIdsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByUidTargetIdsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByUidTargetIdsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByUidTargetIdsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByUidTargetIdsReq.Merge(dst, src)
}
func (m *GetByUidTargetIdsReq) XXX_Size() int {
	return m.Size()
}
func (m *GetByUidTargetIdsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByUidTargetIdsReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetByUidTargetIdsReq proto.InternalMessageInfo

func (m *GetByUidTargetIdsReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetByUidTargetIdsReq) GetTargetIDs() []*TargetIds {
	if m != nil {
		return m.TargetIDs
	}
	return nil
}

type GetByUidTargetIdsResp struct {
	Data                 map[int64]*DaHangHaiInfo `protobuf:"bytes,1,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetByUidTargetIdsResp) Reset()         { *m = GetByUidTargetIdsResp{} }
func (m *GetByUidTargetIdsResp) String() string { return proto.CompactTextString(m) }
func (*GetByUidTargetIdsResp) ProtoMessage()    {}
func (*GetByUidTargetIdsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{11}
}
func (m *GetByUidTargetIdsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByUidTargetIdsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByUidTargetIdsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByUidTargetIdsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByUidTargetIdsResp.Merge(dst, src)
}
func (m *GetByUidTargetIdsResp) XXX_Size() int {
	return m.Size()
}
func (m *GetByUidTargetIdsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByUidTargetIdsResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetByUidTargetIdsResp proto.InternalMessageInfo

func (m *GetByUidTargetIdsResp) GetData() map[int64]*DaHangHaiInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type TargetIds struct {
	TargetId             int64    `protobuf:"varint,1,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty" form:"target_id" validate:"gt=0,required"`
	SortType             int64    `protobuf:"varint,2,opt,name=sort_type,json=sortType,proto3" json:"sort_type,omitempty" form:"sort_type" validate:"gt=0"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetIds) Reset()         { *m = TargetIds{} }
func (m *TargetIds) String() string { return proto.CompactTextString(m) }
func (*TargetIds) ProtoMessage()    {}
func (*TargetIds) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{12}
}
func (m *TargetIds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetIds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetIds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TargetIds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetIds.Merge(dst, src)
}
func (m *TargetIds) XXX_Size() int {
	return m.Size()
}
func (m *TargetIds) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetIds.DiscardUnknown(m)
}

var xxx_messageInfo_TargetIds proto.InternalMessageInfo

func (m *TargetIds) GetTargetId() int64 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *TargetIds) GetSortType() int64 {
	if m != nil {
		return m.SortType
	}
	return 0
}

// GetByTargetIdsBatchReq 根据uids批量获取所有守护关系
type GetByTargetIdsReq struct {
	TargetIDs            []*TargetIds `protobuf:"bytes,1,rep,name=targetIDs" json:"targetIDs,omitempty" form:"targetIDs" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetByTargetIdsReq) Reset()         { *m = GetByTargetIdsReq{} }
func (m *GetByTargetIdsReq) String() string { return proto.CompactTextString(m) }
func (*GetByTargetIdsReq) ProtoMessage()    {}
func (*GetByTargetIdsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{13}
}
func (m *GetByTargetIdsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByTargetIdsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByTargetIdsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByTargetIdsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByTargetIdsReq.Merge(dst, src)
}
func (m *GetByTargetIdsReq) XXX_Size() int {
	return m.Size()
}
func (m *GetByTargetIdsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByTargetIdsReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetByTargetIdsReq proto.InternalMessageInfo

func (m *GetByTargetIdsReq) GetTargetIDs() []*TargetIds {
	if m != nil {
		return m.TargetIDs
	}
	return nil
}

// TODO 实现
type GetByTargetIdsResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetByTargetIdsResp) Reset()         { *m = GetByTargetIdsResp{} }
func (m *GetByTargetIdsResp) String() string { return proto.CompactTextString(m) }
func (*GetByTargetIdsResp) ProtoMessage()    {}
func (*GetByTargetIdsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{14}
}
func (m *GetByTargetIdsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByTargetIdsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByTargetIdsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByTargetIdsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByTargetIdsResp.Merge(dst, src)
}
func (m *GetByTargetIdsResp) XXX_Size() int {
	return m.Size()
}
func (m *GetByTargetIdsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByTargetIdsResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetByTargetIdsResp proto.InternalMessageInfo

// GetAllShouHuReq 目标全部守护数据
type GetByUidReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetByUidReq) Reset()         { *m = GetByUidReq{} }
func (m *GetByUidReq) String() string { return proto.CompactTextString(m) }
func (*GetByUidReq) ProtoMessage()    {}
func (*GetByUidReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{15}
}
func (m *GetByUidReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByUidReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByUidReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByUidReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByUidReq.Merge(dst, src)
}
func (m *GetByUidReq) XXX_Size() int {
	return m.Size()
}
func (m *GetByUidReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByUidReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetByUidReq proto.InternalMessageInfo

func (m *GetByUidReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type GetByUidResp struct {
	Data                 map[int64]*DaHangHaiInfo `protobuf:"bytes,1,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetByUidResp) Reset()         { *m = GetByUidResp{} }
func (m *GetByUidResp) String() string { return proto.CompactTextString(m) }
func (*GetByUidResp) ProtoMessage()    {}
func (*GetByUidResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{16}
}
func (m *GetByUidResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByUidResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByUidResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByUidResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByUidResp.Merge(dst, src)
}
func (m *GetByUidResp) XXX_Size() int {
	return m.Size()
}
func (m *GetByUidResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByUidResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetByUidResp proto.InternalMessageInfo

func (m *GetByUidResp) GetData() map[int64]*DaHangHaiInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

// GetAllShouHuBatchReq 目标全部守护数据(批量)
type GetByUidBatchReq struct {
	Uids                 []int64  `protobuf:"varint,1,rep,packed,name=uids" json:"uids,omitempty" form:"uids" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetByUidBatchReq) Reset()         { *m = GetByUidBatchReq{} }
func (m *GetByUidBatchReq) String() string { return proto.CompactTextString(m) }
func (*GetByUidBatchReq) ProtoMessage()    {}
func (*GetByUidBatchReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{17}
}
func (m *GetByUidBatchReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByUidBatchReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByUidBatchReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByUidBatchReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByUidBatchReq.Merge(dst, src)
}
func (m *GetByUidBatchReq) XXX_Size() int {
	return m.Size()
}
func (m *GetByUidBatchReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByUidBatchReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetByUidBatchReq proto.InternalMessageInfo

func (m *GetByUidBatchReq) GetUids() []int64 {
	if m != nil {
		return m.Uids
	}
	return nil
}

type GetByUidBatchResp struct {
	Data                 map[int64]*DaHangHaiInfoList `protobuf:"bytes,1,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *GetByUidBatchResp) Reset()         { *m = GetByUidBatchResp{} }
func (m *GetByUidBatchResp) String() string { return proto.CompactTextString(m) }
func (*GetByUidBatchResp) ProtoMessage()    {}
func (*GetByUidBatchResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{18}
}
func (m *GetByUidBatchResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetByUidBatchResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetByUidBatchResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetByUidBatchResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetByUidBatchResp.Merge(dst, src)
}
func (m *GetByUidBatchResp) XXX_Size() int {
	return m.Size()
}
func (m *GetByUidBatchResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetByUidBatchResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetByUidBatchResp proto.InternalMessageInfo

func (m *GetByUidBatchResp) GetData() map[int64]*DaHangHaiInfoList {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetAnchorRecentTopGuardReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAnchorRecentTopGuardReq) Reset()         { *m = GetAnchorRecentTopGuardReq{} }
func (m *GetAnchorRecentTopGuardReq) String() string { return proto.CompactTextString(m) }
func (*GetAnchorRecentTopGuardReq) ProtoMessage()    {}
func (*GetAnchorRecentTopGuardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{19}
}
func (m *GetAnchorRecentTopGuardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAnchorRecentTopGuardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAnchorRecentTopGuardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAnchorRecentTopGuardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAnchorRecentTopGuardReq.Merge(dst, src)
}
func (m *GetAnchorRecentTopGuardReq) XXX_Size() int {
	return m.Size()
}
func (m *GetAnchorRecentTopGuardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAnchorRecentTopGuardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetAnchorRecentTopGuardReq proto.InternalMessageInfo

func (m *GetAnchorRecentTopGuardReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type GetAnchorRecentTopGuardResp struct {
	// 主键
	Cnt                  int64                          `protobuf:"varint,1,opt,name=cnt,proto3" json:"cnt"`
	List                 []*GetAnchorRecentTopGuardList `protobuf:"bytes,2,rep,name=list" json:"list"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *GetAnchorRecentTopGuardResp) Reset()         { *m = GetAnchorRecentTopGuardResp{} }
func (m *GetAnchorRecentTopGuardResp) String() string { return proto.CompactTextString(m) }
func (*GetAnchorRecentTopGuardResp) ProtoMessage()    {}
func (*GetAnchorRecentTopGuardResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{20}
}
func (m *GetAnchorRecentTopGuardResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAnchorRecentTopGuardResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAnchorRecentTopGuardResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAnchorRecentTopGuardResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAnchorRecentTopGuardResp.Merge(dst, src)
}
func (m *GetAnchorRecentTopGuardResp) XXX_Size() int {
	return m.Size()
}
func (m *GetAnchorRecentTopGuardResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAnchorRecentTopGuardResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetAnchorRecentTopGuardResp proto.InternalMessageInfo

func (m *GetAnchorRecentTopGuardResp) GetCnt() int64 {
	if m != nil {
		return m.Cnt
	}
	return 0
}

func (m *GetAnchorRecentTopGuardResp) GetList() []*GetAnchorRecentTopGuardList {
	if m != nil {
		return m.List
	}
	return nil
}

type GetAnchorRecentTopGuardList struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid"`
	EndTime              int64    `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	IsOpen               int64    `protobuf:"varint,3,opt,name=is_open,json=isOpen,proto3" json:"is_open"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAnchorRecentTopGuardList) Reset()         { *m = GetAnchorRecentTopGuardList{} }
func (m *GetAnchorRecentTopGuardList) String() string { return proto.CompactTextString(m) }
func (*GetAnchorRecentTopGuardList) ProtoMessage()    {}
func (*GetAnchorRecentTopGuardList) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{21}
}
func (m *GetAnchorRecentTopGuardList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAnchorRecentTopGuardList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAnchorRecentTopGuardList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAnchorRecentTopGuardList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAnchorRecentTopGuardList.Merge(dst, src)
}
func (m *GetAnchorRecentTopGuardList) XXX_Size() int {
	return m.Size()
}
func (m *GetAnchorRecentTopGuardList) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAnchorRecentTopGuardList.DiscardUnknown(m)
}

var xxx_messageInfo_GetAnchorRecentTopGuardList proto.InternalMessageInfo

func (m *GetAnchorRecentTopGuardList) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetAnchorRecentTopGuardList) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *GetAnchorRecentTopGuardList) GetIsOpen() int64 {
	if m != nil {
		return m.IsOpen
	}
	return 0
}

type GetTopListGuardReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid" validate:"gt=0,required"`
	Page                 int64    `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty" form:"page" validate:"gte=1"`
	PageSize             int64    `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty" form:"page_size" validate:"gte=1"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTopListGuardReq) Reset()         { *m = GetTopListGuardReq{} }
func (m *GetTopListGuardReq) String() string { return proto.CompactTextString(m) }
func (*GetTopListGuardReq) ProtoMessage()    {}
func (*GetTopListGuardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{22}
}
func (m *GetTopListGuardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTopListGuardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTopListGuardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetTopListGuardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTopListGuardReq.Merge(dst, src)
}
func (m *GetTopListGuardReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTopListGuardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTopListGuardReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTopListGuardReq proto.InternalMessageInfo

func (m *GetTopListGuardReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetTopListGuardReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *GetTopListGuardReq) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

type GetTopListGuardResp struct {
	// 守护总数量
	Num                  int64           `protobuf:"varint,1,opt,name=num,proto3" json:"num"`
	Page                 int64           `protobuf:"varint,2,opt,name=page,proto3" json:"page"`
	Now                  int64           `protobuf:"varint,3,opt,name=now,proto3" json:"now"`
	List                 []*TopListGuard `protobuf:"bytes,4,rep,name=list" json:"list"`
	Top3                 []*TopListGuard `protobuf:"bytes,5,rep,name=top3" json:"top3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetTopListGuardResp) Reset()         { *m = GetTopListGuardResp{} }
func (m *GetTopListGuardResp) String() string { return proto.CompactTextString(m) }
func (*GetTopListGuardResp) ProtoMessage()    {}
func (*GetTopListGuardResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{23}
}
func (m *GetTopListGuardResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTopListGuardResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTopListGuardResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetTopListGuardResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTopListGuardResp.Merge(dst, src)
}
func (m *GetTopListGuardResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTopListGuardResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTopListGuardResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTopListGuardResp proto.InternalMessageInfo

func (m *GetTopListGuardResp) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *GetTopListGuardResp) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *GetTopListGuardResp) GetNow() int64 {
	if m != nil {
		return m.Now
	}
	return 0
}

func (m *GetTopListGuardResp) GetList() []*TopListGuard {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *GetTopListGuardResp) GetTop3() []*TopListGuard {
	if m != nil {
		return m.Top3
	}
	return nil
}

type TopListGuard struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid"`
	Ruid                 int64    `protobuf:"varint,2,opt,name=ruid,proto3" json:"ruid"`
	Rank                 int64    `protobuf:"varint,4,opt,name=rank,proto3" json:"rank"`
	GuardLevel           int64    `protobuf:"varint,3,opt,name=guard_level,json=guardLevel,proto3" json:"guard_level"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopListGuard) Reset()         { *m = TopListGuard{} }
func (m *TopListGuard) String() string { return proto.CompactTextString(m) }
func (*TopListGuard) ProtoMessage()    {}
func (*TopListGuard) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{24}
}
func (m *TopListGuard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopListGuard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopListGuard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TopListGuard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopListGuard.Merge(dst, src)
}
func (m *TopListGuard) XXX_Size() int {
	return m.Size()
}
func (m *TopListGuard) XXX_DiscardUnknown() {
	xxx_messageInfo_TopListGuard.DiscardUnknown(m)
}

var xxx_messageInfo_TopListGuard proto.InternalMessageInfo

func (m *TopListGuard) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *TopListGuard) GetRuid() int64 {
	if m != nil {
		return m.Ruid
	}
	return 0
}

func (m *TopListGuard) GetRank() int64 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *TopListGuard) GetGuardLevel() int64 {
	if m != nil {
		return m.GuardLevel
	}
	return 0
}

type GetTopListGuardNumReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" form:"uid" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTopListGuardNumReq) Reset()         { *m = GetTopListGuardNumReq{} }
func (m *GetTopListGuardNumReq) String() string { return proto.CompactTextString(m) }
func (*GetTopListGuardNumReq) ProtoMessage()    {}
func (*GetTopListGuardNumReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{25}
}
func (m *GetTopListGuardNumReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTopListGuardNumReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTopListGuardNumReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetTopListGuardNumReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTopListGuardNumReq.Merge(dst, src)
}
func (m *GetTopListGuardNumReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTopListGuardNumReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTopListGuardNumReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTopListGuardNumReq proto.InternalMessageInfo

func (m *GetTopListGuardNumReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type GetTopListGuardNumResp struct {
	TotalCount           int64    `protobuf:"varint,1,opt,name=total_count,json=totalCount,proto3" json:"total_count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTopListGuardNumResp) Reset()         { *m = GetTopListGuardNumResp{} }
func (m *GetTopListGuardNumResp) String() string { return proto.CompactTextString(m) }
func (*GetTopListGuardNumResp) ProtoMessage()    {}
func (*GetTopListGuardNumResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_guard_f5515e6e1476a9e5, []int{26}
}
func (m *GetTopListGuardNumResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTopListGuardNumResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTopListGuardNumResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetTopListGuardNumResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTopListGuardNumResp.Merge(dst, src)
}
func (m *GetTopListGuardNumResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTopListGuardNumResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTopListGuardNumResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTopListGuardNumResp proto.InternalMessageInfo

func (m *GetTopListGuardNumResp) GetTotalCount() int64 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func init() {
	proto.RegisterType((*GuardBuyReq)(nil), "live.xuser.v1.GuardBuyReq")
	proto.RegisterType((*GuardBuyReply)(nil), "live.xuser.v1.GuardBuyReply")
	proto.RegisterType((*ClearUIDCacheReq)(nil), "live.xuser.v1.ClearUIDCacheReq")
	proto.RegisterType((*ClearUIDCacheResp)(nil), "live.xuser.v1.ClearUIDCacheResp")
	proto.RegisterType((*GetByUidTargetIdReq)(nil), "live.xuser.v1.GetByUidTargetIdReq")
	proto.RegisterType((*GetByUidTargetIdResp)(nil), "live.xuser.v1.GetByUidTargetIdResp")
	proto.RegisterMapType((map[int64]*DaHangHaiInfo)(nil), "live.xuser.v1.GetByUidTargetIdResp.DataEntry")
	proto.RegisterType((*AllDaHangHaiInfo)(nil), "live.xuser.v1.AllDaHangHaiInfo")
	proto.RegisterMapType((map[int64]*DaHangHaiInfo)(nil), "live.xuser.v1.AllDaHangHaiInfo.GuardInfoEntry")
	proto.RegisterType((*FilterDaHangHaiInfo)(nil), "live.xuser.v1.FilterDaHangHaiInfo")
	proto.RegisterMapType((map[int64]*DaHangHaiInfo)(nil), "live.xuser.v1.FilterDaHangHaiInfo.GuardInfoEntry")
	proto.RegisterType((*DaHangHaiInfo)(nil), "live.xuser.v1.DaHangHaiInfo")
	proto.RegisterType((*DaHangHaiInfoList)(nil), "live.xuser.v1.DaHangHaiInfoList")
	proto.RegisterType((*GetByUidTargetIdsReq)(nil), "live.xuser.v1.GetByUidTargetIdsReq")
	proto.RegisterType((*GetByUidTargetIdsResp)(nil), "live.xuser.v1.GetByUidTargetIdsResp")
	proto.RegisterMapType((map[int64]*DaHangHaiInfo)(nil), "live.xuser.v1.GetByUidTargetIdsResp.DataEntry")
	proto.RegisterType((*TargetIds)(nil), "live.xuser.v1.TargetIds")
	proto.RegisterType((*GetByTargetIdsReq)(nil), "live.xuser.v1.GetByTargetIdsReq")
	proto.RegisterType((*GetByTargetIdsResp)(nil), "live.xuser.v1.GetByTargetIdsResp")
	proto.RegisterType((*GetByUidReq)(nil), "live.xuser.v1.GetByUidReq")
	proto.RegisterType((*GetByUidResp)(nil), "live.xuser.v1.GetByUidResp")
	proto.RegisterMapType((map[int64]*DaHangHaiInfo)(nil), "live.xuser.v1.GetByUidResp.DataEntry")
	proto.RegisterType((*GetByUidBatchReq)(nil), "live.xuser.v1.GetByUidBatchReq")
	proto.RegisterType((*GetByUidBatchResp)(nil), "live.xuser.v1.GetByUidBatchResp")
	proto.RegisterMapType((map[int64]*DaHangHaiInfoList)(nil), "live.xuser.v1.GetByUidBatchResp.DataEntry")
	proto.RegisterType((*GetAnchorRecentTopGuardReq)(nil), "live.xuser.v1.GetAnchorRecentTopGuardReq")
	proto.RegisterType((*GetAnchorRecentTopGuardResp)(nil), "live.xuser.v1.GetAnchorRecentTopGuardResp")
	proto.RegisterType((*GetAnchorRecentTopGuardList)(nil), "live.xuser.v1.GetAnchorRecentTopGuardList")
	proto.RegisterType((*GetTopListGuardReq)(nil), "live.xuser.v1.GetTopListGuardReq")
	proto.RegisterType((*GetTopListGuardResp)(nil), "live.xuser.v1.GetTopListGuardResp")
	proto.RegisterType((*TopListGuard)(nil), "live.xuser.v1.TopListGuard")
	proto.RegisterType((*GetTopListGuardNumReq)(nil), "live.xuser.v1.GetTopListGuardNumReq")
	proto.RegisterType((*GetTopListGuardNumResp)(nil), "live.xuser.v1.GetTopListGuardNumResp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GuardClient is the client API for Guard service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GuardClient interface {
	// Buy 购买大航海
	Buy(ctx context.Context, in *GuardBuyReq, opts ...grpc.CallOption) (*GuardBuyReply, error)
	// GetByUIDTargetID 获取我与目标用户守护关系,不支持批量(P0级)
	GetByUIDTargetID(ctx context.Context, in *GetByUidTargetIdReq, opts ...grpc.CallOption) (*GetByUidTargetIdResp, error)
	// GetByTargetIdsBatch 获取我与目标用户守护关系,支持批量(P2级,必要时刻降级)
	GetByTargetIdsBatch(ctx context.Context, in *GetByTargetIdsReq, opts ...grpc.CallOption) (*GetByTargetIdsResp, error)
	// GetByUIDTargetIds 根据uids批量获取所有守护关系,粉丝勋章使用
	GetByUIDTargetIds(ctx context.Context, in *GetByUidTargetIdsReq, opts ...grpc.CallOption) (*GetByUidTargetIdsResp, error)
	// GetByUID 获取我所有的守护,不支持批量(P0级)
	GetByUIDForGift(ctx context.Context, in *GetByUidReq, opts ...grpc.CallOption) (*GetByUidResp, error)
	// GetByUIDBatch 根据uids获取所有的守护,支持批量(P2级)
	GetByUIDBatch(ctx context.Context, in *GetByUidBatchReq, opts ...grpc.CallOption) (*GetByUidBatchResp, error)
	// GetAnchorRecentTopGuard 获取最近的提督弹窗提醒
	GetAnchorRecentTopGuard(ctx context.Context, in *GetAnchorRecentTopGuardReq, opts ...grpc.CallOption) (*GetAnchorRecentTopGuardResp, error)
	// GetTopListGuard 获取某个up主的守护排行榜
	GetTopListGuard(ctx context.Context, in *GetTopListGuardReq, opts ...grpc.CallOption) (*GetTopListGuardResp, error)
	// GetTopListGuardNum 获取某个up主所有的守护数量,和GetTopListGuard接口的区别是此接口用于房间页首屏,逻辑比较简单,因此拆分开来
	GetTopListGuardNum(ctx context.Context, in *GetTopListGuardNumReq, opts ...grpc.CallOption) (*GetTopListGuardNumResp, error)
	// ClearUIDCache 清除cache
	ClearUIDCache(ctx context.Context, in *ClearUIDCacheReq, opts ...grpc.CallOption) (*ClearUIDCacheResp, error)
}

type guardClient struct {
	cc *grpc.ClientConn
}

func NewGuardClient(cc *grpc.ClientConn) GuardClient {
	return &guardClient{cc}
}

func (c *guardClient) Buy(ctx context.Context, in *GuardBuyReq, opts ...grpc.CallOption) (*GuardBuyReply, error) {
	out := new(GuardBuyReply)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/Buy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardClient) GetByUIDTargetID(ctx context.Context, in *GetByUidTargetIdReq, opts ...grpc.CallOption) (*GetByUidTargetIdResp, error) {
	out := new(GetByUidTargetIdResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/GetByUIDTargetID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardClient) GetByTargetIdsBatch(ctx context.Context, in *GetByTargetIdsReq, opts ...grpc.CallOption) (*GetByTargetIdsResp, error) {
	out := new(GetByTargetIdsResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/GetByTargetIdsBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardClient) GetByUIDTargetIds(ctx context.Context, in *GetByUidTargetIdsReq, opts ...grpc.CallOption) (*GetByUidTargetIdsResp, error) {
	out := new(GetByUidTargetIdsResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/GetByUIDTargetIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardClient) GetByUIDForGift(ctx context.Context, in *GetByUidReq, opts ...grpc.CallOption) (*GetByUidResp, error) {
	out := new(GetByUidResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/GetByUIDForGift", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardClient) GetByUIDBatch(ctx context.Context, in *GetByUidBatchReq, opts ...grpc.CallOption) (*GetByUidBatchResp, error) {
	out := new(GetByUidBatchResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/GetByUIDBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardClient) GetAnchorRecentTopGuard(ctx context.Context, in *GetAnchorRecentTopGuardReq, opts ...grpc.CallOption) (*GetAnchorRecentTopGuardResp, error) {
	out := new(GetAnchorRecentTopGuardResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/GetAnchorRecentTopGuard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardClient) GetTopListGuard(ctx context.Context, in *GetTopListGuardReq, opts ...grpc.CallOption) (*GetTopListGuardResp, error) {
	out := new(GetTopListGuardResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/GetTopListGuard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardClient) GetTopListGuardNum(ctx context.Context, in *GetTopListGuardNumReq, opts ...grpc.CallOption) (*GetTopListGuardNumResp, error) {
	out := new(GetTopListGuardNumResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/GetTopListGuardNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guardClient) ClearUIDCache(ctx context.Context, in *ClearUIDCacheReq, opts ...grpc.CallOption) (*ClearUIDCacheResp, error) {
	out := new(ClearUIDCacheResp)
	err := c.cc.Invoke(ctx, "/live.xuser.v1.Guard/ClearUIDCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuardServer is the server API for Guard service.
type GuardServer interface {
	// Buy 购买大航海
	Buy(context.Context, *GuardBuyReq) (*GuardBuyReply, error)
	// GetByUIDTargetID 获取我与目标用户守护关系,不支持批量(P0级)
	GetByUIDTargetID(context.Context, *GetByUidTargetIdReq) (*GetByUidTargetIdResp, error)
	// GetByTargetIdsBatch 获取我与目标用户守护关系,支持批量(P2级,必要时刻降级)
	GetByTargetIdsBatch(context.Context, *GetByTargetIdsReq) (*GetByTargetIdsResp, error)
	// GetByUIDTargetIds 根据uids批量获取所有守护关系,粉丝勋章使用
	GetByUIDTargetIds(context.Context, *GetByUidTargetIdsReq) (*GetByUidTargetIdsResp, error)
	// GetByUID 获取我所有的守护,不支持批量(P0级)
	GetByUIDForGift(context.Context, *GetByUidReq) (*GetByUidResp, error)
	// GetByUIDBatch 根据uids获取所有的守护,支持批量(P2级)
	GetByUIDBatch(context.Context, *GetByUidBatchReq) (*GetByUidBatchResp, error)
	// GetAnchorRecentTopGuard 获取最近的提督弹窗提醒
	GetAnchorRecentTopGuard(context.Context, *GetAnchorRecentTopGuardReq) (*GetAnchorRecentTopGuardResp, error)
	// GetTopListGuard 获取某个up主的守护排行榜
	GetTopListGuard(context.Context, *GetTopListGuardReq) (*GetTopListGuardResp, error)
	// GetTopListGuardNum 获取某个up主所有的守护数量,和GetTopListGuard接口的区别是此接口用于房间页首屏,逻辑比较简单,因此拆分开来
	GetTopListGuardNum(context.Context, *GetTopListGuardNumReq) (*GetTopListGuardNumResp, error)
	// ClearUIDCache 清除cache
	ClearUIDCache(context.Context, *ClearUIDCacheReq) (*ClearUIDCacheResp, error)
}

func RegisterGuardServer(s *grpc.Server, srv GuardServer) {
	s.RegisterService(&_Guard_serviceDesc, srv)
}

func _Guard_Buy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GuardBuyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).Buy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/Buy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).Buy(ctx, req.(*GuardBuyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guard_GetByUIDTargetID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByUidTargetIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).GetByUIDTargetID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/GetByUIDTargetID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).GetByUIDTargetID(ctx, req.(*GetByUidTargetIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guard_GetByTargetIdsBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByTargetIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).GetByTargetIdsBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/GetByTargetIdsBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).GetByTargetIdsBatch(ctx, req.(*GetByTargetIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guard_GetByUIDTargetIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByUidTargetIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).GetByUIDTargetIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/GetByUIDTargetIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).GetByUIDTargetIds(ctx, req.(*GetByUidTargetIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guard_GetByUIDForGift_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByUidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).GetByUIDForGift(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/GetByUIDForGift",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).GetByUIDForGift(ctx, req.(*GetByUidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guard_GetByUIDBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByUidBatchReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).GetByUIDBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/GetByUIDBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).GetByUIDBatch(ctx, req.(*GetByUidBatchReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guard_GetAnchorRecentTopGuard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAnchorRecentTopGuardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).GetAnchorRecentTopGuard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/GetAnchorRecentTopGuard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).GetAnchorRecentTopGuard(ctx, req.(*GetAnchorRecentTopGuardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guard_GetTopListGuard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopListGuardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).GetTopListGuard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/GetTopListGuard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).GetTopListGuard(ctx, req.(*GetTopListGuardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guard_GetTopListGuardNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopListGuardNumReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).GetTopListGuardNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/GetTopListGuardNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).GetTopListGuardNum(ctx, req.(*GetTopListGuardNumReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guard_ClearUIDCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearUIDCacheReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuardServer).ClearUIDCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xuser.v1.Guard/ClearUIDCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuardServer).ClearUIDCache(ctx, req.(*ClearUIDCacheReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Guard_serviceDesc = grpc.ServiceDesc{
	ServiceName: "live.xuser.v1.Guard",
	HandlerType: (*GuardServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Buy",
			Handler:    _Guard_Buy_Handler,
		},
		{
			MethodName: "GetByUIDTargetID",
			Handler:    _Guard_GetByUIDTargetID_Handler,
		},
		{
			MethodName: "GetByTargetIdsBatch",
			Handler:    _Guard_GetByTargetIdsBatch_Handler,
		},
		{
			MethodName: "GetByUIDTargetIds",
			Handler:    _Guard_GetByUIDTargetIds_Handler,
		},
		{
			MethodName: "GetByUIDForGift",
			Handler:    _Guard_GetByUIDForGift_Handler,
		},
		{
			MethodName: "GetByUIDBatch",
			Handler:    _Guard_GetByUIDBatch_Handler,
		},
		{
			MethodName: "GetAnchorRecentTopGuard",
			Handler:    _Guard_GetAnchorRecentTopGuard_Handler,
		},
		{
			MethodName: "GetTopListGuard",
			Handler:    _Guard_GetTopListGuard_Handler,
		},
		{
			MethodName: "GetTopListGuardNum",
			Handler:    _Guard_GetTopListGuardNum_Handler,
		},
		{
			MethodName: "ClearUIDCache",
			Handler:    _Guard_ClearUIDCache_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/live/xuser/api/grpc/v1/guard.proto",
}

func (m *GuardBuyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuardBuyReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGuard(dAtA, i, uint64(len(m.OrderId)))
		i += copy(dAtA[i:], m.OrderId)
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if m.Ruid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Ruid))
	}
	if m.GuardLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.GuardLevel))
	}
	if m.Num != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Num))
	}
	if m.Platform != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Platform))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GuardBuyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuardBuyReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClearUIDCacheReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearUIDCacheReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if len(m.MagicKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGuard(dAtA, i, uint64(len(m.MagicKey)))
		i += copy(dAtA[i:], m.MagicKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClearUIDCacheResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearUIDCacheResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByUidTargetIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByUidTargetIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if m.TargetId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.TargetId))
	}
	if m.SortType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.SortType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByUidTargetIdResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByUidTargetIdResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGuard(uint64(msgSize))
			}
			mapSize := 1 + sovGuard(uint64(k)) + msgSize
			i = encodeVarintGuard(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintGuard(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGuard(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllDaHangHaiInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllDaHangHaiInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GuardInfo) > 0 {
		for k, _ := range m.GuardInfo {
			dAtA[i] = 0xa
			i++
			v := m.GuardInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGuard(uint64(msgSize))
			}
			mapSize := 1 + sovGuard(uint64(k)) + msgSize
			i = encodeVarintGuard(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintGuard(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGuard(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FilterDaHangHaiInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterDaHangHaiInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GuardInfo) > 0 {
		for k, _ := range m.GuardInfo {
			dAtA[i] = 0xa
			i++
			v := m.GuardInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGuard(uint64(msgSize))
			}
			mapSize := 1 + sovGuard(uint64(k)) + msgSize
			i = encodeVarintGuard(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintGuard(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGuard(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DaHangHaiInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaHangHaiInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Id))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if m.TargetId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.TargetId))
	}
	if m.PrivilegeType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.PrivilegeType))
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGuard(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.ExpiredTime) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGuard(dAtA, i, uint64(len(m.ExpiredTime)))
		i += copy(dAtA[i:], m.ExpiredTime)
	}
	if len(m.Ctime) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Ctime)))
		i += copy(dAtA[i:], m.Ctime)
	}
	if len(m.Utime) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGuard(dAtA, i, uint64(len(m.Utime)))
		i += copy(dAtA[i:], m.Utime)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DaHangHaiInfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaHangHaiInfoList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGuard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByUidTargetIdsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByUidTargetIdsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if len(m.TargetIDs) > 0 {
		for _, msg := range m.TargetIDs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGuard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByUidTargetIdsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByUidTargetIdsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGuard(uint64(msgSize))
			}
			mapSize := 1 + sovGuard(uint64(k)) + msgSize
			i = encodeVarintGuard(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintGuard(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGuard(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TargetIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetIds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.TargetId))
	}
	if m.SortType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.SortType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByTargetIdsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByTargetIdsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TargetIDs) > 0 {
		for _, msg := range m.TargetIDs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGuard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByTargetIdsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByTargetIdsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByUidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByUidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByUidResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByUidResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGuard(uint64(msgSize))
			}
			mapSize := 1 + sovGuard(uint64(k)) + msgSize
			i = encodeVarintGuard(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintGuard(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGuard(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByUidBatchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByUidBatchReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		dAtA7 := make([]byte, len(m.Uids)*10)
		var j6 int
		for _, num1 := range m.Uids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintGuard(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetByUidBatchResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetByUidBatchResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovGuard(uint64(msgSize))
			}
			mapSize := 1 + sovGuard(uint64(k)) + msgSize
			i = encodeVarintGuard(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintGuard(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintGuard(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAnchorRecentTopGuardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAnchorRecentTopGuardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAnchorRecentTopGuardResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAnchorRecentTopGuardResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cnt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Cnt))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGuard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAnchorRecentTopGuardList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAnchorRecentTopGuardList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.EndTime))
	}
	if m.IsOpen != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.IsOpen))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTopListGuardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopListGuardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Page))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTopListGuardResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopListGuardResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Num))
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Page))
	}
	if m.Now != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Now))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGuard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Top3) > 0 {
		for _, msg := range m.Top3 {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintGuard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TopListGuard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopListGuard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if m.Ruid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Ruid))
	}
	if m.GuardLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.GuardLevel))
	}
	if m.Rank != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTopListGuardNumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopListGuardNumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTopListGuardNumResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopListGuardNumResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGuard(dAtA, i, uint64(m.TotalCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintGuard(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GuardBuyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if m.Ruid != 0 {
		n += 1 + sovGuard(uint64(m.Ruid))
	}
	if m.GuardLevel != 0 {
		n += 1 + sovGuard(uint64(m.GuardLevel))
	}
	if m.Num != 0 {
		n += 1 + sovGuard(uint64(m.Num))
	}
	if m.Platform != 0 {
		n += 1 + sovGuard(uint64(m.Platform))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuardBuyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovGuard(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearUIDCacheReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	l = len(m.MagicKey)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearUIDCacheResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByUidTargetIdReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if m.TargetId != 0 {
		n += 1 + sovGuard(uint64(m.TargetId))
	}
	if m.SortType != 0 {
		n += 1 + sovGuard(uint64(m.SortType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByUidTargetIdResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGuard(uint64(l))
			}
			mapEntrySize := 1 + sovGuard(uint64(k)) + l
			n += mapEntrySize + 1 + sovGuard(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllDaHangHaiInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GuardInfo) > 0 {
		for k, v := range m.GuardInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGuard(uint64(l))
			}
			mapEntrySize := 1 + sovGuard(uint64(k)) + l
			n += mapEntrySize + 1 + sovGuard(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FilterDaHangHaiInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GuardInfo) > 0 {
		for k, v := range m.GuardInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGuard(uint64(l))
			}
			mapEntrySize := 1 + sovGuard(uint64(k)) + l
			n += mapEntrySize + 1 + sovGuard(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaHangHaiInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGuard(uint64(m.Id))
	}
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if m.TargetId != 0 {
		n += 1 + sovGuard(uint64(m.TargetId))
	}
	if m.PrivilegeType != 0 {
		n += 1 + sovGuard(uint64(m.PrivilegeType))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.ExpiredTime)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Ctime)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	l = len(m.Utime)
	if l > 0 {
		n += 1 + l + sovGuard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DaHangHaiInfoList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByUidTargetIdsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if len(m.TargetIDs) > 0 {
		for _, e := range m.TargetIDs {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByUidTargetIdsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGuard(uint64(l))
			}
			mapEntrySize := 1 + sovGuard(uint64(k)) + l
			n += mapEntrySize + 1 + sovGuard(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetId != 0 {
		n += 1 + sovGuard(uint64(m.TargetId))
	}
	if m.SortType != 0 {
		n += 1 + sovGuard(uint64(m.SortType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByTargetIdsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TargetIDs) > 0 {
		for _, e := range m.TargetIDs {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByTargetIdsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByUidReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByUidResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGuard(uint64(l))
			}
			mapEntrySize := 1 + sovGuard(uint64(k)) + l
			n += mapEntrySize + 1 + sovGuard(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByUidBatchReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovGuard(uint64(e))
		}
		n += 1 + sovGuard(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetByUidBatchResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGuard(uint64(l))
			}
			mapEntrySize := 1 + sovGuard(uint64(k)) + l
			n += mapEntrySize + 1 + sovGuard(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAnchorRecentTopGuardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAnchorRecentTopGuardResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cnt != 0 {
		n += 1 + sovGuard(uint64(m.Cnt))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAnchorRecentTopGuardList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if m.EndTime != 0 {
		n += 1 + sovGuard(uint64(m.EndTime))
	}
	if m.IsOpen != 0 {
		n += 1 + sovGuard(uint64(m.IsOpen))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTopListGuardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if m.Page != 0 {
		n += 1 + sovGuard(uint64(m.Page))
	}
	if m.PageSize != 0 {
		n += 1 + sovGuard(uint64(m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTopListGuardResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovGuard(uint64(m.Num))
	}
	if m.Page != 0 {
		n += 1 + sovGuard(uint64(m.Page))
	}
	if m.Now != 0 {
		n += 1 + sovGuard(uint64(m.Now))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if len(m.Top3) > 0 {
		for _, e := range m.Top3 {
			l = e.Size()
			n += 1 + l + sovGuard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TopListGuard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if m.Ruid != 0 {
		n += 1 + sovGuard(uint64(m.Ruid))
	}
	if m.GuardLevel != 0 {
		n += 1 + sovGuard(uint64(m.GuardLevel))
	}
	if m.Rank != 0 {
		n += 1 + sovGuard(uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTopListGuardNumReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGuard(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTopListGuardNumResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalCount != 0 {
		n += 1 + sovGuard(uint64(m.TotalCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGuard(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGuard(x uint64) (n int) {
	return sovGuard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GuardBuyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuardBuyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuardBuyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ruid", wireType)
			}
			m.Ruid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ruid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardLevel", wireType)
			}
			m.GuardLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuardLevel |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			m.Platform = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Platform |= (grpc1.Platform(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuardBuyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuardBuyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuardBuyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearUIDCacheReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearUIDCacheReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearUIDCacheReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MagicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearUIDCacheResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearUIDCacheResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearUIDCacheResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByUidTargetIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByUidTargetIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByUidTargetIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortType", wireType)
			}
			m.SortType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByUidTargetIdResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByUidTargetIdResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByUidTargetIdResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int64]*DaHangHaiInfo)
			}
			var mapkey int64
			var mapvalue *DaHangHaiInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGuard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DaHangHaiInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGuard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGuard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllDaHangHaiInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllDaHangHaiInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllDaHangHaiInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuardInfo == nil {
				m.GuardInfo = make(map[int64]*DaHangHaiInfo)
			}
			var mapkey int64
			var mapvalue *DaHangHaiInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGuard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DaHangHaiInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGuard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGuard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GuardInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterDaHangHaiInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterDaHangHaiInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterDaHangHaiInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuardInfo == nil {
				m.GuardInfo = make(map[int64]*DaHangHaiInfo)
			}
			var mapkey int64
			var mapvalue *DaHangHaiInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGuard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DaHangHaiInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGuard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGuard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GuardInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaHangHaiInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaHangHaiInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaHangHaiInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeType", wireType)
			}
			m.PrivilegeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivilegeType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpiredTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ctime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Utime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Utime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaHangHaiInfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaHangHaiInfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaHangHaiInfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &DaHangHaiInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByUidTargetIdsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByUidTargetIdsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByUidTargetIdsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetIDs = append(m.TargetIDs, &TargetIds{})
			if err := m.TargetIDs[len(m.TargetIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByUidTargetIdsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByUidTargetIdsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByUidTargetIdsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int64]*DaHangHaiInfo)
			}
			var mapkey int64
			var mapvalue *DaHangHaiInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGuard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DaHangHaiInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGuard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGuard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortType", wireType)
			}
			m.SortType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByTargetIdsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByTargetIdsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByTargetIdsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetIDs = append(m.TargetIDs, &TargetIds{})
			if err := m.TargetIDs[len(m.TargetIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByTargetIdsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByTargetIdsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByTargetIdsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByUidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByUidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByUidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByUidResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByUidResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByUidResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int64]*DaHangHaiInfo)
			}
			var mapkey int64
			var mapvalue *DaHangHaiInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGuard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DaHangHaiInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGuard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGuard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByUidBatchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByUidBatchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByUidBatchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGuard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGuard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGuard
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetByUidBatchResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetByUidBatchResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetByUidBatchResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int64]*DaHangHaiInfoList)
			}
			var mapkey int64
			var mapvalue *DaHangHaiInfoList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGuard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGuard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthGuard
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DaHangHaiInfoList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGuard(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGuard
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAnchorRecentTopGuardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAnchorRecentTopGuardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAnchorRecentTopGuardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAnchorRecentTopGuardResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAnchorRecentTopGuardResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAnchorRecentTopGuardResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cnt", wireType)
			}
			m.Cnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cnt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &GetAnchorRecentTopGuardList{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAnchorRecentTopGuardList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAnchorRecentTopGuardList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAnchorRecentTopGuardList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOpen", wireType)
			}
			m.IsOpen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsOpen |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopListGuardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopListGuardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopListGuardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopListGuardResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopListGuardResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopListGuardResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			m.Now = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Now |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &TopListGuard{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGuard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Top3 = append(m.Top3, &TopListGuard{})
			if err := m.Top3[len(m.Top3)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopListGuard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopListGuard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopListGuard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ruid", wireType)
			}
			m.Ruid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ruid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardLevel", wireType)
			}
			m.GuardLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuardLevel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopListGuardNumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopListGuardNumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopListGuardNumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopListGuardNumResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopListGuardNumResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopListGuardNumResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGuard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGuard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGuard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGuard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGuard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGuard
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGuard
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGuard(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGuard = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGuard   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/live/xuser/api/grpc/v1/guard.proto", fileDescriptor_guard_f5515e6e1476a9e5)
}

var fileDescriptor_guard_f5515e6e1476a9e5 = []byte{
	// 1589 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcb, 0x6f, 0xdb, 0x36,
	0x18, 0x87, 0x6c, 0x27, 0xb1, 0x99, 0x47, 0x13, 0xb6, 0x6b, 0x5d, 0x37, 0xa8, 0x5c, 0x25, 0x45,
	0xd3, 0x6c, 0xb1, 0x93, 0x74, 0xaf, 0x06, 0x28, 0x86, 0x3a, 0x6e, 0x13, 0x37, 0x45, 0x3b, 0x68,
	0x29, 0xb6, 0x75, 0xc0, 0x3c, 0xd5, 0x62, 0x1c, 0xa1, 0xb2, 0xc4, 0x88, 0x94, 0x5b, 0xef, 0x38,
	0x0c, 0xd8, 0x9f, 0x30, 0xa0, 0xd8, 0x5f, 0xb0, 0xeb, 0x2e, 0xc3, 0xb0, 0x3f, 0x60, 0x3b, 0x6d,
	0x97, 0x9d, 0x06, 0x68, 0x43, 0x8f, 0x3e, 0xfa, 0xb8, 0xd3, 0x40, 0x52, 0x96, 0x25, 0xf9, 0x09,
	0xa4, 0x43, 0x77, 0x91, 0x44, 0xf2, 0xfb, 0x7d, 0xfc, 0xde, 0x1f, 0x29, 0x50, 0xd0, 0x30, 0x2e,
	0x12, 0xe4, 0x34, 0x8d, 0x1a, 0x2a, 0x9a, 0x46, 0x13, 0x15, 0x9f, 0xbb, 0x04, 0x39, 0x45, 0x0d,
	0x1b, 0xc5, 0xba, 0x83, 0x6b, 0xc5, 0xe6, 0x56, 0xb1, 0xee, 0x6a, 0x8e, 0x5e, 0xc0, 0x8e, 0x4d,
	0x6d, 0x38, 0xcf, 0x68, 0x0a, 0x9c, 0xa6, 0xd0, 0xdc, 0xca, 0x6d, 0xd4, 0x0d, 0x7a, 0xec, 0x3e,
	0x29, 0xd4, 0xec, 0x46, 0xb1, 0x6e, 0xd7, 0xed, 0x22, 0xa7, 0x7a, 0xe2, 0x1e, 0xf1, 0x11, 0x1f,
	0xf0, 0x2f, 0x81, 0xce, 0xbd, 0x39, 0x6e, 0x37, 0xc1, 0x98, 0x13, 0x2b, 0xdf, 0x25, 0xc1, 0xec,
	0x1e, 0xdb, 0xba, 0xe4, 0xb6, 0x54, 0x74, 0x02, 0xb7, 0x41, 0xda, 0x76, 0x74, 0xe4, 0x54, 0x0d,
	0x3d, 0x2b, 0xe5, 0xa5, 0xb5, 0x4c, 0xe9, 0x42, 0xc7, 0x93, 0xcf, 0x36, 0x35, 0xd3, 0xd0, 0x35,
	0x8a, 0x76, 0x14, 0x07, 0x9d, 0xb8, 0x86, 0x83, 0x74, 0x45, 0x9d, 0xe1, 0x84, 0x15, 0x1d, 0x16,
	0x40, 0xd2, 0x35, 0xf4, 0x6c, 0x22, 0x2f, 0xad, 0x25, 0x4b, 0xcb, 0x1d, 0x4f, 0xce, 0xf6, 0xc8,
	0xeb, 0xf4, 0xd6, 0xe6, 0x5b, 0x3d, 0x0c, 0x23, 0x84, 0x9b, 0x20, 0xe5, 0x30, 0x40, 0x72, 0x02,
	0x00, 0xa7, 0x84, 0x65, 0x30, 0xcb, 0xed, 0x53, 0x35, 0x51, 0x13, 0x99, 0xd9, 0x54, 0x5e, 0x5a,
	0x9b, 0x2a, 0xad, 0x8c, 0x02, 0xfe, 0xe3, 0xc9, 0x49, 0xc3, 0xa2, 0x2a, 0xe0, 0xb8, 0xfb, 0x0c,
	0x06, 0xdf, 0x01, 0x49, 0xcb, 0x6d, 0x64, 0xa7, 0x26, 0x47, 0x33, 0x7a, 0x58, 0x01, 0x69, 0x6c,
	0x6a, 0xf4, 0xc8, 0x76, 0x1a, 0xd9, 0xe9, 0xbc, 0xb4, 0xb6, 0xb0, 0x7d, 0xae, 0x10, 0x72, 0xd0,
	0x87, 0xfe, 0xda, 0x70, 0x43, 0x05, 0x70, 0x58, 0x04, 0xd3, 0xc4, 0x76, 0x9d, 0x1a, 0xca, 0xce,
	0x8c, 0xb6, 0xad, 0x4f, 0xa6, 0xec, 0x80, 0xf9, 0x9e, 0x77, 0xb0, 0xd9, 0x82, 0xd7, 0xc1, 0x34,
	0xa1, 0x1a, 0x75, 0x09, 0xf7, 0xce, 0x54, 0x69, 0xa9, 0xed, 0xc9, 0xfe, 0x4c, 0x57, 0x68, 0x7f,
	0xa8, 0xbc, 0x90, 0xc0, 0xe2, 0xae, 0x89, 0x34, 0xe7, 0x51, 0xa5, 0xbc, 0xab, 0xd5, 0x8e, 0x11,
	0xf3, 0xef, 0x4d, 0xe1, 0x2b, 0x89, 0x9b, 0xfe, 0x5a, 0xc7, 0x93, 0x57, 0x98, 0x60, 0x3b, 0x8a,
	0x6b, 0xe8, 0x4a, 0x7e, 0xb4, 0xdb, 0x0e, 0x40, 0xa6, 0xa1, 0xd5, 0x8d, 0x5a, 0xf5, 0x29, 0x6a,
	0x71, 0x67, 0x67, 0x4a, 0x85, 0x8e, 0x27, 0xaf, 0x0b, 0x06, 0xc1, 0x52, 0x98, 0x8d, 0x66, 0xe2,
	0x63, 0x2d, 0xc4, 0x27, 0xcd, 0xa9, 0x0e, 0x50, 0x4b, 0x39, 0x0b, 0x96, 0x62, 0xb2, 0x11, 0xac,
	0xfc, 0x29, 0x81, 0xb3, 0x7b, 0x88, 0x96, 0x5a, 0x8f, 0x0c, 0xfd, 0x50, 0x73, 0xea, 0x88, 0x56,
	0xf4, 0x53, 0x0a, 0x7d, 0x07, 0x64, 0x28, 0xe7, 0x54, 0x0d, 0x22, 0x74, 0xad, 0xe3, 0xc9, 0xab,
	0x82, 0x41, 0xb0, 0x14, 0x66, 0x13, 0x12, 0x97, 0xfa, 0x42, 0xc0, 0x12, 0xc8, 0x10, 0xdb, 0xa1,
	0x55, 0xda, 0xc2, 0xc8, 0x8f, 0xdb, 0xab, 0x1d, 0x4f, 0xbe, 0x22, 0xd8, 0x04, 0x4b, 0x51, 0x69,
	0xd0, 0xad, 0x4d, 0x45, 0x4d, 0xb3, 0xc5, 0x43, 0xb6, 0xf6, 0x93, 0x04, 0xce, 0xf5, 0x6b, 0x47,
	0x30, 0x3c, 0x00, 0x29, 0x5d, 0xa3, 0x5a, 0x56, 0xca, 0x27, 0xd7, 0x66, 0xb7, 0x37, 0x0a, 0x91,
	0xec, 0x2f, 0x0c, 0x82, 0x14, 0xca, 0x1a, 0xd5, 0xee, 0x58, 0xd4, 0x69, 0x95, 0xd2, 0x6d, 0x4f,
	0xe6, 0x70, 0x95, 0x3f, 0x73, 0x8f, 0x40, 0x26, 0x58, 0x84, 0x8b, 0x20, 0xc9, 0x9c, 0xc5, 0x0d,
	0xa7, 0xb2, 0x4f, 0xb8, 0x0d, 0xa6, 0x9a, 0x9a, 0xe9, 0x22, 0x6e, 0x8b, 0xd9, 0xed, 0xe5, 0xd8,
	0x66, 0x65, 0x6d, 0x5f, 0xb3, 0xea, 0xfb, 0x9a, 0x51, 0xb1, 0x8e, 0x6c, 0x55, 0x90, 0xee, 0x24,
	0xde, 0x97, 0x94, 0x3f, 0x24, 0xb0, 0x78, 0xdb, 0x34, 0x23, 0xeb, 0x10, 0x81, 0x0c, 0x4f, 0x2f,
	0x36, 0xf0, 0xa5, 0x2f, 0xc4, 0x18, 0xc6, 0x31, 0x85, 0xbd, 0x2e, 0x40, 0x88, 0x3f, 0x34, 0x03,
	0x7a, 0x9c, 0x73, 0x8f, 0xc1, 0x42, 0x14, 0xf5, 0x0a, 0xf5, 0x62, 0x21, 0x77, 0xd7, 0x30, 0x29,
	0x72, 0xa2, 0xaa, 0x1d, 0xf7, 0xab, 0xb6, 0x15, 0xe3, 0x39, 0x00, 0xf6, 0x7f, 0xd3, 0xee, 0xb7,
	0x04, 0x98, 0x8f, 0xea, 0x75, 0x1e, 0x24, 0x82, 0x4c, 0x9a, 0x6e, 0x7b, 0x72, 0xc2, 0xd0, 0xd5,
	0x84, 0xa1, 0xc3, 0x8b, 0xe1, 0x1a, 0x3e, 0xd3, 0xf6, 0x64, 0x36, 0x14, 0x29, 0xb4, 0x1e, 0x4e,
	0x21, 0x11, 0xfb, 0xf3, 0x6d, 0x4f, 0xee, 0x4d, 0x86, 0xf2, 0xe4, 0x26, 0x58, 0xc0, 0x8e, 0xd1,
	0x34, 0x4c, 0x54, 0x47, 0x22, 0x59, 0x52, 0x1c, 0x00, 0xdb, 0x9e, 0x1c, 0x5b, 0x51, 0xe7, 0x83,
	0x31, 0x4b, 0x0f, 0xb8, 0x01, 0x00, 0xa1, 0x1a, 0x4b, 0x24, 0xa3, 0x81, 0x78, 0x91, 0xce, 0x94,
	0x16, 0xda, 0x9e, 0x1c, 0x9a, 0x55, 0x33, 0xfc, 0xfb, 0xd0, 0x68, 0x20, 0x78, 0x03, 0xcc, 0xa1,
	0xe7, 0x98, 0x59, 0x53, 0x00, 0xa6, 0x39, 0x60, 0xb1, 0xed, 0xc9, 0x91, 0x79, 0x75, 0xd6, 0x1f,
	0x71, 0x90, 0x0c, 0xa6, 0x6a, 0x9c, 0x5a, 0x94, 0xdf, 0x4c, 0xdb, 0x93, 0xc5, 0x84, 0x2a, 0x5e,
	0x8c, 0xc0, 0xe5, 0x04, 0xe9, 0x1e, 0x81, 0x2b, 0x08, 0xf8, 0x4b, 0x79, 0x08, 0x96, 0x22, 0x06,
	0xbd, 0x6f, 0x10, 0x0a, 0x77, 0x40, 0xca, 0x34, 0x08, 0xf5, 0xe3, 0x64, 0xa4, 0x77, 0x44, 0xbe,
	0x32, 0x6a, 0x95, 0x3f, 0x95, 0x1f, 0x06, 0x54, 0x05, 0x72, 0xca, 0xa2, 0xf7, 0x45, 0xd7, 0x63,
	0x95, 0x32, 0xc9, 0x26, 0xb8, 0x50, 0xd9, 0x98, 0x50, 0xc1, 0x56, 0xfd, 0xe5, 0xb0, 0x52, 0x26,
	0x83, 0xcb, 0x61, 0x8f, 0xa9, 0xf2, 0xb3, 0x04, 0xde, 0x18, 0x20, 0x35, 0xc1, 0xf0, 0x7e, 0xa4,
	0x98, 0x15, 0xc6, 0x14, 0x33, 0xf2, 0x7a, 0xaa, 0xd9, 0x0b, 0x09, 0x64, 0x02, 0x11, 0xe0, 0xbd,
	0x70, 0x80, 0x0b, 0x7b, 0x6f, 0x74, 0x3c, 0xf9, 0xfa, 0x88, 0x1e, 0x11, 0xb3, 0x7a, 0x2f, 0x01,
	0x6e, 0x87, 0x1b, 0x85, 0xc8, 0xa6, 0xd5, 0x8e, 0x27, 0xe7, 0x47, 0x36, 0x8a, 0x68, 0x9f, 0x70,
	0xc1, 0x12, 0x37, 0x53, 0x24, 0x1a, 0x22, 0x2e, 0x95, 0xfe, 0x0b, 0x97, 0x9e, 0x03, 0x30, 0xbe,
	0x2d, 0xc1, 0xca, 0x3e, 0x98, 0xed, 0xfa, 0xec, 0x74, 0x41, 0xa9, 0x7c, 0x2f, 0x81, 0xb9, 0x1e,
	0x2b, 0x82, 0xe1, 0x6e, 0x24, 0x52, 0xae, 0x0e, 0x89, 0x94, 0xd7, 0x13, 0x20, 0x07, 0x60, 0xb1,
	0x2b, 0x40, 0x49, 0xa3, 0xb5, 0x63, 0xa6, 0xfb, 0x7b, 0x20, 0xe5, 0x1a, 0xba, 0xb0, 0x7e, 0x92,
	0x9f, 0x1f, 0xe5, 0x40, 0xf9, 0x21, 0xe6, 0xe5, 0x00, 0xe5, 0x47, 0xc9, 0xf7, 0x68, 0x8f, 0x1b,
	0xc1, 0x70, 0x3f, 0xa2, 0xfe, 0xfa, 0x10, 0xf5, 0x03, 0xfa, 0x11, 0x36, 0xf8, 0x74, 0xb4, 0x0d,
	0xde, 0x8d, 0xda, 0x20, 0x3f, 0xca, 0x06, 0xac, 0x9c, 0x85, 0xed, 0xf0, 0x31, 0xc8, 0xed, 0x21,
	0x7a, 0xdb, 0xaa, 0x1d, 0xdb, 0x8e, 0x8a, 0x6a, 0xc8, 0xa2, 0x87, 0x36, 0xe6, 0xed, 0xea, 0x94,
	0xd1, 0xf0, 0x95, 0x04, 0x2e, 0x0d, 0xe5, 0x4c, 0x30, 0xeb, 0x47, 0x35, 0x8b, 0xfa, 0xac, 0x79,
	0x3f, 0xaa, 0xb1, 0xf3, 0x78, 0xcd, 0xa2, 0xcc, 0x70, 0xbc, 0xda, 0x26, 0x86, 0x19, 0x6e, 0x10,
	0x53, 0xa6, 0x58, 0x5f, 0xed, 0xfd, 0x66, 0xb8, 0x10, 0xbc, 0xae, 0x5f, 0x0c, 0xeb, 0x17, 0x6d,
	0x8a, 0xd7, 0x40, 0x1a, 0x59, 0x7e, 0xeb, 0x11, 0x69, 0x3e, 0xd7, 0xf6, 0xe4, 0x60, 0x4e, 0x9d,
	0x41, 0x96, 0x68, 0x39, 0xab, 0x60, 0xc6, 0x20, 0x55, 0x1b, 0x23, 0xcb, 0xef, 0x9d, 0xb3, 0x6d,
	0x4f, 0xee, 0x4e, 0xa9, 0xd3, 0x06, 0x79, 0x88, 0x91, 0xa5, 0xfc, 0x2a, 0xf1, 0xec, 0x3b, 0xb4,
	0x31, 0xdb, 0xf8, 0x15, 0x18, 0x18, 0xbe, 0x0d, 0x52, 0x58, 0xab, 0x77, 0x85, 0xcb, 0x77, 0x3c,
	0x79, 0x59, 0x60, 0xd9, 0x6c, 0xfc, 0x9c, 0xba, 0xa5, 0xa8, 0x9c, 0x9a, 0x9d, 0x73, 0xd9, 0xbb,
	0x4a, 0x8c, 0x2f, 0x07, 0x9c, 0x73, 0x83, 0xa5, 0x01, 0xf8, 0x34, 0x5b, 0xfc, 0x88, 0xad, 0xfd,
	0x25, 0x4e, 0xf1, 0x51, 0x5d, 0x84, 0x4b, 0xd9, 0xf5, 0x2b, 0x64, 0x4d, 0xcb, 0x6d, 0x88, 0x2b,
	0xd6, 0x72, 0x44, 0x58, 0xee, 0x26, 0x36, 0xf6, 0x85, 0x62, 0x40, 0xfb, 0x99, 0x2f, 0x8e, 0x00,
	0xda, 0xcf, 0x54, 0xf6, 0x80, 0x37, 0xfd, 0x58, 0x48, 0xf1, 0x58, 0xb8, 0x14, 0xaf, 0x88, 0x21,
	0x11, 0xe2, 0xce, 0x67, 0x50, 0x6a, 0xe3, 0x1b, 0xd9, 0xa9, 0x09, 0xa1, 0x8c, 0x58, 0xe5, 0x4f,
	0xe5, 0x5b, 0x09, 0xcc, 0x85, 0x09, 0x46, 0x05, 0xca, 0xb2, 0x7f, 0xd9, 0x0d, 0xa9, 0xc6, 0xc6,
	0xfe, 0xc5, 0x76, 0x33, 0x7a, 0xb1, 0x15, 0x2a, 0x9e, 0x69, 0x7b, 0x72, 0x78, 0x3a, 0x72, 0x89,
	0x65, 0xfc, 0x34, 0xeb, 0xa9, 0x7f, 0xae, 0x12, 0xfc, 0x34, 0xeb, 0xa9, 0xca, 0x9f, 0x8a, 0xca,
	0xdb, 0x72, 0x58, 0xb6, 0x07, 0x6e, 0xe3, 0x94, 0xa9, 0x7a, 0x0f, 0x9c, 0x1f, 0xc4, 0x93, 0x60,
	0x26, 0x3d, 0xb5, 0xa9, 0x66, 0x56, 0x6b, 0xb6, 0x1b, 0x24, 0x2b, 0x97, 0x3e, 0x34, 0xad, 0x02,
	0x3e, 0xd8, 0x65, 0xdf, 0xdb, 0x5f, 0xcf, 0x80, 0x29, 0x61, 0xb2, 0x0f, 0x40, 0xb2, 0xe4, 0xb6,
	0x60, 0x2e, 0x9e, 0xbe, 0xbd, 0x7f, 0x11, 0xb9, 0xe5, 0xa1, 0x6b, 0xec, 0x26, 0xfc, 0x59, 0xb7,
	0x44, 0x57, 0xca, 0x7e, 0xcb, 0x2a, 0x43, 0x65, 0xec, 0xdd, 0xe9, 0x24, 0xb7, 0x32, 0xc1, 0xfd,
	0x0a, 0x3e, 0xf6, 0x2f, 0xa2, 0xbd, 0x9e, 0xca, 0xea, 0x30, 0xcc, 0x0f, 0xc2, 0x86, 0xfb, 0x74,
	0xee, 0xca, 0x18, 0x0a, 0x82, 0xe1, 0xe7, 0xdd, 0x6e, 0x10, 0x08, 0xae, 0x13, 0xb8, 0x32, 0xfe,
	0xa0, 0x74, 0x92, 0x5b, 0x9d, 0xe4, 0x34, 0x05, 0xef, 0x81, 0x33, 0x5d, 0xfe, 0x77, 0x6d, 0x67,
	0xcf, 0x38, 0xa2, 0xfd, 0x56, 0xee, 0xb5, 0xf4, 0xdc, 0xa5, 0x11, 0x8d, 0x17, 0xaa, 0x60, 0xbe,
	0xcb, 0x4b, 0x58, 0x40, 0x1e, 0xdd, 0xa7, 0x4e, 0x72, 0xf9, 0x71, 0x8d, 0x0c, 0x62, 0x70, 0x61,
	0x48, 0xd1, 0x85, 0xd7, 0x27, 0x2b, 0xe6, 0x6c, 0x9f, 0xf5, 0x49, 0x49, 0x09, 0x86, 0x9f, 0x70,
	0x8b, 0x44, 0x32, 0x76, 0x80, 0x9f, 0x62, 0xc5, 0x37, 0xa7, 0x8c, 0x23, 0x21, 0x18, 0x6a, 0x7d,
	0x65, 0xfb, 0x81, 0xdb, 0x80, 0xab, 0xa3, 0x91, 0x22, 0x25, 0x73, 0x57, 0x27, 0xa0, 0x12, 0x2e,
	0x88, 0xfc, 0x29, 0xe9, 0x73, 0x41, 0xfc, 0x1f, 0x4f, 0x9f, 0x0b, 0xfa, 0x7e, 0xb4, 0x94, 0x16,
	0x7f, 0x79, 0x79, 0x59, 0xfa, 0xfd, 0xe5, 0x65, 0xe9, 0xef, 0x97, 0x97, 0xa5, 0xc7, 0x89, 0xe6,
	0xd6, 0x93, 0x69, 0xfe, 0x3b, 0xf0, 0xc6, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x3f, 0xe0, 0xb4,
	0x3b, 0xab, 0x14, 0x00, 0x00,
}
