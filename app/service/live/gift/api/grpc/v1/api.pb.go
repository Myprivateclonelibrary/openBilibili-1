// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/live/gift/api/grpc/v1/api.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type RoomGiftListReq struct {
	RoomId               int64    `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	AreaV2ParentId       int64    `protobuf:"varint,2,opt,name=area_v2_parent_id,json=areaV2ParentId,proto3" json:"area_v2_parent_id,omitempty"`
	AreaV2Id             int64    `protobuf:"varint,3,opt,name=area_v2_id,json=areaV2Id,proto3" json:"area_v2_id,omitempty"`
	Platform             string   `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform,omitempty"`
	Build                int64    `protobuf:"varint,5,opt,name=build,proto3" json:"build,omitempty"`
	MobiApp              string   `protobuf:"bytes,6,opt,name=mobi_app,json=mobiApp,proto3" json:"mobi_app,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomGiftListReq) Reset()         { *m = RoomGiftListReq{} }
func (m *RoomGiftListReq) String() string { return proto.CompactTextString(m) }
func (*RoomGiftListReq) ProtoMessage()    {}
func (*RoomGiftListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{0}
}
func (m *RoomGiftListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGiftListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGiftListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGiftListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGiftListReq.Merge(dst, src)
}
func (m *RoomGiftListReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomGiftListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGiftListReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGiftListReq proto.InternalMessageInfo

type RoomGiftListResp struct {
	List                 []*RoomGiftListResp_List    `protobuf:"bytes,1,rep,name=list" json:"list"`
	SilverList           []*RoomGiftListResp_List    `protobuf:"bytes,2,rep,name=silver_list,json=silverList" json:"silver_list"`
	ShowCountMap         int64                       `protobuf:"varint,3,opt,name=show_count_map,json=showCountMap,proto3" json:"show_count_map"`
	OldList              []*RoomGiftListResp_OldList `protobuf:"bytes,4,rep,name=old_list,json=oldList" json:"old_list"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *RoomGiftListResp) Reset()         { *m = RoomGiftListResp{} }
func (m *RoomGiftListResp) String() string { return proto.CompactTextString(m) }
func (*RoomGiftListResp) ProtoMessage()    {}
func (*RoomGiftListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{1}
}
func (m *RoomGiftListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGiftListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGiftListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGiftListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGiftListResp.Merge(dst, src)
}
func (m *RoomGiftListResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomGiftListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGiftListResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGiftListResp proto.InternalMessageInfo

type RoomGiftListResp_List struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Position             int64    `protobuf:"varint,2,opt,name=position,proto3" json:"position"`
	PlanId               int64    `protobuf:"varint,3,opt,name=plan_id,json=planId,proto3" json:"plan_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomGiftListResp_List) Reset()         { *m = RoomGiftListResp_List{} }
func (m *RoomGiftListResp_List) String() string { return proto.CompactTextString(m) }
func (*RoomGiftListResp_List) ProtoMessage()    {}
func (*RoomGiftListResp_List) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{1, 0}
}
func (m *RoomGiftListResp_List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGiftListResp_List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGiftListResp_List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGiftListResp_List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGiftListResp_List.Merge(dst, src)
}
func (m *RoomGiftListResp_List) XXX_Size() int {
	return m.Size()
}
func (m *RoomGiftListResp_List) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGiftListResp_List.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGiftListResp_List proto.InternalMessageInfo

type RoomGiftListResp_OldList struct {
	Id                   int64             `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Name                 string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Price                int64             `protobuf:"varint,3,opt,name=price,proto3" json:"price"`
	Type                 int64             `protobuf:"varint,4,opt,name=type,proto3" json:"type"`
	CoinType             map[string]string `protobuf:"bytes,5,rep,name=coin_type,json=coinType" json:"coin_type" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Img                  string            `protobuf:"bytes,6,opt,name=img,proto3" json:"img"`
	GiftUrl              string            `protobuf:"bytes,7,opt,name=gift_url,json=giftUrl,proto3" json:"gift_url"`
	CountSet             string            `protobuf:"bytes,8,opt,name=count_set,json=countSet,proto3" json:"count_set"`
	ComboNum             int64             `protobuf:"varint,9,opt,name=combo_num,json=comboNum,proto3" json:"combo_num"`
	SuperNum             int64             `protobuf:"varint,10,opt,name=super_num,json=superNum,proto3" json:"super_num"`
	CountMap             map[int64]string  `protobuf:"bytes,11,rep,name=count_map,json=countMap" json:"count_map" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RoomGiftListResp_OldList) Reset()         { *m = RoomGiftListResp_OldList{} }
func (m *RoomGiftListResp_OldList) String() string { return proto.CompactTextString(m) }
func (*RoomGiftListResp_OldList) ProtoMessage()    {}
func (*RoomGiftListResp_OldList) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{1, 1}
}
func (m *RoomGiftListResp_OldList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGiftListResp_OldList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGiftListResp_OldList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGiftListResp_OldList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGiftListResp_OldList.Merge(dst, src)
}
func (m *RoomGiftListResp_OldList) XXX_Size() int {
	return m.Size()
}
func (m *RoomGiftListResp_OldList) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGiftListResp_OldList.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGiftListResp_OldList proto.InternalMessageInfo

type GiftConfigReq struct {
	Platform             string   `protobuf:"bytes,1,opt,name=platform,proto3" json:"platform,omitempty"`
	Build                int64    `protobuf:"varint,2,opt,name=build,proto3" json:"build,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GiftConfigReq) Reset()         { *m = GiftConfigReq{} }
func (m *GiftConfigReq) String() string { return proto.CompactTextString(m) }
func (*GiftConfigReq) ProtoMessage()    {}
func (*GiftConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{2}
}
func (m *GiftConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiftConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiftConfigReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GiftConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiftConfigReq.Merge(dst, src)
}
func (m *GiftConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *GiftConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GiftConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_GiftConfigReq proto.InternalMessageInfo

type GiftConfigResp struct {
	Data                 []*GiftConfigResp_Config `protobuf:"bytes,1,rep,name=data" json:"data"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GiftConfigResp) Reset()         { *m = GiftConfigResp{} }
func (m *GiftConfigResp) String() string { return proto.CompactTextString(m) }
func (*GiftConfigResp) ProtoMessage()    {}
func (*GiftConfigResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{3}
}
func (m *GiftConfigResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiftConfigResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiftConfigResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GiftConfigResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiftConfigResp.Merge(dst, src)
}
func (m *GiftConfigResp) XXX_Size() int {
	return m.Size()
}
func (m *GiftConfigResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GiftConfigResp.DiscardUnknown(m)
}

var xxx_messageInfo_GiftConfigResp proto.InternalMessageInfo

type GiftConfigResp_Config struct {
	Id                   int64                      `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Name                 string                     `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Price                int64                      `protobuf:"varint,3,opt,name=price,proto3" json:"price"`
	Type                 int64                      `protobuf:"varint,4,opt,name=type,proto3" json:"type"`
	CoinType             string                     `protobuf:"bytes,5,opt,name=coin_type,json=coinType,proto3" json:"coin_type"`
	BagGift              int64                      `protobuf:"varint,6,opt,name=bag_gift,json=bagGift,proto3" json:"bag_gift"`
	Effect               int64                      `protobuf:"varint,7,opt,name=effect,proto3" json:"effect"`
	CornerMark           string                     `protobuf:"bytes,8,opt,name=corner_mark,json=cornerMark,proto3" json:"corner_mark"`
	Broadcast            int64                      `protobuf:"varint,9,opt,name=broadcast,proto3" json:"broadcast"`
	Draw                 int64                      `protobuf:"varint,10,opt,name=draw,proto3" json:"draw"`
	StayTime             int64                      `protobuf:"varint,11,opt,name=stay_time,json=stayTime,proto3" json:"stay_time"`
	AnimationFrameNum    int64                      `protobuf:"varint,12,opt,name=animation_frame_num,json=animationFrameNum,proto3" json:"animation_frame_num"`
	Desc                 string                     `protobuf:"bytes,13,opt,name=desc,proto3" json:"desc"`
	Rule                 string                     `protobuf:"bytes,14,opt,name=rule,proto3" json:"rule"`
	Rights               string                     `protobuf:"bytes,15,opt,name=rights,proto3" json:"rights"`
	PrivilegeRequired    int64                      `protobuf:"varint,16,opt,name=privilege_required,json=privilegeRequired,proto3" json:"privilege_required"`
	CountMap             []*GiftConfigResp_CountMap `protobuf:"bytes,17,rep,name=count_map,json=countMap" json:"count_map"`
	ImgBasic             string                     `protobuf:"bytes,18,opt,name=img_basic,json=imgBasic,proto3" json:"img_basic"`
	ImgDynamic           string                     `protobuf:"bytes,19,opt,name=img_dynamic,json=imgDynamic,proto3" json:"img_dynamic"`
	FrameAnimation       string                     `protobuf:"bytes,20,opt,name=frame_animation,json=frameAnimation,proto3" json:"frame_animation"`
	Gif                  string                     `protobuf:"bytes,21,opt,name=gif,proto3" json:"gif"`
	Webp                 string                     `protobuf:"bytes,22,opt,name=webp,proto3" json:"webp"`
	FullScWeb            string                     `protobuf:"bytes,23,opt,name=full_sc_web,json=fullScWeb,proto3" json:"full_sc_web"`
	FullScHorizontal     string                     `protobuf:"bytes,24,opt,name=full_sc_horizontal,json=fullScHorizontal,proto3" json:"full_sc_horizontal"`
	FullScVertical       string                     `protobuf:"bytes,25,opt,name=full_sc_vertical,json=fullScVertical,proto3" json:"full_sc_vertical"`
	FullScHorizontalSvga string                     `protobuf:"bytes,26,opt,name=full_sc_horizontal_svga,json=fullScHorizontalSvga,proto3" json:"full_sc_horizontal_svga"`
	FullScVerticalSvga   string                     `protobuf:"bytes,27,opt,name=full_sc_vertical_svga,json=fullScVerticalSvga,proto3" json:"full_sc_vertical_svga"`
	BulletHead           string                     `protobuf:"bytes,28,opt,name=bullet_head,json=bulletHead,proto3" json:"bullet_head"`
	BulletTail           string                     `protobuf:"bytes,29,opt,name=bullet_tail,json=bulletTail,proto3" json:"bullet_tail"`
	LimitInterval        int64                      `protobuf:"varint,30,opt,name=limit_interval,json=limitInterval,proto3" json:"limit_interval"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *GiftConfigResp_Config) Reset()         { *m = GiftConfigResp_Config{} }
func (m *GiftConfigResp_Config) String() string { return proto.CompactTextString(m) }
func (*GiftConfigResp_Config) ProtoMessage()    {}
func (*GiftConfigResp_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{3, 0}
}
func (m *GiftConfigResp_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiftConfigResp_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiftConfigResp_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GiftConfigResp_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiftConfigResp_Config.Merge(dst, src)
}
func (m *GiftConfigResp_Config) XXX_Size() int {
	return m.Size()
}
func (m *GiftConfigResp_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_GiftConfigResp_Config.DiscardUnknown(m)
}

var xxx_messageInfo_GiftConfigResp_Config proto.InternalMessageInfo

type GiftConfigResp_CountMap struct {
	Num                  int64    `protobuf:"varint,1,opt,name=num,proto3" json:"num"`
	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GiftConfigResp_CountMap) Reset()         { *m = GiftConfigResp_CountMap{} }
func (m *GiftConfigResp_CountMap) String() string { return proto.CompactTextString(m) }
func (*GiftConfigResp_CountMap) ProtoMessage()    {}
func (*GiftConfigResp_CountMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{3, 1}
}
func (m *GiftConfigResp_CountMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiftConfigResp_CountMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiftConfigResp_CountMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GiftConfigResp_CountMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiftConfigResp_CountMap.Merge(dst, src)
}
func (m *GiftConfigResp_CountMap) XXX_Size() int {
	return m.Size()
}
func (m *GiftConfigResp_CountMap) XXX_DiscardUnknown() {
	xxx_messageInfo_GiftConfigResp_CountMap.DiscardUnknown(m)
}

var xxx_messageInfo_GiftConfigResp_CountMap proto.InternalMessageInfo

type DiscountGiftListReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Roomid               int64    `protobuf:"varint,2,opt,name=roomid,proto3" json:"roomid,omitempty"`
	AreaV2ParentId       int64    `protobuf:"varint,3,opt,name=area_v2_parent_id,json=areaV2ParentId,proto3" json:"area_v2_parent_id,omitempty"`
	AreaV2Id             int64    `protobuf:"varint,4,opt,name=area_v2_id,json=areaV2Id,proto3" json:"area_v2_id,omitempty"`
	Platform             string   `protobuf:"bytes,5,opt,name=platform,proto3" json:"platform,omitempty"`
	Ruid                 int64    `protobuf:"varint,6,opt,name=ruid,proto3" json:"ruid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiscountGiftListReq) Reset()         { *m = DiscountGiftListReq{} }
func (m *DiscountGiftListReq) String() string { return proto.CompactTextString(m) }
func (*DiscountGiftListReq) ProtoMessage()    {}
func (*DiscountGiftListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{4}
}
func (m *DiscountGiftListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscountGiftListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscountGiftListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DiscountGiftListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscountGiftListReq.Merge(dst, src)
}
func (m *DiscountGiftListReq) XXX_Size() int {
	return m.Size()
}
func (m *DiscountGiftListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscountGiftListReq.DiscardUnknown(m)
}

var xxx_messageInfo_DiscountGiftListReq proto.InternalMessageInfo

type DiscountGiftListResp struct {
	DiscountList         []*DiscountGiftListResp_GiftInfo `protobuf:"bytes,1,rep,name=discount_list,json=discountList" json:"discount_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DiscountGiftListResp) Reset()         { *m = DiscountGiftListResp{} }
func (m *DiscountGiftListResp) String() string { return proto.CompactTextString(m) }
func (*DiscountGiftListResp) ProtoMessage()    {}
func (*DiscountGiftListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{5}
}
func (m *DiscountGiftListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscountGiftListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscountGiftListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DiscountGiftListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscountGiftListResp.Merge(dst, src)
}
func (m *DiscountGiftListResp) XXX_Size() int {
	return m.Size()
}
func (m *DiscountGiftListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscountGiftListResp.DiscardUnknown(m)
}

var xxx_messageInfo_DiscountGiftListResp proto.InternalMessageInfo

type DiscountGiftListResp_GiftInfo struct {
	GiftId               int64    `protobuf:"varint,1,opt,name=gift_id,json=giftId,proto3" json:"gift_id"`
	Price                int64    `protobuf:"varint,2,opt,name=price,proto3" json:"price"`
	DiscountPrice        int64    `protobuf:"varint,3,opt,name=discount_price,json=discountPrice,proto3" json:"discount_price"`
	CornerMark           string   `protobuf:"bytes,4,opt,name=corner_mark,json=cornerMark,proto3" json:"corner_mark"`
	CornerPosition       int64    `protobuf:"varint,5,opt,name=corner_position,json=cornerPosition,proto3" json:"corner_position"`
	CornerColor          string   `protobuf:"bytes,6,opt,name=corner_color,json=cornerColor,proto3" json:"corner_color"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiscountGiftListResp_GiftInfo) Reset()         { *m = DiscountGiftListResp_GiftInfo{} }
func (m *DiscountGiftListResp_GiftInfo) String() string { return proto.CompactTextString(m) }
func (*DiscountGiftListResp_GiftInfo) ProtoMessage()    {}
func (*DiscountGiftListResp_GiftInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{5, 0}
}
func (m *DiscountGiftListResp_GiftInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscountGiftListResp_GiftInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscountGiftListResp_GiftInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DiscountGiftListResp_GiftInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscountGiftListResp_GiftInfo.Merge(dst, src)
}
func (m *DiscountGiftListResp_GiftInfo) XXX_Size() int {
	return m.Size()
}
func (m *DiscountGiftListResp_GiftInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscountGiftListResp_GiftInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DiscountGiftListResp_GiftInfo proto.InternalMessageInfo

type DailyBagReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DailyBagReq) Reset()         { *m = DailyBagReq{} }
func (m *DailyBagReq) String() string { return proto.CompactTextString(m) }
func (*DailyBagReq) ProtoMessage()    {}
func (*DailyBagReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{6}
}
func (m *DailyBagReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagReq.Merge(dst, src)
}
func (m *DailyBagReq) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagReq.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagReq proto.InternalMessageInfo

type DailyBagResp struct {
	BagStatus            int64                   `protobuf:"varint,1,opt,name=bag_status,json=bagStatus,proto3" json:"bag_status"`
	BagExpireStatus      int64                   `protobuf:"varint,2,opt,name=bag_expire_status,json=bagExpireStatus,proto3" json:"bag_expire_status"`
	BagToast             *DailyBagResp_BagToast  `protobuf:"bytes,3,opt,name=bag_toast,json=bagToast" json:"bag_toast"`
	BagList              []*DailyBagResp_BagList `protobuf:"bytes,4,rep,name=bag_list,json=bagList" json:"bag_list"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *DailyBagResp) Reset()         { *m = DailyBagResp{} }
func (m *DailyBagResp) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp) ProtoMessage()    {}
func (*DailyBagResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{7}
}
func (m *DailyBagResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp.Merge(dst, src)
}
func (m *DailyBagResp) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp proto.InternalMessageInfo

type DailyBagResp_BagToast struct {
	ToastStatus          int64    `protobuf:"varint,1,opt,name=toast_status,json=toastStatus,proto3" json:"toast_status"`
	ToastMessage         string   `protobuf:"bytes,2,opt,name=toast_message,json=toastMessage,proto3" json:"toast_message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DailyBagResp_BagToast) Reset()         { *m = DailyBagResp_BagToast{} }
func (m *DailyBagResp_BagToast) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp_BagToast) ProtoMessage()    {}
func (*DailyBagResp_BagToast) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{7, 0}
}
func (m *DailyBagResp_BagToast) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp_BagToast) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp_BagToast.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp_BagToast) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp_BagToast.Merge(dst, src)
}
func (m *DailyBagResp_BagToast) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp_BagToast) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp_BagToast.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp_BagToast proto.InternalMessageInfo

type DailyBagResp_BagList struct {
	Type                 int64                            `protobuf:"varint,1,opt,name=type,proto3" json:"type"`
	BagName              string                           `protobuf:"bytes,2,opt,name=bag_name,json=bagName,proto3" json:"bag_name"`
	Source               *DailyBagResp_BagList_Source     `protobuf:"bytes,3,opt,name=source" json:"source"`
	GiftList             []*DailyBagResp_BagList_GiftList `protobuf:"bytes,4,rep,name=gift_list,json=giftList" json:"gift_list"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DailyBagResp_BagList) Reset()         { *m = DailyBagResp_BagList{} }
func (m *DailyBagResp_BagList) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp_BagList) ProtoMessage()    {}
func (*DailyBagResp_BagList) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{7, 1}
}
func (m *DailyBagResp_BagList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp_BagList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp_BagList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp_BagList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp_BagList.Merge(dst, src)
}
func (m *DailyBagResp_BagList) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp_BagList) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp_BagList.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp_BagList proto.InternalMessageInfo

type DailyBagResp_BagList_Source struct {
	MedalId              int64    `protobuf:"varint,1,opt,name=medal_id,json=medalId,proto3" json:"medal_id"`
	MedalName            string   `protobuf:"bytes,2,opt,name=medal_name,json=medalName,proto3" json:"medal_name"`
	Level                int64    `protobuf:"varint,3,opt,name=level,proto3" json:"level"`
	UserLevel            int64    `protobuf:"varint,4,opt,name=user_level,json=userLevel,proto3" json:"user_level"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DailyBagResp_BagList_Source) Reset()         { *m = DailyBagResp_BagList_Source{} }
func (m *DailyBagResp_BagList_Source) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp_BagList_Source) ProtoMessage()    {}
func (*DailyBagResp_BagList_Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{7, 1, 0}
}
func (m *DailyBagResp_BagList_Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp_BagList_Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp_BagList_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp_BagList_Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp_BagList_Source.Merge(dst, src)
}
func (m *DailyBagResp_BagList_Source) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp_BagList_Source) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp_BagList_Source.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp_BagList_Source proto.InternalMessageInfo

type DailyBagResp_BagList_GiftList struct {
	GiftId               string   `protobuf:"bytes,1,opt,name=gift_id,json=giftId,proto3" json:"gift_id"`
	GiftNum              int64    `protobuf:"varint,2,opt,name=gift_num,json=giftNum,proto3" json:"gift_num"`
	ExpireAt             int64    `protobuf:"varint,3,opt,name=expire_at,json=expireAt,proto3" json:"expire_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DailyBagResp_BagList_GiftList) Reset()         { *m = DailyBagResp_BagList_GiftList{} }
func (m *DailyBagResp_BagList_GiftList) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp_BagList_GiftList) ProtoMessage()    {}
func (*DailyBagResp_BagList_GiftList) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_1a46064cda2fcbfc, []int{7, 1, 1}
}
func (m *DailyBagResp_BagList_GiftList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp_BagList_GiftList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp_BagList_GiftList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp_BagList_GiftList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp_BagList_GiftList.Merge(dst, src)
}
func (m *DailyBagResp_BagList_GiftList) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp_BagList_GiftList) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp_BagList_GiftList.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp_BagList_GiftList proto.InternalMessageInfo

func init() {
	proto.RegisterType((*RoomGiftListReq)(nil), "live.xgift.v1.RoomGiftListReq")
	proto.RegisterType((*RoomGiftListResp)(nil), "live.xgift.v1.RoomGiftListResp")
	proto.RegisterType((*RoomGiftListResp_List)(nil), "live.xgift.v1.RoomGiftListResp.List")
	proto.RegisterType((*RoomGiftListResp_OldList)(nil), "live.xgift.v1.RoomGiftListResp.OldList")
	proto.RegisterMapType((map[string]string)(nil), "live.xgift.v1.RoomGiftListResp.OldList.CoinTypeEntry")
	proto.RegisterMapType((map[int64]string)(nil), "live.xgift.v1.RoomGiftListResp.OldList.CountMapEntry")
	proto.RegisterType((*GiftConfigReq)(nil), "live.xgift.v1.GiftConfigReq")
	proto.RegisterType((*GiftConfigResp)(nil), "live.xgift.v1.GiftConfigResp")
	proto.RegisterType((*GiftConfigResp_Config)(nil), "live.xgift.v1.GiftConfigResp.Config")
	proto.RegisterType((*GiftConfigResp_CountMap)(nil), "live.xgift.v1.GiftConfigResp.CountMap")
	proto.RegisterType((*DiscountGiftListReq)(nil), "live.xgift.v1.DiscountGiftListReq")
	proto.RegisterType((*DiscountGiftListResp)(nil), "live.xgift.v1.DiscountGiftListResp")
	proto.RegisterType((*DiscountGiftListResp_GiftInfo)(nil), "live.xgift.v1.DiscountGiftListResp.GiftInfo")
	proto.RegisterType((*DailyBagReq)(nil), "live.xgift.v1.DailyBagReq")
	proto.RegisterType((*DailyBagResp)(nil), "live.xgift.v1.DailyBagResp")
	proto.RegisterType((*DailyBagResp_BagToast)(nil), "live.xgift.v1.DailyBagResp.BagToast")
	proto.RegisterType((*DailyBagResp_BagList)(nil), "live.xgift.v1.DailyBagResp.BagList")
	proto.RegisterType((*DailyBagResp_BagList_Source)(nil), "live.xgift.v1.DailyBagResp.BagList.Source")
	proto.RegisterType((*DailyBagResp_BagList_GiftList)(nil), "live.xgift.v1.DailyBagResp.BagList.GiftList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GiftClient is the client API for Gift service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GiftClient interface {
	RoomGiftList(ctx context.Context, in *RoomGiftListReq, opts ...grpc.CallOption) (*RoomGiftListResp, error)
	GiftConfig(ctx context.Context, in *GiftConfigReq, opts ...grpc.CallOption) (*GiftConfigResp, error)
	DiscountGiftList(ctx context.Context, in *DiscountGiftListReq, opts ...grpc.CallOption) (*DiscountGiftListResp, error)
	DailyBag(ctx context.Context, in *DailyBagReq, opts ...grpc.CallOption) (*DailyBagResp, error)
}

type giftClient struct {
	cc *grpc.ClientConn
}

func NewGiftClient(cc *grpc.ClientConn) GiftClient {
	return &giftClient{cc}
}

func (c *giftClient) RoomGiftList(ctx context.Context, in *RoomGiftListReq, opts ...grpc.CallOption) (*RoomGiftListResp, error) {
	out := new(RoomGiftListResp)
	err := c.cc.Invoke(ctx, "/live.xgift.v1.Gift/room_gift_list", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *giftClient) GiftConfig(ctx context.Context, in *GiftConfigReq, opts ...grpc.CallOption) (*GiftConfigResp, error) {
	out := new(GiftConfigResp)
	err := c.cc.Invoke(ctx, "/live.xgift.v1.Gift/gift_config", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *giftClient) DiscountGiftList(ctx context.Context, in *DiscountGiftListReq, opts ...grpc.CallOption) (*DiscountGiftListResp, error) {
	out := new(DiscountGiftListResp)
	err := c.cc.Invoke(ctx, "/live.xgift.v1.Gift/discount_gift_list", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *giftClient) DailyBag(ctx context.Context, in *DailyBagReq, opts ...grpc.CallOption) (*DailyBagResp, error) {
	out := new(DailyBagResp)
	err := c.cc.Invoke(ctx, "/live.xgift.v1.Gift/daily_bag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GiftServer is the server API for Gift service.
type GiftServer interface {
	RoomGiftList(context.Context, *RoomGiftListReq) (*RoomGiftListResp, error)
	GiftConfig(context.Context, *GiftConfigReq) (*GiftConfigResp, error)
	DiscountGiftList(context.Context, *DiscountGiftListReq) (*DiscountGiftListResp, error)
	DailyBag(context.Context, *DailyBagReq) (*DailyBagResp, error)
}

func RegisterGiftServer(s *grpc.Server, srv GiftServer) {
	s.RegisterService(&_Gift_serviceDesc, srv)
}

func _Gift_RoomGiftList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomGiftListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GiftServer).RoomGiftList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xgift.v1.Gift/RoomGiftList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GiftServer).RoomGiftList(ctx, req.(*RoomGiftListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gift_GiftConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GiftConfigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GiftServer).GiftConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xgift.v1.Gift/GiftConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GiftServer).GiftConfig(ctx, req.(*GiftConfigReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gift_DiscountGiftList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscountGiftListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GiftServer).DiscountGiftList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xgift.v1.Gift/DiscountGiftList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GiftServer).DiscountGiftList(ctx, req.(*DiscountGiftListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gift_DailyBag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DailyBagReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GiftServer).DailyBag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xgift.v1.Gift/DailyBag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GiftServer).DailyBag(ctx, req.(*DailyBagReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gift_serviceDesc = grpc.ServiceDesc{
	ServiceName: "live.xgift.v1.Gift",
	HandlerType: (*GiftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "room_gift_list",
			Handler:    _Gift_RoomGiftList_Handler,
		},
		{
			MethodName: "gift_config",
			Handler:    _Gift_GiftConfig_Handler,
		},
		{
			MethodName: "discount_gift_list",
			Handler:    _Gift_DiscountGiftList_Handler,
		},
		{
			MethodName: "daily_bag",
			Handler:    _Gift_DailyBag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/live/gift/api/grpc/v1/api.proto",
}

func (m *RoomGiftListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGiftListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.AreaV2ParentId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaV2ParentId))
	}
	if m.AreaV2Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaV2Id))
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.Build != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Build))
	}
	if len(m.MobiApp) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MobiApp)))
		i += copy(dAtA[i:], m.MobiApp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomGiftListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGiftListResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SilverList) > 0 {
		for _, msg := range m.SilverList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ShowCountMap != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShowCountMap))
	}
	if len(m.OldList) > 0 {
		for _, msg := range m.OldList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomGiftListResp_List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGiftListResp_List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if m.Position != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Position))
	}
	if m.PlanId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlanId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomGiftListResp_OldList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGiftListResp_OldList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Price != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Price))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.CoinType) > 0 {
		for k, _ := range m.CoinType {
			dAtA[i] = 0x2a
			i++
			v := m.CoinType[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Img) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Img)))
		i += copy(dAtA[i:], m.Img)
	}
	if len(m.GiftUrl) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.GiftUrl)))
		i += copy(dAtA[i:], m.GiftUrl)
	}
	if len(m.CountSet) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CountSet)))
		i += copy(dAtA[i:], m.CountSet)
	}
	if m.ComboNum != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ComboNum))
	}
	if m.SuperNum != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SuperNum))
	}
	if len(m.CountMap) > 0 {
		for k, _ := range m.CountMap {
			dAtA[i] = 0x5a
			i++
			v := m.CountMap[k]
			mapSize := 1 + sovApi(uint64(k)) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GiftConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftConfigReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Platform) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.Build != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Build))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GiftConfigResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftConfigResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GiftConfigResp_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftConfigResp_Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Price != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Price))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.CoinType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CoinType)))
		i += copy(dAtA[i:], m.CoinType)
	}
	if m.BagGift != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BagGift))
	}
	if m.Effect != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Effect))
	}
	if len(m.CornerMark) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CornerMark)))
		i += copy(dAtA[i:], m.CornerMark)
	}
	if m.Broadcast != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Broadcast))
	}
	if m.Draw != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Draw))
	}
	if m.StayTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.StayTime))
	}
	if m.AnimationFrameNum != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnimationFrameNum))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Rule) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Rule)))
		i += copy(dAtA[i:], m.Rule)
	}
	if len(m.Rights) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Rights)))
		i += copy(dAtA[i:], m.Rights)
	}
	if m.PrivilegeRequired != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PrivilegeRequired))
	}
	if len(m.CountMap) > 0 {
		for _, msg := range m.CountMap {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImgBasic) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ImgBasic)))
		i += copy(dAtA[i:], m.ImgBasic)
	}
	if len(m.ImgDynamic) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ImgDynamic)))
		i += copy(dAtA[i:], m.ImgDynamic)
	}
	if len(m.FrameAnimation) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FrameAnimation)))
		i += copy(dAtA[i:], m.FrameAnimation)
	}
	if len(m.Gif) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Gif)))
		i += copy(dAtA[i:], m.Gif)
	}
	if len(m.Webp) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Webp)))
		i += copy(dAtA[i:], m.Webp)
	}
	if len(m.FullScWeb) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FullScWeb)))
		i += copy(dAtA[i:], m.FullScWeb)
	}
	if len(m.FullScHorizontal) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FullScHorizontal)))
		i += copy(dAtA[i:], m.FullScHorizontal)
	}
	if len(m.FullScVertical) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FullScVertical)))
		i += copy(dAtA[i:], m.FullScVertical)
	}
	if len(m.FullScHorizontalSvga) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FullScHorizontalSvga)))
		i += copy(dAtA[i:], m.FullScHorizontalSvga)
	}
	if len(m.FullScVerticalSvga) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.FullScVerticalSvga)))
		i += copy(dAtA[i:], m.FullScVerticalSvga)
	}
	if len(m.BulletHead) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.BulletHead)))
		i += copy(dAtA[i:], m.BulletHead)
	}
	if len(m.BulletTail) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.BulletTail)))
		i += copy(dAtA[i:], m.BulletTail)
	}
	if m.LimitInterval != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LimitInterval))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GiftConfigResp_CountMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftConfigResp_CountMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Num))
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DiscountGiftListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscountGiftListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.Roomid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Roomid))
	}
	if m.AreaV2ParentId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaV2ParentId))
	}
	if m.AreaV2Id != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaV2Id))
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.Ruid != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ruid))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DiscountGiftListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscountGiftListResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DiscountList) > 0 {
		for _, msg := range m.DiscountList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DiscountGiftListResp_GiftInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscountGiftListResp_GiftInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GiftId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftId))
	}
	if m.Price != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Price))
	}
	if m.DiscountPrice != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DiscountPrice))
	}
	if len(m.CornerMark) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CornerMark)))
		i += copy(dAtA[i:], m.CornerMark)
	}
	if m.CornerPosition != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CornerPosition))
	}
	if len(m.CornerColor) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.CornerColor)))
		i += copy(dAtA[i:], m.CornerColor)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BagStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BagStatus))
	}
	if m.BagExpireStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BagExpireStatus))
	}
	if m.BagToast != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.BagToast.Size()))
		n1, err := m.BagToast.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.BagList) > 0 {
		for _, msg := range m.BagList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp_BagToast) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp_BagToast) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ToastStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ToastStatus))
	}
	if len(m.ToastMessage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ToastMessage)))
		i += copy(dAtA[i:], m.ToastMessage)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp_BagList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp_BagList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Type))
	}
	if len(m.BagName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.BagName)))
		i += copy(dAtA[i:], m.BagName)
	}
	if m.Source != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Source.Size()))
		n2, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.GiftList) > 0 {
		for _, msg := range m.GiftList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp_BagList_Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp_BagList_Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MedalId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MedalId))
	}
	if len(m.MedalName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.MedalName)))
		i += copy(dAtA[i:], m.MedalName)
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Level))
	}
	if m.UserLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.UserLevel))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp_BagList_GiftList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp_BagList_GiftList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GiftId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.GiftId)))
		i += copy(dAtA[i:], m.GiftId)
	}
	if m.GiftNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftNum))
	}
	if m.ExpireAt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ExpireAt))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RoomGiftListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.AreaV2ParentId != 0 {
		n += 1 + sovApi(uint64(m.AreaV2ParentId))
	}
	if m.AreaV2Id != 0 {
		n += 1 + sovApi(uint64(m.AreaV2Id))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Build != 0 {
		n += 1 + sovApi(uint64(m.Build))
	}
	l = len(m.MobiApp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomGiftListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.SilverList) > 0 {
		for _, e := range m.SilverList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.ShowCountMap != 0 {
		n += 1 + sovApi(uint64(m.ShowCountMap))
	}
	if len(m.OldList) > 0 {
		for _, e := range m.OldList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomGiftListResp_List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Position != 0 {
		n += 1 + sovApi(uint64(m.Position))
	}
	if m.PlanId != 0 {
		n += 1 + sovApi(uint64(m.PlanId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomGiftListResp_OldList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovApi(uint64(m.Price))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	if len(m.CoinType) > 0 {
		for k, v := range m.CoinType {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Img)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GiftUrl)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CountSet)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ComboNum != 0 {
		n += 1 + sovApi(uint64(m.ComboNum))
	}
	if m.SuperNum != 0 {
		n += 1 + sovApi(uint64(m.SuperNum))
	}
	if len(m.CountMap) > 0 {
		for k, v := range m.CountMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovApi(uint64(k)) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GiftConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Build != 0 {
		n += 1 + sovApi(uint64(m.Build))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GiftConfigResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GiftConfigResp_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovApi(uint64(m.Price))
	}
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.CoinType)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BagGift != 0 {
		n += 1 + sovApi(uint64(m.BagGift))
	}
	if m.Effect != 0 {
		n += 1 + sovApi(uint64(m.Effect))
	}
	l = len(m.CornerMark)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Broadcast != 0 {
		n += 1 + sovApi(uint64(m.Broadcast))
	}
	if m.Draw != 0 {
		n += 1 + sovApi(uint64(m.Draw))
	}
	if m.StayTime != 0 {
		n += 1 + sovApi(uint64(m.StayTime))
	}
	if m.AnimationFrameNum != 0 {
		n += 1 + sovApi(uint64(m.AnimationFrameNum))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Rule)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Rights)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.PrivilegeRequired != 0 {
		n += 2 + sovApi(uint64(m.PrivilegeRequired))
	}
	if len(m.CountMap) > 0 {
		for _, e := range m.CountMap {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	l = len(m.ImgBasic)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.ImgDynamic)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.FrameAnimation)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Gif)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Webp)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.FullScWeb)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.FullScHorizontal)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.FullScVertical)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.FullScHorizontalSvga)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.FullScVerticalSvga)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.BulletHead)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.BulletTail)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.LimitInterval != 0 {
		n += 2 + sovApi(uint64(m.LimitInterval))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GiftConfigResp_CountMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovApi(uint64(m.Num))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiscountGiftListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.Roomid != 0 {
		n += 1 + sovApi(uint64(m.Roomid))
	}
	if m.AreaV2ParentId != 0 {
		n += 1 + sovApi(uint64(m.AreaV2ParentId))
	}
	if m.AreaV2Id != 0 {
		n += 1 + sovApi(uint64(m.AreaV2Id))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Ruid != 0 {
		n += 1 + sovApi(uint64(m.Ruid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiscountGiftListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DiscountList) > 0 {
		for _, e := range m.DiscountList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiscountGiftListResp_GiftInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GiftId != 0 {
		n += 1 + sovApi(uint64(m.GiftId))
	}
	if m.Price != 0 {
		n += 1 + sovApi(uint64(m.Price))
	}
	if m.DiscountPrice != 0 {
		n += 1 + sovApi(uint64(m.DiscountPrice))
	}
	l = len(m.CornerMark)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CornerPosition != 0 {
		n += 1 + sovApi(uint64(m.CornerPosition))
	}
	l = len(m.CornerColor)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BagStatus != 0 {
		n += 1 + sovApi(uint64(m.BagStatus))
	}
	if m.BagExpireStatus != 0 {
		n += 1 + sovApi(uint64(m.BagExpireStatus))
	}
	if m.BagToast != nil {
		l = m.BagToast.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.BagList) > 0 {
		for _, e := range m.BagList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp_BagToast) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToastStatus != 0 {
		n += 1 + sovApi(uint64(m.ToastStatus))
	}
	l = len(m.ToastMessage)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp_BagList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApi(uint64(m.Type))
	}
	l = len(m.BagName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.GiftList) > 0 {
		for _, e := range m.GiftList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp_BagList_Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MedalId != 0 {
		n += 1 + sovApi(uint64(m.MedalId))
	}
	l = len(m.MedalName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovApi(uint64(m.Level))
	}
	if m.UserLevel != 0 {
		n += 1 + sovApi(uint64(m.UserLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp_BagList_GiftList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GiftId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.GiftNum != 0 {
		n += 1 + sovApi(uint64(m.GiftNum))
	}
	if m.ExpireAt != 0 {
		n += 1 + sovApi(uint64(m.ExpireAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RoomGiftListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomGiftListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomGiftListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2ParentId", wireType)
			}
			m.AreaV2ParentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2ParentId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2Id", wireType)
			}
			m.AreaV2Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobiApp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MobiApp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomGiftListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomGiftListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomGiftListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RoomGiftListResp_List{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SilverList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SilverList = append(m.SilverList, &RoomGiftListResp_List{})
			if err := m.SilverList[len(m.SilverList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowCountMap", wireType)
			}
			m.ShowCountMap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowCountMap |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldList = append(m.OldList, &RoomGiftListResp_OldList{})
			if err := m.OldList[len(m.OldList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomGiftListResp_List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanId", wireType)
			}
			m.PlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomGiftListResp_OldList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OldList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OldList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinType == nil {
				m.CoinType = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CoinType[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Img = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountSet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountSet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComboNum", wireType)
			}
			m.ComboNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComboNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuperNum", wireType)
			}
			m.SuperNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuperNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CountMap == nil {
				m.CountMap = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CountMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftConfigResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftConfigResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftConfigResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &GiftConfigResp_Config{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftConfigResp_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagGift", wireType)
			}
			m.BagGift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagGift |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			m.Effect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Effect |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CornerMark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CornerMark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Broadcast", wireType)
			}
			m.Broadcast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Broadcast |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draw", wireType)
			}
			m.Draw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Draw |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StayTime", wireType)
			}
			m.StayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StayTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnimationFrameNum", wireType)
			}
			m.AnimationFrameNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnimationFrameNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rights = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeRequired", wireType)
			}
			m.PrivilegeRequired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivilegeRequired |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountMap = append(m.CountMap, &GiftConfigResp_CountMap{})
			if err := m.CountMap[len(m.CountMap)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImgBasic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImgBasic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImgDynamic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImgDynamic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameAnimation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameAnimation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gif", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gif = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Webp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScWeb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScWeb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScHorizontal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScHorizontal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScVertical", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScVertical = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScHorizontalSvga", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScHorizontalSvga = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScVerticalSvga", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScVerticalSvga = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletHead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BulletHead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletTail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BulletTail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitInterval", wireType)
			}
			m.LimitInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitInterval |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftConfigResp_CountMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscountGiftListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscountGiftListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscountGiftListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2ParentId", wireType)
			}
			m.AreaV2ParentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2ParentId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2Id", wireType)
			}
			m.AreaV2Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ruid", wireType)
			}
			m.Ruid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ruid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscountGiftListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscountGiftListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscountGiftListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiscountList = append(m.DiscountList, &DiscountGiftListResp_GiftInfo{})
			if err := m.DiscountList[len(m.DiscountList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscountGiftListResp_GiftInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftId", wireType)
			}
			m.GiftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountPrice", wireType)
			}
			m.DiscountPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountPrice |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CornerMark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CornerMark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CornerPosition", wireType)
			}
			m.CornerPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CornerPosition |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CornerColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CornerColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyBagReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyBagReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyBagResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyBagResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagStatus", wireType)
			}
			m.BagStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagExpireStatus", wireType)
			}
			m.BagExpireStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagExpireStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagToast", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BagToast == nil {
				m.BagToast = &DailyBagResp_BagToast{}
			}
			if err := m.BagToast.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BagList = append(m.BagList, &DailyBagResp_BagList{})
			if err := m.BagList[len(m.BagList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp_BagToast) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BagToast: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BagToast: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToastStatus", wireType)
			}
			m.ToastStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToastStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToastMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToastMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp_BagList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BagList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BagList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &DailyBagResp_BagList_Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftList = append(m.GiftList, &DailyBagResp_BagList_GiftList{})
			if err := m.GiftList[len(m.GiftList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp_BagList_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedalId", wireType)
			}
			m.MedalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedalId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MedalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserLevel", wireType)
			}
			m.UserLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserLevel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp_BagList_GiftList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftNum", wireType)
			}
			m.GiftNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireAt", wireType)
			}
			m.ExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/live/gift/api/grpc/v1/api.proto", fileDescriptor_api_1a46064cda2fcbfc)
}

var fileDescriptor_api_1a46064cda2fcbfc = []byte{
	// 1934 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x5f, 0x6f, 0x1b, 0xc7,
	0x11, 0x2f, 0x49, 0x89, 0x7f, 0x86, 0x12, 0x25, 0xad, 0x65, 0xfb, 0x4c, 0x3b, 0x3a, 0x83, 0x09,
	0x6a, 0xd7, 0x49, 0xa8, 0xd8, 0x41, 0x8b, 0xa4, 0x0d, 0x0a, 0x98, 0xb6, 0x9b, 0xa8, 0xb0, 0x5d,
	0x67, 0xed, 0xba, 0x45, 0x81, 0xe2, 0xb0, 0xe4, 0x2d, 0xcf, 0x0b, 0xdf, 0xf1, 0x4e, 0x77, 0x47,
	0xca, 0xea, 0x7b, 0xfb, 0x2d, 0xfa, 0x1d, 0x52, 0x14, 0x05, 0xfa, 0xd8, 0xc7, 0xa0, 0xe8, 0x43,
	0xfb, 0x05, 0x0e, 0xad, 0x1f, 0xef, 0x53, 0x14, 0x33, 0x7b, 0xff, 0x48, 0x49, 0x96, 0xf2, 0x94,
	0x97, 0xe5, 0xcc, 0x6f, 0x66, 0x76, 0xe7, 0x66, 0x67, 0x67, 0x67, 0x09, 0x1f, 0x8a, 0x20, 0xd8,
	0x8f, 0x64, 0xb8, 0x50, 0x13, 0xb9, 0xef, 0xaa, 0x85, 0xdc, 0x77, 0xd4, 0x34, 0xde, 0x17, 0x81,
	0xda, 0x77, 0xc2, 0x60, 0xb2, 0xbf, 0xb8, 0x8b, 0xf4, 0x30, 0x08, 0xfd, 0xd8, 0x67, 0x9b, 0xa8,
	0x30, 0x7c, 0x83, 0x1a, 0xc3, 0xc5, 0xdd, 0xfe, 0xc7, 0x8e, 0x8a, 0x5f, 0xcd, 0xc7, 0xc3, 0x89,
	0xef, 0xed, 0x3b, 0xbe, 0xe3, 0xef, 0x93, 0xd6, 0x78, 0x3e, 0x25, 0x8e, 0x18, 0xa2, 0xb4, 0xf5,
	0xe0, 0x1f, 0x35, 0xd8, 0xe2, 0xbe, 0xef, 0x7d, 0xa9, 0xa6, 0xf1, 0x63, 0x15, 0xc5, 0x5c, 0x1e,
	0xb2, 0xab, 0xd0, 0x0a, 0x7d, 0xdf, 0xb3, 0x94, 0x6d, 0xd4, 0x6e, 0xd6, 0x6e, 0x37, 0x78, 0x13,
	0xd9, 0x03, 0x9b, 0xfd, 0x08, 0x76, 0x44, 0x28, 0x85, 0xb5, 0xb8, 0x67, 0x05, 0x22, 0x94, 0xb3,
	0x18, 0x55, 0xea, 0xa4, 0xd2, 0x43, 0xc1, 0xcb, 0x7b, 0xcf, 0x08, 0x3e, 0xb0, 0xd9, 0x0d, 0x80,
	0x5c, 0x55, 0xd9, 0x46, 0x83, 0x74, 0xda, 0x5a, 0xe7, 0xc0, 0x66, 0x7d, 0x68, 0x07, 0xae, 0x88,
	0xa7, 0x7e, 0xe8, 0x19, 0x6b, 0x37, 0x6b, 0xb7, 0x3b, 0xbc, 0xe0, 0xd9, 0x2e, 0xac, 0x8f, 0xe7,
	0xca, 0xb5, 0x8d, 0x75, 0x32, 0xd2, 0x0c, 0xbb, 0x06, 0x6d, 0xcf, 0x1f, 0x2b, 0x4b, 0x04, 0x81,
	0xd1, 0x24, 0x8b, 0x16, 0xf2, 0xf7, 0x83, 0x60, 0xf0, 0xd7, 0x36, 0x6c, 0x2f, 0x7f, 0x42, 0x14,
	0xb0, 0x11, 0xac, 0xb9, 0x2a, 0x8a, 0x8d, 0xda, 0xcd, 0xc6, 0xed, 0xee, 0xbd, 0x0f, 0x86, 0x4b,
	0x41, 0x1a, 0xae, 0xaa, 0x0f, 0x91, 0x18, 0xb5, 0xd3, 0xc4, 0x24, 0x2b, 0x4e, 0x23, 0x7b, 0x09,
	0xdd, 0x48, 0xb9, 0x0b, 0x19, 0x5a, 0x34, 0x55, 0xfd, 0x3b, 0x4c, 0xb5, 0x95, 0x26, 0x66, 0xd5,
	0x98, 0x83, 0x66, 0x50, 0xc8, 0x3e, 0x83, 0x5e, 0xf4, 0xca, 0x3f, 0xb2, 0x26, 0xfe, 0x7c, 0x16,
	0x5b, 0x9e, 0x08, 0x74, 0x7c, 0x46, 0x2c, 0x4d, 0xcc, 0x15, 0x09, 0xdf, 0x40, 0xfe, 0x01, 0xb2,
	0x4f, 0x44, 0xc0, 0x9e, 0x41, 0xdb, 0x77, 0x6d, 0xed, 0xce, 0x1a, 0xb9, 0x73, 0xeb, 0x3c, 0x77,
	0x7e, 0xe5, 0xda, 0xe4, 0xd1, 0x46, 0x9a, 0x98, 0x85, 0x31, 0x6f, 0xf9, 0x1a, 0xee, 0xcf, 0x60,
	0x8d, 0x7c, 0xba, 0x02, 0xf5, 0x7c, 0xbb, 0x47, 0xcd, 0x34, 0x31, 0xeb, 0xca, 0xe6, 0x75, 0x65,
	0xb3, 0xdb, 0xd0, 0x0e, 0xfc, 0x48, 0xc5, 0xca, 0x9f, 0xe9, 0x9d, 0xd6, 0x13, 0xe5, 0x18, 0x2f,
	0x28, 0xf6, 0x01, 0xb4, 0x02, 0x57, 0xcc, 0x8a, 0xed, 0x1e, 0x75, 0xd3, 0xc4, 0xcc, 0x21, 0xde,
	0x44, 0xe2, 0xc0, 0xee, 0xff, 0x69, 0x1d, 0x5a, 0x99, 0x4b, 0x67, 0xae, 0x79, 0x03, 0xd6, 0x66,
	0xc2, 0x93, 0xb4, 0x5e, 0x47, 0xef, 0x0a, 0xf2, 0x9c, 0x46, 0x66, 0xc2, 0x7a, 0x10, 0xaa, 0x89,
	0xcc, 0x56, 0xe9, 0xa4, 0x89, 0xa9, 0x01, 0xae, 0x7f, 0xd0, 0x3c, 0x3e, 0x0e, 0x24, 0x25, 0x56,
	0x43, 0x9b, 0x23, 0xcf, 0x69, 0x64, 0x02, 0x3a, 0x13, 0x5f, 0xcd, 0x2c, 0x52, 0x59, 0xa7, 0x18,
	0xfe, 0xf8, 0x82, 0x31, 0x1c, 0x3e, 0xf0, 0xd5, 0xec, 0xc5, 0x71, 0x20, 0x1f, 0xcd, 0xe2, 0xf0,
	0x78, 0xb4, 0x99, 0x26, 0x66, 0x39, 0x17, 0x6f, 0x4f, 0x32, 0x29, 0xbb, 0x06, 0x0d, 0xe5, 0x39,
	0x3a, 0x4d, 0x47, 0xad, 0x34, 0x31, 0x91, 0xe5, 0x38, 0xb0, 0x5b, 0xd0, 0xc6, 0x55, 0xac, 0x79,
	0xe8, 0x1a, 0x2d, 0x92, 0x53, 0x38, 0x73, 0x8c, 0xb7, 0x90, 0xfa, 0x75, 0xe8, 0xb2, 0x3b, 0xe8,
	0x26, 0x26, 0x41, 0x24, 0x63, 0xa3, 0x4d, 0x9a, 0xd9, 0x7a, 0x19, 0x88, 0xeb, 0xcd, 0x67, 0xf1,
	0x73, 0x19, 0x6b, 0x5d, 0x6f, 0xec, 0x5b, 0xb3, 0xb9, 0x67, 0x74, 0xe8, 0xab, 0x33, 0xdd, 0x0c,
	0x44, 0x5d, 0x6f, 0xec, 0x3f, 0x9d, 0x7b, 0xa8, 0x1b, 0xcd, 0x03, 0x19, 0x92, 0x2e, 0x94, 0xba,
	0x05, 0xc8, 0xdb, 0x44, 0xa2, 0xae, 0xc8, 0x7d, 0xc0, 0x14, 0xed, 0x7e, 0xd7, 0x50, 0xe9, 0x94,
	0x5d, 0x0a, 0x55, 0x9e, 0xd4, 0xda, 0xf5, 0x27, 0x22, 0xe8, 0xff, 0x0c, 0x36, 0x97, 0x82, 0xca,
	0xb6, 0xa1, 0xf1, 0x5a, 0x1e, 0x53, 0x52, 0x74, 0x38, 0x92, 0x58, 0x0f, 0x16, 0xc2, 0x9d, 0x67,
	0xe9, 0xc0, 0x35, 0xf3, 0xd3, 0xfa, 0x67, 0x35, 0x6d, 0x5c, 0x59, 0xa6, 0x6a, 0xdc, 0x38, 0xc7,
	0x78, 0x70, 0x1f, 0x36, 0xd1, 0xf1, 0x07, 0xfe, 0x6c, 0xaa, 0x1c, 0xac, 0x7a, 0xd5, 0x9a, 0x54,
	0x3b, 0xab, 0x26, 0xd5, 0x2b, 0x35, 0x69, 0xf0, 0xaf, 0x0d, 0xe8, 0x55, 0xe7, 0xd0, 0x65, 0xc7,
	0x16, 0xb1, 0x38, 0xa3, 0xec, 0x2c, 0x2b, 0x0f, 0x35, 0xa9, 0x33, 0x14, 0xad, 0x38, 0x8d, 0xfd,
	0x6f, 0xba, 0xd0, 0xd4, 0xa2, 0xef, 0xe7, 0x84, 0xdc, 0x59, 0x3e, 0x21, 0x95, 0xd4, 0x3b, 0x99,
	0xea, 0xb7, 0xa0, 0x3d, 0x16, 0x8e, 0x85, 0x1f, 0x48, 0xf9, 0x9e, 0x95, 0x87, 0x1c, 0xe3, 0xad,
	0xb1, 0x70, 0xf0, 0xab, 0xd9, 0x00, 0x9a, 0x72, 0x3a, 0x95, 0x93, 0x98, 0xd2, 0xbe, 0x31, 0x82,
	0x34, 0x31, 0x33, 0x84, 0x67, 0xbf, 0xec, 0x13, 0xe8, 0x4e, 0xfc, 0x70, 0x26, 0x43, 0xcb, 0x13,
	0xe1, 0xeb, 0x2c, 0xeb, 0xa9, 0x92, 0x56, 0x60, 0x0e, 0x9a, 0x79, 0x22, 0xc2, 0xd7, 0xec, 0x43,
	0xe8, 0x8c, 0x43, 0x5f, 0xd8, 0x13, 0x11, 0xc5, 0xd5, 0xcc, 0x2f, 0x40, 0x5e, 0x92, 0xf8, 0xd5,
	0x76, 0x28, 0x8e, 0xb2, 0xac, 0xd7, 0x51, 0x0f, 0xc5, 0x11, 0xa7, 0x91, 0x0e, 0x46, 0x2c, 0x8e,
	0xad, 0x58, 0x79, 0xd2, 0xe8, 0x56, 0x0e, 0x46, 0x0e, 0xf2, 0x36, 0x92, 0x2f, 0x94, 0x27, 0xd9,
	0x97, 0x70, 0x49, 0xcc, 0x94, 0x27, 0xb0, 0xee, 0x59, 0xd3, 0x50, 0x78, 0x92, 0x8e, 0xd3, 0x06,
	0x59, 0x5d, 0x4d, 0x13, 0xf3, 0x34, 0x31, 0xdf, 0x29, 0xc0, 0x5f, 0x20, 0x86, 0x27, 0x0c, 0x5d,
	0x92, 0xd1, 0xc4, 0xd8, 0x2c, 0xf7, 0x11, 0x79, 0x4e, 0x23, 0x4a, 0xc3, 0xb9, 0x2b, 0x8d, 0x5e,
	0x29, 0x45, 0x9e, 0xd3, 0x88, 0x11, 0x0d, 0x95, 0xf3, 0x2a, 0x8e, 0x8c, 0x2d, 0x92, 0x53, 0x44,
	0x35, 0xc2, 0xb3, 0x5f, 0xf6, 0x08, 0x58, 0x10, 0xaa, 0x85, 0x72, 0xa5, 0x23, 0xad, 0x50, 0x1e,
	0xce, 0x55, 0x28, 0x6d, 0x63, 0x9b, 0xfc, 0xbc, 0x92, 0x26, 0xe6, 0x29, 0x52, 0xbe, 0x53, 0x60,
	0x3c, 0x83, 0x18, 0xaf, 0x16, 0x82, 0x1d, 0x4a, 0xed, 0x1f, 0x9e, 0x97, 0xda, 0xfa, 0x5c, 0x9e,
	0x79, 0xf2, 0x31, 0xde, 0xca, 0x73, 0xac, 0xb1, 0x88, 0xd4, 0xc4, 0x60, 0x65, 0x96, 0x15, 0x20,
	0x6f, 0x2b, 0xcf, 0x19, 0x21, 0x85, 0x89, 0x81, 0xb0, 0x7d, 0x3c, 0x13, 0x9e, 0x9a, 0x18, 0x97,
	0xca, 0xc4, 0xa8, 0xc0, 0x1c, 0x94, 0xe7, 0x3c, 0xd4, 0x34, 0xfb, 0x02, 0xb6, 0x74, 0xe0, 0x8b,
	0x98, 0x1b, 0xbb, 0x64, 0x75, 0x29, 0x4d, 0xcc, 0x55, 0x11, 0xef, 0x11, 0x70, 0x3f, 0xe7, 0xb1,
	0x80, 0x3b, 0x6a, 0x6a, 0x5c, 0x2e, 0x0b, 0xb8, 0xa3, 0xa6, 0x1c, 0x07, 0xdc, 0x93, 0x23, 0x39,
	0x0e, 0x8c, 0x2b, 0xe5, 0x9e, 0x20, 0xcf, 0x69, 0x64, 0xfb, 0xd0, 0x9d, 0xce, 0x5d, 0xd7, 0x8a,
	0x26, 0xd6, 0x91, 0x1c, 0x1b, 0x57, 0x4b, 0x47, 0x2b, 0x30, 0xef, 0x20, 0xf3, 0x7c, 0xf2, 0x1b,
	0x39, 0x66, 0x0f, 0x81, 0xe5, 0x92, 0x57, 0x7e, 0xa8, 0xfe, 0xe0, 0xcf, 0x62, 0xe1, 0x1a, 0x06,
	0xd9, 0xd1, 0x06, 0x9d, 0x94, 0xf2, 0x6d, 0x6d, 0xfe, 0x55, 0x81, 0xb0, 0x9f, 0xc3, 0x76, 0xae,
	0xb7, 0x90, 0x61, 0xac, 0x26, 0xc2, 0x35, 0xae, 0xd1, 0x1c, 0xbb, 0x69, 0x62, 0x9e, 0x90, 0xf1,
	0x9e, 0x9e, 0xe1, 0x65, 0xc6, 0x33, 0x0e, 0x57, 0x4f, 0xae, 0x63, 0x45, 0x0b, 0x47, 0x18, 0x7d,
	0x9a, 0xe6, 0x7a, 0x9a, 0x98, 0x67, 0xa9, 0xf0, 0xdd, 0x55, 0x7f, 0x9e, 0x2f, 0x1c, 0xc1, 0x1e,
	0xc3, 0xe5, 0xd5, 0x75, 0xf5, 0x8c, 0xd7, 0x69, 0xc6, 0x6b, 0x69, 0x62, 0x9e, 0xae, 0xc0, 0xd9,
	0xb2, 0x77, 0x34, 0xdb, 0x27, 0xd0, 0x1d, 0xcf, 0x5d, 0x57, 0xc6, 0xd6, 0x2b, 0x29, 0x6c, 0xe3,
	0x46, 0x19, 0xd8, 0x0a, 0xcc, 0x41, 0x33, 0x5f, 0x49, 0x61, 0x57, 0x2c, 0x62, 0xa1, 0x5c, 0xe3,
	0xbd, 0x13, 0x16, 0x08, 0xe7, 0x16, 0x2f, 0x84, 0x72, 0xd9, 0xe7, 0xd0, 0x73, 0x95, 0xa7, 0x62,
	0x4b, 0xcd, 0x62, 0x19, 0x2e, 0x84, 0x6b, 0xec, 0x95, 0x6d, 0xd9, 0xb2, 0x84, 0x6f, 0x12, 0x7f,
	0x90, 0xb1, 0xfd, 0x07, 0xd0, 0x2e, 0x7a, 0xb4, 0x6b, 0xd0, 0xc0, 0x62, 0xa0, 0x8b, 0x36, 0x25,
	0x0f, 0x1e, 0x7e, 0x1c, 0xa8, 0xee, 0xca, 0x37, 0x71, 0xb5, 0x6c, 0x23, 0xcf, 0x69, 0x1c, 0xfc,
	0xbd, 0x06, 0x97, 0x1e, 0xaa, 0x88, 0x4e, 0x48, 0xb5, 0x1d, 0xdf, 0x86, 0xc6, 0xbc, 0x68, 0xc5,
	0x91, 0x64, 0x57, 0x80, 0x3a, 0xf2, 0xa2, 0xf9, 0xce, 0xb8, 0xd3, 0xfb, 0xf3, 0xc6, 0x05, 0xfa,
	0xf3, 0xb5, 0x77, 0xf4, 0xe7, 0xeb, 0x2b, 0x77, 0x21, 0xc3, 0xaa, 0xa4, 0x6c, 0x5d, 0xee, 0x39,
	0xd1, 0x83, 0x3f, 0x37, 0x60, 0xf7, 0xa4, 0xeb, 0x51, 0xc0, 0xbe, 0x86, 0x4d, 0x3b, 0xc3, 0xad,
	0x4a, 0x3f, 0xfe, 0xd1, 0x4a, 0xf5, 0x38, 0xcd, 0x96, 0x4a, 0xca, 0xc1, 0x6c, 0xea, 0xf3, 0x8d,
	0x7c, 0x0a, 0xea, 0x58, 0xff, 0x52, 0x87, 0x76, 0x2e, 0xc2, 0xa6, 0x93, 0x7a, 0xa7, 0xe2, 0x96,
	0xa4, 0xa6, 0x33, 0x83, 0x78, 0x13, 0x89, 0x03, 0xbb, 0xbc, 0x10, 0xeb, 0x67, 0x5c, 0x88, 0x9f,
	0x43, 0xaf, 0x70, 0xb3, 0x7a, 0x75, 0xd2, 0xd6, 0x2f, 0x4b, 0x78, 0xf1, 0x41, 0xcf, 0xc8, 0x74,
	0xe5, 0xd2, 0x5a, 0x3b, 0xff, 0xd2, 0xfa, 0x02, 0xb6, 0x32, 0x51, 0xd1, 0x59, 0xd3, 0x53, 0x47,
	0xd7, 0xa6, 0x15, 0x11, 0xef, 0x69, 0xe0, 0x59, 0xde, 0x66, 0x7f, 0x0a, 0x1b, 0x99, 0xca, 0xc4,
	0x77, 0xfd, 0x30, 0xeb, 0x32, 0xb7, 0xd3, 0xc4, 0x5c, 0xc2, 0x79, 0xb6, 0xfc, 0x03, 0x64, 0x06,
	0x26, 0x74, 0x1f, 0x0a, 0xe5, 0x1e, 0x8f, 0x84, 0x73, 0x6a, 0x46, 0x0d, 0xfe, 0xd3, 0x82, 0x8d,
	0x52, 0x23, 0x0a, 0xd8, 0xc7, 0x00, 0x78, 0x89, 0x47, 0xb1, 0x88, 0xe7, 0x51, 0x16, 0xdb, 0x5e,
	0x9a, 0x98, 0x15, 0x94, 0x77, 0xc6, 0xc2, 0x79, 0x4e, 0x24, 0xbb, 0x0f, 0x3b, 0x28, 0x90, 0x6f,
	0x02, 0x15, 0xca, 0xdc, 0x4a, 0x47, 0xfb, 0x72, 0x9a, 0x98, 0x27, 0x85, 0x7c, 0x6b, 0x2c, 0x9c,
	0x47, 0x84, 0x64, 0x53, 0x3c, 0x03, 0x9c, 0xcf, 0x8a, 0x7d, 0xbc, 0xcb, 0x31, 0xfc, 0x27, 0xfb,
	0xa7, 0xaa, 0x87, 0xc3, 0x91, 0x70, 0x5e, 0xa0, 0x6e, 0x76, 0xe3, 0xe7, 0xa6, 0x1c, 0x9b, 0x0f,
	0x12, 0xb0, 0xc7, 0xba, 0x39, 0xa9, 0xbc, 0x96, 0xde, 0x3f, 0x67, 0xc2, 0xf2, 0xa5, 0x94, 0x1b,
	0x52, 0x07, 0x43, 0x79, 0x77, 0x04, 0xed, 0x7c, 0x49, 0xdc, 0x04, 0x5a, 0x6c, 0x39, 0x3e, 0xb4,
	0x09, 0x55, 0x9c, 0x77, 0x89, 0xcb, 0x3e, 0xf0, 0x27, 0xb0, 0xa9, 0x85, 0x9e, 0x8c, 0x22, 0xe1,
	0xe4, 0xdd, 0xdb, 0x4e, 0x9a, 0x98, 0xcb, 0x02, 0xae, 0x27, 0x79, 0xa2, 0xb9, 0xfe, 0xdf, 0xd6,
	0xa0, 0x95, 0xf9, 0x56, 0x74, 0x6e, 0xb5, 0x53, 0x3b, 0xb7, 0xac, 0x1b, 0xab, 0xb4, 0x86, 0xc5,
	0xb7, 0x50, 0x7b, 0x88, 0xdf, 0xf2, 0x14, 0x3b, 0xc4, 0xa7, 0xd0, 0x8c, 0xfc, 0x79, 0x98, 0xe5,
	0x79, 0xf7, 0xde, 0x9d, 0x0b, 0xc4, 0x65, 0xf8, 0x9c, 0x2c, 0x74, 0x9f, 0xa1, 0xad, 0x79, 0xf6,
	0xcb, 0x7e, 0x0b, 0x1d, 0x3a, 0x73, 0x95, 0x50, 0x7f, 0x74, 0x91, 0x29, 0xf3, 0xf3, 0xae, 0xf7,
	0xb0, 0x98, 0x82, 0xd3, 0x83, 0x88, 0xa2, 0xfe, 0x4d, 0x0d, 0x9a, 0x7a, 0x61, 0xfc, 0x3a, 0x4f,
	0xda, 0xc2, 0x2d, 0x0f, 0x3b, 0x7d, 0x5d, 0x8e, 0xf1, 0x16, 0x51, 0x07, 0x36, 0xe6, 0xae, 0x06,
	0x2b, 0x81, 0xa0, 0xdc, 0x2d, 0x51, 0xde, 0x21, 0xfa, 0x69, 0xd6, 0x2e, 0xbb, 0x72, 0x21, 0xdd,
	0x6a, 0xbb, 0x4c, 0x00, 0xd7, 0x3f, 0x38, 0xdf, 0x3c, 0xc2, 0x87, 0x3c, 0x69, 0xad, 0x95, 0x67,
	0xa1, 0x44, 0x79, 0x07, 0xe9, 0xc7, 0x48, 0xf6, 0xff, 0x58, 0xd3, 0x05, 0x8a, 0x36, 0x6c, 0xa5,
	0x40, 0x75, 0x4e, 0x2f, 0x50, 0xf9, 0xb3, 0x10, 0x2f, 0x8e, 0xca, 0x2b, 0x3b, 0xc7, 0xf4, 0xb3,
	0x30, 0x7b, 0xbe, 0x65, 0xc7, 0x48, 0xc4, 0x99, 0xbf, 0x14, 0xba, 0x02, 0xe4, 0x6d, 0x4d, 0xde,
	0x8f, 0xef, 0xfd, 0xb3, 0x0e, 0x6b, 0xd4, 0x7b, 0x7f, 0x0d, 0x3d, 0xfa, 0x3f, 0xa7, 0x88, 0x2f,
	0xdb, 0x7b, 0xe7, 0x33, 0xee, 0xb0, 0x6f, 0x9e, 0xf3, 0xcc, 0x63, 0xbf, 0x84, 0x2e, 0xcd, 0x36,
	0xd1, 0xef, 0x94, 0x1b, 0xef, 0xe8, 0x06, 0x0f, 0xfb, 0xef, 0xbd, 0xb3, 0x57, 0x64, 0xbf, 0x07,
	0x56, 0x94, 0xd8, 0xd2, 0xc5, 0xc1, 0xb9, 0x57, 0xc4, 0x61, 0xff, 0xfd, 0x0b, 0x5c, 0x23, 0xec,
	0x21, 0x74, 0x6c, 0xcc, 0x3d, 0x6b, 0x2c, 0x1c, 0xd6, 0x3f, 0x33, 0x2b, 0x0f, 0xfb, 0xd7, 0xdf,
	0x91, 0xb1, 0xa3, 0xdd, 0x6f, 0xff, 0xb7, 0xf7, 0x83, 0x6f, 0xdf, 0xee, 0xd5, 0xfe, 0xfd, 0x76,
	0xaf, 0xf6, 0xdf, 0xb7, 0x7b, 0xb5, 0xdf, 0xd5, 0x17, 0x77, 0xc7, 0x4d, 0xfa, 0x13, 0xed, 0xd3,
	0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0xeb, 0xe1, 0x4f, 0x96, 0xb1, 0x13, 0x00, 0x00,
}
