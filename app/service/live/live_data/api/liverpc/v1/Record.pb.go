// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/Record.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type RecordSessionReq struct {
	// sessionid
	Sessionids []int64 `protobuf:"varint,1,rep,packed,name=sessionids" json:"sessionids"`
}

func (m *RecordSessionReq) Reset()         { *m = RecordSessionReq{} }
func (m *RecordSessionReq) String() string { return proto.CompactTextString(m) }
func (*RecordSessionReq) ProtoMessage()    {}
func (*RecordSessionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{0}
}
func (m *RecordSessionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordSessionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordSessionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordSessionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordSessionReq.Merge(dst, src)
}
func (m *RecordSessionReq) XXX_Size() int {
	return m.Size()
}
func (m *RecordSessionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordSessionReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecordSessionReq proto.InternalMessageInfo

func (m *RecordSessionReq) GetSessionids() []int64 {
	if m != nil {
		return m.Sessionids
	}
	return nil
}

type RecordSessionResp struct {
	// code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data map[int64]*RecordSessionResp_LiveInfo `protobuf:"bytes,3,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RecordSessionResp) Reset()         { *m = RecordSessionResp{} }
func (m *RecordSessionResp) String() string { return proto.CompactTextString(m) }
func (*RecordSessionResp) ProtoMessage()    {}
func (*RecordSessionResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{1}
}
func (m *RecordSessionResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordSessionResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordSessionResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordSessionResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordSessionResp.Merge(dst, src)
}
func (m *RecordSessionResp) XXX_Size() int {
	return m.Size()
}
func (m *RecordSessionResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordSessionResp.DiscardUnknown(m)
}

var xxx_messageInfo_RecordSessionResp proto.InternalMessageInfo

func (m *RecordSessionResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RecordSessionResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RecordSessionResp) GetData() map[int64]*RecordSessionResp_LiveInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type RecordSessionResp_LiveInfo struct {
	//
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	//
	Roomid int64 `protobuf:"varint,2,opt,name=roomid,proto3" json:"roomid"`
	//
	Uid int64 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid"`
	//
	Title string `protobuf:"bytes,4,opt,name=title,proto3" json:"title"`
	//
	Cover string `protobuf:"bytes,5,opt,name=cover,proto3" json:"cover"`
	//
	UserCover string `protobuf:"bytes,6,opt,name=user_cover,json=userCover,proto3" json:"user_cover"`
	//
	Online int64 `protobuf:"varint,7,opt,name=online,proto3" json:"online"`
	//
	JumpUrl string `protobuf:"bytes,8,opt,name=jump_url,json=jumpUrl,proto3" json:"jump_url"`
	//
	AreaV2Id int64 `protobuf:"varint,9,opt,name=area_v2_id,json=areaV2Id,proto3" json:"area_v2_id"`
	//
	StartTime string `protobuf:"bytes,10,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	//
	EndTime string `protobuf:"bytes,11,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	//
	Sessionid int64 `protobuf:"varint,12,opt,name=sessionid,proto3" json:"sessionid"`
}

func (m *RecordSessionResp_LiveInfo) Reset()         { *m = RecordSessionResp_LiveInfo{} }
func (m *RecordSessionResp_LiveInfo) String() string { return proto.CompactTextString(m) }
func (*RecordSessionResp_LiveInfo) ProtoMessage()    {}
func (*RecordSessionResp_LiveInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{1, 1}
}
func (m *RecordSessionResp_LiveInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordSessionResp_LiveInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordSessionResp_LiveInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordSessionResp_LiveInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordSessionResp_LiveInfo.Merge(dst, src)
}
func (m *RecordSessionResp_LiveInfo) XXX_Size() int {
	return m.Size()
}
func (m *RecordSessionResp_LiveInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordSessionResp_LiveInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RecordSessionResp_LiveInfo proto.InternalMessageInfo

func (m *RecordSessionResp_LiveInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RecordSessionResp_LiveInfo) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *RecordSessionResp_LiveInfo) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RecordSessionResp_LiveInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RecordSessionResp_LiveInfo) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *RecordSessionResp_LiveInfo) GetUserCover() string {
	if m != nil {
		return m.UserCover
	}
	return ""
}

func (m *RecordSessionResp_LiveInfo) GetOnline() int64 {
	if m != nil {
		return m.Online
	}
	return 0
}

func (m *RecordSessionResp_LiveInfo) GetJumpUrl() string {
	if m != nil {
		return m.JumpUrl
	}
	return ""
}

func (m *RecordSessionResp_LiveInfo) GetAreaV2Id() int64 {
	if m != nil {
		return m.AreaV2Id
	}
	return 0
}

func (m *RecordSessionResp_LiveInfo) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *RecordSessionResp_LiveInfo) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *RecordSessionResp_LiveInfo) GetSessionid() int64 {
	if m != nil {
		return m.Sessionid
	}
	return 0
}

type RecordGetReq struct {
	// 房间id数组
	Roomids []int64 `protobuf:"varint,1,rep,packed,name=roomids" json:"roomids"`
}

func (m *RecordGetReq) Reset()         { *m = RecordGetReq{} }
func (m *RecordGetReq) String() string { return proto.CompactTextString(m) }
func (*RecordGetReq) ProtoMessage()    {}
func (*RecordGetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{2}
}
func (m *RecordGetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordGetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordGetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordGetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordGetReq.Merge(dst, src)
}
func (m *RecordGetReq) XXX_Size() int {
	return m.Size()
}
func (m *RecordGetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordGetReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecordGetReq proto.InternalMessageInfo

func (m *RecordGetReq) GetRoomids() []int64 {
	if m != nil {
		return m.Roomids
	}
	return nil
}

type RecordGetResp struct {
	// code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data map[string]*RecordGetResp_TimeInfo `protobuf:"bytes,3,rep,name=data" json:"data" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RecordGetResp) Reset()         { *m = RecordGetResp{} }
func (m *RecordGetResp) String() string { return proto.CompactTextString(m) }
func (*RecordGetResp) ProtoMessage()    {}
func (*RecordGetResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{3}
}
func (m *RecordGetResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordGetResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordGetResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordGetResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordGetResp.Merge(dst, src)
}
func (m *RecordGetResp) XXX_Size() int {
	return m.Size()
}
func (m *RecordGetResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordGetResp.DiscardUnknown(m)
}

var xxx_messageInfo_RecordGetResp proto.InternalMessageInfo

func (m *RecordGetResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RecordGetResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RecordGetResp) GetData() map[string]*RecordGetResp_TimeInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type RecordGetResp_TimeInfo struct {
	// 房间
	Roomid int64 `protobuf:"varint,1,opt,name=roomid,proto3" json:"roomid"`
	// 最近开播时间
	RecentEndTime string `protobuf:"bytes,2,opt,name=recent_end_time,json=recentEndTime,proto3" json:"recent_end_time"`
}

func (m *RecordGetResp_TimeInfo) Reset()         { *m = RecordGetResp_TimeInfo{} }
func (m *RecordGetResp_TimeInfo) String() string { return proto.CompactTextString(m) }
func (*RecordGetResp_TimeInfo) ProtoMessage()    {}
func (*RecordGetResp_TimeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{3, 1}
}
func (m *RecordGetResp_TimeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordGetResp_TimeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordGetResp_TimeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordGetResp_TimeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordGetResp_TimeInfo.Merge(dst, src)
}
func (m *RecordGetResp_TimeInfo) XXX_Size() int {
	return m.Size()
}
func (m *RecordGetResp_TimeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordGetResp_TimeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RecordGetResp_TimeInfo proto.InternalMessageInfo

func (m *RecordGetResp_TimeInfo) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *RecordGetResp_TimeInfo) GetRecentEndTime() string {
	if m != nil {
		return m.RecentEndTime
	}
	return ""
}

type RecordLiveTimeReq struct {
	//
	Roomids []int64 `protobuf:"varint,1,rep,packed,name=roomids" json:"roomids"`
	//
	StartTime string `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	//
	EndTime string `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3" json:"end_time"`
}

func (m *RecordLiveTimeReq) Reset()         { *m = RecordLiveTimeReq{} }
func (m *RecordLiveTimeReq) String() string { return proto.CompactTextString(m) }
func (*RecordLiveTimeReq) ProtoMessage()    {}
func (*RecordLiveTimeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{4}
}
func (m *RecordLiveTimeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordLiveTimeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordLiveTimeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordLiveTimeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordLiveTimeReq.Merge(dst, src)
}
func (m *RecordLiveTimeReq) XXX_Size() int {
	return m.Size()
}
func (m *RecordLiveTimeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordLiveTimeReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecordLiveTimeReq proto.InternalMessageInfo

func (m *RecordLiveTimeReq) GetRoomids() []int64 {
	if m != nil {
		return m.Roomids
	}
	return nil
}

func (m *RecordLiveTimeReq) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *RecordLiveTimeReq) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

type RecordLiveTimeResp struct {
	// code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data map[int64]*RecordLiveTimeResp_LiveInfo `protobuf:"bytes,3,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RecordLiveTimeResp) Reset()         { *m = RecordLiveTimeResp{} }
func (m *RecordLiveTimeResp) String() string { return proto.CompactTextString(m) }
func (*RecordLiveTimeResp) ProtoMessage()    {}
func (*RecordLiveTimeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{5}
}
func (m *RecordLiveTimeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordLiveTimeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordLiveTimeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordLiveTimeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordLiveTimeResp.Merge(dst, src)
}
func (m *RecordLiveTimeResp) XXX_Size() int {
	return m.Size()
}
func (m *RecordLiveTimeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordLiveTimeResp.DiscardUnknown(m)
}

var xxx_messageInfo_RecordLiveTimeResp proto.InternalMessageInfo

func (m *RecordLiveTimeResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RecordLiveTimeResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RecordLiveTimeResp) GetData() map[int64]*RecordLiveTimeResp_LiveInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type RecordLiveTimeResp_LiveInfo struct {
	//
	Roomid int64 `protobuf:"varint,1,opt,name=roomid,proto3" json:"roomid"`
	//
	Uid int64 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid"`
	//
	AreaV2Id int64 `protobuf:"varint,3,opt,name=area_v2_id,json=areaV2Id,proto3" json:"area_v2_id"`
	//
	AreaV2ParentId int64 `protobuf:"varint,4,opt,name=area_v2_parent_id,json=areaV2ParentId,proto3" json:"area_v2_parent_id"`
	//
	StartTime string `protobuf:"bytes,5,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	//
	EndTime string `protobuf:"bytes,6,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	// 该时间段内最大人气
	MaxOnlineNum int64 `protobuf:"varint,7,opt,name=max_online_num,json=maxOnlineNum,proto3" json:"max_online_num"`
	// 该时间段内最后关注数
	Attention int64 `protobuf:"varint,8,opt,name=attention,proto3" json:"attention"`
	// 是否是后台自动切分的记录
	IsCut int64 `protobuf:"varint,9,opt,name=is_cut,json=isCut,proto3" json:"is_cut"`
}

func (m *RecordLiveTimeResp_LiveInfo) Reset()         { *m = RecordLiveTimeResp_LiveInfo{} }
func (m *RecordLiveTimeResp_LiveInfo) String() string { return proto.CompactTextString(m) }
func (*RecordLiveTimeResp_LiveInfo) ProtoMessage()    {}
func (*RecordLiveTimeResp_LiveInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{5, 1}
}
func (m *RecordLiveTimeResp_LiveInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordLiveTimeResp_LiveInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordLiveTimeResp_LiveInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordLiveTimeResp_LiveInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordLiveTimeResp_LiveInfo.Merge(dst, src)
}
func (m *RecordLiveTimeResp_LiveInfo) XXX_Size() int {
	return m.Size()
}
func (m *RecordLiveTimeResp_LiveInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordLiveTimeResp_LiveInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RecordLiveTimeResp_LiveInfo proto.InternalMessageInfo

func (m *RecordLiveTimeResp_LiveInfo) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *RecordLiveTimeResp_LiveInfo) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RecordLiveTimeResp_LiveInfo) GetAreaV2Id() int64 {
	if m != nil {
		return m.AreaV2Id
	}
	return 0
}

func (m *RecordLiveTimeResp_LiveInfo) GetAreaV2ParentId() int64 {
	if m != nil {
		return m.AreaV2ParentId
	}
	return 0
}

func (m *RecordLiveTimeResp_LiveInfo) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *RecordLiveTimeResp_LiveInfo) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *RecordLiveTimeResp_LiveInfo) GetMaxOnlineNum() int64 {
	if m != nil {
		return m.MaxOnlineNum
	}
	return 0
}

func (m *RecordLiveTimeResp_LiveInfo) GetAttention() int64 {
	if m != nil {
		return m.Attention
	}
	return 0
}

func (m *RecordLiveTimeResp_LiveInfo) GetIsCut() int64 {
	if m != nil {
		return m.IsCut
	}
	return 0
}

type RecordAreasReq struct {
	// 房间id
	Roomid int64 `protobuf:"varint,1,opt,name=roomid,proto3" json:"roomid"`
	// 月份 2018-09
	Date string `protobuf:"bytes,2,opt,name=date,proto3" json:"date"`
}

func (m *RecordAreasReq) Reset()         { *m = RecordAreasReq{} }
func (m *RecordAreasReq) String() string { return proto.CompactTextString(m) }
func (*RecordAreasReq) ProtoMessage()    {}
func (*RecordAreasReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{6}
}
func (m *RecordAreasReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordAreasReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordAreasReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordAreasReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordAreasReq.Merge(dst, src)
}
func (m *RecordAreasReq) XXX_Size() int {
	return m.Size()
}
func (m *RecordAreasReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordAreasReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecordAreasReq proto.InternalMessageInfo

func (m *RecordAreasReq) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *RecordAreasReq) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

type RecordAreasResp struct {
	// 返回code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// 返回msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data []*RecordAreasResp_Data `protobuf:"bytes,3,rep,name=data" json:"data"`
}

func (m *RecordAreasResp) Reset()         { *m = RecordAreasResp{} }
func (m *RecordAreasResp) String() string { return proto.CompactTextString(m) }
func (*RecordAreasResp) ProtoMessage()    {}
func (*RecordAreasResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{7}
}
func (m *RecordAreasResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordAreasResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordAreasResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordAreasResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordAreasResp.Merge(dst, src)
}
func (m *RecordAreasResp) XXX_Size() int {
	return m.Size()
}
func (m *RecordAreasResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordAreasResp.DiscardUnknown(m)
}

var xxx_messageInfo_RecordAreasResp proto.InternalMessageInfo

func (m *RecordAreasResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RecordAreasResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RecordAreasResp) GetData() []*RecordAreasResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type RecordAreasResp_List struct {
	//
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	//
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	//
	ParentId int64 `protobuf:"varint,3,opt,name=parent_id,json=parentId,proto3" json:"parent_id"`
}

func (m *RecordAreasResp_List) Reset()         { *m = RecordAreasResp_List{} }
func (m *RecordAreasResp_List) String() string { return proto.CompactTextString(m) }
func (*RecordAreasResp_List) ProtoMessage()    {}
func (*RecordAreasResp_List) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{7, 0}
}
func (m *RecordAreasResp_List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordAreasResp_List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordAreasResp_List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordAreasResp_List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordAreasResp_List.Merge(dst, src)
}
func (m *RecordAreasResp_List) XXX_Size() int {
	return m.Size()
}
func (m *RecordAreasResp_List) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordAreasResp_List.DiscardUnknown(m)
}

var xxx_messageInfo_RecordAreasResp_List proto.InternalMessageInfo

func (m *RecordAreasResp_List) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RecordAreasResp_List) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RecordAreasResp_List) GetParentId() int64 {
	if m != nil {
		return m.ParentId
	}
	return 0
}

type RecordAreasResp_Data struct {
	//
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	//
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	//
	List []*RecordAreasResp_List `protobuf:"bytes,3,rep,name=list" json:"list"`
}

func (m *RecordAreasResp_Data) Reset()         { *m = RecordAreasResp_Data{} }
func (m *RecordAreasResp_Data) String() string { return proto.CompactTextString(m) }
func (*RecordAreasResp_Data) ProtoMessage()    {}
func (*RecordAreasResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{7, 1}
}
func (m *RecordAreasResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordAreasResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordAreasResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordAreasResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordAreasResp_Data.Merge(dst, src)
}
func (m *RecordAreasResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *RecordAreasResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordAreasResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_RecordAreasResp_Data proto.InternalMessageInfo

func (m *RecordAreasResp_Data) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RecordAreasResp_Data) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RecordAreasResp_Data) GetList() []*RecordAreasResp_List {
	if m != nil {
		return m.List
	}
	return nil
}

type RecordAreaLiveReq struct {
	// 房间id
	Roomid int64 `protobuf:"varint,1,opt,name=roomid,proto3" json:"roomid"`
	// 月份 2018-09
	Date string `protobuf:"bytes,2,opt,name=date,proto3" json:"date"`
	// 逗号隔开的分区id组成的字符串
	AreaIds string `protobuf:"bytes,3,opt,name=area_ids,json=areaIds,proto3" json:"area_ids"`
}

func (m *RecordAreaLiveReq) Reset()         { *m = RecordAreaLiveReq{} }
func (m *RecordAreaLiveReq) String() string { return proto.CompactTextString(m) }
func (*RecordAreaLiveReq) ProtoMessage()    {}
func (*RecordAreaLiveReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{8}
}
func (m *RecordAreaLiveReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordAreaLiveReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordAreaLiveReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordAreaLiveReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordAreaLiveReq.Merge(dst, src)
}
func (m *RecordAreaLiveReq) XXX_Size() int {
	return m.Size()
}
func (m *RecordAreaLiveReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordAreaLiveReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecordAreaLiveReq proto.InternalMessageInfo

func (m *RecordAreaLiveReq) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *RecordAreaLiveReq) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *RecordAreaLiveReq) GetAreaIds() string {
	if m != nil {
		return m.AreaIds
	}
	return ""
}

type RecordAreaLiveResp struct {
	// 返回code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// 返回msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data *RecordAreaLiveResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *RecordAreaLiveResp) Reset()         { *m = RecordAreaLiveResp{} }
func (m *RecordAreaLiveResp) String() string { return proto.CompactTextString(m) }
func (*RecordAreaLiveResp) ProtoMessage()    {}
func (*RecordAreaLiveResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{9}
}
func (m *RecordAreaLiveResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordAreaLiveResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordAreaLiveResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordAreaLiveResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordAreaLiveResp.Merge(dst, src)
}
func (m *RecordAreaLiveResp) XXX_Size() int {
	return m.Size()
}
func (m *RecordAreaLiveResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordAreaLiveResp.DiscardUnknown(m)
}

var xxx_messageInfo_RecordAreaLiveResp proto.InternalMessageInfo

func (m *RecordAreaLiveResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RecordAreaLiveResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RecordAreaLiveResp) GetData() *RecordAreaLiveResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type RecordAreaLiveResp_List struct {
	// 日期 2018-09-01
	Date string `protobuf:"bytes,1,opt,name=date,proto3" json:"date"`
	// 直播时长，分钟
	LiveTime int64 `protobuf:"varint,2,opt,name=live_time,json=liveTime,proto3" json:"live_time"`
	// 直播次数
	LiveNum int64 `protobuf:"varint,3,opt,name=live_num,json=liveNum,proto3" json:"live_num"`
	// 该日期下最大人气
	MaxOnline int64 `protobuf:"varint,4,opt,name=max_online,json=maxOnline,proto3" json:"max_online"`
}

func (m *RecordAreaLiveResp_List) Reset()         { *m = RecordAreaLiveResp_List{} }
func (m *RecordAreaLiveResp_List) String() string { return proto.CompactTextString(m) }
func (*RecordAreaLiveResp_List) ProtoMessage()    {}
func (*RecordAreaLiveResp_List) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{9, 0}
}
func (m *RecordAreaLiveResp_List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordAreaLiveResp_List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordAreaLiveResp_List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordAreaLiveResp_List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordAreaLiveResp_List.Merge(dst, src)
}
func (m *RecordAreaLiveResp_List) XXX_Size() int {
	return m.Size()
}
func (m *RecordAreaLiveResp_List) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordAreaLiveResp_List.DiscardUnknown(m)
}

var xxx_messageInfo_RecordAreaLiveResp_List proto.InternalMessageInfo

func (m *RecordAreaLiveResp_List) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *RecordAreaLiveResp_List) GetLiveTime() int64 {
	if m != nil {
		return m.LiveTime
	}
	return 0
}

func (m *RecordAreaLiveResp_List) GetLiveNum() int64 {
	if m != nil {
		return m.LiveNum
	}
	return 0
}

func (m *RecordAreaLiveResp_List) GetMaxOnline() int64 {
	if m != nil {
		return m.MaxOnline
	}
	return 0
}

type RecordAreaLiveResp_Count struct {
	// 该月直播总时长
	AllLiveTime string `protobuf:"bytes,1,opt,name=all_live_time,json=allLiveTime,proto3" json:"all_live_time"`
	// 该月直播总天数（某一天有直播记录就算一天，对直播时长没要求）
	AllLiveDay int64 `protobuf:"varint,2,opt,name=all_live_day,json=allLiveDay,proto3" json:"all_live_day"`
	// 该月最大人气
	MaxOnline int64 `protobuf:"varint,3,opt,name=max_online,json=maxOnline,proto3" json:"max_online"`
}

func (m *RecordAreaLiveResp_Count) Reset()         { *m = RecordAreaLiveResp_Count{} }
func (m *RecordAreaLiveResp_Count) String() string { return proto.CompactTextString(m) }
func (*RecordAreaLiveResp_Count) ProtoMessage()    {}
func (*RecordAreaLiveResp_Count) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{9, 1}
}
func (m *RecordAreaLiveResp_Count) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordAreaLiveResp_Count) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordAreaLiveResp_Count.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordAreaLiveResp_Count) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordAreaLiveResp_Count.Merge(dst, src)
}
func (m *RecordAreaLiveResp_Count) XXX_Size() int {
	return m.Size()
}
func (m *RecordAreaLiveResp_Count) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordAreaLiveResp_Count.DiscardUnknown(m)
}

var xxx_messageInfo_RecordAreaLiveResp_Count proto.InternalMessageInfo

func (m *RecordAreaLiveResp_Count) GetAllLiveTime() string {
	if m != nil {
		return m.AllLiveTime
	}
	return ""
}

func (m *RecordAreaLiveResp_Count) GetAllLiveDay() int64 {
	if m != nil {
		return m.AllLiveDay
	}
	return 0
}

func (m *RecordAreaLiveResp_Count) GetMaxOnline() int64 {
	if m != nil {
		return m.MaxOnline
	}
	return 0
}

type RecordAreaLiveResp_Data struct {
	//
	List []*RecordAreaLiveResp_List `protobuf:"bytes,1,rep,name=list" json:"list"`
	//
	Count *RecordAreaLiveResp_Count `protobuf:"bytes,2,opt,name=count" json:"count"`
}

func (m *RecordAreaLiveResp_Data) Reset()         { *m = RecordAreaLiveResp_Data{} }
func (m *RecordAreaLiveResp_Data) String() string { return proto.CompactTextString(m) }
func (*RecordAreaLiveResp_Data) ProtoMessage()    {}
func (*RecordAreaLiveResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{9, 2}
}
func (m *RecordAreaLiveResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordAreaLiveResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordAreaLiveResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordAreaLiveResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordAreaLiveResp_Data.Merge(dst, src)
}
func (m *RecordAreaLiveResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *RecordAreaLiveResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordAreaLiveResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_RecordAreaLiveResp_Data proto.InternalMessageInfo

func (m *RecordAreaLiveResp_Data) GetList() []*RecordAreaLiveResp_List {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *RecordAreaLiveResp_Data) GetCount() *RecordAreaLiveResp_Count {
	if m != nil {
		return m.Count
	}
	return nil
}

type RecordDayLiveReq struct {
	// 房间id
	Roomid int64 `protobuf:"varint,1,opt,name=roomid,proto3" json:"roomid"`
	// 日期 2018-09-01
	Day string `protobuf:"bytes,2,opt,name=day,proto3" json:"day"`
}

func (m *RecordDayLiveReq) Reset()         { *m = RecordDayLiveReq{} }
func (m *RecordDayLiveReq) String() string { return proto.CompactTextString(m) }
func (*RecordDayLiveReq) ProtoMessage()    {}
func (*RecordDayLiveReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{10}
}
func (m *RecordDayLiveReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordDayLiveReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordDayLiveReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordDayLiveReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordDayLiveReq.Merge(dst, src)
}
func (m *RecordDayLiveReq) XXX_Size() int {
	return m.Size()
}
func (m *RecordDayLiveReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordDayLiveReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecordDayLiveReq proto.InternalMessageInfo

func (m *RecordDayLiveReq) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *RecordDayLiveReq) GetDay() string {
	if m != nil {
		return m.Day
	}
	return ""
}

type RecordDayLiveResp struct {
	// 返回code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// 返回msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data *RecordDayLiveResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *RecordDayLiveResp) Reset()         { *m = RecordDayLiveResp{} }
func (m *RecordDayLiveResp) String() string { return proto.CompactTextString(m) }
func (*RecordDayLiveResp) ProtoMessage()    {}
func (*RecordDayLiveResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{11}
}
func (m *RecordDayLiveResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordDayLiveResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordDayLiveResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordDayLiveResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordDayLiveResp.Merge(dst, src)
}
func (m *RecordDayLiveResp) XXX_Size() int {
	return m.Size()
}
func (m *RecordDayLiveResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordDayLiveResp.DiscardUnknown(m)
}

var xxx_messageInfo_RecordDayLiveResp proto.InternalMessageInfo

func (m *RecordDayLiveResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RecordDayLiveResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RecordDayLiveResp) GetData() *RecordDayLiveResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type RecordDayLiveResp_List struct {
	// 日期 2018-09-01
	Date string `protobuf:"bytes,1,opt,name=date,proto3" json:"date"`
	// 直播时长，分钟
	LiveTime int64 `protobuf:"varint,2,opt,name=live_time,json=liveTime,proto3" json:"live_time"`
	// 开播时间
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	// 关播时间
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	// 该日期下最大人气
	MaxOnline int64 `protobuf:"varint,5,opt,name=max_online,json=maxOnline,proto3" json:"max_online"`
}

func (m *RecordDayLiveResp_List) Reset()         { *m = RecordDayLiveResp_List{} }
func (m *RecordDayLiveResp_List) String() string { return proto.CompactTextString(m) }
func (*RecordDayLiveResp_List) ProtoMessage()    {}
func (*RecordDayLiveResp_List) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{11, 0}
}
func (m *RecordDayLiveResp_List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordDayLiveResp_List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordDayLiveResp_List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordDayLiveResp_List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordDayLiveResp_List.Merge(dst, src)
}
func (m *RecordDayLiveResp_List) XXX_Size() int {
	return m.Size()
}
func (m *RecordDayLiveResp_List) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordDayLiveResp_List.DiscardUnknown(m)
}

var xxx_messageInfo_RecordDayLiveResp_List proto.InternalMessageInfo

func (m *RecordDayLiveResp_List) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *RecordDayLiveResp_List) GetLiveTime() int64 {
	if m != nil {
		return m.LiveTime
	}
	return 0
}

func (m *RecordDayLiveResp_List) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *RecordDayLiveResp_List) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *RecordDayLiveResp_List) GetMaxOnline() int64 {
	if m != nil {
		return m.MaxOnline
	}
	return 0
}

type RecordDayLiveResp_Data struct {
	//
	List []*RecordDayLiveResp_List `protobuf:"bytes,1,rep,name=list" json:"list"`
}

func (m *RecordDayLiveResp_Data) Reset()         { *m = RecordDayLiveResp_Data{} }
func (m *RecordDayLiveResp_Data) String() string { return proto.CompactTextString(m) }
func (*RecordDayLiveResp_Data) ProtoMessage()    {}
func (*RecordDayLiveResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_Record_7724024fde989e5d, []int{11, 1}
}
func (m *RecordDayLiveResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordDayLiveResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordDayLiveResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecordDayLiveResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordDayLiveResp_Data.Merge(dst, src)
}
func (m *RecordDayLiveResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *RecordDayLiveResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordDayLiveResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_RecordDayLiveResp_Data proto.InternalMessageInfo

func (m *RecordDayLiveResp_Data) GetList() []*RecordDayLiveResp_List {
	if m != nil {
		return m.List
	}
	return nil
}

func init() {
	proto.RegisterType((*RecordSessionReq)(nil), "live_data.v1.RecordSessionReq")
	proto.RegisterType((*RecordSessionResp)(nil), "live_data.v1.RecordSessionResp")
	proto.RegisterMapType((map[int64]*RecordSessionResp_LiveInfo)(nil), "live_data.v1.RecordSessionResp.DataEntry")
	proto.RegisterType((*RecordSessionResp_LiveInfo)(nil), "live_data.v1.RecordSessionResp.LiveInfo")
	proto.RegisterType((*RecordGetReq)(nil), "live_data.v1.RecordGetReq")
	proto.RegisterType((*RecordGetResp)(nil), "live_data.v1.RecordGetResp")
	proto.RegisterMapType((map[string]*RecordGetResp_TimeInfo)(nil), "live_data.v1.RecordGetResp.DataEntry")
	proto.RegisterType((*RecordGetResp_TimeInfo)(nil), "live_data.v1.RecordGetResp.TimeInfo")
	proto.RegisterType((*RecordLiveTimeReq)(nil), "live_data.v1.RecordLiveTimeReq")
	proto.RegisterType((*RecordLiveTimeResp)(nil), "live_data.v1.RecordLiveTimeResp")
	proto.RegisterMapType((map[int64]*RecordLiveTimeResp_LiveInfo)(nil), "live_data.v1.RecordLiveTimeResp.DataEntry")
	proto.RegisterType((*RecordLiveTimeResp_LiveInfo)(nil), "live_data.v1.RecordLiveTimeResp.LiveInfo")
	proto.RegisterType((*RecordAreasReq)(nil), "live_data.v1.RecordAreasReq")
	proto.RegisterType((*RecordAreasResp)(nil), "live_data.v1.RecordAreasResp")
	proto.RegisterType((*RecordAreasResp_List)(nil), "live_data.v1.RecordAreasResp.List")
	proto.RegisterType((*RecordAreasResp_Data)(nil), "live_data.v1.RecordAreasResp.Data")
	proto.RegisterType((*RecordAreaLiveReq)(nil), "live_data.v1.RecordAreaLiveReq")
	proto.RegisterType((*RecordAreaLiveResp)(nil), "live_data.v1.RecordAreaLiveResp")
	proto.RegisterType((*RecordAreaLiveResp_List)(nil), "live_data.v1.RecordAreaLiveResp.List")
	proto.RegisterType((*RecordAreaLiveResp_Count)(nil), "live_data.v1.RecordAreaLiveResp.Count")
	proto.RegisterType((*RecordAreaLiveResp_Data)(nil), "live_data.v1.RecordAreaLiveResp.Data")
	proto.RegisterType((*RecordDayLiveReq)(nil), "live_data.v1.RecordDayLiveReq")
	proto.RegisterType((*RecordDayLiveResp)(nil), "live_data.v1.RecordDayLiveResp")
	proto.RegisterType((*RecordDayLiveResp_List)(nil), "live_data.v1.RecordDayLiveResp.List")
	proto.RegisterType((*RecordDayLiveResp_Data)(nil), "live_data.v1.RecordDayLiveResp.Data")
}
func (m *RecordSessionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordSessionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessionids) > 0 {
		dAtA2 := make([]byte, len(m.Sessionids)*10)
		var j1 int
		for _, num1 := range m.Sessionids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecord(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *RecordSessionResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordSessionResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0x1a
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRecord(uint64(msgSize))
			}
			mapSize := 1 + sovRecord(uint64(k)) + msgSize
			i = encodeVarintRecord(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRecord(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRecord(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *RecordSessionResp_LiveInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordSessionResp_LiveInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Id))
	}
	if m.Roomid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Roomid))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Uid))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if len(m.UserCover) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.UserCover)))
		i += copy(dAtA[i:], m.UserCover)
	}
	if m.Online != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Online))
	}
	if len(m.JumpUrl) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.JumpUrl)))
		i += copy(dAtA[i:], m.JumpUrl)
	}
	if m.AreaV2Id != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.AreaV2Id))
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	if m.Sessionid != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Sessionid))
	}
	return i, nil
}

func (m *RecordGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordGetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roomids) > 0 {
		dAtA5 := make([]byte, len(m.Roomids)*10)
		var j4 int
		for _, num1 := range m.Roomids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecord(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *RecordGetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordGetResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0x1a
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRecord(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovRecord(uint64(len(k))) + msgSize
			i = encodeVarintRecord(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRecord(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRecord(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	return i, nil
}

func (m *RecordGetResp_TimeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordGetResp_TimeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Roomid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Roomid))
	}
	if len(m.RecentEndTime) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.RecentEndTime)))
		i += copy(dAtA[i:], m.RecentEndTime)
	}
	return i, nil
}

func (m *RecordLiveTimeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordLiveTimeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roomids) > 0 {
		dAtA8 := make([]byte, len(m.Roomids)*10)
		var j7 int
		for _, num1 := range m.Roomids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecord(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	return i, nil
}

func (m *RecordLiveTimeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordLiveTimeResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0x1a
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRecord(uint64(msgSize))
			}
			mapSize := 1 + sovRecord(uint64(k)) + msgSize
			i = encodeVarintRecord(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRecord(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRecord(dAtA, i, uint64(v.Size()))
				n9, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	return i, nil
}

func (m *RecordLiveTimeResp_LiveInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordLiveTimeResp_LiveInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Roomid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Roomid))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Uid))
	}
	if m.AreaV2Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.AreaV2Id))
	}
	if m.AreaV2ParentId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.AreaV2ParentId))
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	if m.MaxOnlineNum != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.MaxOnlineNum))
	}
	if m.Attention != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Attention))
	}
	if m.IsCut != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.IsCut))
	}
	return i, nil
}

func (m *RecordAreasReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordAreasReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Roomid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Roomid))
	}
	if len(m.Date) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	return i, nil
}

func (m *RecordAreasResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordAreasResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRecord(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RecordAreasResp_List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordAreasResp_List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.ParentId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.ParentId))
	}
	return i, nil
}

func (m *RecordAreasResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordAreasResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRecord(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RecordAreaLiveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordAreaLiveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Roomid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Roomid))
	}
	if len(m.Date) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	if len(m.AreaIds) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.AreaIds)))
		i += copy(dAtA[i:], m.AreaIds)
	}
	return i, nil
}

func (m *RecordAreaLiveResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordAreaLiveResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Data.Size()))
		n10, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *RecordAreaLiveResp_List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordAreaLiveResp_List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Date) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	if m.LiveTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.LiveTime))
	}
	if m.LiveNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.LiveNum))
	}
	if m.MaxOnline != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.MaxOnline))
	}
	return i, nil
}

func (m *RecordAreaLiveResp_Count) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordAreaLiveResp_Count) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllLiveTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.AllLiveTime)))
		i += copy(dAtA[i:], m.AllLiveTime)
	}
	if m.AllLiveDay != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.AllLiveDay))
	}
	if m.MaxOnline != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.MaxOnline))
	}
	return i, nil
}

func (m *RecordAreaLiveResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordAreaLiveResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRecord(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Count.Size()))
		n11, err := m.Count.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *RecordDayLiveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordDayLiveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Roomid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Roomid))
	}
	if len(m.Day) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Day)))
		i += copy(dAtA[i:], m.Day)
	}
	return i, nil
}

func (m *RecordDayLiveResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordDayLiveResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.Data.Size()))
		n12, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *RecordDayLiveResp_List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordDayLiveResp_List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Date) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.Date)))
		i += copy(dAtA[i:], m.Date)
	}
	if m.LiveTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.LiveTime))
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRecord(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	if m.MaxOnline != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRecord(dAtA, i, uint64(m.MaxOnline))
	}
	return i, nil
}

func (m *RecordDayLiveResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordDayLiveResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRecord(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintRecord(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RecordSessionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessionids) > 0 {
		l = 0
		for _, e := range m.Sessionids {
			l += sovRecord(uint64(e))
		}
		n += 1 + sovRecord(uint64(l)) + l
	}
	return n
}

func (m *RecordSessionResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRecord(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRecord(uint64(l))
			}
			mapEntrySize := 1 + sovRecord(uint64(k)) + l
			n += mapEntrySize + 1 + sovRecord(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RecordSessionResp_LiveInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRecord(uint64(m.Id))
	}
	if m.Roomid != 0 {
		n += 1 + sovRecord(uint64(m.Roomid))
	}
	if m.Uid != 0 {
		n += 1 + sovRecord(uint64(m.Uid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	l = len(m.UserCover)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.Online != 0 {
		n += 1 + sovRecord(uint64(m.Online))
	}
	l = len(m.JumpUrl)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.AreaV2Id != 0 {
		n += 1 + sovRecord(uint64(m.AreaV2Id))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.Sessionid != 0 {
		n += 1 + sovRecord(uint64(m.Sessionid))
	}
	return n
}

func (m *RecordGetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roomids) > 0 {
		l = 0
		for _, e := range m.Roomids {
			l += sovRecord(uint64(e))
		}
		n += 1 + sovRecord(uint64(l)) + l
	}
	return n
}

func (m *RecordGetResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRecord(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRecord(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRecord(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRecord(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RecordGetResp_TimeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Roomid != 0 {
		n += 1 + sovRecord(uint64(m.Roomid))
	}
	l = len(m.RecentEndTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	return n
}

func (m *RecordLiveTimeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roomids) > 0 {
		l = 0
		for _, e := range m.Roomids {
			l += sovRecord(uint64(e))
		}
		n += 1 + sovRecord(uint64(l)) + l
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	return n
}

func (m *RecordLiveTimeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRecord(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRecord(uint64(l))
			}
			mapEntrySize := 1 + sovRecord(uint64(k)) + l
			n += mapEntrySize + 1 + sovRecord(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RecordLiveTimeResp_LiveInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Roomid != 0 {
		n += 1 + sovRecord(uint64(m.Roomid))
	}
	if m.Uid != 0 {
		n += 1 + sovRecord(uint64(m.Uid))
	}
	if m.AreaV2Id != 0 {
		n += 1 + sovRecord(uint64(m.AreaV2Id))
	}
	if m.AreaV2ParentId != 0 {
		n += 1 + sovRecord(uint64(m.AreaV2ParentId))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.MaxOnlineNum != 0 {
		n += 1 + sovRecord(uint64(m.MaxOnlineNum))
	}
	if m.Attention != 0 {
		n += 1 + sovRecord(uint64(m.Attention))
	}
	if m.IsCut != 0 {
		n += 1 + sovRecord(uint64(m.IsCut))
	}
	return n
}

func (m *RecordAreasReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Roomid != 0 {
		n += 1 + sovRecord(uint64(m.Roomid))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	return n
}

func (m *RecordAreasResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRecord(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovRecord(uint64(l))
		}
	}
	return n
}

func (m *RecordAreasResp_List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRecord(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.ParentId != 0 {
		n += 1 + sovRecord(uint64(m.ParentId))
	}
	return n
}

func (m *RecordAreasResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRecord(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovRecord(uint64(l))
		}
	}
	return n
}

func (m *RecordAreaLiveReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Roomid != 0 {
		n += 1 + sovRecord(uint64(m.Roomid))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	l = len(m.AreaIds)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	return n
}

func (m *RecordAreaLiveResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRecord(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovRecord(uint64(l))
	}
	return n
}

func (m *RecordAreaLiveResp_List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.LiveTime != 0 {
		n += 1 + sovRecord(uint64(m.LiveTime))
	}
	if m.LiveNum != 0 {
		n += 1 + sovRecord(uint64(m.LiveNum))
	}
	if m.MaxOnline != 0 {
		n += 1 + sovRecord(uint64(m.MaxOnline))
	}
	return n
}

func (m *RecordAreaLiveResp_Count) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AllLiveTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.AllLiveDay != 0 {
		n += 1 + sovRecord(uint64(m.AllLiveDay))
	}
	if m.MaxOnline != 0 {
		n += 1 + sovRecord(uint64(m.MaxOnline))
	}
	return n
}

func (m *RecordAreaLiveResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovRecord(uint64(l))
		}
	}
	if m.Count != nil {
		l = m.Count.Size()
		n += 1 + l + sovRecord(uint64(l))
	}
	return n
}

func (m *RecordDayLiveReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Roomid != 0 {
		n += 1 + sovRecord(uint64(m.Roomid))
	}
	l = len(m.Day)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	return n
}

func (m *RecordDayLiveResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRecord(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovRecord(uint64(l))
	}
	return n
}

func (m *RecordDayLiveResp_List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.LiveTime != 0 {
		n += 1 + sovRecord(uint64(m.LiveTime))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovRecord(uint64(l))
	}
	if m.MaxOnline != 0 {
		n += 1 + sovRecord(uint64(m.MaxOnline))
	}
	return n
}

func (m *RecordDayLiveResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovRecord(uint64(l))
		}
	}
	return n
}

func sovRecord(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRecord(x uint64) (n int) {
	return sovRecord(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RecordSessionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordSessionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordSessionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sessionids = append(m.Sessionids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRecord
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Sessionids) == 0 {
					m.Sessionids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sessionids = append(m.Sessionids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessionids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordSessionResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordSessionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordSessionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int64]*RecordSessionResp_LiveInfo)
			}
			var mapkey int64
			var mapvalue *RecordSessionResp_LiveInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRecord
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRecord
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RecordSessionResp_LiveInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRecord(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRecord
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordSessionResp_LiveInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiveInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiveInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserCover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			m.Online = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Online |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JumpUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2Id", wireType)
			}
			m.AreaV2Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessionid", wireType)
			}
			m.Sessionid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sessionid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roomids = append(m.Roomids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRecord
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Roomids) == 0 {
					m.Roomids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roomids = append(m.Roomids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordGetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordGetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordGetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[string]*RecordGetResp_TimeInfo)
			}
			var mapkey string
			var mapvalue *RecordGetResp_TimeInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRecord
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRecord
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRecord
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RecordGetResp_TimeInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRecord(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRecord
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordGetResp_TimeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentEndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecentEndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordLiveTimeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordLiveTimeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordLiveTimeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roomids = append(m.Roomids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRecord
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Roomids) == 0 {
					m.Roomids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roomids = append(m.Roomids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomids", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordLiveTimeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordLiveTimeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordLiveTimeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int64]*RecordLiveTimeResp_LiveInfo)
			}
			var mapkey int64
			var mapvalue *RecordLiveTimeResp_LiveInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRecord
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRecord
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRecord
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RecordLiveTimeResp_LiveInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRecord(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRecord
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordLiveTimeResp_LiveInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiveInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiveInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2Id", wireType)
			}
			m.AreaV2Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2ParentId", wireType)
			}
			m.AreaV2ParentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2ParentId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOnlineNum", wireType)
			}
			m.MaxOnlineNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOnlineNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attention", wireType)
			}
			m.Attention = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attention |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCut", wireType)
			}
			m.IsCut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCut |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordAreasReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordAreasReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordAreasReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordAreasResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordAreasResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordAreasResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &RecordAreasResp_Data{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordAreasResp_List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			m.ParentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordAreasResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RecordAreasResp_List{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordAreaLiveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordAreaLiveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordAreaLiveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AreaIds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordAreaLiveResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordAreaLiveResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordAreaLiveResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &RecordAreaLiveResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordAreaLiveResp_List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveTime", wireType)
			}
			m.LiveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveNum", wireType)
			}
			m.LiveNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOnline", wireType)
			}
			m.MaxOnline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOnline |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordAreaLiveResp_Count) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Count: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Count: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllLiveTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllLiveTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllLiveDay", wireType)
			}
			m.AllLiveDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllLiveDay |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOnline", wireType)
			}
			m.MaxOnline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOnline |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordAreaLiveResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RecordAreaLiveResp_List{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Count == nil {
				m.Count = &RecordAreaLiveResp_Count{}
			}
			if err := m.Count.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordDayLiveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordDayLiveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordDayLiveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Day", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Day = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordDayLiveResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordDayLiveResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordDayLiveResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &RecordDayLiveResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordDayLiveResp_List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveTime", wireType)
			}
			m.LiveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOnline", wireType)
			}
			m.MaxOnline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOnline |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordDayLiveResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecord
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RecordDayLiveResp_List{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRecord(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRecord
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecord
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRecord
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRecord
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRecord(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRecord = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRecord   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("v1/Record.proto", fileDescriptor_Record_7724024fde989e5d) }

var fileDescriptor_Record_7724024fde989e5d = []byte{
	// 1306 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4d, 0x6f, 0xdc, 0x44,
	0x18, 0xae, 0xd7, 0xfb, 0xf9, 0x66, 0x93, 0x36, 0x83, 0x40, 0xee, 0x12, 0xd6, 0xc1, 0xa2, 0x90,
	0x06, 0xb2, 0x51, 0x16, 0x55, 0xaa, 0x8a, 0x54, 0xc2, 0x26, 0x55, 0x48, 0x54, 0xbe, 0x86, 0x8f,
	0x03, 0x12, 0x5a, 0x39, 0xeb, 0x69, 0x6a, 0xea, 0xb5, 0x13, 0x7f, 0xac, 0x9a, 0x4b, 0x7f, 0x03,
	0x42, 0x5c, 0x10, 0x27, 0x6e, 0xfc, 0x02, 0x7e, 0x01, 0x07, 0x2e, 0x48, 0x15, 0x17, 0xe0, 0x62,
	0xa1, 0xe4, 0xe6, 0x1f, 0x80, 0x38, 0xa2, 0xf9, 0xf0, 0xda, 0xde, 0x78, 0xbd, 0x09, 0xc9, 0x65,
	0x3c, 0xf3, 0x78, 0x3c, 0xef, 0x3b, 0xef, 0xfb, 0xbc, 0xcf, 0xcc, 0x2e, 0x5c, 0x1f, 0x6d, 0xac,
	0x63, 0x32, 0x70, 0x5c, 0xa3, 0x73, 0xe8, 0x3a, 0xbe, 0x83, 0x9a, 0x96, 0x39, 0x22, 0x7d, 0x43,
	0xf7, 0xf5, 0xce, 0x68, 0xa3, 0xb5, 0x76, 0x60, 0xfa, 0x8f, 0x83, 0xfd, 0xce, 0xc0, 0x19, 0xae,
	0x1f, 0x38, 0x07, 0xce, 0x3a, 0x9b, 0xb4, 0x1f, 0x3c, 0x62, 0x23, 0x36, 0x60, 0x3d, 0xfe, 0xb1,
	0xd6, 0x83, 0x1b, 0x7c, 0xb1, 0x4f, 0x89, 0xe7, 0x99, 0x8e, 0x8d, 0xc9, 0x11, 0xea, 0x00, 0x78,
	0x7c, 0x64, 0x1a, 0x9e, 0x22, 0x2d, 0xcb, 0x2b, 0x72, 0x6f, 0x21, 0x0a, 0xd5, 0x14, 0x8a, 0x53,
	0x7d, 0xed, 0xb7, 0x0a, 0x2c, 0x4e, 0x2c, 0xe2, 0x1d, 0xa2, 0x25, 0x28, 0x0f, 0x1c, 0x83, 0x28,
	0xd2, 0xb2, 0xb4, 0x22, 0xf7, 0xea, 0x51, 0xa8, 0xb2, 0x31, 0x66, 0x2d, 0xba, 0x09, 0xf2, 0xd0,
	0x3b, 0x50, 0x4a, 0xcb, 0xd2, 0x4a, 0xa3, 0x57, 0x8b, 0x42, 0x95, 0x0e, 0x31, 0x6d, 0xd0, 0x0e,
	0x94, 0xe9, 0x66, 0x14, 0x79, 0x59, 0x5e, 0x99, 0xeb, 0xde, 0xee, 0xa4, 0xb7, 0xd7, 0x39, 0x63,
	0xa7, 0xb3, 0xad, 0xfb, 0xfa, 0x03, 0xdb, 0x77, 0x8f, 0xb9, 0x0d, 0x3a, 0x11, 0xb3, 0xb6, 0xa5,
	0x43, 0x63, 0xfc, 0x12, 0xdd, 0x00, 0xf9, 0x09, 0x39, 0xe6, 0xde, 0x60, 0xda, 0x45, 0xf7, 0xa1,
	0x32, 0xd2, 0xad, 0x80, 0x30, 0x27, 0xe6, 0xba, 0x2b, 0xb3, 0x0c, 0x3d, 0x34, 0x47, 0x64, 0xd7,
	0x7e, 0xe4, 0x60, 0xfe, 0xd9, 0xbd, 0xd2, 0x5d, 0xa9, 0xf5, 0xbb, 0x0c, 0xf5, 0x18, 0x47, 0x2f,
	0x41, 0xc9, 0x34, 0xc4, 0x7e, 0xab, 0x51, 0xa8, 0x96, 0x4c, 0x03, 0x97, 0x4c, 0x03, 0x69, 0x50,
	0x75, 0x1d, 0x67, 0x68, 0x1a, 0xcc, 0x92, 0xdc, 0x83, 0x28, 0x54, 0x05, 0x82, 0xc5, 0x93, 0xc6,
	0x23, 0x30, 0x0d, 0x45, 0x66, 0x13, 0x58, 0x3c, 0x02, 0xd3, 0xc0, 0xb4, 0x41, 0x2a, 0x54, 0x7c,
	0xd3, 0xb7, 0x88, 0x52, 0x66, 0xc1, 0x6a, 0x44, 0xa1, 0xca, 0x01, 0xcc, 0x1f, 0x74, 0xc2, 0xc0,
	0x19, 0x11, 0x57, 0xa9, 0x24, 0x13, 0x18, 0x80, 0xf9, 0x03, 0xad, 0x01, 0x04, 0x1e, 0x71, 0xfb,
	0x7c, 0x56, 0x95, 0xcd, 0x62, 0x09, 0x4d, 0x50, 0xdc, 0xa0, 0xfd, 0x2d, 0x36, 0x5d, 0x83, 0xaa,
	0x63, 0x5b, 0xa6, 0x4d, 0x94, 0x5a, 0xe2, 0x2f, 0x47, 0xb0, 0x78, 0xa2, 0x37, 0xa0, 0xfe, 0x75,
	0x30, 0x3c, 0xec, 0x07, 0xae, 0xa5, 0xd4, 0xd9, 0x82, 0xcd, 0x28, 0x54, 0xc7, 0x18, 0xae, 0xd1,
	0xde, 0xe7, 0xae, 0x85, 0xde, 0x02, 0xd0, 0x5d, 0xa2, 0xf7, 0x47, 0xdd, 0xbe, 0x69, 0x28, 0x0d,
	0xb6, 0x20, 0xb3, 0x9d, 0xa0, 0xb8, 0x4e, 0xfb, 0x5f, 0x74, 0x77, 0x0d, 0xea, 0xa9, 0xe7, 0xeb,
	0xae, 0xdf, 0xf7, 0xcd, 0x21, 0x51, 0x20, 0xf1, 0x34, 0x41, 0x71, 0x83, 0xf5, 0x3f, 0x33, 0x87,
	0xcc, 0x0b, 0x62, 0x1b, 0x7c, 0xf2, 0x5c, 0xe2, 0x45, 0x8c, 0xe1, 0x1a, 0xb1, 0x0d, 0x36, 0xf1,
	0x4d, 0x68, 0x8c, 0x09, 0xab, 0x34, 0x99, 0x13, 0xf3, 0x51, 0xa8, 0x26, 0x20, 0x4e, 0xba, 0xda,
	0x1d, 0x68, 0xf2, 0xec, 0xef, 0x10, 0x9f, 0xd6, 0xc3, 0x2d, 0xa8, 0xf1, 0x2c, 0xc5, 0xc5, 0x30,
	0x17, 0x85, 0x6a, 0x0c, 0xe1, 0xb8, 0xa3, 0xfd, 0x55, 0x82, 0xf9, 0xd4, 0x77, 0x97, 0x29, 0x81,
	0xad, 0x4c, 0x09, 0xdc, 0xca, 0x63, 0xa6, 0xb0, 0x51, 0x40, 0xff, 0xaf, 0xa6, 0xd0, 0xbf, 0xc1,
	0xe9, 0x7f, 0x2f, 0x4b, 0xff, 0xd7, 0x8a, 0x8c, 0xd0, 0x18, 0x4e, 0x52, 0xff, 0x09, 0xd4, 0x63,
	0x38, 0xc5, 0x70, 0x69, 0x2a, 0xc3, 0xdf, 0x81, 0xeb, 0x2e, 0x19, 0x10, 0xdb, 0xef, 0x8f, 0x53,
	0xc6, 0xb7, 0xfe, 0x42, 0x14, 0xaa, 0x93, 0xaf, 0xf0, 0x3c, 0x07, 0x1e, 0xf0, 0xfc, 0x69, 0xdf,
	0x4a, 0xb1, 0xc4, 0xd0, 0x6a, 0xa3, 0xd0, 0xf9, 0x13, 0x33, 0x41, 0xaa, 0xd2, 0x45, 0x48, 0x25,
	0x17, 0x90, 0x4a, 0xfb, 0xbe, 0x02, 0x68, 0xd2, 0xa9, 0xcb, 0x64, 0xfd, 0xfd, 0x4c, 0xd6, 0x57,
	0xf3, 0x12, 0x92, 0x36, 0x54, 0x90, 0xfa, 0xfd, 0x62, 0xe5, 0x7b, 0x37, 0x9b, 0xfa, 0xdb, 0x33,
	0x2d, 0xe5, 0x49, 0xdf, 0x0f, 0x69, 0xe9, 0x3b, 0x0f, 0x01, 0x84, 0xc4, 0x95, 0x72, 0x24, 0x2e,
	0x2b, 0x12, 0xf2, 0x0c, 0x91, 0xd8, 0x84, 0xc5, 0x18, 0x3f, 0xd4, 0x5d, 0x4a, 0x1b, 0xd3, 0x60,
	0xe2, 0x28, 0xf7, 0x5e, 0x8c, 0x42, 0xf5, 0xec, 0x4b, 0xbc, 0xc0, 0xbf, 0xfd, 0x98, 0x01, 0x67,
	0x64, 0xa6, 0x72, 0x11, 0x46, 0x54, 0x8b, 0x64, 0xe6, 0x2e, 0x2c, 0x0c, 0xf5, 0xa7, 0x7d, 0xae,
	0x91, 0x7d, 0x3b, 0x18, 0x0a, 0x05, 0x45, 0x51, 0xa8, 0x4e, 0xbc, 0xc1, 0xcd, 0xa1, 0xfe, 0xf4,
	0x23, 0x36, 0xfc, 0x30, 0x18, 0x52, 0x81, 0xd2, 0x7d, 0x9f, 0xd8, 0xbe, 0xe9, 0xd8, 0x4c, 0x50,
	0x85, 0x40, 0x8d, 0x41, 0x9c, 0x74, 0xd1, 0xab, 0x50, 0x35, 0xbd, 0xfe, 0x20, 0xf0, 0x85, 0x9e,
	0xb2, 0x68, 0x73, 0x04, 0x57, 0x4c, 0x6f, 0x2b, 0xf0, 0x35, 0x0c, 0x0b, 0x3c, 0x8f, 0xef, 0xb9,
	0x44, 0xf7, 0x68, 0xb1, 0x9c, 0x27, 0x45, 0x4b, 0x8c, 0x81, 0x71, 0x8d, 0xc4, 0xac, 0x22, 0x8c,
	0x55, 0x44, 0xfb, 0xa7, 0x04, 0xd7, 0x33, 0x8b, 0x5e, 0x86, 0xec, 0x9b, 0x19, 0xb2, 0x6b, 0x79,
	0x14, 0x1c, 0x5b, 0x61, 0x4c, 0x3f, 0x43, 0xf2, 0xc7, 0x50, 0x7e, 0x68, 0x7a, 0xfe, 0xd4, 0x63,
	0x77, 0x09, 0xca, 0xb6, 0x3e, 0xcc, 0x6c, 0x86, 0x8e, 0x31, 0x6b, 0xd1, 0x2a, 0x34, 0x12, 0xf2,
	0xc8, 0x49, 0xc0, 0x13, 0xd2, 0xd4, 0x0f, 0x05, 0x5d, 0x5a, 0xcf, 0xa0, 0x4c, 0x3d, 0xf8, 0x9f,
	0x96, 0x36, 0xa1, 0x6c, 0x99, 0x9e, 0x7f, 0xbe, 0x9d, 0xd2, 0x1d, 0xf1, 0x15, 0xe8, 0x37, 0x98,
	0xb5, 0xda, 0xb3, 0x58, 0xfc, 0xe8, 0x3c, 0x5a, 0x73, 0x57, 0x92, 0x4f, 0x4a, 0x6b, 0x56, 0x2a,
	0x54, 0x3f, 0x53, 0x42, 0x17, 0x63, 0xb8, 0x46, 0x7b, 0xbb, 0x86, 0xa7, 0xfd, 0x5b, 0x8e, 0x85,
	0x2e, 0x71, 0xe0, 0x6a, 0x8e, 0x37, 0x69, 0xda, 0xf1, 0x96, 0x36, 0x94, 0x9f, 0xfe, 0x9f, 0x24,
	0x91, 0xff, 0x78, 0x93, 0x52, 0xee, 0x26, 0x57, 0xa1, 0xc1, 0x96, 0x1f, 0x6b, 0xbf, 0xc8, 0xf3,
	0x18, 0xc4, 0x75, 0x4b, 0x48, 0x1d, 0x0d, 0x08, 0x83, 0x69, 0xe1, 0x72, 0x4a, 0xb0, 0x80, 0xc4,
	0x18, 0xae, 0xd1, 0x1e, 0xad, 0xd6, 0x35, 0x80, 0xa4, 0x9a, 0x85, 0xf4, 0x30, 0xfd, 0x48, 0x50,
	0xdc, 0x18, 0xd7, 0x77, 0xeb, 0x47, 0x09, 0x2a, 0x5b, 0x4e, 0x60, 0xfb, 0xe8, 0x0e, 0xcc, 0xeb,
	0x96, 0xd5, 0x4f, 0x3c, 0xe2, 0x4e, 0x2f, 0x46, 0xa1, 0x9a, 0x7d, 0x81, 0xe7, 0x74, 0xcb, 0x8a,
	0x35, 0x18, 0x75, 0xa1, 0x39, 0x7e, 0x6b, 0xe8, 0xc7, 0x62, 0x1f, 0x37, 0xa2, 0x50, 0xcd, 0xe0,
	0x18, 0xc4, 0x47, 0xdb, 0xfa, 0xf1, 0x84, 0x8f, 0xf2, 0x2c, 0x1f, 0xbf, 0x93, 0x04, 0xc9, 0xb7,
	0x04, 0x5d, 0xa5, 0xe9, 0x77, 0x8f, 0x4c, 0x72, 0xf2, 0x18, 0x8b, 0x76, 0xe8, 0x95, 0x34, 0xb0,
	0x7d, 0x71, 0xc2, 0xbc, 0x3e, 0x73, 0x15, 0x16, 0x9e, 0xf8, 0xea, 0x1a, 0xd8, 0x3e, 0xe6, 0x0f,
	0xed, 0x93, 0xf8, 0xf7, 0xc9, 0xb6, 0x7e, 0x7c, 0x11, 0xe6, 0xdf, 0x04, 0x39, 0x0e, 0x94, 0x60,
	0x1f, 0x8d, 0x0f, 0x6d, 0xb4, 0x9f, 0xe5, 0xb8, 0x9c, 0xc6, 0x6b, 0x5e, 0x86, 0xcc, 0xbd, 0x0c,
	0x99, 0x73, 0xaf, 0x51, 0x29, 0x3b, 0xf9, 0x5c, 0xfe, 0xe3, 0xea, 0xb9, 0x9c, 0x3d, 0xe2, 0xe4,
	0x8b, 0x1c, 0x71, 0xe5, 0xa2, 0x23, 0x2e, 0x4b, 0xab, 0xca, 0x2c, 0x5a, 0xed, 0x09, 0x56, 0xf5,
	0x32, 0xac, 0x9a, 0x19, 0xa5, 0x3c, 0x52, 0x75, 0x7f, 0x91, 0xa1, 0xca, 0xa7, 0xa2, 0x3d, 0xa8,
	0x89, 0xfb, 0x3a, 0x6a, 0x17, 0xfe, 0x6e, 0x3b, 0x6a, 0xa9, 0x33, 0x7e, 0xd7, 0xa1, 0xfb, 0x20,
	0x1f, 0x10, 0x1f, 0xb5, 0xa6, 0x5e, 0x80, 0x8f, 0x5a, 0x2f, 0x17, 0x5c, 0x8e, 0xd1, 0x07, 0x90,
	0x44, 0x5d, 0x2d, 0xbe, 0x4a, 0x1d, 0xb5, 0x96, 0x67, 0xdd, 0xb5, 0xd0, 0x36, 0x54, 0xa8, 0xee,
	0x7a, 0x68, 0xa9, 0xe0, 0xa4, 0x38, 0x6a, 0xbd, 0x52, 0x78, 0x8e, 0x50, 0xa7, 0x74, 0x51, 0x5f,
	0xf9, 0x4e, 0xa5, 0x8e, 0x92, 0x7c, 0xa7, 0x32, 0x52, 0xbf, 0x07, 0x35, 0x83, 0xa7, 0x27, 0x3f,
	0xde, 0x49, 0x75, 0xe6, 0xc7, 0x3b, 0x95, 0xdb, 0xde, 0xd2, 0xaf, 0x27, 0x6d, 0xe9, 0xf9, 0x49,
	0x5b, 0xfa, 0xfb, 0xa4, 0x2d, 0x7d, 0x73, 0xda, 0xbe, 0xf6, 0xfc, 0xb4, 0x7d, 0xed, 0xcf, 0xd3,
	0xf6, 0xb5, 0x2f, 0x4b, 0xa3, 0x8d, 0xfd, 0x2a, 0xfb, 0x5f, 0xe2, 0xed, 0xff, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x0d, 0xdf, 0x2c, 0xaf, 0xe7, 0x10, 0x00, 0x00,
}
