// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/DanmuConf.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DanmuConfGetAllReq struct {
	// 房间号
	Roomid int64 `protobuf:"varint,1,opt,name=roomid,proto3" json:"roomid"`
	// 用户id(优先取登录态)
	Uid int64 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid"`
}

func (m *DanmuConfGetAllReq) Reset()         { *m = DanmuConfGetAllReq{} }
func (m *DanmuConfGetAllReq) String() string { return proto.CompactTextString(m) }
func (*DanmuConfGetAllReq) ProtoMessage()    {}
func (*DanmuConfGetAllReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_DanmuConf_aa3d2c061886559f, []int{0}
}
func (m *DanmuConfGetAllReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmuConfGetAllReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmuConfGetAllReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DanmuConfGetAllReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmuConfGetAllReq.Merge(dst, src)
}
func (m *DanmuConfGetAllReq) XXX_Size() int {
	return m.Size()
}
func (m *DanmuConfGetAllReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmuConfGetAllReq.DiscardUnknown(m)
}

var xxx_messageInfo_DanmuConfGetAllReq proto.InternalMessageInfo

func (m *DanmuConfGetAllReq) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *DanmuConfGetAllReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type DanmuConfGetAllResp struct {
	// code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data *DanmuConfGetAllResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *DanmuConfGetAllResp) Reset()         { *m = DanmuConfGetAllResp{} }
func (m *DanmuConfGetAllResp) String() string { return proto.CompactTextString(m) }
func (*DanmuConfGetAllResp) ProtoMessage()    {}
func (*DanmuConfGetAllResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_DanmuConf_aa3d2c061886559f, []int{1}
}
func (m *DanmuConfGetAllResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmuConfGetAllResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmuConfGetAllResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DanmuConfGetAllResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmuConfGetAllResp.Merge(dst, src)
}
func (m *DanmuConfGetAllResp) XXX_Size() int {
	return m.Size()
}
func (m *DanmuConfGetAllResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmuConfGetAllResp.DiscardUnknown(m)
}

var xxx_messageInfo_DanmuConfGetAllResp proto.InternalMessageInfo

func (m *DanmuConfGetAllResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DanmuConfGetAllResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *DanmuConfGetAllResp) GetData() *DanmuConfGetAllResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type DanmuConfGetAllResp_Data struct {
	// 模式
	Mode int64 `protobuf:"varint,1,opt,name=mode,proto3" json:"mode"`
	// 颜色
	Color int64 `protobuf:"varint,2,opt,name=color,proto3" json:"color"`
	// 长度
	Length int64 `protobuf:"varint,3,opt,name=length,proto3" json:"length"`
	// roomid
	Roomid int64 `protobuf:"varint,4,opt,name=roomid,proto3" json:"roomid"`
}

func (m *DanmuConfGetAllResp_Data) Reset()         { *m = DanmuConfGetAllResp_Data{} }
func (m *DanmuConfGetAllResp_Data) String() string { return proto.CompactTextString(m) }
func (*DanmuConfGetAllResp_Data) ProtoMessage()    {}
func (*DanmuConfGetAllResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_DanmuConf_aa3d2c061886559f, []int{1, 0}
}
func (m *DanmuConfGetAllResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmuConfGetAllResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmuConfGetAllResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DanmuConfGetAllResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmuConfGetAllResp_Data.Merge(dst, src)
}
func (m *DanmuConfGetAllResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *DanmuConfGetAllResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmuConfGetAllResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_DanmuConfGetAllResp_Data proto.InternalMessageInfo

func (m *DanmuConfGetAllResp_Data) GetMode() int64 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *DanmuConfGetAllResp_Data) GetColor() int64 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *DanmuConfGetAllResp_Data) GetLength() int64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DanmuConfGetAllResp_Data) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

type DanmuConfAddByTypeReq struct {
	// color:颜色, mode:弹幕模式, length:弹幕长度
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type"`
	// uid
	Uid int64 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid"`
	// 房间号,传0为全局
	Roomid int64 `protobuf:"varint,3,opt,name=roomid,proto3" json:"roomid"`
	// 不填则为永久
	Expire int64 `protobuf:"varint,4,opt,name=expire,proto3" json:"expire"`
	// 配置值
	Value int64 `protobuf:"varint,5,opt,name=value,proto3" json:"value"`
}

func (m *DanmuConfAddByTypeReq) Reset()         { *m = DanmuConfAddByTypeReq{} }
func (m *DanmuConfAddByTypeReq) String() string { return proto.CompactTextString(m) }
func (*DanmuConfAddByTypeReq) ProtoMessage()    {}
func (*DanmuConfAddByTypeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_DanmuConf_aa3d2c061886559f, []int{2}
}
func (m *DanmuConfAddByTypeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmuConfAddByTypeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmuConfAddByTypeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DanmuConfAddByTypeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmuConfAddByTypeReq.Merge(dst, src)
}
func (m *DanmuConfAddByTypeReq) XXX_Size() int {
	return m.Size()
}
func (m *DanmuConfAddByTypeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmuConfAddByTypeReq.DiscardUnknown(m)
}

var xxx_messageInfo_DanmuConfAddByTypeReq proto.InternalMessageInfo

func (m *DanmuConfAddByTypeReq) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *DanmuConfAddByTypeReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DanmuConfAddByTypeReq) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *DanmuConfAddByTypeReq) GetExpire() int64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *DanmuConfAddByTypeReq) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type DanmuConfAddByTypeResp struct {
	// code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data *DanmuConfAddByTypeResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *DanmuConfAddByTypeResp) Reset()         { *m = DanmuConfAddByTypeResp{} }
func (m *DanmuConfAddByTypeResp) String() string { return proto.CompactTextString(m) }
func (*DanmuConfAddByTypeResp) ProtoMessage()    {}
func (*DanmuConfAddByTypeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_DanmuConf_aa3d2c061886559f, []int{3}
}
func (m *DanmuConfAddByTypeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmuConfAddByTypeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmuConfAddByTypeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DanmuConfAddByTypeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmuConfAddByTypeResp.Merge(dst, src)
}
func (m *DanmuConfAddByTypeResp) XXX_Size() int {
	return m.Size()
}
func (m *DanmuConfAddByTypeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmuConfAddByTypeResp.DiscardUnknown(m)
}

var xxx_messageInfo_DanmuConfAddByTypeResp proto.InternalMessageInfo

func (m *DanmuConfAddByTypeResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DanmuConfAddByTypeResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *DanmuConfAddByTypeResp) GetData() *DanmuConfAddByTypeResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type DanmuConfAddByTypeResp_Data struct {
	// true:操作成功 false:操作失败
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result"`
}

func (m *DanmuConfAddByTypeResp_Data) Reset()         { *m = DanmuConfAddByTypeResp_Data{} }
func (m *DanmuConfAddByTypeResp_Data) String() string { return proto.CompactTextString(m) }
func (*DanmuConfAddByTypeResp_Data) ProtoMessage()    {}
func (*DanmuConfAddByTypeResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_DanmuConf_aa3d2c061886559f, []int{3, 0}
}
func (m *DanmuConfAddByTypeResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmuConfAddByTypeResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmuConfAddByTypeResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DanmuConfAddByTypeResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmuConfAddByTypeResp_Data.Merge(dst, src)
}
func (m *DanmuConfAddByTypeResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *DanmuConfAddByTypeResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmuConfAddByTypeResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_DanmuConfAddByTypeResp_Data proto.InternalMessageInfo

func (m *DanmuConfAddByTypeResp_Data) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type DanmuConfGetAllPrivilegeReq struct {
	// 用户id
	Uid int64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid"`
}

func (m *DanmuConfGetAllPrivilegeReq) Reset()         { *m = DanmuConfGetAllPrivilegeReq{} }
func (m *DanmuConfGetAllPrivilegeReq) String() string { return proto.CompactTextString(m) }
func (*DanmuConfGetAllPrivilegeReq) ProtoMessage()    {}
func (*DanmuConfGetAllPrivilegeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_DanmuConf_aa3d2c061886559f, []int{4}
}
func (m *DanmuConfGetAllPrivilegeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmuConfGetAllPrivilegeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmuConfGetAllPrivilegeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DanmuConfGetAllPrivilegeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmuConfGetAllPrivilegeReq.Merge(dst, src)
}
func (m *DanmuConfGetAllPrivilegeReq) XXX_Size() int {
	return m.Size()
}
func (m *DanmuConfGetAllPrivilegeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmuConfGetAllPrivilegeReq.DiscardUnknown(m)
}

var xxx_messageInfo_DanmuConfGetAllPrivilegeReq proto.InternalMessageInfo

func (m *DanmuConfGetAllPrivilegeReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type DanmuConfGetAllPrivilegeResp struct {
	//
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	//
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message"`
	//
	Data []*DanmuConfGetAllPrivilegeResp_Data `protobuf:"bytes,4,rep,name=data" json:"data"`
}

func (m *DanmuConfGetAllPrivilegeResp) Reset()         { *m = DanmuConfGetAllPrivilegeResp{} }
func (m *DanmuConfGetAllPrivilegeResp) String() string { return proto.CompactTextString(m) }
func (*DanmuConfGetAllPrivilegeResp) ProtoMessage()    {}
func (*DanmuConfGetAllPrivilegeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_DanmuConf_aa3d2c061886559f, []int{5}
}
func (m *DanmuConfGetAllPrivilegeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmuConfGetAllPrivilegeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmuConfGetAllPrivilegeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DanmuConfGetAllPrivilegeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmuConfGetAllPrivilegeResp.Merge(dst, src)
}
func (m *DanmuConfGetAllPrivilegeResp) XXX_Size() int {
	return m.Size()
}
func (m *DanmuConfGetAllPrivilegeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmuConfGetAllPrivilegeResp.DiscardUnknown(m)
}

var xxx_messageInfo_DanmuConfGetAllPrivilegeResp proto.InternalMessageInfo

func (m *DanmuConfGetAllPrivilegeResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DanmuConfGetAllPrivilegeResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *DanmuConfGetAllPrivilegeResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *DanmuConfGetAllPrivilegeResp) GetData() []*DanmuConfGetAllPrivilegeResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type DanmuConfGetAllPrivilegeResp_Data struct {
	// UID
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid"`
	// roomID
	Roomid string `protobuf:"bytes,2,opt,name=roomid,proto3" json:"roomid"`
	// 0：color，1：mode，2：length
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type"`
	//
	Value string `protobuf:"bytes,4,opt,name=value,proto3" json:"value"`
	// 初始0，佩戴中1
	Status string `protobuf:"bytes,5,opt,name=status,proto3" json:"status"`
	//
	ExpiredAt string `protobuf:"bytes,6,opt,name=expired_at,json=expiredAt,proto3" json:"expired_at"`
}

func (m *DanmuConfGetAllPrivilegeResp_Data) Reset()         { *m = DanmuConfGetAllPrivilegeResp_Data{} }
func (m *DanmuConfGetAllPrivilegeResp_Data) String() string { return proto.CompactTextString(m) }
func (*DanmuConfGetAllPrivilegeResp_Data) ProtoMessage()    {}
func (*DanmuConfGetAllPrivilegeResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_DanmuConf_aa3d2c061886559f, []int{5, 0}
}
func (m *DanmuConfGetAllPrivilegeResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DanmuConfGetAllPrivilegeResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DanmuConfGetAllPrivilegeResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DanmuConfGetAllPrivilegeResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DanmuConfGetAllPrivilegeResp_Data.Merge(dst, src)
}
func (m *DanmuConfGetAllPrivilegeResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *DanmuConfGetAllPrivilegeResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_DanmuConfGetAllPrivilegeResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_DanmuConfGetAllPrivilegeResp_Data proto.InternalMessageInfo

func (m *DanmuConfGetAllPrivilegeResp_Data) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *DanmuConfGetAllPrivilegeResp_Data) GetRoomid() string {
	if m != nil {
		return m.Roomid
	}
	return ""
}

func (m *DanmuConfGetAllPrivilegeResp_Data) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *DanmuConfGetAllPrivilegeResp_Data) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *DanmuConfGetAllPrivilegeResp_Data) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *DanmuConfGetAllPrivilegeResp_Data) GetExpiredAt() string {
	if m != nil {
		return m.ExpiredAt
	}
	return ""
}

func init() {
	proto.RegisterType((*DanmuConfGetAllReq)(nil), "userext.v1.DanmuConfGetAllReq")
	proto.RegisterType((*DanmuConfGetAllResp)(nil), "userext.v1.DanmuConfGetAllResp")
	proto.RegisterType((*DanmuConfGetAllResp_Data)(nil), "userext.v1.DanmuConfGetAllResp.Data")
	proto.RegisterType((*DanmuConfAddByTypeReq)(nil), "userext.v1.DanmuConfAddByTypeReq")
	proto.RegisterType((*DanmuConfAddByTypeResp)(nil), "userext.v1.DanmuConfAddByTypeResp")
	proto.RegisterType((*DanmuConfAddByTypeResp_Data)(nil), "userext.v1.DanmuConfAddByTypeResp.Data")
	proto.RegisterType((*DanmuConfGetAllPrivilegeReq)(nil), "userext.v1.DanmuConfGetAllPrivilegeReq")
	proto.RegisterType((*DanmuConfGetAllPrivilegeResp)(nil), "userext.v1.DanmuConfGetAllPrivilegeResp")
	proto.RegisterType((*DanmuConfGetAllPrivilegeResp_Data)(nil), "userext.v1.DanmuConfGetAllPrivilegeResp.Data")
}
func (m *DanmuConfGetAllReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmuConfGetAllReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Roomid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Roomid))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *DanmuConfGetAllResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmuConfGetAllResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Data.Size()))
		n1, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *DanmuConfGetAllResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmuConfGetAllResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Mode))
	}
	if m.Color != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Color))
	}
	if m.Length != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Length))
	}
	if m.Roomid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Roomid))
	}
	return i, nil
}

func (m *DanmuConfAddByTypeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmuConfAddByTypeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Uid))
	}
	if m.Roomid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Roomid))
	}
	if m.Expire != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Expire))
	}
	if m.Value != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *DanmuConfAddByTypeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmuConfAddByTypeResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Data.Size()))
		n2, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *DanmuConfAddByTypeResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmuConfAddByTypeResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DanmuConfGetAllPrivilegeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmuConfGetAllPrivilegeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *DanmuConfGetAllPrivilegeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmuConfGetAllPrivilegeResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDanmuConf(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DanmuConfGetAllPrivilegeResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanmuConfGetAllPrivilegeResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.Roomid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Roomid)))
		i += copy(dAtA[i:], m.Roomid)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.ExpiredAt) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDanmuConf(dAtA, i, uint64(len(m.ExpiredAt)))
		i += copy(dAtA[i:], m.ExpiredAt)
	}
	return i, nil
}

func encodeVarintDanmuConf(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DanmuConfGetAllReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Roomid != 0 {
		n += 1 + sovDanmuConf(uint64(m.Roomid))
	}
	if m.Uid != 0 {
		n += 1 + sovDanmuConf(uint64(m.Uid))
	}
	return n
}

func (m *DanmuConfGetAllResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDanmuConf(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	return n
}

func (m *DanmuConfGetAllResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovDanmuConf(uint64(m.Mode))
	}
	if m.Color != 0 {
		n += 1 + sovDanmuConf(uint64(m.Color))
	}
	if m.Length != 0 {
		n += 1 + sovDanmuConf(uint64(m.Length))
	}
	if m.Roomid != 0 {
		n += 1 + sovDanmuConf(uint64(m.Roomid))
	}
	return n
}

func (m *DanmuConfAddByTypeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovDanmuConf(uint64(m.Uid))
	}
	if m.Roomid != 0 {
		n += 1 + sovDanmuConf(uint64(m.Roomid))
	}
	if m.Expire != 0 {
		n += 1 + sovDanmuConf(uint64(m.Expire))
	}
	if m.Value != 0 {
		n += 1 + sovDanmuConf(uint64(m.Value))
	}
	return n
}

func (m *DanmuConfAddByTypeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDanmuConf(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	return n
}

func (m *DanmuConfAddByTypeResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *DanmuConfGetAllPrivilegeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovDanmuConf(uint64(m.Uid))
	}
	return n
}

func (m *DanmuConfGetAllPrivilegeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDanmuConf(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovDanmuConf(uint64(l))
		}
	}
	return n
}

func (m *DanmuConfGetAllPrivilegeResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	l = len(m.Roomid)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	l = len(m.ExpiredAt)
	if l > 0 {
		n += 1 + l + sovDanmuConf(uint64(l))
	}
	return n
}

func sovDanmuConf(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDanmuConf(x uint64) (n int) {
	return sovDanmuConf(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DanmuConfGetAllReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DanmuConfGetAllReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DanmuConfGetAllReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDanmuConf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDanmuConf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DanmuConfGetAllResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DanmuConfGetAllResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DanmuConfGetAllResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &DanmuConfGetAllResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDanmuConf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDanmuConf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DanmuConfGetAllResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDanmuConf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDanmuConf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DanmuConfAddByTypeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DanmuConfAddByTypeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DanmuConfAddByTypeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDanmuConf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDanmuConf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DanmuConfAddByTypeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DanmuConfAddByTypeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DanmuConfAddByTypeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &DanmuConfAddByTypeResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDanmuConf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDanmuConf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DanmuConfAddByTypeResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDanmuConf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDanmuConf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DanmuConfGetAllPrivilegeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DanmuConfGetAllPrivilegeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DanmuConfGetAllPrivilegeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDanmuConf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDanmuConf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DanmuConfGetAllPrivilegeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DanmuConfGetAllPrivilegeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DanmuConfGetAllPrivilegeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &DanmuConfGetAllPrivilegeResp_Data{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDanmuConf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDanmuConf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DanmuConfGetAllPrivilegeResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roomid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDanmuConf
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpiredAt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDanmuConf(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDanmuConf
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDanmuConf(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDanmuConf
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDanmuConf
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDanmuConf
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDanmuConf
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDanmuConf(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDanmuConf = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDanmuConf   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("v1/DanmuConf.proto", fileDescriptor_DanmuConf_aa3d2c061886559f) }

var fileDescriptor_DanmuConf_aa3d2c061886559f = []byte{
	// 619 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xae, 0x63, 0x37, 0xad, 0x27, 0xd2, 0xef, 0x27, 0x2d, 0x02, 0x85, 0x10, 0xd9, 0xc1, 0x02,
	0x35, 0x42, 0x8a, 0xa3, 0x84, 0x0b, 0xd7, 0x84, 0x22, 0x84, 0xb8, 0xa0, 0x85, 0x13, 0x17, 0xe4,
	0xc4, 0x5b, 0xd7, 0x92, 0x1d, 0x27, 0xf6, 0x3a, 0x6a, 0x1e, 0x02, 0xa9, 0xcf, 0x80, 0xc4, 0x43,
	0x70, 0xe7, 0xc0, 0xb1, 0x37, 0x38, 0x59, 0x28, 0xb9, 0xf9, 0x29, 0xd0, 0xfe, 0x49, 0x9a, 0xb4,
	0x4e, 0x52, 0xa9, 0x97, 0x99, 0x9d, 0xf1, 0xee, 0xcc, 0xb7, 0xdf, 0x7c, 0xb6, 0x01, 0x4d, 0x3b,
	0xed, 0x53, 0x67, 0x14, 0xa6, 0xaf, 0xa3, 0xd1, 0x99, 0x3d, 0x8e, 0x23, 0x1a, 0x21, 0x48, 0x13,
	0x12, 0x93, 0x0b, 0x6a, 0x4f, 0x3b, 0xb5, 0x96, 0xe7, 0xd3, 0xf3, 0x74, 0x60, 0x0f, 0xa3, 0xb0,
	0xed, 0x45, 0x5e, 0xd4, 0xe6, 0x5b, 0x06, 0xe9, 0x19, 0x8f, 0x78, 0xc0, 0x57, 0xe2, 0xa8, 0xf5,
	0x11, 0xd0, 0xaa, 0xda, 0x5b, 0x42, 0x7b, 0x41, 0x80, 0xc9, 0x04, 0x59, 0x50, 0x8e, 0xa3, 0x28,
	0xf4, 0xdd, 0xaa, 0xd2, 0x50, 0x9a, 0x6a, 0x1f, 0xf2, 0xcc, 0x94, 0x19, 0x2c, 0x3d, 0x7a, 0x0c,
	0x6a, 0xea, 0xbb, 0xd5, 0x12, 0xdf, 0x70, 0x94, 0x67, 0x26, 0x0b, 0x31, 0x33, 0xd6, 0xb7, 0x12,
	0x3c, 0xb8, 0x55, 0x35, 0x19, 0xa3, 0x3a, 0x68, 0xc3, 0xc8, 0x25, 0xb2, 0xe8, 0x71, 0x9e, 0x99,
	0x3c, 0xc6, 0xdc, 0xb2, 0x82, 0x61, 0xe2, 0xf1, 0x82, 0xba, 0x28, 0x18, 0x26, 0x1e, 0x66, 0x06,
	0xf5, 0x41, 0x73, 0x1d, 0xea, 0x54, 0xd5, 0x86, 0xd2, 0xac, 0x74, 0x9f, 0xd9, 0xd7, 0xf7, 0xb5,
	0x0b, 0xfa, 0xd8, 0xa7, 0x0e, 0x75, 0x44, 0x79, 0x76, 0x0a, 0x73, 0x5b, 0xfb, 0xaa, 0x80, 0xc6,
	0x1e, 0x30, 0x14, 0xe1, 0x0d, 0x14, 0x21, 0x47, 0xc1, 0x2c, 0x32, 0xe1, 0x70, 0x18, 0x05, 0x51,
	0x2c, 0x2f, 0xa6, 0xe7, 0x99, 0x29, 0x12, 0x58, 0x38, 0xc6, 0x4d, 0x40, 0x46, 0x1e, 0x3d, 0xe7,
	0x68, 0x24, 0x37, 0x22, 0x83, 0xa5, 0x5f, 0xe3, 0x4f, 0xdb, 0xc6, 0x9f, 0xf5, 0x43, 0x81, 0x87,
	0x2b, 0xf0, 0x3d, 0xd7, 0xed, 0xcf, 0x3e, 0xcd, 0xc6, 0x84, 0xb1, 0x5f, 0x07, 0x8d, 0xce, 0xc6,
	0x02, 0xa0, 0x2e, 0x00, 0xb2, 0x18, 0x73, 0xbb, 0x83, 0xf7, 0xb5, 0xb6, 0xea, 0xd6, 0xb1, 0x59,
	0x50, 0x26, 0x17, 0x63, 0x3f, 0x26, 0xeb, 0xd0, 0x44, 0x06, 0x4b, 0xcf, 0x38, 0x98, 0x3a, 0x41,
	0x4a, 0xaa, 0x87, 0xd7, 0x1c, 0xf0, 0x04, 0x16, 0xce, 0xfa, 0xa9, 0xc0, 0xa3, 0x22, 0xec, 0xf7,
	0x99, 0xf1, 0x9b, 0x8d, 0x19, 0x9f, 0x14, 0xce, 0x78, 0xa3, 0x55, 0xf1, 0x98, 0x5f, 0xc8, 0x29,
	0x33, 0x2e, 0x48, 0x92, 0x06, 0x94, 0x23, 0x39, 0x96, 0x5c, 0xf0, 0x0c, 0x96, 0xde, 0x7a, 0x05,
	0x4f, 0x6e, 0xc8, 0xe7, 0x43, 0xec, 0x4f, 0xfd, 0x80, 0x78, 0x7c, 0x0e, 0x92, 0x69, 0xa5, 0x40,
	0xe1, 0xdf, 0x55, 0xa8, 0x6f, 0x3f, 0x7a, 0x1f, 0x1a, 0x9e, 0xc3, 0x51, 0x48, 0x92, 0xc4, 0xf1,
	0x08, 0x67, 0x42, 0xef, 0x57, 0xf2, 0xcc, 0x5c, 0xa6, 0xf0, 0x72, 0x81, 0xde, 0x4b, 0xb6, 0xb4,
	0x86, 0xda, 0xac, 0x74, 0x5b, 0x3b, 0xde, 0x88, 0x0d, 0x5c, 0xc5, 0x9c, 0xfd, 0x5e, 0xbe, 0x1a,
	0x6b, 0x37, 0xd6, 0xb7, 0x6a, 0x4b, 0xa0, 0x2e, 0xd2, 0xd6, 0x52, 0xb8, 0x6a, 0xa1, 0x70, 0x57,
	0xaa, 0xd2, 0xf8, 0xe3, 0x5b, 0xaa, 0x62, 0x2d, 0x12, 0xea, 0xd0, 0x34, 0xe1, 0xba, 0x93, 0x2d,
	0x44, 0x06, 0x4b, 0x8f, 0x5a, 0x00, 0x42, 0xa4, 0xee, 0x17, 0x87, 0x56, 0xcb, 0x7c, 0xdf, 0x7f,
	0x79, 0x66, 0xae, 0x65, 0xb1, 0x2e, 0xd7, 0x3d, 0xda, 0xbd, 0x2c, 0x81, 0xbe, 0xe2, 0x03, 0xbd,
	0x83, 0xb2, 0xc7, 0x39, 0x41, 0xc6, 0xce, 0x4f, 0xc8, 0xa4, 0x66, 0xee, 0xf9, 0xc4, 0x20, 0x0c,
	0xba, 0xb3, 0x14, 0x23, 0x7a, 0xba, 0x4f, 0xac, 0x93, 0x9a, 0xb5, 0x5f, 0xcf, 0xc8, 0x85, 0xff,
	0xbd, 0xcd, 0x91, 0xa1, 0x93, 0xbb, 0x0d, 0x76, 0x52, 0x6b, 0xde, 0x55, 0x01, 0xfd, 0xfa, 0xaf,
	0xb9, 0xa1, 0x5c, 0xcd, 0x0d, 0xe5, 0xef, 0xdc, 0x50, 0x2e, 0x17, 0xc6, 0xc1, 0xd5, 0xc2, 0x38,
	0xf8, 0xb3, 0x30, 0x0e, 0x3e, 0x97, 0xa6, 0x9d, 0x41, 0x99, 0xff, 0x16, 0x5e, 0xfe, 0x0b, 0x00,
	0x00, 0xff, 0xff, 0xeb, 0xba, 0x22, 0x2a, 0x67, 0x06, 0x00, 0x00,
}
