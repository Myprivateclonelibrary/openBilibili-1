// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/live/dao-anchor/api/grpc/v1/api.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type AnchorLevel struct {
	// 当前等级
	Level int64 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	// 当前等级颜色
	Color int64 `protobuf:"varint,2,opt,name=color,proto3" json:"color,omitempty"`
	// 当前积分
	Score int64 `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	// 当前等级最小积分
	Left int64 `protobuf:"varint,4,opt,name=left,proto3" json:"left,omitempty"`
	// 当前等级最大积分
	Right int64 `protobuf:"varint,5,opt,name=right,proto3" json:"right,omitempty"`
	// 最大等级
	MaxLevel             int64    `protobuf:"varint,6,opt,name=max_level,json=maxLevel,proto3" json:"max_level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnchorLevel) Reset()         { *m = AnchorLevel{} }
func (m *AnchorLevel) String() string { return proto.CompactTextString(m) }
func (*AnchorLevel) ProtoMessage()    {}
func (*AnchorLevel) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{0}
}
func (m *AnchorLevel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorLevel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorLevel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorLevel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorLevel.Merge(dst, src)
}
func (m *AnchorLevel) XXX_Size() int {
	return m.Size()
}
func (m *AnchorLevel) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorLevel.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorLevel proto.InternalMessageInfo

func (m *AnchorLevel) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *AnchorLevel) GetColor() int64 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *AnchorLevel) GetScore() int64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *AnchorLevel) GetLeft() int64 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *AnchorLevel) GetRight() int64 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *AnchorLevel) GetMaxLevel() int64 {
	if m != nil {
		return m.MaxLevel
	}
	return 0
}

type TagData struct {
	TagId                int64    `protobuf:"varint,1,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty"`
	TagSubId             int64    `protobuf:"varint,2,opt,name=tag_sub_id,json=tagSubId,proto3" json:"tag_sub_id,omitempty"`
	TagValue             int64    `protobuf:"varint,3,opt,name=tag_value,json=tagValue,proto3" json:"tag_value,omitempty"`
	TagExt               string   `protobuf:"bytes,4,opt,name=tag_ext,json=tagExt,proto3" json:"tag_ext,omitempty"`
	TagExpireAt          int64    `protobuf:"varint,5,opt,name=tag_expire_at,json=tagExpireAt,proto3" json:"tag_expire_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TagData) Reset()         { *m = TagData{} }
func (m *TagData) String() string { return proto.CompactTextString(m) }
func (*TagData) ProtoMessage()    {}
func (*TagData) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{1}
}
func (m *TagData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TagData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagData.Merge(dst, src)
}
func (m *TagData) XXX_Size() int {
	return m.Size()
}
func (m *TagData) XXX_DiscardUnknown() {
	xxx_messageInfo_TagData.DiscardUnknown(m)
}

var xxx_messageInfo_TagData proto.InternalMessageInfo

func (m *TagData) GetTagId() int64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

func (m *TagData) GetTagSubId() int64 {
	if m != nil {
		return m.TagSubId
	}
	return 0
}

func (m *TagData) GetTagValue() int64 {
	if m != nil {
		return m.TagValue
	}
	return 0
}

func (m *TagData) GetTagExt() string {
	if m != nil {
		return m.TagExt
	}
	return ""
}

func (m *TagData) GetTagExpireAt() int64 {
	if m != nil {
		return m.TagExpireAt
	}
	return 0
}

type RoomData struct {
	Uid                int64        `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	RoomId             int64        `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	ShortId            int64        `protobuf:"varint,3,opt,name=short_id,json=shortId,proto3" json:"short_id,omitempty" validate:"gt=0,required"`
	Title              string       `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty" validate:"required"`
	Cover              string       `protobuf:"bytes,5,opt,name=cover,proto3" json:"cover,omitempty"`
	Tags               string       `protobuf:"bytes,6,opt,name=tags,proto3" json:"tags,omitempty"`
	Background         string       `protobuf:"bytes,7,opt,name=background,proto3" json:"background,omitempty"`
	Description        string       `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	LiveStatus         int64        `protobuf:"varint,9,opt,name=live_status,json=liveStatus,proto3" json:"live_status,omitempty" validate:"gt=0,required"`
	LiveStartTime      int64        `protobuf:"varint,10,opt,name=live_start_time,json=liveStartTime,proto3" json:"live_start_time,omitempty" validate:"gt=0,required"`
	LiveScreenType     int64        `protobuf:"varint,11,opt,name=live_screen_type,json=liveScreenType,proto3" json:"live_screen_type,omitempty" validate:"gt=0,required"`
	LiveMark           int64        `protobuf:"varint,12,opt,name=live_mark,json=liveMark,proto3" json:"live_mark,omitempty"`
	LockStatus         int64        `protobuf:"varint,13,opt,name=lock_status,json=lockStatus,proto3" json:"lock_status,omitempty"`
	LockTime           int64        `protobuf:"varint,14,opt,name=lock_time,json=lockTime,proto3" json:"lock_time,omitempty"`
	HiddenStatus       int64        `protobuf:"varint,15,opt,name=hidden_status,json=hiddenStatus,proto3" json:"hidden_status,omitempty" validate:"gt=0,required"`
	HiddenTime         int64        `protobuf:"varint,16,opt,name=hidden_time,json=hiddenTime,proto3" json:"hidden_time,omitempty"`
	AreaId             int64        `protobuf:"varint,17,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty" validate:"gt=0,required"`
	AreaName           string       `protobuf:"bytes,18,opt,name=area_name,json=areaName,proto3" json:"area_name,omitempty" validate:"required"`
	ParentAreaId       int64        `protobuf:"varint,19,opt,name=parent_area_id,json=parentAreaId,proto3" json:"parent_area_id,omitempty" validate:"gt=0,required"`
	ParentAreaName     string       `protobuf:"bytes,20,opt,name=parent_area_name,json=parentAreaName,proto3" json:"parent_area_name,omitempty" validate:"required"`
	Keyframe           string       `protobuf:"bytes,21,opt,name=keyframe,proto3" json:"keyframe,omitempty"`
	PopularityCount    int64        `protobuf:"varint,22,opt,name=popularity_count,json=popularityCount,proto3" json:"popularity_count,omitempty"`
	TagList            []*TagData   `protobuf:"bytes,23,rep,name=tag_list,json=tagList" json:"tag_list,omitempty"`
	AnchorProfileType  int64        `protobuf:"varint,25,opt,name=anchor_profile_type,json=anchorProfileType,proto3" json:"anchor_profile_type,omitempty"`
	AnchorLevel        *AnchorLevel `protobuf:"bytes,26,opt,name=anchor_level,json=anchorLevel" json:"anchor_level,omitempty"`
	AnchorRoundSwitch  int64        `protobuf:"varint,27,opt,name=anchor_round_switch,json=anchorRoundSwitch,proto3" json:"anchor_round_switch,omitempty"`
	AnchorRoundStatus  int64        `protobuf:"varint,28,opt,name=anchor_round_status,json=anchorRoundStatus,proto3" json:"anchor_round_status,omitempty"`
	AnchorRecordSwitch int64        `protobuf:"varint,29,opt,name=anchor_record_switch,json=anchorRecordSwitch,proto3" json:"anchor_record_switch,omitempty"`
	AnchorRecordStatus int64        `protobuf:"varint,30,opt,name=anchor_record_status,json=anchorRecordStatus,proto3" json:"anchor_record_status,omitempty"`
	AnchorSan          int64        `protobuf:"varint,31,opt,name=anchor_san,json=anchorSan,proto3" json:"anchor_san,omitempty"`
	// 0默认 1摄像头直播 2录屏直播 3语音直播
	LiveType             int64    `protobuf:"varint,32,opt,name=live_type,json=liveType,proto3" json:"live_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomData) Reset()         { *m = RoomData{} }
func (m *RoomData) String() string { return proto.CompactTextString(m) }
func (*RoomData) ProtoMessage()    {}
func (*RoomData) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{2}
}
func (m *RoomData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomData.Merge(dst, src)
}
func (m *RoomData) XXX_Size() int {
	return m.Size()
}
func (m *RoomData) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomData.DiscardUnknown(m)
}

var xxx_messageInfo_RoomData proto.InternalMessageInfo

func (m *RoomData) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RoomData) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomData) GetShortId() int64 {
	if m != nil {
		return m.ShortId
	}
	return 0
}

func (m *RoomData) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RoomData) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *RoomData) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *RoomData) GetBackground() string {
	if m != nil {
		return m.Background
	}
	return ""
}

func (m *RoomData) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RoomData) GetLiveStatus() int64 {
	if m != nil {
		return m.LiveStatus
	}
	return 0
}

func (m *RoomData) GetLiveStartTime() int64 {
	if m != nil {
		return m.LiveStartTime
	}
	return 0
}

func (m *RoomData) GetLiveScreenType() int64 {
	if m != nil {
		return m.LiveScreenType
	}
	return 0
}

func (m *RoomData) GetLiveMark() int64 {
	if m != nil {
		return m.LiveMark
	}
	return 0
}

func (m *RoomData) GetLockStatus() int64 {
	if m != nil {
		return m.LockStatus
	}
	return 0
}

func (m *RoomData) GetLockTime() int64 {
	if m != nil {
		return m.LockTime
	}
	return 0
}

func (m *RoomData) GetHiddenStatus() int64 {
	if m != nil {
		return m.HiddenStatus
	}
	return 0
}

func (m *RoomData) GetHiddenTime() int64 {
	if m != nil {
		return m.HiddenTime
	}
	return 0
}

func (m *RoomData) GetAreaId() int64 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (m *RoomData) GetAreaName() string {
	if m != nil {
		return m.AreaName
	}
	return ""
}

func (m *RoomData) GetParentAreaId() int64 {
	if m != nil {
		return m.ParentAreaId
	}
	return 0
}

func (m *RoomData) GetParentAreaName() string {
	if m != nil {
		return m.ParentAreaName
	}
	return ""
}

func (m *RoomData) GetKeyframe() string {
	if m != nil {
		return m.Keyframe
	}
	return ""
}

func (m *RoomData) GetPopularityCount() int64 {
	if m != nil {
		return m.PopularityCount
	}
	return 0
}

func (m *RoomData) GetTagList() []*TagData {
	if m != nil {
		return m.TagList
	}
	return nil
}

func (m *RoomData) GetAnchorProfileType() int64 {
	if m != nil {
		return m.AnchorProfileType
	}
	return 0
}

func (m *RoomData) GetAnchorLevel() *AnchorLevel {
	if m != nil {
		return m.AnchorLevel
	}
	return nil
}

func (m *RoomData) GetAnchorRoundSwitch() int64 {
	if m != nil {
		return m.AnchorRoundSwitch
	}
	return 0
}

func (m *RoomData) GetAnchorRoundStatus() int64 {
	if m != nil {
		return m.AnchorRoundStatus
	}
	return 0
}

func (m *RoomData) GetAnchorRecordSwitch() int64 {
	if m != nil {
		return m.AnchorRecordSwitch
	}
	return 0
}

func (m *RoomData) GetAnchorRecordStatus() int64 {
	if m != nil {
		return m.AnchorRecordStatus
	}
	return 0
}

func (m *RoomData) GetAnchorSan() int64 {
	if m != nil {
		return m.AnchorSan
	}
	return 0
}

func (m *RoomData) GetLiveType() int64 {
	if m != nil {
		return m.LiveType
	}
	return 0
}

type RoomByIDsReq struct {
	RoomIds              []int64  `protobuf:"varint,1,rep,packed,name=room_ids,json=roomIds" json:"room_ids,omitempty"`
	Uids                 []int64  `protobuf:"varint,2,rep,packed,name=uids" json:"uids,omitempty"`
	Fields               []string `protobuf:"bytes,3,rep,name=fields" json:"fields,omitempty"`
	DefaultFields        int64    `protobuf:"varint,4,opt,name=default_fields,json=defaultFields,proto3" json:"default_fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomByIDsReq) Reset()         { *m = RoomByIDsReq{} }
func (m *RoomByIDsReq) String() string { return proto.CompactTextString(m) }
func (*RoomByIDsReq) ProtoMessage()    {}
func (*RoomByIDsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{3}
}
func (m *RoomByIDsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomByIDsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomByIDsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomByIDsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomByIDsReq.Merge(dst, src)
}
func (m *RoomByIDsReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomByIDsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomByIDsReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomByIDsReq proto.InternalMessageInfo

func (m *RoomByIDsReq) GetRoomIds() []int64 {
	if m != nil {
		return m.RoomIds
	}
	return nil
}

func (m *RoomByIDsReq) GetUids() []int64 {
	if m != nil {
		return m.Uids
	}
	return nil
}

func (m *RoomByIDsReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RoomByIDsReq) GetDefaultFields() int64 {
	if m != nil {
		return m.DefaultFields
	}
	return 0
}

type RoomByIDsResp struct {
	RoomDataSet          map[int64]*RoomData `protobuf:"bytes,1,rep,name=room_data_set,json=roomDataSet" json:"room_data_set,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RoomByIDsResp) Reset()         { *m = RoomByIDsResp{} }
func (m *RoomByIDsResp) String() string { return proto.CompactTextString(m) }
func (*RoomByIDsResp) ProtoMessage()    {}
func (*RoomByIDsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{4}
}
func (m *RoomByIDsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomByIDsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomByIDsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomByIDsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomByIDsResp.Merge(dst, src)
}
func (m *RoomByIDsResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomByIDsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomByIDsResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomByIDsResp proto.InternalMessageInfo

func (m *RoomByIDsResp) GetRoomDataSet() map[int64]*RoomData {
	if m != nil {
		return m.RoomDataSet
	}
	return nil
}

type RoomOnlineListReq struct {
	Filter               string   `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	Sort                 string   `protobuf:"bytes,2,opt,name=sort,proto3" json:"sort,omitempty"`
	Page                 int64    `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	PageSize             int64    `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Fields               []string `protobuf:"bytes,5,rep,name=fields" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomOnlineListReq) Reset()         { *m = RoomOnlineListReq{} }
func (m *RoomOnlineListReq) String() string { return proto.CompactTextString(m) }
func (*RoomOnlineListReq) ProtoMessage()    {}
func (*RoomOnlineListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{5}
}
func (m *RoomOnlineListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomOnlineListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomOnlineListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomOnlineListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomOnlineListReq.Merge(dst, src)
}
func (m *RoomOnlineListReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomOnlineListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomOnlineListReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomOnlineListReq proto.InternalMessageInfo

func (m *RoomOnlineListReq) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *RoomOnlineListReq) GetSort() string {
	if m != nil {
		return m.Sort
	}
	return ""
}

func (m *RoomOnlineListReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *RoomOnlineListReq) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *RoomOnlineListReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type RoomOnlineListResp struct {
	RoomDataList         map[int64]*RoomData `protobuf:"bytes,1,rep,name=room_data_list,json=roomDataList" json:"room_data_list,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RoomOnlineListResp) Reset()         { *m = RoomOnlineListResp{} }
func (m *RoomOnlineListResp) String() string { return proto.CompactTextString(m) }
func (*RoomOnlineListResp) ProtoMessage()    {}
func (*RoomOnlineListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{6}
}
func (m *RoomOnlineListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomOnlineListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomOnlineListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomOnlineListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomOnlineListResp.Merge(dst, src)
}
func (m *RoomOnlineListResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomOnlineListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomOnlineListResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomOnlineListResp proto.InternalMessageInfo

func (m *RoomOnlineListResp) GetRoomDataList() map[int64]*RoomData {
	if m != nil {
		return m.RoomDataList
	}
	return nil
}

type RoomOnlineListByAreaReq struct {
	AreaIds              []int64  `protobuf:"varint,1,rep,packed,name=area_ids,json=areaIds" json:"area_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomOnlineListByAreaReq) Reset()         { *m = RoomOnlineListByAreaReq{} }
func (m *RoomOnlineListByAreaReq) String() string { return proto.CompactTextString(m) }
func (*RoomOnlineListByAreaReq) ProtoMessage()    {}
func (*RoomOnlineListByAreaReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{7}
}
func (m *RoomOnlineListByAreaReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomOnlineListByAreaReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomOnlineListByAreaReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomOnlineListByAreaReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomOnlineListByAreaReq.Merge(dst, src)
}
func (m *RoomOnlineListByAreaReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomOnlineListByAreaReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomOnlineListByAreaReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomOnlineListByAreaReq proto.InternalMessageInfo

func (m *RoomOnlineListByAreaReq) GetAreaIds() []int64 {
	if m != nil {
		return m.AreaIds
	}
	return nil
}

type RoomOnlineListByAreaResp struct {
	RoomIds              []int64  `protobuf:"varint,1,rep,packed,name=room_ids,json=roomIds" json:"room_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomOnlineListByAreaResp) Reset()         { *m = RoomOnlineListByAreaResp{} }
func (m *RoomOnlineListByAreaResp) String() string { return proto.CompactTextString(m) }
func (*RoomOnlineListByAreaResp) ProtoMessage()    {}
func (*RoomOnlineListByAreaResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{8}
}
func (m *RoomOnlineListByAreaResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomOnlineListByAreaResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomOnlineListByAreaResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomOnlineListByAreaResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomOnlineListByAreaResp.Merge(dst, src)
}
func (m *RoomOnlineListByAreaResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomOnlineListByAreaResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomOnlineListByAreaResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomOnlineListByAreaResp proto.InternalMessageInfo

func (m *RoomOnlineListByAreaResp) GetRoomIds() []int64 {
	if m != nil {
		return m.RoomIds
	}
	return nil
}

type RoomCreateReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	RoomId               int64    `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomCreateReq) Reset()         { *m = RoomCreateReq{} }
func (m *RoomCreateReq) String() string { return proto.CompactTextString(m) }
func (*RoomCreateReq) ProtoMessage()    {}
func (*RoomCreateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{9}
}
func (m *RoomCreateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomCreateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomCreateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomCreateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomCreateReq.Merge(dst, src)
}
func (m *RoomCreateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomCreateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomCreateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomCreateReq proto.InternalMessageInfo

func (m *RoomCreateReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RoomCreateReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type RoomCreateResp struct {
	RoomId               int64    `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomCreateResp) Reset()         { *m = RoomCreateResp{} }
func (m *RoomCreateResp) String() string { return proto.CompactTextString(m) }
func (*RoomCreateResp) ProtoMessage()    {}
func (*RoomCreateResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{10}
}
func (m *RoomCreateResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomCreateResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomCreateResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomCreateResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomCreateResp.Merge(dst, src)
}
func (m *RoomCreateResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomCreateResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomCreateResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomCreateResp proto.InternalMessageInfo

func (m *RoomCreateResp) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type UpdateResp struct {
	AffectedRows         int64    `protobuf:"varint,1,opt,name=affected_rows,json=affectedRows,proto3" json:"affected_rows,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateResp) Reset()         { *m = UpdateResp{} }
func (m *UpdateResp) String() string { return proto.CompactTextString(m) }
func (*UpdateResp) ProtoMessage()    {}
func (*UpdateResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{11}
}
func (m *UpdateResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateResp.Merge(dst, src)
}
func (m *UpdateResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateResp proto.InternalMessageInfo

func (m *UpdateResp) GetAffectedRows() int64 {
	if m != nil {
		return m.AffectedRows
	}
	return 0
}

type RoomUpdateReq struct {
	Fields               []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" validate:"required"`
	RoomId               int64    `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	Title                string   `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Cover                string   `protobuf:"bytes,4,opt,name=cover,proto3" json:"cover,omitempty"`
	Tags                 string   `protobuf:"bytes,5,opt,name=tags,proto3" json:"tags,omitempty"`
	Background           string   `protobuf:"bytes,6,opt,name=background,proto3" json:"background,omitempty"`
	Description          string   `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	LiveStartTime        int64    `protobuf:"varint,8,opt,name=live_start_time,json=liveStartTime,proto3" json:"live_start_time,omitempty"`
	LiveScreenType       int64    `protobuf:"varint,9,opt,name=live_screen_type,json=liveScreenType,proto3" json:"live_screen_type,omitempty"`
	LockStatus           int64    `protobuf:"varint,10,opt,name=lock_status,json=lockStatus,proto3" json:"lock_status,omitempty"`
	LockTime             int64    `protobuf:"varint,11,opt,name=lock_time,json=lockTime,proto3" json:"lock_time,omitempty"`
	HiddenTime           int64    `protobuf:"varint,12,opt,name=hidden_time,json=hiddenTime,proto3" json:"hidden_time,omitempty"`
	AreaId               int64    `protobuf:"varint,13,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty"`
	AnchorRoundSwitch    int64    `protobuf:"varint,14,opt,name=anchor_round_switch,json=anchorRoundSwitch,proto3" json:"anchor_round_switch,omitempty"`
	AnchorRecordSwitch   int64    `protobuf:"varint,15,opt,name=anchor_record_switch,json=anchorRecordSwitch,proto3" json:"anchor_record_switch,omitempty"`
	LiveType             int64    `protobuf:"varint,16,opt,name=live_type,json=liveType,proto3" json:"live_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomUpdateReq) Reset()         { *m = RoomUpdateReq{} }
func (m *RoomUpdateReq) String() string { return proto.CompactTextString(m) }
func (*RoomUpdateReq) ProtoMessage()    {}
func (*RoomUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{12}
}
func (m *RoomUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomUpdateReq.Merge(dst, src)
}
func (m *RoomUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomUpdateReq proto.InternalMessageInfo

func (m *RoomUpdateReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RoomUpdateReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomUpdateReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RoomUpdateReq) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *RoomUpdateReq) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *RoomUpdateReq) GetBackground() string {
	if m != nil {
		return m.Background
	}
	return ""
}

func (m *RoomUpdateReq) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RoomUpdateReq) GetLiveStartTime() int64 {
	if m != nil {
		return m.LiveStartTime
	}
	return 0
}

func (m *RoomUpdateReq) GetLiveScreenType() int64 {
	if m != nil {
		return m.LiveScreenType
	}
	return 0
}

func (m *RoomUpdateReq) GetLockStatus() int64 {
	if m != nil {
		return m.LockStatus
	}
	return 0
}

func (m *RoomUpdateReq) GetLockTime() int64 {
	if m != nil {
		return m.LockTime
	}
	return 0
}

func (m *RoomUpdateReq) GetHiddenTime() int64 {
	if m != nil {
		return m.HiddenTime
	}
	return 0
}

func (m *RoomUpdateReq) GetAreaId() int64 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (m *RoomUpdateReq) GetAnchorRoundSwitch() int64 {
	if m != nil {
		return m.AnchorRoundSwitch
	}
	return 0
}

func (m *RoomUpdateReq) GetAnchorRecordSwitch() int64 {
	if m != nil {
		return m.AnchorRecordSwitch
	}
	return 0
}

func (m *RoomUpdateReq) GetLiveType() int64 {
	if m != nil {
		return m.LiveType
	}
	return 0
}

type RoomBatchUpdateReq struct {
	Reqs                 []*RoomUpdateReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RoomBatchUpdateReq) Reset()         { *m = RoomBatchUpdateReq{} }
func (m *RoomBatchUpdateReq) String() string { return proto.CompactTextString(m) }
func (*RoomBatchUpdateReq) ProtoMessage()    {}
func (*RoomBatchUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{13}
}
func (m *RoomBatchUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomBatchUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomBatchUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomBatchUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomBatchUpdateReq.Merge(dst, src)
}
func (m *RoomBatchUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomBatchUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomBatchUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomBatchUpdateReq proto.InternalMessageInfo

func (m *RoomBatchUpdateReq) GetReqs() []*RoomUpdateReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type AnchorUpdateReq struct {
	Fields               []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" validate:"required"`
	Uid                  int64    `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	ProfileType          int64    `protobuf:"varint,3,opt,name=profile_type,json=profileType,proto3" json:"profile_type,omitempty"`
	SanScore             int64    `protobuf:"varint,4,opt,name=san_score,json=sanScore,proto3" json:"san_score,omitempty"`
	RoundStatus          int64    `protobuf:"varint,5,opt,name=round_status,json=roundStatus,proto3" json:"round_status,omitempty"`
	RecordStatus         int64    `protobuf:"varint,6,opt,name=record_status,json=recordStatus,proto3" json:"record_status,omitempty"`
	Exp                  int64    `protobuf:"varint,7,opt,name=exp,proto3" json:"exp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnchorUpdateReq) Reset()         { *m = AnchorUpdateReq{} }
func (m *AnchorUpdateReq) String() string { return proto.CompactTextString(m) }
func (*AnchorUpdateReq) ProtoMessage()    {}
func (*AnchorUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{14}
}
func (m *AnchorUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorUpdateReq.Merge(dst, src)
}
func (m *AnchorUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *AnchorUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorUpdateReq proto.InternalMessageInfo

func (m *AnchorUpdateReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *AnchorUpdateReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AnchorUpdateReq) GetProfileType() int64 {
	if m != nil {
		return m.ProfileType
	}
	return 0
}

func (m *AnchorUpdateReq) GetSanScore() int64 {
	if m != nil {
		return m.SanScore
	}
	return 0
}

func (m *AnchorUpdateReq) GetRoundStatus() int64 {
	if m != nil {
		return m.RoundStatus
	}
	return 0
}

func (m *AnchorUpdateReq) GetRecordStatus() int64 {
	if m != nil {
		return m.RecordStatus
	}
	return 0
}

func (m *AnchorUpdateReq) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type AnchorBatchUpdateReq struct {
	Reqs                 []*AnchorUpdateReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AnchorBatchUpdateReq) Reset()         { *m = AnchorBatchUpdateReq{} }
func (m *AnchorBatchUpdateReq) String() string { return proto.CompactTextString(m) }
func (*AnchorBatchUpdateReq) ProtoMessage()    {}
func (*AnchorBatchUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{15}
}
func (m *AnchorBatchUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorBatchUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorBatchUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorBatchUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorBatchUpdateReq.Merge(dst, src)
}
func (m *AnchorBatchUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *AnchorBatchUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorBatchUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorBatchUpdateReq proto.InternalMessageInfo

func (m *AnchorBatchUpdateReq) GetReqs() []*AnchorUpdateReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type AnchorIncreReq struct {
	ReqId                string   `protobuf:"bytes,1,opt,name=req_id,json=reqId,proto3" json:"req_id,omitempty" validate:"required"`
	Fields               []string `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty" validate:"required"`
	Uid                  int64    `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	SanScore             int64    `protobuf:"varint,4,opt,name=san_score,json=sanScore,proto3" json:"san_score,omitempty"`
	Exp                  int64    `protobuf:"varint,5,opt,name=exp,proto3" json:"exp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnchorIncreReq) Reset()         { *m = AnchorIncreReq{} }
func (m *AnchorIncreReq) String() string { return proto.CompactTextString(m) }
func (*AnchorIncreReq) ProtoMessage()    {}
func (*AnchorIncreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{16}
}
func (m *AnchorIncreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorIncreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorIncreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorIncreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorIncreReq.Merge(dst, src)
}
func (m *AnchorIncreReq) XXX_Size() int {
	return m.Size()
}
func (m *AnchorIncreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorIncreReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorIncreReq proto.InternalMessageInfo

func (m *AnchorIncreReq) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *AnchorIncreReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *AnchorIncreReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AnchorIncreReq) GetSanScore() int64 {
	if m != nil {
		return m.SanScore
	}
	return 0
}

func (m *AnchorIncreReq) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type AnchorBatchIncreReq struct {
	Reqs                 []*AnchorIncreReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AnchorBatchIncreReq) Reset()         { *m = AnchorBatchIncreReq{} }
func (m *AnchorBatchIncreReq) String() string { return proto.CompactTextString(m) }
func (*AnchorBatchIncreReq) ProtoMessage()    {}
func (*AnchorBatchIncreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{17}
}
func (m *AnchorBatchIncreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorBatchIncreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorBatchIncreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorBatchIncreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorBatchIncreReq.Merge(dst, src)
}
func (m *AnchorBatchIncreReq) XXX_Size() int {
	return m.Size()
}
func (m *AnchorBatchIncreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorBatchIncreReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorBatchIncreReq proto.InternalMessageInfo

func (m *AnchorBatchIncreReq) GetReqs() []*AnchorIncreReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type RoomExtendUpdateReq struct {
	Fields               []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" validate:"required"`
	RoomId               int64    `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	Keyframe             string   `protobuf:"bytes,3,opt,name=keyframe,proto3" json:"keyframe,omitempty"`
	DanmuCount           int64    `protobuf:"varint,4,opt,name=danmu_count,json=danmuCount,proto3" json:"danmu_count,omitempty"`
	PopularityCount      int64    `protobuf:"varint,5,opt,name=popularity_count,json=popularityCount,proto3" json:"popularity_count,omitempty"`
	AudienceCount        int64    `protobuf:"varint,6,opt,name=audience_count,json=audienceCount,proto3" json:"audience_count,omitempty"`
	GiftCount            int64    `protobuf:"varint,7,opt,name=gift_count,json=giftCount,proto3" json:"gift_count,omitempty"`
	GiftGoldAmount       int64    `protobuf:"varint,8,opt,name=gift_gold_amount,json=giftGoldAmount,proto3" json:"gift_gold_amount,omitempty"`
	GiftGoldCount        int64    `protobuf:"varint,9,opt,name=gift_gold_count,json=giftGoldCount,proto3" json:"gift_gold_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomExtendUpdateReq) Reset()         { *m = RoomExtendUpdateReq{} }
func (m *RoomExtendUpdateReq) String() string { return proto.CompactTextString(m) }
func (*RoomExtendUpdateReq) ProtoMessage()    {}
func (*RoomExtendUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{18}
}
func (m *RoomExtendUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomExtendUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomExtendUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomExtendUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomExtendUpdateReq.Merge(dst, src)
}
func (m *RoomExtendUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomExtendUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomExtendUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomExtendUpdateReq proto.InternalMessageInfo

func (m *RoomExtendUpdateReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RoomExtendUpdateReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetKeyframe() string {
	if m != nil {
		return m.Keyframe
	}
	return ""
}

func (m *RoomExtendUpdateReq) GetDanmuCount() int64 {
	if m != nil {
		return m.DanmuCount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetPopularityCount() int64 {
	if m != nil {
		return m.PopularityCount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetAudienceCount() int64 {
	if m != nil {
		return m.AudienceCount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetGiftCount() int64 {
	if m != nil {
		return m.GiftCount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetGiftGoldAmount() int64 {
	if m != nil {
		return m.GiftGoldAmount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetGiftGoldCount() int64 {
	if m != nil {
		return m.GiftGoldCount
	}
	return 0
}

type RoomExtendBatchUpdateReq struct {
	Reqs                 []*RoomExtendUpdateReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *RoomExtendBatchUpdateReq) Reset()         { *m = RoomExtendBatchUpdateReq{} }
func (m *RoomExtendBatchUpdateReq) String() string { return proto.CompactTextString(m) }
func (*RoomExtendBatchUpdateReq) ProtoMessage()    {}
func (*RoomExtendBatchUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{19}
}
func (m *RoomExtendBatchUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomExtendBatchUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomExtendBatchUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomExtendBatchUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomExtendBatchUpdateReq.Merge(dst, src)
}
func (m *RoomExtendBatchUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomExtendBatchUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomExtendBatchUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomExtendBatchUpdateReq proto.InternalMessageInfo

func (m *RoomExtendBatchUpdateReq) GetReqs() []*RoomExtendUpdateReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type RoomExtendIncreReq struct {
	ReqId                string   `protobuf:"bytes,1,opt,name=req_id,json=reqId,proto3" json:"req_id,omitempty" validate:"required"`
	Fields               []string `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty" validate:"required"`
	RoomId               int64    `protobuf:"varint,3,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	DanmuCount           int64    `protobuf:"varint,4,opt,name=danmu_count,json=danmuCount,proto3" json:"danmu_count,omitempty"`
	PopularityCount      int64    `protobuf:"varint,5,opt,name=popularity_count,json=popularityCount,proto3" json:"popularity_count,omitempty"`
	AudienceCount        int64    `protobuf:"varint,6,opt,name=audience_count,json=audienceCount,proto3" json:"audience_count,omitempty"`
	GiftCount            int64    `protobuf:"varint,7,opt,name=gift_count,json=giftCount,proto3" json:"gift_count,omitempty"`
	GiftGoldAmount       int64    `protobuf:"varint,8,opt,name=gift_gold_amount,json=giftGoldAmount,proto3" json:"gift_gold_amount,omitempty"`
	GiftGoldCount        int64    `protobuf:"varint,9,opt,name=gift_gold_count,json=giftGoldCount,proto3" json:"gift_gold_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomExtendIncreReq) Reset()         { *m = RoomExtendIncreReq{} }
func (m *RoomExtendIncreReq) String() string { return proto.CompactTextString(m) }
func (*RoomExtendIncreReq) ProtoMessage()    {}
func (*RoomExtendIncreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{20}
}
func (m *RoomExtendIncreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomExtendIncreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomExtendIncreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomExtendIncreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomExtendIncreReq.Merge(dst, src)
}
func (m *RoomExtendIncreReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomExtendIncreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomExtendIncreReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomExtendIncreReq proto.InternalMessageInfo

func (m *RoomExtendIncreReq) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *RoomExtendIncreReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RoomExtendIncreReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomExtendIncreReq) GetDanmuCount() int64 {
	if m != nil {
		return m.DanmuCount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetPopularityCount() int64 {
	if m != nil {
		return m.PopularityCount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetAudienceCount() int64 {
	if m != nil {
		return m.AudienceCount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetGiftCount() int64 {
	if m != nil {
		return m.GiftCount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetGiftGoldAmount() int64 {
	if m != nil {
		return m.GiftGoldAmount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetGiftGoldCount() int64 {
	if m != nil {
		return m.GiftGoldCount
	}
	return 0
}

type RoomExtendBatchIncreReq struct {
	Reqs                 []*RoomExtendIncreReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *RoomExtendBatchIncreReq) Reset()         { *m = RoomExtendBatchIncreReq{} }
func (m *RoomExtendBatchIncreReq) String() string { return proto.CompactTextString(m) }
func (*RoomExtendBatchIncreReq) ProtoMessage()    {}
func (*RoomExtendBatchIncreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{21}
}
func (m *RoomExtendBatchIncreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomExtendBatchIncreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomExtendBatchIncreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomExtendBatchIncreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomExtendBatchIncreReq.Merge(dst, src)
}
func (m *RoomExtendBatchIncreReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomExtendBatchIncreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomExtendBatchIncreReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomExtendBatchIncreReq proto.InternalMessageInfo

func (m *RoomExtendBatchIncreReq) GetReqs() []*RoomExtendIncreReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type RoomTagCreateReq struct {
	RoomId               int64    `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	TagId                int64    `protobuf:"varint,2,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty" validate:"gt=0,required"`
	TagSubId             int64    `protobuf:"varint,3,opt,name=tag_sub_id,json=tagSubId,proto3" json:"tag_sub_id,omitempty"`
	TagValue             int64    `protobuf:"varint,4,opt,name=tag_value,json=tagValue,proto3" json:"tag_value,omitempty"`
	TagExt               string   `protobuf:"bytes,5,opt,name=tag_ext,json=tagExt,proto3" json:"tag_ext,omitempty"`
	TagExpireAt          int64    `protobuf:"varint,6,opt,name=tag_expire_at,json=tagExpireAt,proto3" json:"tag_expire_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomTagCreateReq) Reset()         { *m = RoomTagCreateReq{} }
func (m *RoomTagCreateReq) String() string { return proto.CompactTextString(m) }
func (*RoomTagCreateReq) ProtoMessage()    {}
func (*RoomTagCreateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{22}
}
func (m *RoomTagCreateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomTagCreateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomTagCreateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomTagCreateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomTagCreateReq.Merge(dst, src)
}
func (m *RoomTagCreateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomTagCreateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomTagCreateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomTagCreateReq proto.InternalMessageInfo

func (m *RoomTagCreateReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomTagCreateReq) GetTagId() int64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

func (m *RoomTagCreateReq) GetTagSubId() int64 {
	if m != nil {
		return m.TagSubId
	}
	return 0
}

func (m *RoomTagCreateReq) GetTagValue() int64 {
	if m != nil {
		return m.TagValue
	}
	return 0
}

func (m *RoomTagCreateReq) GetTagExt() string {
	if m != nil {
		return m.TagExt
	}
	return ""
}

func (m *RoomTagCreateReq) GetTagExpireAt() int64 {
	if m != nil {
		return m.TagExpireAt
	}
	return 0
}

type RoomAttrCreateReq struct {
	RoomId               int64    `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	AttrId               int64    `protobuf:"varint,2,opt,name=attr_id,json=attrId,proto3" json:"attr_id,omitempty" validate:"gt=0,required"`
	AttrSubId            int64    `protobuf:"varint,3,opt,name=attr_sub_id,json=attrSubId,proto3" json:"attr_sub_id,omitempty"`
	AttrValue            int64    `protobuf:"varint,4,opt,name=attr_value,json=attrValue,proto3" json:"attr_value,omitempty"`
	AttrExt              string   `protobuf:"bytes,5,opt,name=attr_ext,json=attrExt,proto3" json:"attr_ext,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomAttrCreateReq) Reset()         { *m = RoomAttrCreateReq{} }
func (m *RoomAttrCreateReq) String() string { return proto.CompactTextString(m) }
func (*RoomAttrCreateReq) ProtoMessage()    {}
func (*RoomAttrCreateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{23}
}
func (m *RoomAttrCreateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomAttrCreateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomAttrCreateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomAttrCreateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomAttrCreateReq.Merge(dst, src)
}
func (m *RoomAttrCreateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomAttrCreateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomAttrCreateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomAttrCreateReq proto.InternalMessageInfo

func (m *RoomAttrCreateReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomAttrCreateReq) GetAttrId() int64 {
	if m != nil {
		return m.AttrId
	}
	return 0
}

func (m *RoomAttrCreateReq) GetAttrSubId() int64 {
	if m != nil {
		return m.AttrSubId
	}
	return 0
}

func (m *RoomAttrCreateReq) GetAttrValue() int64 {
	if m != nil {
		return m.AttrValue
	}
	return 0
}

func (m *RoomAttrCreateReq) GetAttrExt() string {
	if m != nil {
		return m.AttrExt
	}
	return ""
}

type RoomAttrSetExReq struct {
	RoomId               int64    `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	AttrId               int64    `protobuf:"varint,2,opt,name=attr_id,json=attrId,proto3" json:"attr_id,omitempty" validate:"gt=0,required"`
	AttrSubId            int64    `protobuf:"varint,3,opt,name=attr_sub_id,json=attrSubId,proto3" json:"attr_sub_id,omitempty"`
	AttrValue            int64    `protobuf:"varint,4,opt,name=attr_value,json=attrValue,proto3" json:"attr_value,omitempty"`
	AttrExt              string   `protobuf:"bytes,5,opt,name=attr_ext,json=attrExt,proto3" json:"attr_ext,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomAttrSetExReq) Reset()         { *m = RoomAttrSetExReq{} }
func (m *RoomAttrSetExReq) String() string { return proto.CompactTextString(m) }
func (*RoomAttrSetExReq) ProtoMessage()    {}
func (*RoomAttrSetExReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{24}
}
func (m *RoomAttrSetExReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomAttrSetExReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomAttrSetExReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomAttrSetExReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomAttrSetExReq.Merge(dst, src)
}
func (m *RoomAttrSetExReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomAttrSetExReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomAttrSetExReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomAttrSetExReq proto.InternalMessageInfo

func (m *RoomAttrSetExReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomAttrSetExReq) GetAttrId() int64 {
	if m != nil {
		return m.AttrId
	}
	return 0
}

func (m *RoomAttrSetExReq) GetAttrSubId() int64 {
	if m != nil {
		return m.AttrSubId
	}
	return 0
}

func (m *RoomAttrSetExReq) GetAttrValue() int64 {
	if m != nil {
		return m.AttrValue
	}
	return 0
}

func (m *RoomAttrSetExReq) GetAttrExt() string {
	if m != nil {
		return m.AttrExt
	}
	return ""
}

type FetchAreasReq struct {
	AreaId               int64    `protobuf:"varint,1,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchAreasReq) Reset()         { *m = FetchAreasReq{} }
func (m *FetchAreasReq) String() string { return proto.CompactTextString(m) }
func (*FetchAreasReq) ProtoMessage()    {}
func (*FetchAreasReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{25}
}
func (m *FetchAreasReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchAreasReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchAreasReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FetchAreasReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchAreasReq.Merge(dst, src)
}
func (m *FetchAreasReq) XXX_Size() int {
	return m.Size()
}
func (m *FetchAreasReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchAreasReq.DiscardUnknown(m)
}

var xxx_messageInfo_FetchAreasReq proto.InternalMessageInfo

func (m *FetchAreasReq) GetAreaId() int64 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

type AreaInfo struct {
	AreaId               int64    `protobuf:"varint,1,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty"`
	AreaName             string   `protobuf:"bytes,2,opt,name=area_name,json=areaName,proto3" json:"area_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AreaInfo) Reset()         { *m = AreaInfo{} }
func (m *AreaInfo) String() string { return proto.CompactTextString(m) }
func (*AreaInfo) ProtoMessage()    {}
func (*AreaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{26}
}
func (m *AreaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AreaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AreaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AreaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AreaInfo.Merge(dst, src)
}
func (m *AreaInfo) XXX_Size() int {
	return m.Size()
}
func (m *AreaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AreaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AreaInfo proto.InternalMessageInfo

func (m *AreaInfo) GetAreaId() int64 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (m *AreaInfo) GetAreaName() string {
	if m != nil {
		return m.AreaName
	}
	return ""
}

type FetchAreasResp struct {
	Info                 *AreaInfo   `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
	Areas                []*AreaInfo `protobuf:"bytes,2,rep,name=areas" json:"areas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FetchAreasResp) Reset()         { *m = FetchAreasResp{} }
func (m *FetchAreasResp) String() string { return proto.CompactTextString(m) }
func (*FetchAreasResp) ProtoMessage()    {}
func (*FetchAreasResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{27}
}
func (m *FetchAreasResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchAreasResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchAreasResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FetchAreasResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchAreasResp.Merge(dst, src)
}
func (m *FetchAreasResp) XXX_Size() int {
	return m.Size()
}
func (m *FetchAreasResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchAreasResp.DiscardUnknown(m)
}

var xxx_messageInfo_FetchAreasResp proto.InternalMessageInfo

func (m *FetchAreasResp) GetInfo() *AreaInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *FetchAreasResp) GetAreas() []*AreaInfo {
	if m != nil {
		return m.Areas
	}
	return nil
}

type FetchAttrByIDsReq struct {
	RoomIds              []int64  `protobuf:"varint,1,rep,packed,name=room_ids,json=roomIds" json:"room_ids,omitempty" validate:"dive,gt=0,required"`
	AttrId               int64    `protobuf:"varint,2,opt,name=attr_id,json=attrId,proto3" json:"attr_id,omitempty" validate:"gt=0,required"`
	AttrSubId            int64    `protobuf:"varint,3,opt,name=attr_sub_id,json=attrSubId,proto3" json:"attr_sub_id,omitempty" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchAttrByIDsReq) Reset()         { *m = FetchAttrByIDsReq{} }
func (m *FetchAttrByIDsReq) String() string { return proto.CompactTextString(m) }
func (*FetchAttrByIDsReq) ProtoMessage()    {}
func (*FetchAttrByIDsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{28}
}
func (m *FetchAttrByIDsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchAttrByIDsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchAttrByIDsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FetchAttrByIDsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchAttrByIDsReq.Merge(dst, src)
}
func (m *FetchAttrByIDsReq) XXX_Size() int {
	return m.Size()
}
func (m *FetchAttrByIDsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchAttrByIDsReq.DiscardUnknown(m)
}

var xxx_messageInfo_FetchAttrByIDsReq proto.InternalMessageInfo

func (m *FetchAttrByIDsReq) GetRoomIds() []int64 {
	if m != nil {
		return m.RoomIds
	}
	return nil
}

func (m *FetchAttrByIDsReq) GetAttrId() int64 {
	if m != nil {
		return m.AttrId
	}
	return 0
}

func (m *FetchAttrByIDsReq) GetAttrSubId() int64 {
	if m != nil {
		return m.AttrSubId
	}
	return 0
}

type AttrData struct {
	RoomId               int64    `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	AttrId               int64    `protobuf:"varint,2,opt,name=attr_id,json=attrId,proto3" json:"attr_id,omitempty"`
	AttrSubId            int64    `protobuf:"varint,3,opt,name=attr_sub_id,json=attrSubId,proto3" json:"attr_sub_id,omitempty"`
	AttrValue            int64    `protobuf:"varint,4,opt,name=attr_value,json=attrValue,proto3" json:"attr_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttrData) Reset()         { *m = AttrData{} }
func (m *AttrData) String() string { return proto.CompactTextString(m) }
func (*AttrData) ProtoMessage()    {}
func (*AttrData) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{29}
}
func (m *AttrData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AttrData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrData.Merge(dst, src)
}
func (m *AttrData) XXX_Size() int {
	return m.Size()
}
func (m *AttrData) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrData.DiscardUnknown(m)
}

var xxx_messageInfo_AttrData proto.InternalMessageInfo

func (m *AttrData) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *AttrData) GetAttrId() int64 {
	if m != nil {
		return m.AttrId
	}
	return 0
}

func (m *AttrData) GetAttrSubId() int64 {
	if m != nil {
		return m.AttrSubId
	}
	return 0
}

func (m *AttrData) GetAttrValue() int64 {
	if m != nil {
		return m.AttrValue
	}
	return 0
}

type FetchAttrByIDsResp struct {
	Attrs                map[int64]*AttrData `protobuf:"bytes,1,rep,name=attrs" json:"attrs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *FetchAttrByIDsResp) Reset()         { *m = FetchAttrByIDsResp{} }
func (m *FetchAttrByIDsResp) String() string { return proto.CompactTextString(m) }
func (*FetchAttrByIDsResp) ProtoMessage()    {}
func (*FetchAttrByIDsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{30}
}
func (m *FetchAttrByIDsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchAttrByIDsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchAttrByIDsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FetchAttrByIDsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchAttrByIDsResp.Merge(dst, src)
}
func (m *FetchAttrByIDsResp) XXX_Size() int {
	return m.Size()
}
func (m *FetchAttrByIDsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchAttrByIDsResp.DiscardUnknown(m)
}

var xxx_messageInfo_FetchAttrByIDsResp proto.InternalMessageInfo

func (m *FetchAttrByIDsResp) GetAttrs() map[int64]*AttrData {
	if m != nil {
		return m.Attrs
	}
	return nil
}

type AttrReq struct {
	AttrId               int64    `protobuf:"varint,1,opt,name=attr_id,json=attrId,proto3" json:"attr_id,omitempty"`
	AttrSubId            int64    `protobuf:"varint,2,opt,name=attr_sub_id,json=attrSubId,proto3" json:"attr_sub_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttrReq) Reset()         { *m = AttrReq{} }
func (m *AttrReq) String() string { return proto.CompactTextString(m) }
func (*AttrReq) ProtoMessage()    {}
func (*AttrReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{31}
}
func (m *AttrReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AttrReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrReq.Merge(dst, src)
}
func (m *AttrReq) XXX_Size() int {
	return m.Size()
}
func (m *AttrReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrReq.DiscardUnknown(m)
}

var xxx_messageInfo_AttrReq proto.InternalMessageInfo

func (m *AttrReq) GetAttrId() int64 {
	if m != nil {
		return m.AttrId
	}
	return 0
}

func (m *AttrReq) GetAttrSubId() int64 {
	if m != nil {
		return m.AttrSubId
	}
	return 0
}

type RoomOnlineListByAttrsReq struct {
	Attrs                []*AttrReq `protobuf:"bytes,1,rep,name=attrs" json:"attrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RoomOnlineListByAttrsReq) Reset()         { *m = RoomOnlineListByAttrsReq{} }
func (m *RoomOnlineListByAttrsReq) String() string { return proto.CompactTextString(m) }
func (*RoomOnlineListByAttrsReq) ProtoMessage()    {}
func (*RoomOnlineListByAttrsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{32}
}
func (m *RoomOnlineListByAttrsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomOnlineListByAttrsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomOnlineListByAttrsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomOnlineListByAttrsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomOnlineListByAttrsReq.Merge(dst, src)
}
func (m *RoomOnlineListByAttrsReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomOnlineListByAttrsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomOnlineListByAttrsReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomOnlineListByAttrsReq proto.InternalMessageInfo

func (m *RoomOnlineListByAttrsReq) GetAttrs() []*AttrReq {
	if m != nil {
		return m.Attrs
	}
	return nil
}

type AttrResp struct {
	Uid                  int64       `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	RoomId               int64       `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	AreaId               int64       `protobuf:"varint,3,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty" validate:"gt=0,required"`
	ParentAreaId         int64       `protobuf:"varint,4,opt,name=parent_area_id,json=parentAreaId,proto3" json:"parent_area_id,omitempty" validate:"gt=0,required"`
	TagList              []*TagData  `protobuf:"bytes,5,rep,name=tag_list,json=tagList" json:"tag_list,omitempty"`
	AttrList             []*AttrData `protobuf:"bytes,6,rep,name=attr_list,json=attrList" json:"attr_list,omitempty"`
	PopularityCount      int64       `protobuf:"varint,7,opt,name=popularity_count,json=popularityCount,proto3" json:"popularity_count,omitempty"`
	AnchorProfileType    int64       `protobuf:"varint,8,opt,name=anchor_profile_type,json=anchorProfileType,proto3" json:"anchor_profile_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AttrResp) Reset()         { *m = AttrResp{} }
func (m *AttrResp) String() string { return proto.CompactTextString(m) }
func (*AttrResp) ProtoMessage()    {}
func (*AttrResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{33}
}
func (m *AttrResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AttrResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrResp.Merge(dst, src)
}
func (m *AttrResp) XXX_Size() int {
	return m.Size()
}
func (m *AttrResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrResp.DiscardUnknown(m)
}

var xxx_messageInfo_AttrResp proto.InternalMessageInfo

func (m *AttrResp) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AttrResp) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *AttrResp) GetAreaId() int64 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (m *AttrResp) GetParentAreaId() int64 {
	if m != nil {
		return m.ParentAreaId
	}
	return 0
}

func (m *AttrResp) GetTagList() []*TagData {
	if m != nil {
		return m.TagList
	}
	return nil
}

func (m *AttrResp) GetAttrList() []*AttrData {
	if m != nil {
		return m.AttrList
	}
	return nil
}

func (m *AttrResp) GetPopularityCount() int64 {
	if m != nil {
		return m.PopularityCount
	}
	return 0
}

func (m *AttrResp) GetAnchorProfileType() int64 {
	if m != nil {
		return m.AnchorProfileType
	}
	return 0
}

type RoomOnlineListByAttrsResp struct {
	Attrs                map[int64]*AttrResp `protobuf:"bytes,1,rep,name=attrs" json:"attrs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RoomOnlineListByAttrsResp) Reset()         { *m = RoomOnlineListByAttrsResp{} }
func (m *RoomOnlineListByAttrsResp) String() string { return proto.CompactTextString(m) }
func (*RoomOnlineListByAttrsResp) ProtoMessage()    {}
func (*RoomOnlineListByAttrsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{34}
}
func (m *RoomOnlineListByAttrsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomOnlineListByAttrsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomOnlineListByAttrsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomOnlineListByAttrsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomOnlineListByAttrsResp.Merge(dst, src)
}
func (m *RoomOnlineListByAttrsResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomOnlineListByAttrsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomOnlineListByAttrsResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomOnlineListByAttrsResp proto.InternalMessageInfo

func (m *RoomOnlineListByAttrsResp) GetAttrs() map[int64]*AttrResp {
	if m != nil {
		return m.Attrs
	}
	return nil
}

type DeleteAttrReq struct {
	AttrId               int64    `protobuf:"varint,1,opt,name=attr_id,json=attrId,proto3" json:"attr_id,omitempty" validate:"gt=0,required"`
	AttrSubId            int64    `protobuf:"varint,2,opt,name=attr_sub_id,json=attrSubId,proto3" json:"attr_sub_id,omitempty" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAttrReq) Reset()         { *m = DeleteAttrReq{} }
func (m *DeleteAttrReq) String() string { return proto.CompactTextString(m) }
func (*DeleteAttrReq) ProtoMessage()    {}
func (*DeleteAttrReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_ae6aa4fad8591398, []int{35}
}
func (m *DeleteAttrReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteAttrReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteAttrReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeleteAttrReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteAttrReq.Merge(dst, src)
}
func (m *DeleteAttrReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteAttrReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteAttrReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteAttrReq proto.InternalMessageInfo

func (m *DeleteAttrReq) GetAttrId() int64 {
	if m != nil {
		return m.AttrId
	}
	return 0
}

func (m *DeleteAttrReq) GetAttrSubId() int64 {
	if m != nil {
		return m.AttrSubId
	}
	return 0
}

func init() {
	proto.RegisterType((*AnchorLevel)(nil), "live.daoanchor.v1.AnchorLevel")
	proto.RegisterType((*TagData)(nil), "live.daoanchor.v1.TagData")
	proto.RegisterType((*RoomData)(nil), "live.daoanchor.v1.RoomData")
	proto.RegisterType((*RoomByIDsReq)(nil), "live.daoanchor.v1.RoomByIDsReq")
	proto.RegisterType((*RoomByIDsResp)(nil), "live.daoanchor.v1.RoomByIDsResp")
	proto.RegisterMapType((map[int64]*RoomData)(nil), "live.daoanchor.v1.RoomByIDsResp.RoomDataSetEntry")
	proto.RegisterType((*RoomOnlineListReq)(nil), "live.daoanchor.v1.RoomOnlineListReq")
	proto.RegisterType((*RoomOnlineListResp)(nil), "live.daoanchor.v1.RoomOnlineListResp")
	proto.RegisterMapType((map[int64]*RoomData)(nil), "live.daoanchor.v1.RoomOnlineListResp.RoomDataListEntry")
	proto.RegisterType((*RoomOnlineListByAreaReq)(nil), "live.daoanchor.v1.RoomOnlineListByAreaReq")
	proto.RegisterType((*RoomOnlineListByAreaResp)(nil), "live.daoanchor.v1.RoomOnlineListByAreaResp")
	proto.RegisterType((*RoomCreateReq)(nil), "live.daoanchor.v1.RoomCreateReq")
	proto.RegisterType((*RoomCreateResp)(nil), "live.daoanchor.v1.RoomCreateResp")
	proto.RegisterType((*UpdateResp)(nil), "live.daoanchor.v1.UpdateResp")
	proto.RegisterType((*RoomUpdateReq)(nil), "live.daoanchor.v1.RoomUpdateReq")
	proto.RegisterType((*RoomBatchUpdateReq)(nil), "live.daoanchor.v1.RoomBatchUpdateReq")
	proto.RegisterType((*AnchorUpdateReq)(nil), "live.daoanchor.v1.AnchorUpdateReq")
	proto.RegisterType((*AnchorBatchUpdateReq)(nil), "live.daoanchor.v1.AnchorBatchUpdateReq")
	proto.RegisterType((*AnchorIncreReq)(nil), "live.daoanchor.v1.AnchorIncreReq")
	proto.RegisterType((*AnchorBatchIncreReq)(nil), "live.daoanchor.v1.AnchorBatchIncreReq")
	proto.RegisterType((*RoomExtendUpdateReq)(nil), "live.daoanchor.v1.RoomExtendUpdateReq")
	proto.RegisterType((*RoomExtendBatchUpdateReq)(nil), "live.daoanchor.v1.RoomExtendBatchUpdateReq")
	proto.RegisterType((*RoomExtendIncreReq)(nil), "live.daoanchor.v1.RoomExtendIncreReq")
	proto.RegisterType((*RoomExtendBatchIncreReq)(nil), "live.daoanchor.v1.RoomExtendBatchIncreReq")
	proto.RegisterType((*RoomTagCreateReq)(nil), "live.daoanchor.v1.RoomTagCreateReq")
	proto.RegisterType((*RoomAttrCreateReq)(nil), "live.daoanchor.v1.RoomAttrCreateReq")
	proto.RegisterType((*RoomAttrSetExReq)(nil), "live.daoanchor.v1.RoomAttrSetExReq")
	proto.RegisterType((*FetchAreasReq)(nil), "live.daoanchor.v1.FetchAreasReq")
	proto.RegisterType((*AreaInfo)(nil), "live.daoanchor.v1.AreaInfo")
	proto.RegisterType((*FetchAreasResp)(nil), "live.daoanchor.v1.FetchAreasResp")
	proto.RegisterType((*FetchAttrByIDsReq)(nil), "live.daoanchor.v1.FetchAttrByIDsReq")
	proto.RegisterType((*AttrData)(nil), "live.daoanchor.v1.AttrData")
	proto.RegisterType((*FetchAttrByIDsResp)(nil), "live.daoanchor.v1.FetchAttrByIDsResp")
	proto.RegisterMapType((map[int64]*AttrData)(nil), "live.daoanchor.v1.FetchAttrByIDsResp.AttrsEntry")
	proto.RegisterType((*AttrReq)(nil), "live.daoanchor.v1.AttrReq")
	proto.RegisterType((*RoomOnlineListByAttrsReq)(nil), "live.daoanchor.v1.RoomOnlineListByAttrsReq")
	proto.RegisterType((*AttrResp)(nil), "live.daoanchor.v1.AttrResp")
	proto.RegisterType((*RoomOnlineListByAttrsResp)(nil), "live.daoanchor.v1.RoomOnlineListByAttrsResp")
	proto.RegisterMapType((map[int64]*AttrResp)(nil), "live.daoanchor.v1.RoomOnlineListByAttrsResp.AttrsEntry")
	proto.RegisterType((*DeleteAttrReq)(nil), "live.daoanchor.v1.DeleteAttrReq")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DaoAnchorClient is the client API for DaoAnchor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DaoAnchorClient interface {
	// FetchRoomByIDs 查询房间信息
	FetchRoomByIDs(ctx context.Context, in *RoomByIDsReq, opts ...grpc.CallOption) (*RoomByIDsResp, error)
	// RoomOnlineList 在线房间列表
	RoomOnlineList(ctx context.Context, in *RoomOnlineListReq, opts ...grpc.CallOption) (*RoomOnlineListResp, error)
	// RoomOnlineListByArea 分区在线房间列表(只返回room_id列表，不传分区，默认查找所有)
	RoomOnlineListByArea(ctx context.Context, in *RoomOnlineListByAreaReq, opts ...grpc.CallOption) (*RoomOnlineListByAreaResp, error)
	// RoomOnlineListByAttrs 在线房间维度信息(不传attrs，不查询attr)
	RoomOnlineListByAttrs(ctx context.Context, in *RoomOnlineListByAttrsReq, opts ...grpc.CallOption) (*RoomOnlineListByAttrsResp, error)
	// RoomCreate 房间创建
	RoomCreate(ctx context.Context, in *RoomCreateReq, opts ...grpc.CallOption) (*RoomCreateResp, error)
	// RoomUpdate 房间信息更新
	RoomUpdate(ctx context.Context, in *RoomUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomBatchUpdate 房间信息批量更新
	RoomBatchUpdate(ctx context.Context, in *RoomBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomExtendUpdate 房间扩展信息更新
	RoomExtendUpdate(ctx context.Context, in *RoomExtendUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomExtendBatchUpdate 房间扩展信息批量更新
	RoomExtendBatchUpdate(ctx context.Context, in *RoomExtendBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomExtendIncre 房间信息增量更新
	RoomExtendIncre(ctx context.Context, in *RoomExtendIncreReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomExtendBatchIncre 房间信息批量增量更新
	RoomExtendBatchIncre(ctx context.Context, in *RoomExtendBatchIncreReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomTagCreate 房间Tag创建
	RoomTagCreate(ctx context.Context, in *RoomTagCreateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomAttrCreate 房间Attr创建
	RoomAttrCreate(ctx context.Context, in *RoomAttrCreateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomAttrSetEx 房间Attr更新
	RoomAttrSetEx(ctx context.Context, in *RoomAttrSetExReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// AnchorUpdate 主播信息更新
	AnchorUpdate(ctx context.Context, in *AnchorUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// AnchorBatchUpdate 主播信息批量更新
	AnchorBatchUpdate(ctx context.Context, in *AnchorBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// AnchorIncre 主播信息增量更新
	AnchorIncre(ctx context.Context, in *AnchorIncreReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// AnchorBatchIncre 主播信息批量增量更新
	AnchorBatchIncre(ctx context.Context, in *AnchorBatchIncreReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// FetchAreas 根据父分区号查询子分区
	FetchAreas(ctx context.Context, in *FetchAreasReq, opts ...grpc.CallOption) (*FetchAreasResp, error)
	// FetchAttrByIDs 批量根据房间号查询指标
	FetchAttrByIDs(ctx context.Context, in *FetchAttrByIDsReq, opts ...grpc.CallOption) (*FetchAttrByIDsResp, error)
	// DeleteAttr 删除某一个指标
	DeleteAttr(ctx context.Context, in *DeleteAttrReq, opts ...grpc.CallOption) (*UpdateResp, error)
}

type daoAnchorClient struct {
	cc *grpc.ClientConn
}

func NewDaoAnchorClient(cc *grpc.ClientConn) DaoAnchorClient {
	return &daoAnchorClient{cc}
}

func (c *daoAnchorClient) FetchRoomByIDs(ctx context.Context, in *RoomByIDsReq, opts ...grpc.CallOption) (*RoomByIDsResp, error) {
	out := new(RoomByIDsResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/FetchRoomByIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomOnlineList(ctx context.Context, in *RoomOnlineListReq, opts ...grpc.CallOption) (*RoomOnlineListResp, error) {
	out := new(RoomOnlineListResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomOnlineList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomOnlineListByArea(ctx context.Context, in *RoomOnlineListByAreaReq, opts ...grpc.CallOption) (*RoomOnlineListByAreaResp, error) {
	out := new(RoomOnlineListByAreaResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomOnlineListByArea", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomOnlineListByAttrs(ctx context.Context, in *RoomOnlineListByAttrsReq, opts ...grpc.CallOption) (*RoomOnlineListByAttrsResp, error) {
	out := new(RoomOnlineListByAttrsResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomOnlineListByAttrs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomCreate(ctx context.Context, in *RoomCreateReq, opts ...grpc.CallOption) (*RoomCreateResp, error) {
	out := new(RoomCreateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomUpdate(ctx context.Context, in *RoomUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomBatchUpdate(ctx context.Context, in *RoomBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomBatchUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomExtendUpdate(ctx context.Context, in *RoomExtendUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomExtendUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomExtendBatchUpdate(ctx context.Context, in *RoomExtendBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomExtendBatchUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomExtendIncre(ctx context.Context, in *RoomExtendIncreReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomExtendIncre", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomExtendBatchIncre(ctx context.Context, in *RoomExtendBatchIncreReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomExtendBatchIncre", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomTagCreate(ctx context.Context, in *RoomTagCreateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomTagCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomAttrCreate(ctx context.Context, in *RoomAttrCreateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomAttrCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) RoomAttrSetEx(ctx context.Context, in *RoomAttrSetExReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/RoomAttrSetEx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) AnchorUpdate(ctx context.Context, in *AnchorUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/AnchorUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) AnchorBatchUpdate(ctx context.Context, in *AnchorBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/AnchorBatchUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) AnchorIncre(ctx context.Context, in *AnchorIncreReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/AnchorIncre", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) AnchorBatchIncre(ctx context.Context, in *AnchorBatchIncreReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/AnchorBatchIncre", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) FetchAreas(ctx context.Context, in *FetchAreasReq, opts ...grpc.CallOption) (*FetchAreasResp, error) {
	out := new(FetchAreasResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/FetchAreas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) FetchAttrByIDs(ctx context.Context, in *FetchAttrByIDsReq, opts ...grpc.CallOption) (*FetchAttrByIDsResp, error) {
	out := new(FetchAttrByIDsResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/FetchAttrByIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daoAnchorClient) DeleteAttr(ctx context.Context, in *DeleteAttrReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.daoanchor.v1.DaoAnchor/DeleteAttr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaoAnchorServer is the server API for DaoAnchor service.
type DaoAnchorServer interface {
	// FetchRoomByIDs 查询房间信息
	FetchRoomByIDs(context.Context, *RoomByIDsReq) (*RoomByIDsResp, error)
	// RoomOnlineList 在线房间列表
	RoomOnlineList(context.Context, *RoomOnlineListReq) (*RoomOnlineListResp, error)
	// RoomOnlineListByArea 分区在线房间列表(只返回room_id列表，不传分区，默认查找所有)
	RoomOnlineListByArea(context.Context, *RoomOnlineListByAreaReq) (*RoomOnlineListByAreaResp, error)
	// RoomOnlineListByAttrs 在线房间维度信息(不传attrs，不查询attr)
	RoomOnlineListByAttrs(context.Context, *RoomOnlineListByAttrsReq) (*RoomOnlineListByAttrsResp, error)
	// RoomCreate 房间创建
	RoomCreate(context.Context, *RoomCreateReq) (*RoomCreateResp, error)
	// RoomUpdate 房间信息更新
	RoomUpdate(context.Context, *RoomUpdateReq) (*UpdateResp, error)
	// RoomBatchUpdate 房间信息批量更新
	RoomBatchUpdate(context.Context, *RoomBatchUpdateReq) (*UpdateResp, error)
	// RoomExtendUpdate 房间扩展信息更新
	RoomExtendUpdate(context.Context, *RoomExtendUpdateReq) (*UpdateResp, error)
	// RoomExtendBatchUpdate 房间扩展信息批量更新
	RoomExtendBatchUpdate(context.Context, *RoomExtendBatchUpdateReq) (*UpdateResp, error)
	// RoomExtendIncre 房间信息增量更新
	RoomExtendIncre(context.Context, *RoomExtendIncreReq) (*UpdateResp, error)
	// RoomExtendBatchIncre 房间信息批量增量更新
	RoomExtendBatchIncre(context.Context, *RoomExtendBatchIncreReq) (*UpdateResp, error)
	// RoomTagCreate 房间Tag创建
	RoomTagCreate(context.Context, *RoomTagCreateReq) (*UpdateResp, error)
	// RoomAttrCreate 房间Attr创建
	RoomAttrCreate(context.Context, *RoomAttrCreateReq) (*UpdateResp, error)
	// RoomAttrSetEx 房间Attr更新
	RoomAttrSetEx(context.Context, *RoomAttrSetExReq) (*UpdateResp, error)
	// AnchorUpdate 主播信息更新
	AnchorUpdate(context.Context, *AnchorUpdateReq) (*UpdateResp, error)
	// AnchorBatchUpdate 主播信息批量更新
	AnchorBatchUpdate(context.Context, *AnchorBatchUpdateReq) (*UpdateResp, error)
	// AnchorIncre 主播信息增量更新
	AnchorIncre(context.Context, *AnchorIncreReq) (*UpdateResp, error)
	// AnchorBatchIncre 主播信息批量增量更新
	AnchorBatchIncre(context.Context, *AnchorBatchIncreReq) (*UpdateResp, error)
	// FetchAreas 根据父分区号查询子分区
	FetchAreas(context.Context, *FetchAreasReq) (*FetchAreasResp, error)
	// FetchAttrByIDs 批量根据房间号查询指标
	FetchAttrByIDs(context.Context, *FetchAttrByIDsReq) (*FetchAttrByIDsResp, error)
	// DeleteAttr 删除某一个指标
	DeleteAttr(context.Context, *DeleteAttrReq) (*UpdateResp, error)
}

func RegisterDaoAnchorServer(s *grpc.Server, srv DaoAnchorServer) {
	s.RegisterService(&_DaoAnchor_serviceDesc, srv)
}

func _DaoAnchor_FetchRoomByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomByIDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).FetchRoomByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/FetchRoomByIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).FetchRoomByIDs(ctx, req.(*RoomByIDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomOnlineList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomOnlineListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomOnlineList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomOnlineList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomOnlineList(ctx, req.(*RoomOnlineListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomOnlineListByArea_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomOnlineListByAreaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomOnlineListByArea(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomOnlineListByArea",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomOnlineListByArea(ctx, req.(*RoomOnlineListByAreaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomOnlineListByAttrs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomOnlineListByAttrsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomOnlineListByAttrs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomOnlineListByAttrs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomOnlineListByAttrs(ctx, req.(*RoomOnlineListByAttrsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomCreate(ctx, req.(*RoomCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomUpdate(ctx, req.(*RoomUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomBatchUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomBatchUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomBatchUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomBatchUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomBatchUpdate(ctx, req.(*RoomBatchUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomExtendUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomExtendUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomExtendUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomExtendUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomExtendUpdate(ctx, req.(*RoomExtendUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomExtendBatchUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomExtendBatchUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomExtendBatchUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomExtendBatchUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomExtendBatchUpdate(ctx, req.(*RoomExtendBatchUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomExtendIncre_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomExtendIncreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomExtendIncre(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomExtendIncre",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomExtendIncre(ctx, req.(*RoomExtendIncreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomExtendBatchIncre_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomExtendBatchIncreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomExtendBatchIncre(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomExtendBatchIncre",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomExtendBatchIncre(ctx, req.(*RoomExtendBatchIncreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomTagCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomTagCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomTagCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomTagCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomTagCreate(ctx, req.(*RoomTagCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomAttrCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomAttrCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomAttrCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomAttrCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomAttrCreate(ctx, req.(*RoomAttrCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_RoomAttrSetEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomAttrSetExReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).RoomAttrSetEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/RoomAttrSetEx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).RoomAttrSetEx(ctx, req.(*RoomAttrSetExReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_AnchorUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).AnchorUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/AnchorUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).AnchorUpdate(ctx, req.(*AnchorUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_AnchorBatchUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorBatchUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).AnchorBatchUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/AnchorBatchUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).AnchorBatchUpdate(ctx, req.(*AnchorBatchUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_AnchorIncre_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorIncreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).AnchorIncre(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/AnchorIncre",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).AnchorIncre(ctx, req.(*AnchorIncreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_AnchorBatchIncre_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorBatchIncreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).AnchorBatchIncre(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/AnchorBatchIncre",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).AnchorBatchIncre(ctx, req.(*AnchorBatchIncreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_FetchAreas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchAreasReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).FetchAreas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/FetchAreas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).FetchAreas(ctx, req.(*FetchAreasReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_FetchAttrByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchAttrByIDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).FetchAttrByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/FetchAttrByIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).FetchAttrByIDs(ctx, req.(*FetchAttrByIDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaoAnchor_DeleteAttr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAttrReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaoAnchorServer).DeleteAttr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.daoanchor.v1.DaoAnchor/DeleteAttr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaoAnchorServer).DeleteAttr(ctx, req.(*DeleteAttrReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _DaoAnchor_serviceDesc = grpc.ServiceDesc{
	ServiceName: "live.daoanchor.v1.DaoAnchor",
	HandlerType: (*DaoAnchorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchRoomByIDs",
			Handler:    _DaoAnchor_FetchRoomByIDs_Handler,
		},
		{
			MethodName: "RoomOnlineList",
			Handler:    _DaoAnchor_RoomOnlineList_Handler,
		},
		{
			MethodName: "RoomOnlineListByArea",
			Handler:    _DaoAnchor_RoomOnlineListByArea_Handler,
		},
		{
			MethodName: "RoomOnlineListByAttrs",
			Handler:    _DaoAnchor_RoomOnlineListByAttrs_Handler,
		},
		{
			MethodName: "RoomCreate",
			Handler:    _DaoAnchor_RoomCreate_Handler,
		},
		{
			MethodName: "RoomUpdate",
			Handler:    _DaoAnchor_RoomUpdate_Handler,
		},
		{
			MethodName: "RoomBatchUpdate",
			Handler:    _DaoAnchor_RoomBatchUpdate_Handler,
		},
		{
			MethodName: "RoomExtendUpdate",
			Handler:    _DaoAnchor_RoomExtendUpdate_Handler,
		},
		{
			MethodName: "RoomExtendBatchUpdate",
			Handler:    _DaoAnchor_RoomExtendBatchUpdate_Handler,
		},
		{
			MethodName: "RoomExtendIncre",
			Handler:    _DaoAnchor_RoomExtendIncre_Handler,
		},
		{
			MethodName: "RoomExtendBatchIncre",
			Handler:    _DaoAnchor_RoomExtendBatchIncre_Handler,
		},
		{
			MethodName: "RoomTagCreate",
			Handler:    _DaoAnchor_RoomTagCreate_Handler,
		},
		{
			MethodName: "RoomAttrCreate",
			Handler:    _DaoAnchor_RoomAttrCreate_Handler,
		},
		{
			MethodName: "RoomAttrSetEx",
			Handler:    _DaoAnchor_RoomAttrSetEx_Handler,
		},
		{
			MethodName: "AnchorUpdate",
			Handler:    _DaoAnchor_AnchorUpdate_Handler,
		},
		{
			MethodName: "AnchorBatchUpdate",
			Handler:    _DaoAnchor_AnchorBatchUpdate_Handler,
		},
		{
			MethodName: "AnchorIncre",
			Handler:    _DaoAnchor_AnchorIncre_Handler,
		},
		{
			MethodName: "AnchorBatchIncre",
			Handler:    _DaoAnchor_AnchorBatchIncre_Handler,
		},
		{
			MethodName: "FetchAreas",
			Handler:    _DaoAnchor_FetchAreas_Handler,
		},
		{
			MethodName: "FetchAttrByIDs",
			Handler:    _DaoAnchor_FetchAttrByIDs_Handler,
		},
		{
			MethodName: "DeleteAttr",
			Handler:    _DaoAnchor_DeleteAttr_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/live/dao-anchor/api/grpc/v1/api.proto",
}

func (m *AnchorLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorLevel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Level))
	}
	if m.Color != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Color))
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Score))
	}
	if m.Left != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Left))
	}
	if m.Right != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Right))
	}
	if m.MaxLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MaxLevel))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TagData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TagId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagId))
	}
	if m.TagSubId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagSubId))
	}
	if m.TagValue != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagValue))
	}
	if len(m.TagExt) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TagExt)))
		i += copy(dAtA[i:], m.TagExt)
	}
	if m.TagExpireAt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagExpireAt))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.ShortId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShortId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if len(m.Tags) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tags)))
		i += copy(dAtA[i:], m.Tags)
	}
	if len(m.Background) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Background)))
		i += copy(dAtA[i:], m.Background)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.LiveStatus != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveStatus))
	}
	if m.LiveStartTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveStartTime))
	}
	if m.LiveScreenType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveScreenType))
	}
	if m.LiveMark != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveMark))
	}
	if m.LockStatus != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LockStatus))
	}
	if m.LockTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LockTime))
	}
	if m.HiddenStatus != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HiddenStatus))
	}
	if m.HiddenTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HiddenTime))
	}
	if m.AreaId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaId))
	}
	if len(m.AreaName) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.AreaName)))
		i += copy(dAtA[i:], m.AreaName)
	}
	if m.ParentAreaId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ParentAreaId))
	}
	if len(m.ParentAreaName) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ParentAreaName)))
		i += copy(dAtA[i:], m.ParentAreaName)
	}
	if len(m.Keyframe) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Keyframe)))
		i += copy(dAtA[i:], m.Keyframe)
	}
	if m.PopularityCount != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PopularityCount))
	}
	if len(m.TagList) > 0 {
		for _, msg := range m.TagList {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AnchorProfileType != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorProfileType))
	}
	if m.AnchorLevel != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorLevel.Size()))
		n1, err := m.AnchorLevel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.AnchorRoundSwitch != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRoundSwitch))
	}
	if m.AnchorRoundStatus != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRoundStatus))
	}
	if m.AnchorRecordSwitch != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRecordSwitch))
	}
	if m.AnchorRecordStatus != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRecordStatus))
	}
	if m.AnchorSan != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorSan))
	}
	if m.LiveType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomByIDsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomByIDsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		dAtA3 := make([]byte, len(m.RoomIds)*10)
		var j2 int
		for _, num1 := range m.RoomIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.Uids) > 0 {
		dAtA5 := make([]byte, len(m.Uids)*10)
		var j4 int
		for _, num1 := range m.Uids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DefaultFields != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DefaultFields))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomByIDsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomByIDsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomDataSet) > 0 {
		for k, _ := range m.RoomDataSet {
			dAtA[i] = 0xa
			i++
			v := m.RoomDataSet[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomOnlineListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOnlineListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Filter) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	if len(m.Sort) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sort)))
		i += copy(dAtA[i:], m.Sort)
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Page))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PageSize))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomOnlineListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOnlineListResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomDataList) > 0 {
		for k, _ := range m.RoomDataList {
			dAtA[i] = 0xa
			i++
			v := m.RoomDataList[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomOnlineListByAreaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOnlineListByAreaReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AreaIds) > 0 {
		dAtA9 := make([]byte, len(m.AreaIds)*10)
		var j8 int
		for _, num1 := range m.AreaIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomOnlineListByAreaResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOnlineListByAreaResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		dAtA11 := make([]byte, len(m.RoomIds)*10)
		var j10 int
		for _, num1 := range m.RoomIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomCreateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomCreateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomCreateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomCreateResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AffectedRows != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AffectedRows))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if len(m.Tags) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tags)))
		i += copy(dAtA[i:], m.Tags)
	}
	if len(m.Background) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Background)))
		i += copy(dAtA[i:], m.Background)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.LiveStartTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveStartTime))
	}
	if m.LiveScreenType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveScreenType))
	}
	if m.LockStatus != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LockStatus))
	}
	if m.LockTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LockTime))
	}
	if m.HiddenTime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HiddenTime))
	}
	if m.AreaId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaId))
	}
	if m.AnchorRoundSwitch != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRoundSwitch))
	}
	if m.AnchorRecordSwitch != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRecordSwitch))
	}
	if m.LiveType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomBatchUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomBatchUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.ProfileType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ProfileType))
	}
	if m.SanScore != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SanScore))
	}
	if m.RoundStatus != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoundStatus))
	}
	if m.RecordStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RecordStatus))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Exp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorBatchUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorBatchUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorIncreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorIncreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReqId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ReqId)))
		i += copy(dAtA[i:], m.ReqId)
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Uid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.SanScore != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SanScore))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Exp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorBatchIncreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorBatchIncreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomExtendUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomExtendUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if len(m.Keyframe) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Keyframe)))
		i += copy(dAtA[i:], m.Keyframe)
	}
	if m.DanmuCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DanmuCount))
	}
	if m.PopularityCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PopularityCount))
	}
	if m.AudienceCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AudienceCount))
	}
	if m.GiftCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftCount))
	}
	if m.GiftGoldAmount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftGoldAmount))
	}
	if m.GiftGoldCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftGoldCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomExtendBatchUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomExtendBatchUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomExtendIncreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomExtendIncreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReqId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ReqId)))
		i += copy(dAtA[i:], m.ReqId)
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.DanmuCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DanmuCount))
	}
	if m.PopularityCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PopularityCount))
	}
	if m.AudienceCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AudienceCount))
	}
	if m.GiftCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftCount))
	}
	if m.GiftGoldAmount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftGoldAmount))
	}
	if m.GiftGoldCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftGoldCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomExtendBatchIncreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomExtendBatchIncreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomTagCreateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomTagCreateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.TagId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagId))
	}
	if m.TagSubId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagSubId))
	}
	if m.TagValue != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagValue))
	}
	if len(m.TagExt) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TagExt)))
		i += copy(dAtA[i:], m.TagExt)
	}
	if m.TagExpireAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagExpireAt))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomAttrCreateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomAttrCreateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.AttrId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrSubId))
	}
	if m.AttrValue != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrValue))
	}
	if len(m.AttrExt) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.AttrExt)))
		i += copy(dAtA[i:], m.AttrExt)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomAttrSetExReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomAttrSetExReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.AttrId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrSubId))
	}
	if m.AttrValue != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrValue))
	}
	if len(m.AttrExt) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.AttrExt)))
		i += copy(dAtA[i:], m.AttrExt)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FetchAreasReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchAreasReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AreaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AreaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AreaInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AreaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaId))
	}
	if len(m.AreaName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.AreaName)))
		i += copy(dAtA[i:], m.AreaName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FetchAreasResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchAreasResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Info.Size()))
		n12, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Areas) > 0 {
		for _, msg := range m.Areas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FetchAttrByIDsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchAttrByIDsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		dAtA14 := make([]byte, len(m.RoomIds)*10)
		var j13 int
		for _, num1 := range m.RoomIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.AttrId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrSubId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttrData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.AttrId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrSubId))
	}
	if m.AttrValue != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrValue))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FetchAttrByIDsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchAttrByIDsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for k, _ := range m.Attrs {
			dAtA[i] = 0xa
			i++
			v := m.Attrs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n15, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n15
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttrReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AttrId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrSubId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomOnlineListByAttrsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOnlineListByAttrsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, msg := range m.Attrs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttrResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.AreaId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaId))
	}
	if m.ParentAreaId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ParentAreaId))
	}
	if len(m.TagList) > 0 {
		for _, msg := range m.TagList {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AttrList) > 0 {
		for _, msg := range m.AttrList {
			dAtA[i] = 0x32
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PopularityCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PopularityCount))
	}
	if m.AnchorProfileType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorProfileType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomOnlineListByAttrsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOnlineListByAttrsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for k, _ := range m.Attrs {
			dAtA[i] = 0xa
			i++
			v := m.Attrs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n16, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n16
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteAttrReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAttrReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AttrId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AttrSubId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AnchorLevel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovApi(uint64(m.Level))
	}
	if m.Color != 0 {
		n += 1 + sovApi(uint64(m.Color))
	}
	if m.Score != 0 {
		n += 1 + sovApi(uint64(m.Score))
	}
	if m.Left != 0 {
		n += 1 + sovApi(uint64(m.Left))
	}
	if m.Right != 0 {
		n += 1 + sovApi(uint64(m.Right))
	}
	if m.MaxLevel != 0 {
		n += 1 + sovApi(uint64(m.MaxLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TagData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TagId != 0 {
		n += 1 + sovApi(uint64(m.TagId))
	}
	if m.TagSubId != 0 {
		n += 1 + sovApi(uint64(m.TagSubId))
	}
	if m.TagValue != 0 {
		n += 1 + sovApi(uint64(m.TagValue))
	}
	l = len(m.TagExt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TagExpireAt != 0 {
		n += 1 + sovApi(uint64(m.TagExpireAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.ShortId != 0 {
		n += 1 + sovApi(uint64(m.ShortId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Background)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.LiveStatus != 0 {
		n += 1 + sovApi(uint64(m.LiveStatus))
	}
	if m.LiveStartTime != 0 {
		n += 1 + sovApi(uint64(m.LiveStartTime))
	}
	if m.LiveScreenType != 0 {
		n += 1 + sovApi(uint64(m.LiveScreenType))
	}
	if m.LiveMark != 0 {
		n += 1 + sovApi(uint64(m.LiveMark))
	}
	if m.LockStatus != 0 {
		n += 1 + sovApi(uint64(m.LockStatus))
	}
	if m.LockTime != 0 {
		n += 1 + sovApi(uint64(m.LockTime))
	}
	if m.HiddenStatus != 0 {
		n += 1 + sovApi(uint64(m.HiddenStatus))
	}
	if m.HiddenTime != 0 {
		n += 2 + sovApi(uint64(m.HiddenTime))
	}
	if m.AreaId != 0 {
		n += 2 + sovApi(uint64(m.AreaId))
	}
	l = len(m.AreaName)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.ParentAreaId != 0 {
		n += 2 + sovApi(uint64(m.ParentAreaId))
	}
	l = len(m.ParentAreaName)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Keyframe)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.PopularityCount != 0 {
		n += 2 + sovApi(uint64(m.PopularityCount))
	}
	if len(m.TagList) > 0 {
		for _, e := range m.TagList {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.AnchorProfileType != 0 {
		n += 2 + sovApi(uint64(m.AnchorProfileType))
	}
	if m.AnchorLevel != nil {
		l = m.AnchorLevel.Size()
		n += 2 + l + sovApi(uint64(l))
	}
	if m.AnchorRoundSwitch != 0 {
		n += 2 + sovApi(uint64(m.AnchorRoundSwitch))
	}
	if m.AnchorRoundStatus != 0 {
		n += 2 + sovApi(uint64(m.AnchorRoundStatus))
	}
	if m.AnchorRecordSwitch != 0 {
		n += 2 + sovApi(uint64(m.AnchorRecordSwitch))
	}
	if m.AnchorRecordStatus != 0 {
		n += 2 + sovApi(uint64(m.AnchorRecordStatus))
	}
	if m.AnchorSan != 0 {
		n += 2 + sovApi(uint64(m.AnchorSan))
	}
	if m.LiveType != 0 {
		n += 2 + sovApi(uint64(m.LiveType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomByIDsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		l = 0
		for _, e := range m.RoomIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.DefaultFields != 0 {
		n += 1 + sovApi(uint64(m.DefaultFields))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomByIDsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomDataSet) > 0 {
		for k, v := range m.RoomDataSet {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomOnlineListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovApi(uint64(m.Page))
	}
	if m.PageSize != 0 {
		n += 1 + sovApi(uint64(m.PageSize))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomOnlineListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomDataList) > 0 {
		for k, v := range m.RoomDataList {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomOnlineListByAreaReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AreaIds) > 0 {
		l = 0
		for _, e := range m.AreaIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomOnlineListByAreaResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		l = 0
		for _, e := range m.RoomIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomCreateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomCreateResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AffectedRows != 0 {
		n += 1 + sovApi(uint64(m.AffectedRows))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Background)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.LiveStartTime != 0 {
		n += 1 + sovApi(uint64(m.LiveStartTime))
	}
	if m.LiveScreenType != 0 {
		n += 1 + sovApi(uint64(m.LiveScreenType))
	}
	if m.LockStatus != 0 {
		n += 1 + sovApi(uint64(m.LockStatus))
	}
	if m.LockTime != 0 {
		n += 1 + sovApi(uint64(m.LockTime))
	}
	if m.HiddenTime != 0 {
		n += 1 + sovApi(uint64(m.HiddenTime))
	}
	if m.AreaId != 0 {
		n += 1 + sovApi(uint64(m.AreaId))
	}
	if m.AnchorRoundSwitch != 0 {
		n += 1 + sovApi(uint64(m.AnchorRoundSwitch))
	}
	if m.AnchorRecordSwitch != 0 {
		n += 1 + sovApi(uint64(m.AnchorRecordSwitch))
	}
	if m.LiveType != 0 {
		n += 2 + sovApi(uint64(m.LiveType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomBatchUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.ProfileType != 0 {
		n += 1 + sovApi(uint64(m.ProfileType))
	}
	if m.SanScore != 0 {
		n += 1 + sovApi(uint64(m.SanScore))
	}
	if m.RoundStatus != 0 {
		n += 1 + sovApi(uint64(m.RoundStatus))
	}
	if m.RecordStatus != 0 {
		n += 1 + sovApi(uint64(m.RecordStatus))
	}
	if m.Exp != 0 {
		n += 1 + sovApi(uint64(m.Exp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorBatchUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorIncreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.SanScore != 0 {
		n += 1 + sovApi(uint64(m.SanScore))
	}
	if m.Exp != 0 {
		n += 1 + sovApi(uint64(m.Exp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorBatchIncreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomExtendUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	l = len(m.Keyframe)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DanmuCount != 0 {
		n += 1 + sovApi(uint64(m.DanmuCount))
	}
	if m.PopularityCount != 0 {
		n += 1 + sovApi(uint64(m.PopularityCount))
	}
	if m.AudienceCount != 0 {
		n += 1 + sovApi(uint64(m.AudienceCount))
	}
	if m.GiftCount != 0 {
		n += 1 + sovApi(uint64(m.GiftCount))
	}
	if m.GiftGoldAmount != 0 {
		n += 1 + sovApi(uint64(m.GiftGoldAmount))
	}
	if m.GiftGoldCount != 0 {
		n += 1 + sovApi(uint64(m.GiftGoldCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomExtendBatchUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomExtendIncreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.DanmuCount != 0 {
		n += 1 + sovApi(uint64(m.DanmuCount))
	}
	if m.PopularityCount != 0 {
		n += 1 + sovApi(uint64(m.PopularityCount))
	}
	if m.AudienceCount != 0 {
		n += 1 + sovApi(uint64(m.AudienceCount))
	}
	if m.GiftCount != 0 {
		n += 1 + sovApi(uint64(m.GiftCount))
	}
	if m.GiftGoldAmount != 0 {
		n += 1 + sovApi(uint64(m.GiftGoldAmount))
	}
	if m.GiftGoldCount != 0 {
		n += 1 + sovApi(uint64(m.GiftGoldCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomExtendBatchIncreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomTagCreateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.TagId != 0 {
		n += 1 + sovApi(uint64(m.TagId))
	}
	if m.TagSubId != 0 {
		n += 1 + sovApi(uint64(m.TagSubId))
	}
	if m.TagValue != 0 {
		n += 1 + sovApi(uint64(m.TagValue))
	}
	l = len(m.TagExt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TagExpireAt != 0 {
		n += 1 + sovApi(uint64(m.TagExpireAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomAttrCreateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.AttrId != 0 {
		n += 1 + sovApi(uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		n += 1 + sovApi(uint64(m.AttrSubId))
	}
	if m.AttrValue != 0 {
		n += 1 + sovApi(uint64(m.AttrValue))
	}
	l = len(m.AttrExt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomAttrSetExReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.AttrId != 0 {
		n += 1 + sovApi(uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		n += 1 + sovApi(uint64(m.AttrSubId))
	}
	if m.AttrValue != 0 {
		n += 1 + sovApi(uint64(m.AttrValue))
	}
	l = len(m.AttrExt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchAreasReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AreaId != 0 {
		n += 1 + sovApi(uint64(m.AreaId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AreaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AreaId != 0 {
		n += 1 + sovApi(uint64(m.AreaId))
	}
	l = len(m.AreaName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchAreasResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Areas) > 0 {
		for _, e := range m.Areas {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchAttrByIDsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		l = 0
		for _, e := range m.RoomIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.AttrId != 0 {
		n += 1 + sovApi(uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		n += 1 + sovApi(uint64(m.AttrSubId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttrData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.AttrId != 0 {
		n += 1 + sovApi(uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		n += 1 + sovApi(uint64(m.AttrSubId))
	}
	if m.AttrValue != 0 {
		n += 1 + sovApi(uint64(m.AttrValue))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchAttrByIDsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for k, v := range m.Attrs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttrReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttrId != 0 {
		n += 1 + sovApi(uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		n += 1 + sovApi(uint64(m.AttrSubId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomOnlineListByAttrsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, e := range m.Attrs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttrResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.AreaId != 0 {
		n += 1 + sovApi(uint64(m.AreaId))
	}
	if m.ParentAreaId != 0 {
		n += 1 + sovApi(uint64(m.ParentAreaId))
	}
	if len(m.TagList) > 0 {
		for _, e := range m.TagList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.AttrList) > 0 {
		for _, e := range m.AttrList {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.PopularityCount != 0 {
		n += 1 + sovApi(uint64(m.PopularityCount))
	}
	if m.AnchorProfileType != 0 {
		n += 1 + sovApi(uint64(m.AnchorProfileType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomOnlineListByAttrsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for k, v := range m.Attrs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteAttrReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttrId != 0 {
		n += 1 + sovApi(uint64(m.AttrId))
	}
	if m.AttrSubId != 0 {
		n += 1 + sovApi(uint64(m.AttrSubId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AnchorLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			m.Left = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Left |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			m.Right = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Right |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLevel", wireType)
			}
			m.MaxLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLevel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagSubId", wireType)
			}
			m.TagSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagSubId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			m.TagValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpireAt", wireType)
			}
			m.TagExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagExpireAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortId", wireType)
			}
			m.ShortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShortId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Background = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStatus", wireType)
			}
			m.LiveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStartTime", wireType)
			}
			m.LiveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveScreenType", wireType)
			}
			m.LiveScreenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveScreenType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveMark", wireType)
			}
			m.LiveMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveMark |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockStatus", wireType)
			}
			m.LockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTime", wireType)
			}
			m.LockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenStatus", wireType)
			}
			m.HiddenStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HiddenStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenTime", wireType)
			}
			m.HiddenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HiddenTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AreaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAreaId", wireType)
			}
			m.ParentAreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentAreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAreaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentAreaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyframe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyframe = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PopularityCount", wireType)
			}
			m.PopularityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PopularityCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagList = append(m.TagList, &TagData{})
			if err := m.TagList[len(m.TagList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorProfileType", wireType)
			}
			m.AnchorProfileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorProfileType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnchorLevel == nil {
				m.AnchorLevel = &AnchorLevel{}
			}
			if err := m.AnchorLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRoundSwitch", wireType)
			}
			m.AnchorRoundSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRoundSwitch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRoundStatus", wireType)
			}
			m.AnchorRoundStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRoundStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRecordSwitch", wireType)
			}
			m.AnchorRecordSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRecordSwitch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRecordStatus", wireType)
			}
			m.AnchorRecordStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRecordStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorSan", wireType)
			}
			m.AnchorSan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorSan |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveType", wireType)
			}
			m.LiveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomByIDsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomByIDsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomByIDsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoomIds = append(m.RoomIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoomIds) == 0 {
					m.RoomIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoomIds = append(m.RoomIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomIds", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFields", wireType)
			}
			m.DefaultFields = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFields |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomByIDsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomByIDsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomByIDsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomDataSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoomDataSet == nil {
				m.RoomDataSet = make(map[int64]*RoomData)
			}
			var mapkey int64
			var mapvalue *RoomData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoomData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoomDataSet[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOnlineListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOnlineListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOnlineListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOnlineListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOnlineListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOnlineListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomDataList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoomDataList == nil {
				m.RoomDataList = make(map[int64]*RoomData)
			}
			var mapkey int64
			var mapvalue *RoomData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoomData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoomDataList[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOnlineListByAreaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOnlineListByAreaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOnlineListByAreaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AreaIds = append(m.AreaIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AreaIds) == 0 {
					m.AreaIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AreaIds = append(m.AreaIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOnlineListByAreaResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOnlineListByAreaResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOnlineListByAreaResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoomIds = append(m.RoomIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoomIds) == 0 {
					m.RoomIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoomIds = append(m.RoomIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomCreateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomCreateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomCreateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomCreateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomCreateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomCreateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedRows", wireType)
			}
			m.AffectedRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedRows |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Background = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStartTime", wireType)
			}
			m.LiveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveScreenType", wireType)
			}
			m.LiveScreenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveScreenType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockStatus", wireType)
			}
			m.LockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTime", wireType)
			}
			m.LockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenTime", wireType)
			}
			m.HiddenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HiddenTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRoundSwitch", wireType)
			}
			m.AnchorRoundSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRoundSwitch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRecordSwitch", wireType)
			}
			m.AnchorRecordSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRecordSwitch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveType", wireType)
			}
			m.LiveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomBatchUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomBatchUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomBatchUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &RoomUpdateReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileType", wireType)
			}
			m.ProfileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProfileType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SanScore", wireType)
			}
			m.SanScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SanScore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundStatus", wireType)
			}
			m.RoundStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordStatus", wireType)
			}
			m.RecordStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorBatchUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorBatchUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorBatchUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &AnchorUpdateReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorIncreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorIncreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorIncreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SanScore", wireType)
			}
			m.SanScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SanScore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorBatchIncreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorBatchIncreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorBatchIncreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &AnchorIncreReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomExtendUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomExtendUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomExtendUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyframe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyframe = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DanmuCount", wireType)
			}
			m.DanmuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DanmuCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PopularityCount", wireType)
			}
			m.PopularityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PopularityCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudienceCount", wireType)
			}
			m.AudienceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AudienceCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftCount", wireType)
			}
			m.GiftCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGoldAmount", wireType)
			}
			m.GiftGoldAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGoldAmount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGoldCount", wireType)
			}
			m.GiftGoldCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGoldCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomExtendBatchUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomExtendBatchUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomExtendBatchUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &RoomExtendUpdateReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomExtendIncreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomExtendIncreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomExtendIncreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DanmuCount", wireType)
			}
			m.DanmuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DanmuCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PopularityCount", wireType)
			}
			m.PopularityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PopularityCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudienceCount", wireType)
			}
			m.AudienceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AudienceCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftCount", wireType)
			}
			m.GiftCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGoldAmount", wireType)
			}
			m.GiftGoldAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGoldAmount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGoldCount", wireType)
			}
			m.GiftGoldCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGoldCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomExtendBatchIncreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomExtendBatchIncreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomExtendBatchIncreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &RoomExtendIncreReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomTagCreateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomTagCreateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomTagCreateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagSubId", wireType)
			}
			m.TagSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagSubId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			m.TagValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpireAt", wireType)
			}
			m.TagExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagExpireAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomAttrCreateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomAttrCreateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomAttrCreateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrId", wireType)
			}
			m.AttrId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrSubId", wireType)
			}
			m.AttrSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrSubId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrValue", wireType)
			}
			m.AttrValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrExt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttrExt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomAttrSetExReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomAttrSetExReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomAttrSetExReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrId", wireType)
			}
			m.AttrId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrSubId", wireType)
			}
			m.AttrSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrSubId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrValue", wireType)
			}
			m.AttrValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrExt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttrExt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchAreasReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchAreasReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchAreasReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AreaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AreaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AreaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AreaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchAreasResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchAreasResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchAreasResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &AreaInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Areas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Areas = append(m.Areas, &AreaInfo{})
			if err := m.Areas[len(m.Areas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchAttrByIDsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchAttrByIDsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchAttrByIDsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoomIds = append(m.RoomIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoomIds) == 0 {
					m.RoomIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoomIds = append(m.RoomIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrId", wireType)
			}
			m.AttrId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrSubId", wireType)
			}
			m.AttrSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrSubId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrId", wireType)
			}
			m.AttrId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrSubId", wireType)
			}
			m.AttrSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrSubId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrValue", wireType)
			}
			m.AttrValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchAttrByIDsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchAttrByIDsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchAttrByIDsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = make(map[int64]*AttrData)
			}
			var mapkey int64
			var mapvalue *AttrData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttrData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attrs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrId", wireType)
			}
			m.AttrId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrSubId", wireType)
			}
			m.AttrSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrSubId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOnlineListByAttrsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOnlineListByAttrsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOnlineListByAttrsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, &AttrReq{})
			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAreaId", wireType)
			}
			m.ParentAreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentAreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagList = append(m.TagList, &TagData{})
			if err := m.TagList[len(m.TagList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttrList = append(m.AttrList, &AttrData{})
			if err := m.AttrList[len(m.AttrList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PopularityCount", wireType)
			}
			m.PopularityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PopularityCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorProfileType", wireType)
			}
			m.AnchorProfileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorProfileType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOnlineListByAttrsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOnlineListByAttrsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOnlineListByAttrsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = make(map[int64]*AttrResp)
			}
			var mapkey int64
			var mapvalue *AttrResp
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AttrResp{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attrs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAttrReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAttrReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAttrReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrId", wireType)
			}
			m.AttrId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrSubId", wireType)
			}
			m.AttrSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrSubId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/live/dao-anchor/api/grpc/v1/api.proto", fileDescriptor_api_ae6aa4fad8591398)
}

var fileDescriptor_api_ae6aa4fad8591398 = []byte{
	// 2430 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x3a, 0xcd, 0x6f, 0x1b, 0xc7,
	0xf5, 0x58, 0x52, 0x14, 0xc9, 0xc7, 0x0f, 0x49, 0x63, 0x25, 0x62, 0x68, 0x5b, 0x92, 0xd7, 0x3f,
	0xe7, 0xa7, 0x34, 0xb6, 0x64, 0x39, 0x11, 0x12, 0x04, 0x09, 0x50, 0x29, 0xb6, 0x0b, 0x01, 0x76,
	0xdc, 0x50, 0x76, 0xbf, 0x52, 0x83, 0x18, 0xed, 0x0e, 0xa9, 0x85, 0xc8, 0xdd, 0xd5, 0xec, 0x50,
	0x96, 0xd2, 0x1e, 0x7b, 0xe8, 0xa1, 0x87, 0x9e, 0x8a, 0xfe, 0x1f, 0x05, 0x8a, 0x5e, 0xdb, 0x02,
	0x45, 0x8f, 0xe9, 0xb5, 0x05, 0x8c, 0xc2, 0x7f, 0x82, 0x0f, 0x05, 0x7a, 0x28, 0x50, 0xcc, 0xbc,
	0x5d, 0xee, 0x07, 0x77, 0xc9, 0x95, 0x93, 0xfa, 0xd0, 0x9e, 0xb4, 0xf3, 0xe6, 0x7d, 0xcd, 0x7b,
	0x6f, 0xde, 0xbc, 0xf7, 0x44, 0xd8, 0xa6, 0xae, 0xbb, 0xe5, 0x31, 0x7e, 0x6a, 0x19, 0x6c, 0x6b,
	0x60, 0x9d, 0xb2, 0x2d, 0x93, 0x3a, 0xb7, 0xa8, 0x6d, 0x1c, 0x39, 0x7c, 0x8b, 0xba, 0xd6, 0x56,
	0x9f, 0xbb, 0xc6, 0xd6, 0xe9, 0xb6, 0xfc, 0xde, 0x74, 0xb9, 0x23, 0x1c, 0xb2, 0x24, 0xd1, 0x36,
	0x4d, 0xea, 0x20, 0xd6, 0xe6, 0xe9, 0x76, 0xfb, 0x56, 0xdf, 0x12, 0x47, 0xa3, 0xc3, 0x4d, 0xc3,
	0x19, 0x6e, 0xf5, 0x9d, 0xbe, 0xb3, 0xa5, 0x30, 0x0f, 0x47, 0x3d, 0xb5, 0x52, 0x0b, 0xf5, 0x85,
	0x1c, 0xf4, 0x5f, 0x69, 0x50, 0xdb, 0x55, 0xc4, 0x0f, 0xd8, 0x29, 0x1b, 0x90, 0x65, 0x28, 0x0d,
	0xe4, 0x47, 0x4b, 0x5b, 0xd7, 0x36, 0x8a, 0x1d, 0x5c, 0x48, 0xa8, 0xe1, 0x0c, 0x1c, 0xde, 0x2a,
	0x20, 0x54, 0x2d, 0x24, 0xd4, 0x33, 0x1c, 0xce, 0x5a, 0x45, 0x84, 0xaa, 0x05, 0x21, 0x30, 0x37,
	0x60, 0x3d, 0xd1, 0x9a, 0x53, 0x40, 0xf5, 0x2d, 0x31, 0xb9, 0xd5, 0x3f, 0x12, 0xad, 0x12, 0x62,
	0xaa, 0x05, 0xb9, 0x0c, 0xd5, 0x21, 0x3d, 0xeb, 0xa2, 0xbc, 0x79, 0xb5, 0x53, 0x19, 0xd2, 0x33,
	0xa5, 0x88, 0xfe, 0x6b, 0x0d, 0xca, 0x8f, 0x69, 0xff, 0x2e, 0x15, 0x94, 0xbc, 0x01, 0xf3, 0x82,
	0xf6, 0xbb, 0x96, 0x19, 0x68, 0x25, 0x68, 0x7f, 0xdf, 0x24, 0x57, 0x00, 0x24, 0xd8, 0x1b, 0x1d,
	0xca, 0x2d, 0x54, 0xad, 0x22, 0x68, 0xff, 0x60, 0x74, 0xb8, 0x6f, 0x4a, 0xee, 0x72, 0xf7, 0x94,
	0x0e, 0x46, 0x81, 0x86, 0x72, 0xf3, 0x7b, 0x72, 0x4d, 0x56, 0xa0, 0x2c, 0x37, 0xd9, 0x19, 0xea,
	0x59, 0xed, 0x48, 0x01, 0xf7, 0xce, 0x04, 0xd1, 0xa1, 0x81, 0x1b, 0xae, 0xc5, 0x59, 0x97, 0x06,
	0x1a, 0xd7, 0xd4, 0xb6, 0x84, 0xed, 0x0a, 0xfd, 0xb7, 0x35, 0xa8, 0x74, 0x1c, 0x67, 0xa8, 0x74,
	0xdb, 0x84, 0xe2, 0x28, 0x50, 0x6c, 0xef, 0xca, 0xcb, 0xe7, 0x6b, 0xad, 0x53, 0x3a, 0xb0, 0x4c,
	0x2a, 0xd8, 0x47, 0x7a, 0x5f, 0x7c, 0x72, 0xfb, 0x26, 0x67, 0x27, 0x23, 0x8b, 0x33, 0x53, 0xef,
	0x48, 0x44, 0xb2, 0x03, 0x65, 0xee, 0x38, 0xc3, 0xb1, 0xc6, 0x33, 0x68, 0xe6, 0x25, 0xf2, 0xbe,
	0x49, 0x3e, 0x80, 0x8a, 0x77, 0xe4, 0x70, 0x21, 0xe9, 0x8a, 0x39, 0xe8, 0xca, 0x0a, 0x7b, 0xdf,
	0x24, 0xb7, 0xa0, 0x24, 0x2c, 0x31, 0x60, 0x78, 0xce, 0xbd, 0x95, 0x97, 0xcf, 0xd7, 0x2e, 0x85,
	0x54, 0x21, 0x01, 0x62, 0xa1, 0xa7, 0x4f, 0x19, 0x57, 0xe7, 0xae, 0x76, 0x70, 0x21, 0x7d, 0x2a,
	0x68, 0xdf, 0x53, 0x4e, 0xaa, 0x76, 0xd4, 0x37, 0x59, 0x05, 0x38, 0xa4, 0xc6, 0x71, 0x9f, 0x3b,
	0x23, 0xdb, 0x6c, 0x95, 0xd5, 0x4e, 0x04, 0x42, 0xd6, 0xa1, 0x66, 0x32, 0xcf, 0xe0, 0x96, 0x2b,
	0x2c, 0xc7, 0x6e, 0x55, 0x14, 0x42, 0x14, 0x44, 0x3e, 0x81, 0x9a, 0x8c, 0xdf, 0xae, 0x27, 0xa8,
	0x18, 0x79, 0xad, 0x6a, 0x8e, 0x63, 0x81, 0x24, 0x38, 0x50, 0xf8, 0xe4, 0x2e, 0x2c, 0x04, 0xe4,
	0x5c, 0x74, 0x85, 0x35, 0x64, 0x2d, 0xc8, 0xc1, 0xa2, 0xe1, 0xb3, 0xe0, 0xe2, 0xb1, 0x35, 0x64,
	0xe4, 0x3e, 0x2c, 0x22, 0x17, 0x83, 0x33, 0x66, 0x77, 0xc5, 0xb9, 0xcb, 0x5a, 0xb5, 0x1c, 0x6c,
	0x9a, 0x8a, 0x8d, 0x22, 0x7a, 0x7c, 0xee, 0x32, 0x19, 0x6e, 0x8a, 0xcf, 0x90, 0xf2, 0xe3, 0x56,
	0x1d, 0xc3, 0x4d, 0x02, 0x1e, 0x52, 0x7e, 0x4c, 0xd6, 0xa0, 0x36, 0x70, 0x8c, 0xe3, 0xe0, 0xa4,
	0x0d, 0xb5, 0x0d, 0x12, 0xe4, 0x9f, 0x45, 0x52, 0x4b, 0x04, 0x75, 0x8a, 0xa6, 0x4f, 0xed, 0x18,
	0xc7, 0x4a, 0xc5, 0x5d, 0x68, 0x1c, 0x59, 0xa6, 0xc9, 0xec, 0x80, 0x7e, 0x21, 0x87, 0x7e, 0x75,
	0x24, 0xf1, 0xf9, 0xaf, 0x41, 0xcd, 0x67, 0xa1, 0x24, 0x2c, 0xa2, 0x02, 0x08, 0x52, 0x32, 0x76,
	0xa0, 0x4c, 0x39, 0xa3, 0x32, 0xbc, 0x96, 0xf2, 0x84, 0xa5, 0x44, 0xde, 0x37, 0xc9, 0xfb, 0x50,
	0x55, 0x64, 0x36, 0x1d, 0xb2, 0x16, 0x99, 0x1e, 0x61, 0x15, 0x89, 0xf9, 0x19, 0x1d, 0x32, 0xb2,
	0x07, 0x4d, 0x97, 0x72, 0x66, 0x8b, 0x6e, 0x20, 0xf3, 0x52, 0x9e, 0x13, 0x21, 0xcd, 0x2e, 0x4a,
	0xde, 0x85, 0xc5, 0x28, 0x0f, 0xa5, 0xc0, 0xf2, 0x74, 0x05, 0x9a, 0x21, 0x03, 0xa5, 0x46, 0x1b,
	0x2a, 0xc7, 0xec, 0xbc, 0xc7, 0x25, 0xe9, 0x1b, 0x2a, 0x3c, 0xc7, 0x6b, 0xf2, 0x0e, 0x2c, 0xba,
	0x8e, 0x3b, 0x1a, 0x50, 0x6e, 0x89, 0xf3, 0xae, 0xe1, 0x8c, 0x6c, 0xd1, 0x7a, 0x53, 0x59, 0x6d,
	0x21, 0x84, 0x7f, 0x2a, 0xc1, 0x64, 0x07, 0x64, 0x5e, 0xe9, 0x0e, 0x2c, 0x4f, 0xb4, 0x56, 0xd6,
	0x8b, 0x1b, 0xb5, 0x3b, 0xed, 0xcd, 0x89, 0xbc, 0xbc, 0xe9, 0xe7, 0xb2, 0x8e, 0xcc, 0x3b, 0x0f,
	0x2c, 0x4f, 0x90, 0x4d, 0xb8, 0x84, 0xbb, 0x5d, 0x97, 0x3b, 0x3d, 0x6b, 0xc0, 0x30, 0xf6, 0xde,
	0x52, 0x42, 0x96, 0x70, 0xeb, 0xbb, 0xb8, 0xa3, 0x02, 0x6c, 0x17, 0xea, 0x3e, 0x3e, 0x26, 0xcc,
	0xf6, 0xba, 0xb6, 0x51, 0xbb, 0xb3, 0x9a, 0x22, 0x2a, 0x92, 0xcf, 0x3b, 0x35, 0x1a, 0x49, 0xee,
	0xa1, 0x48, 0x75, 0x45, 0xbb, 0xde, 0x33, 0x4b, 0x18, 0x47, 0xad, 0xcb, 0x51, 0x91, 0x1d, 0xb9,
	0x73, 0xa0, 0x36, 0x26, 0xf1, 0x31, 0xfc, 0xae, 0x4c, 0xe2, 0x63, 0x94, 0xdd, 0x86, 0xe5, 0x00,
	0x9f, 0x19, 0x0e, 0x1f, 0x0b, 0xb8, 0xaa, 0x08, 0x88, 0x4f, 0xa0, 0xb6, 0x7c, 0x09, 0x93, 0x14,
	0x28, 0x62, 0x35, 0x85, 0x02, 0x65, 0x5c, 0x05, 0xf0, 0x29, 0x3c, 0x6a, 0xb7, 0xd6, 0x14, 0x5e,
	0x15, 0x21, 0x07, 0xd4, 0x1e, 0x5f, 0x43, 0x65, 0xcb, 0xf5, 0xf0, 0x1a, 0x4a, 0x13, 0xea, 0x3f,
	0x85, 0xba, 0xcc, 0xdb, 0x7b, 0xe7, 0xfb, 0x77, 0xbd, 0x0e, 0x3b, 0x21, 0x6f, 0x41, 0xc5, 0xcf,
	0xc5, 0x5e, 0x4b, 0x5b, 0x2f, 0x6e, 0x14, 0x3b, 0x65, 0x4c, 0xb7, 0x9e, 0xcc, 0x78, 0x23, 0x09,
	0x2e, 0x28, 0xb0, 0xfa, 0x26, 0x6f, 0xc2, 0x7c, 0xcf, 0x62, 0x03, 0xd3, 0x6b, 0x15, 0xd7, 0x8b,
	0xf2, 0xcd, 0xc0, 0x15, 0xb9, 0x01, 0x4d, 0x93, 0xf5, 0xe8, 0x68, 0x20, 0xba, 0xfe, 0x3e, 0xbe,
	0x7d, 0x0d, 0x1f, 0x7a, 0x5f, 0x01, 0xf5, 0x3f, 0x6a, 0xd0, 0x88, 0x88, 0xf7, 0x5c, 0xf2, 0x04,
	0x1a, 0x4a, 0xbe, 0x49, 0x05, 0xed, 0x7a, 0x4c, 0x28, 0x25, 0x6a, 0x77, 0xb6, 0x53, 0x7c, 0x1a,
	0x23, 0xdc, 0x0c, 0x5e, 0x9f, 0x03, 0x26, 0xee, 0xd9, 0x82, 0x9f, 0x77, 0x6a, 0x3c, 0x84, 0xb4,
	0xbf, 0x80, 0xc5, 0x24, 0x02, 0x59, 0x84, 0xe2, 0x31, 0x3b, 0xf7, 0xdf, 0x4f, 0xf9, 0x49, 0xb6,
	0xa1, 0x84, 0x6f, 0x63, 0x41, 0x05, 0xd2, 0xe5, 0x0c, 0xa1, 0x2a, 0x68, 0x11, 0xf3, 0xa3, 0xc2,
	0x87, 0x9a, 0xfe, 0x73, 0x0d, 0x96, 0x24, 0xfc, 0x91, 0x3d, 0xb0, 0x6c, 0x26, 0x23, 0x59, 0x5a,
	0x52, 0x99, 0x66, 0x20, 0x18, 0x57, 0x12, 0x94, 0x69, 0xe4, 0x4a, 0x9a, 0xd1, 0x73, 0xb8, 0x50,
	0x32, 0xaa, 0x1d, 0xf5, 0x2d, 0x61, 0x2e, 0xed, 0x07, 0x6f, 0xb2, 0xfa, 0x96, 0x6e, 0x93, 0x7f,
	0xbb, 0x9e, 0xf5, 0x25, 0xf3, 0xad, 0x57, 0x91, 0x80, 0x03, 0xeb, 0x4b, 0x16, 0xb1, 0x7b, 0x29,
	0x6a, 0x77, 0xfd, 0x2f, 0x1a, 0x90, 0xa4, 0x2a, 0x9e, 0x4b, 0x9e, 0x42, 0x33, 0xb4, 0xaa, 0xba,
	0x95, 0x68, 0xd6, 0x0f, 0x32, 0x4e, 0x18, 0x27, 0x1f, 0x1f, 0x5a, 0x02, 0xd0, 0xb8, 0x75, 0x1e,
	0x01, 0xb5, 0x7f, 0x8c, 0xe7, 0x8f, 0xa1, 0x7c, 0x73, 0xe6, 0x7d, 0x1f, 0x56, 0xe2, 0x3a, 0xed,
	0x9d, 0xcb, 0x7c, 0xe5, 0x47, 0xab, 0x9f, 0x2e, 0xc7, 0xd1, 0x8a, 0x59, 0xd8, 0xd3, 0x77, 0xa0,
	0x95, 0x4e, 0xe5, 0xb9, 0x53, 0x82, 0x5c, 0xff, 0x01, 0x06, 0xe4, 0xa7, 0x9c, 0x51, 0xc1, 0xa4,
	0x88, 0x8b, 0x16, 0x33, 0x2b, 0x89, 0x62, 0x26, 0x28, 0x57, 0xf4, 0x77, 0xa0, 0x19, 0xe5, 0xec,
	0xb9, 0x51, 0x54, 0x2d, 0x86, 0xba, 0x0d, 0xf0, 0xc4, 0x35, 0x03, 0xb4, 0xeb, 0xd0, 0xa0, 0xbd,
	0x1e, 0x33, 0x04, 0x33, 0xbb, 0xdc, 0x79, 0xe6, 0xf9, 0xc8, 0xf5, 0x00, 0xd8, 0x71, 0x9e, 0x79,
	0xfa, 0x1f, 0xe6, 0x50, 0xf1, 0x80, 0xee, 0x84, 0x6c, 0x8d, 0x43, 0x44, 0x1e, 0x71, 0xca, 0x1b,
	0x10, 0xdc, 0xd9, 0x57, 0x2c, 0xc3, 0x96, 0x83, 0x6a, 0xaa, 0x88, 0xe5, 0x51, 0xa2, 0x68, 0x9a,
	0x4b, 0x2b, 0x9a, 0x4a, 0x99, 0x45, 0xd3, 0xfc, 0xac, 0xa2, 0xa9, 0x3c, 0x59, 0x34, 0xbd, 0x3d,
	0x59, 0xf5, 0x54, 0x30, 0xdb, 0xc4, 0xeb, 0x9a, 0x8d, 0x94, 0xba, 0x46, 0x55, 0x58, 0x13, 0x95,
	0x4b, 0xa2, 0x38, 0x81, 0xe9, 0xc5, 0x49, 0x2d, 0x51, 0x9c, 0x24, 0x2a, 0x8b, 0xfa, 0x44, 0x65,
	0xb1, 0x12, 0x56, 0x16, 0x58, 0xf7, 0x04, 0xb5, 0x43, 0xc6, 0x6b, 0xd4, 0xcc, 0x7a, 0x8d, 0xb2,
	0x5e, 0x97, 0x85, 0xcc, 0xd7, 0x25, 0xf6, 0x18, 0x2c, 0x26, 0x1e, 0x03, 0x03, 0x93, 0xc7, 0x1e,
	0x15, 0xc6, 0x51, 0x18, 0x48, 0x0f, 0x61, 0x8e, 0xb3, 0x13, 0xcf, 0x4f, 0x19, 0xeb, 0x19, 0xb7,
	0x76, 0x8c, 0x9f, 0x1d, 0x68, 0x8a, 0x8d, 0xfe, 0x8b, 0x02, 0x2c, 0xe0, 0x73, 0xfc, 0x35, 0x62,
	0xd5, 0xbf, 0x95, 0x85, 0xbc, 0xb7, 0xf2, 0x1a, 0xd4, 0x63, 0x25, 0x05, 0x26, 0xda, 0x9a, 0x1b,
	0x29, 0x26, 0x2e, 0x43, 0xd5, 0xa3, 0x76, 0x17, 0xdb, 0x37, 0x3f, 0xdf, 0x7a, 0xd4, 0x3e, 0x50,
	0x1d, 0xdc, 0x35, 0xa8, 0xc7, 0xde, 0x7b, 0xbf, 0x05, 0xe2, 0x91, 0x97, 0xfe, 0x3a, 0x34, 0xe2,
	0x0f, 0x36, 0xb6, 0x6f, 0x75, 0x1e, 0x7d, 0xaa, 0x17, 0xa1, 0xc8, 0xce, 0x5c, 0x15, 0xc4, 0xc5,
	0x8e, 0xfc, 0xd4, 0xfb, 0xb0, 0x8c, 0xd6, 0x48, 0x58, 0xfd, 0x51, 0xcc, 0xea, 0x7a, 0x66, 0x4d,
	0x93, 0xdb, 0xee, 0x5f, 0x69, 0xd0, 0x44, 0x92, 0x7d, 0xdb, 0xe0, 0x7e, 0x6e, 0x9b, 0xe7, 0xec,
	0x24, 0xc8, 0x3f, 0xd3, 0x3a, 0x21, 0xce, 0x4e, 0xf6, 0xcd, 0x88, 0x9b, 0x0a, 0x17, 0x72, 0x53,
	0x31, 0xaf, 0x9b, 0xa6, 0xfa, 0xc0, 0xb7, 0x5d, 0x29, 0xb4, 0x1d, 0x83, 0x4b, 0x11, 0xdb, 0x8d,
	0x8f, 0xf5, 0x59, 0xcc, 0x74, 0xd7, 0x32, 0x4d, 0x17, 0x10, 0xcc, 0xb2, 0xdc, 0xbf, 0x0a, 0x70,
	0x49, 0x86, 0xf8, 0xbd, 0x33, 0xc1, 0x6c, 0xf3, 0xf5, 0x67, 0xd8, 0x68, 0x51, 0x5e, 0x4c, 0x14,
	0xe5, 0x6b, 0x50, 0x33, 0xa9, 0x3d, 0x1c, 0xf9, 0xf5, 0x38, 0xda, 0x0c, 0x14, 0x08, 0x4b, 0xf1,
	0xb4, 0xaa, 0xbd, 0x94, 0x5e, 0xb5, 0xdf, 0x80, 0x26, 0x1d, 0x99, 0x16, 0xb3, 0x0d, 0xe6, 0x23,
	0x62, 0x08, 0x37, 0x02, 0x28, 0xa2, 0x5d, 0x05, 0xe8, 0x5b, 0x3d, 0xe1, 0xa3, 0x60, 0x28, 0x57,
	0x25, 0x04, 0xb7, 0x37, 0x60, 0x51, 0x6d, 0xf7, 0x9d, 0x81, 0xd9, 0xa5, 0x43, 0x85, 0x84, 0xe9,
	0xb8, 0x29, 0xe1, 0xdf, 0x71, 0x06, 0xe6, 0xae, 0x82, 0xca, 0xbc, 0x1d, 0x62, 0x22, 0x37, 0x4c,
	0xc7, 0x8d, 0x00, 0x51, 0x71, 0xd4, 0x1d, 0x7c, 0xca, 0xd1, 0xfc, 0x89, 0x6b, 0x72, 0x10, 0xf3,
	0xf5, 0xdb, 0x19, 0xc9, 0x29, 0xe1, 0xb9, 0x59, 0x0e, 0xff, 0x65, 0x11, 0x13, 0x21, 0x92, 0xbd,
	0xbe, 0xeb, 0x12, 0x89, 0x8f, 0xe2, 0x05, 0xe2, 0xe3, 0x7f, 0x21, 0x06, 0x86, 0x58, 0x04, 0x46,
	0x62, 0x60, 0xec, 0x96, 0x4e, 0x2c, 0x04, 0x6e, 0x4c, 0x0d, 0x81, 0xbc, 0x57, 0xfe, 0x1f, 0x1a,
	0x36, 0x0c, 0x8f, 0x69, 0x3f, 0x2c, 0x05, 0x77, 0x12, 0xf5, 0x5a, 0x4e, 0xf7, 0xbc, 0x37, 0x1e,
	0xd5, 0xe5, 0xb9, 0xf4, 0xa9, 0x83, 0xbc, 0xe2, 0xb4, 0x41, 0xde, 0x5c, 0xf6, 0x20, 0xaf, 0x34,
	0x7d, 0x90, 0x37, 0x3f, 0x39, 0xc8, 0xfb, 0x9b, 0xdf, 0xcb, 0xec, 0x0a, 0xc1, 0xbf, 0xf6, 0xc9,
	0x77, 0xa0, 0x4c, 0x85, 0xe0, 0xb9, 0xf3, 0x9d, 0x44, 0xde, 0x37, 0xc9, 0x2a, 0xd4, 0x14, 0x59,
	0xec, 0xf0, 0x55, 0x09, 0xc2, 0xd3, 0xcb, 0x7e, 0x57, 0xee, 0x47, 0x8f, 0xaf, 0xb6, 0xf1, 0xfc,
	0xb2, 0x29, 0x90, 0xdb, 0xa1, 0x01, 0x94, 0x16, 0xf7, 0xce, 0x84, 0xfe, 0x57, 0xdf, 0xad, 0xf2,
	0x74, 0xb2, 0x0f, 0x3c, 0xfb, 0x6f, 0x3a, 0xdc, 0x06, 0x34, 0xee, 0x33, 0x61, 0x1c, 0xc9, 0x36,
	0x47, 0xf5, 0xf2, 0x91, 0x32, 0x53, 0x8b, 0x96, 0x99, 0xfa, 0xb7, 0xa1, 0xa2, 0x46, 0x46, 0x76,
	0xcf, 0xc9, 0x44, 0x92, 0x31, 0x16, 0x8e, 0x91, 0xb0, 0x59, 0x1d, 0x8f, 0xab, 0x74, 0x01, 0xcd,
	0xa8, 0x2c, 0xcf, 0x25, 0x5b, 0x30, 0x67, 0xd9, 0x3d, 0x47, 0x31, 0x49, 0xef, 0xed, 0x02, 0x91,
	0x1d, 0x85, 0x28, 0xbb, 0x41, 0xc9, 0x0e, 0x93, 0xe3, 0x0c, 0x0a, 0xc4, 0xd4, 0xff, 0xa4, 0xc1,
	0x12, 0x8a, 0x15, 0x82, 0x8f, 0x47, 0x16, 0x1f, 0x27, 0xbb, 0xb9, 0xbd, 0x6b, 0x2f, 0x9f, 0xaf,
	0x5d, 0x0d, 0x3d, 0x61, 0x5a, 0xa7, 0xec, 0x66, 0x72, 0x18, 0x1c, 0x4c, 0x35, 0x5e, 0xd1, 0x8d,
	0x1f, 0xa7, 0xb8, 0x71, 0x06, 0x69, 0xe8, 0x64, 0xfd, 0x27, 0x50, 0x91, 0x47, 0x50, 0xd3, 0xf2,
	0xac, 0x2e, 0x50, 0x79, 0x26, 0xaa, 0xd9, 0x37, 0x14, 0x42, 0xfa, 0x6f, 0x34, 0x20, 0x49, 0x2b,
	0x7a, 0x2e, 0xb9, 0x0f, 0x25, 0x89, 0x13, 0xe4, 0xd1, 0xdb, 0x29, 0xfe, 0x98, 0xa4, 0xda, 0x94,
	0x2b, 0x0f, 0x67, 0x02, 0x48, 0xde, 0x7e, 0x02, 0x10, 0x02, 0x5f, 0x6d, 0x0a, 0x10, 0xd8, 0x26,
	0x3a, 0x05, 0xd8, 0x83, 0xb2, 0x04, 0x07, 0x71, 0xed, 0x1b, 0x46, 0x9b, 0x66, 0x98, 0x42, 0xc2,
	0x30, 0xfa, 0x83, 0x94, 0x99, 0x80, 0x54, 0x55, 0x32, 0xbd, 0x1d, 0x3f, 0x7e, 0x3b, 0x43, 0xad,
	0x0e, 0x3b, 0xf1, 0x0f, 0xaa, 0xff, 0xae, 0x88, 0x5e, 0x54, 0xd6, 0x7b, 0x4d, 0xff, 0xf3, 0x88,
	0xcc, 0xa4, 0x8b, 0x17, 0x98, 0x49, 0x4f, 0x4e, 0x97, 0xe7, 0x2e, 0x3c, 0x5d, 0x8e, 0xce, 0x74,
	0x4b, 0xf9, 0x67, 0xba, 0x1f, 0x82, 0x72, 0x00, 0xd2, 0xcd, 0x67, 0x5f, 0xf5, 0xc0, 0xe5, 0x2a,
	0xbd, 0x29, 0xca, 0xb4, 0xaa, 0xa5, 0x9c, 0x5e, 0xb5, 0x64, 0x0c, 0x8e, 0x2b, 0x19, 0x83, 0x63,
	0xfd, 0xf7, 0x1a, 0xbc, 0x95, 0x11, 0x09, 0x9e, 0x4b, 0x1e, 0xc6, 0x43, 0x61, 0xf6, 0x90, 0x2c,
	0x42, 0xfc, 0x9f, 0xbb, 0x10, 0x92, 0x7b, 0xf4, 0x42, 0xfc, 0x4c, 0x83, 0xc6, 0x5d, 0x36, 0x60,
	0x82, 0x05, 0xf7, 0x62, 0x27, 0x71, 0x2f, 0x5e, 0x2d, 0x95, 0x15, 0x2e, 0x94, 0xca, 0xee, 0xfc,
	0xb3, 0x09, 0xd5, 0xbb, 0xd4, 0xc1, 0x8e, 0x8a, 0x1c, 0xf8, 0xef, 0xc2, 0x78, 0x36, 0x4b, 0xd6,
	0xa6, 0x4f, 0x6e, 0x4f, 0xda, 0xeb, 0xb3, 0x46, 0xbb, 0xe4, 0x29, 0x4e, 0xce, 0x42, 0x7b, 0x93,
	0xff, 0xcb, 0x31, 0xb7, 0x3c, 0x69, 0xdf, 0xc8, 0x35, 0xdd, 0x24, 0x0e, 0x2c, 0xa7, 0x4d, 0x0a,
	0xc9, 0xb7, 0xf2, 0xf8, 0x1d, 0x07, 0x91, 0xed, 0x77, 0x73, 0xe3, 0x7a, 0x2e, 0xe1, 0xf0, 0x46,
	0x6a, 0xfc, 0x90, 0x77, 0xf3, 0x47, 0xda, 0x49, 0xfb, 0xe6, 0x45, 0xc2, 0x92, 0x7c, 0x0e, 0x10,
	0x4e, 0x1f, 0x49, 0x96, 0xcd, 0xc7, 0x15, 0x5f, 0xfb, 0xda, 0x0c, 0x0c, 0x75, 0x4d, 0x20, 0x1c,
	0xfc, 0x90, 0x99, 0x73, 0xa1, 0xf6, 0xd5, 0x14, 0x8c, 0xc8, 0x98, 0xf3, 0xfb, 0xb0, 0x90, 0x18,
	0x3e, 0x91, 0x2c, 0x07, 0xc6, 0x7b, 0xc0, 0x59, 0x8c, 0x7f, 0x88, 0x35, 0x5f, 0xb4, 0x07, 0x24,
	0x39, 0x1b, 0xc5, 0x59, 0xac, 0x0d, 0xf4, 0xe4, 0x44, 0x67, 0x9a, 0xe9, 0xc9, 0xb4, 0x1e, 0x36,
	0xa7, 0x61, 0x22, 0x0d, 0x0c, 0xc9, 0xd7, 0xe4, 0xcc, 0x62, 0x4c, 0x31, 0xf0, 0x93, 0x3d, 0x55,
	0x66, 0xe0, 0xa7, 0x34, 0x5f, 0xb3, 0x44, 0x1c, 0xe0, 0x54, 0x7a, 0xdc, 0x46, 0x91, 0xeb, 0x19,
	0xbc, 0xa3, 0x8d, 0xd6, 0x2c, 0xa6, 0x4f, 0x30, 0x1f, 0x84, 0x2d, 0x4a, 0x66, 0x3e, 0x88, 0x75,
	0x31, 0x39, 0x75, 0x1d, 0xf7, 0x06, 0x99, 0xba, 0x46, 0xbb, 0x87, 0x59, 0x4c, 0x3f, 0x87, 0x7a,
	0x74, 0x4e, 0x47, 0x72, 0x0c, 0xf2, 0x66, 0xb1, 0xfc, 0x02, 0x96, 0x26, 0x26, 0x86, 0xe4, 0xff,
	0x33, 0xf9, 0x5e, 0x2c, 0xd8, 0x1e, 0x05, 0xbf, 0x7d, 0xc1, 0x50, 0x98, 0x3d, 0x3c, 0xcb, 0x71,
	0xfb, 0x92, 0x33, 0xba, 0xd4, 0xdb, 0x97, 0x32, 0xc8, 0x9b, 0x6d, 0x5b, 0x08, 0x9b, 0x90, 0xd4,
	0x04, 0x14, 0xeb, 0x87, 0x52, 0x73, 0x5a, 0xa2, 0x8b, 0x79, 0x1a, 0xf4, 0x35, 0x41, 0x91, 0x9b,
	0x1a, 0x5a, 0x13, 0x3d, 0x48, 0xea, 0x53, 0x93, 0x52, 0x63, 0x3f, 0x04, 0x08, 0x9f, 0xec, 0x54,
	0x8d, 0x63, 0x2f, 0xfa, 0x0c, 0x03, 0xec, 0x2d, 0xfe, 0xf9, 0xc5, 0xaa, 0xf6, 0xd5, 0x8b, 0x55,
	0xed, 0xef, 0x2f, 0x56, 0xb5, 0x1f, 0x15, 0x4e, 0xb7, 0x0f, 0xe7, 0xd5, 0x4f, 0x98, 0xde, 0xfb,
	0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xbd, 0x2d, 0xa5, 0x6f, 0x39, 0x25, 0x00, 0x00,
}
