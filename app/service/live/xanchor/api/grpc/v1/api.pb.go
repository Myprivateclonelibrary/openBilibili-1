// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/live/xanchor/api/grpc/v1/api.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ExpData struct {
	Level                int64    `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty" validate:"gt=0,required"`
	NextLevel            int64    `protobuf:"varint,2,opt,name=next_level,json=nextLevel,proto3" json:"next_level,omitempty" validate:"gt=0,required"`
	LevelColor           int64    `protobuf:"varint,3,opt,name=level_color,json=levelColor,proto3" json:"level_color,omitempty" validate:"gt=0,required"`
	Exp                  int64    `protobuf:"varint,4,opt,name=exp,proto3" json:"exp,omitempty" validate:"gt=0,required"`
	CurrentLevelExp      int64    `protobuf:"varint,5,opt,name=current_level_exp,json=currentLevelExp,proto3" json:"current_level_exp,omitempty" validate:"gt=0,required"`
	NextLevelExp         int64    `protobuf:"varint,6,opt,name=next_level_exp,json=nextLevelExp,proto3" json:"next_level_exp,omitempty" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExpData) Reset()         { *m = ExpData{} }
func (m *ExpData) String() string { return proto.CompactTextString(m) }
func (*ExpData) ProtoMessage()    {}
func (*ExpData) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{0}
}
func (m *ExpData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ExpData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpData.Merge(dst, src)
}
func (m *ExpData) XXX_Size() int {
	return m.Size()
}
func (m *ExpData) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpData.DiscardUnknown(m)
}

var xxx_messageInfo_ExpData proto.InternalMessageInfo

func (m *ExpData) GetLevel() int64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *ExpData) GetNextLevel() int64 {
	if m != nil {
		return m.NextLevel
	}
	return 0
}

func (m *ExpData) GetLevelColor() int64 {
	if m != nil {
		return m.LevelColor
	}
	return 0
}

func (m *ExpData) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *ExpData) GetCurrentLevelExp() int64 {
	if m != nil {
		return m.CurrentLevelExp
	}
	return 0
}

func (m *ExpData) GetNextLevelExp() int64 {
	if m != nil {
		return m.NextLevelExp
	}
	return 0
}

type TagData struct {
	TagId                int64    `protobuf:"varint,1,opt,name=tag_id,json=tagId,proto3" json:"tag_id,omitempty" validate:"gt=0,required"`
	TagType              int64    `protobuf:"varint,2,opt,name=tag_type,json=tagType,proto3" json:"tag_type,omitempty" validate:"gt=0,required"`
	TagValue             int64    `protobuf:"varint,3,opt,name=tag_value,json=tagValue,proto3" json:"tag_value,omitempty" validate:"gt=0,required"`
	TagAttribute         string   `protobuf:"bytes,4,opt,name=tag_attribute,json=tagAttribute,proto3" json:"tag_attribute,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TagData) Reset()         { *m = TagData{} }
func (m *TagData) String() string { return proto.CompactTextString(m) }
func (*TagData) ProtoMessage()    {}
func (*TagData) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{1}
}
func (m *TagData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TagData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TagData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TagData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TagData.Merge(dst, src)
}
func (m *TagData) XXX_Size() int {
	return m.Size()
}
func (m *TagData) XXX_DiscardUnknown() {
	xxx_messageInfo_TagData.DiscardUnknown(m)
}

var xxx_messageInfo_TagData proto.InternalMessageInfo

func (m *TagData) GetTagId() int64 {
	if m != nil {
		return m.TagId
	}
	return 0
}

func (m *TagData) GetTagType() int64 {
	if m != nil {
		return m.TagType
	}
	return 0
}

func (m *TagData) GetTagValue() int64 {
	if m != nil {
		return m.TagValue
	}
	return 0
}

func (m *TagData) GetTagAttribute() string {
	if m != nil {
		return m.TagAttribute
	}
	return ""
}

type RoomData struct {
	Uid                  int64      `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	RoomId               int64      `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	ShortId              int64      `protobuf:"varint,3,opt,name=short_id,json=shortId,proto3" json:"short_id,omitempty" validate:"gt=0,required"`
	Title                string     `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty" validate:"required"`
	Cover                string     `protobuf:"bytes,5,opt,name=cover,proto3" json:"cover,omitempty"`
	Tags                 string     `protobuf:"bytes,6,opt,name=tags,proto3" json:"tags,omitempty"`
	Background           string     `protobuf:"bytes,7,opt,name=background,proto3" json:"background,omitempty"`
	Description          string     `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	LiveStatus           int64      `protobuf:"varint,9,opt,name=live_status,json=liveStatus,proto3" json:"live_status,omitempty" validate:"gt=0,required"`
	LiveStartTime        int64      `protobuf:"varint,10,opt,name=live_start_time,json=liveStartTime,proto3" json:"live_start_time,omitempty" validate:"gt=0,required"`
	LiveScreenType       int64      `protobuf:"varint,11,opt,name=live_screen_type,json=liveScreenType,proto3" json:"live_screen_type,omitempty" validate:"gt=0,required"`
	LiveMark             int64      `protobuf:"varint,12,opt,name=live_mark,json=liveMark,proto3" json:"live_mark,omitempty"`
	LockStatus           int64      `protobuf:"varint,13,opt,name=lock_status,json=lockStatus,proto3" json:"lock_status,omitempty"`
	LockTime             int64      `protobuf:"varint,14,opt,name=lock_time,json=lockTime,proto3" json:"lock_time,omitempty"`
	HiddenStatus         int64      `protobuf:"varint,15,opt,name=hidden_status,json=hiddenStatus,proto3" json:"hidden_status,omitempty" validate:"gt=0,required"`
	HiddenTime           int64      `protobuf:"varint,16,opt,name=hidden_time,json=hiddenTime,proto3" json:"hidden_time,omitempty"`
	AreaId               int64      `protobuf:"varint,17,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty" validate:"gt=0,required"`
	AreaName             string     `protobuf:"bytes,18,opt,name=area_name,json=areaName,proto3" json:"area_name,omitempty" validate:"required"`
	ParentAreaId         int64      `protobuf:"varint,19,opt,name=parent_area_id,json=parentAreaId,proto3" json:"parent_area_id,omitempty" validate:"gt=0,required"`
	ParentAreaName       string     `protobuf:"bytes,20,opt,name=parent_area_name,json=parentAreaName,proto3" json:"parent_area_name,omitempty" validate:"required"`
	Keyframe             string     `protobuf:"bytes,21,opt,name=keyframe,proto3" json:"keyframe,omitempty"`
	PopularityCount      int64      `protobuf:"varint,22,opt,name=popularity_count,json=popularityCount,proto3" json:"popularity_count,omitempty"`
	RoomTagList          []*TagData `protobuf:"bytes,23,rep,name=room_tag_list,json=roomTagList" json:"room_tag_list,omitempty"`
	AnchorTagList        []*TagData `protobuf:"bytes,24,rep,name=anchor_tag_list,json=anchorTagList" json:"anchor_tag_list,omitempty"`
	AnchorProfileType    int64      `protobuf:"varint,25,opt,name=anchor_profile_type,json=anchorProfileType,proto3" json:"anchor_profile_type,omitempty"`
	AnchorExp            []*ExpData `protobuf:"bytes,26,rep,name=anchor_exp,json=anchorExp" json:"anchor_exp,omitempty"`
	AnchorRoundSwitch    int64      `protobuf:"varint,27,opt,name=anchor_round_switch,json=anchorRoundSwitch,proto3" json:"anchor_round_switch,omitempty"`
	AnchorRoundStatus    int64      `protobuf:"varint,28,opt,name=anchor_round_status,json=anchorRoundStatus,proto3" json:"anchor_round_status,omitempty"`
	AnchorRecordSwitch   int64      `protobuf:"varint,29,opt,name=anchor_record_switch,json=anchorRecordSwitch,proto3" json:"anchor_record_switch,omitempty"`
	AnchorRecordStatus   int64      `protobuf:"varint,30,opt,name=anchor_record_status,json=anchorRecordStatus,proto3" json:"anchor_record_status,omitempty"`
	AnchorSan            int64      `protobuf:"varint,31,opt,name=anchor_san,json=anchorSan,proto3" json:"anchor_san,omitempty"`
	LiveType             int64      `protobuf:"varint,32,opt,name=live_type,json=liveType,proto3" json:"live_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RoomData) Reset()         { *m = RoomData{} }
func (m *RoomData) String() string { return proto.CompactTextString(m) }
func (*RoomData) ProtoMessage()    {}
func (*RoomData) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{2}
}
func (m *RoomData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomData.Merge(dst, src)
}
func (m *RoomData) XXX_Size() int {
	return m.Size()
}
func (m *RoomData) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomData.DiscardUnknown(m)
}

var xxx_messageInfo_RoomData proto.InternalMessageInfo

func (m *RoomData) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RoomData) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomData) GetShortId() int64 {
	if m != nil {
		return m.ShortId
	}
	return 0
}

func (m *RoomData) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RoomData) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *RoomData) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *RoomData) GetBackground() string {
	if m != nil {
		return m.Background
	}
	return ""
}

func (m *RoomData) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RoomData) GetLiveStatus() int64 {
	if m != nil {
		return m.LiveStatus
	}
	return 0
}

func (m *RoomData) GetLiveStartTime() int64 {
	if m != nil {
		return m.LiveStartTime
	}
	return 0
}

func (m *RoomData) GetLiveScreenType() int64 {
	if m != nil {
		return m.LiveScreenType
	}
	return 0
}

func (m *RoomData) GetLiveMark() int64 {
	if m != nil {
		return m.LiveMark
	}
	return 0
}

func (m *RoomData) GetLockStatus() int64 {
	if m != nil {
		return m.LockStatus
	}
	return 0
}

func (m *RoomData) GetLockTime() int64 {
	if m != nil {
		return m.LockTime
	}
	return 0
}

func (m *RoomData) GetHiddenStatus() int64 {
	if m != nil {
		return m.HiddenStatus
	}
	return 0
}

func (m *RoomData) GetHiddenTime() int64 {
	if m != nil {
		return m.HiddenTime
	}
	return 0
}

func (m *RoomData) GetAreaId() int64 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (m *RoomData) GetAreaName() string {
	if m != nil {
		return m.AreaName
	}
	return ""
}

func (m *RoomData) GetParentAreaId() int64 {
	if m != nil {
		return m.ParentAreaId
	}
	return 0
}

func (m *RoomData) GetParentAreaName() string {
	if m != nil {
		return m.ParentAreaName
	}
	return ""
}

func (m *RoomData) GetKeyframe() string {
	if m != nil {
		return m.Keyframe
	}
	return ""
}

func (m *RoomData) GetPopularityCount() int64 {
	if m != nil {
		return m.PopularityCount
	}
	return 0
}

func (m *RoomData) GetRoomTagList() []*TagData {
	if m != nil {
		return m.RoomTagList
	}
	return nil
}

func (m *RoomData) GetAnchorTagList() []*TagData {
	if m != nil {
		return m.AnchorTagList
	}
	return nil
}

func (m *RoomData) GetAnchorProfileType() int64 {
	if m != nil {
		return m.AnchorProfileType
	}
	return 0
}

func (m *RoomData) GetAnchorExp() []*ExpData {
	if m != nil {
		return m.AnchorExp
	}
	return nil
}

func (m *RoomData) GetAnchorRoundSwitch() int64 {
	if m != nil {
		return m.AnchorRoundSwitch
	}
	return 0
}

func (m *RoomData) GetAnchorRoundStatus() int64 {
	if m != nil {
		return m.AnchorRoundStatus
	}
	return 0
}

func (m *RoomData) GetAnchorRecordSwitch() int64 {
	if m != nil {
		return m.AnchorRecordSwitch
	}
	return 0
}

func (m *RoomData) GetAnchorRecordStatus() int64 {
	if m != nil {
		return m.AnchorRecordStatus
	}
	return 0
}

func (m *RoomData) GetAnchorSan() int64 {
	if m != nil {
		return m.AnchorSan
	}
	return 0
}

func (m *RoomData) GetLiveType() int64 {
	if m != nil {
		return m.LiveType
	}
	return 0
}

type RoomByIDsReq struct {
	RoomIds              []int64  `protobuf:"varint,1,rep,packed,name=room_ids,json=roomIds" json:"room_ids,omitempty"`
	Uids                 []int64  `protobuf:"varint,2,rep,packed,name=uids" json:"uids,omitempty"`
	Fields               []string `protobuf:"bytes,3,rep,name=fields" json:"fields,omitempty"`
	DefaultFields        int64    `protobuf:"varint,4,opt,name=default_fields,json=defaultFields,proto3" json:"default_fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomByIDsReq) Reset()         { *m = RoomByIDsReq{} }
func (m *RoomByIDsReq) String() string { return proto.CompactTextString(m) }
func (*RoomByIDsReq) ProtoMessage()    {}
func (*RoomByIDsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{3}
}
func (m *RoomByIDsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomByIDsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomByIDsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomByIDsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomByIDsReq.Merge(dst, src)
}
func (m *RoomByIDsReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomByIDsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomByIDsReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomByIDsReq proto.InternalMessageInfo

func (m *RoomByIDsReq) GetRoomIds() []int64 {
	if m != nil {
		return m.RoomIds
	}
	return nil
}

func (m *RoomByIDsReq) GetUids() []int64 {
	if m != nil {
		return m.Uids
	}
	return nil
}

func (m *RoomByIDsReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RoomByIDsReq) GetDefaultFields() int64 {
	if m != nil {
		return m.DefaultFields
	}
	return 0
}

type RoomByIDsResp struct {
	RoomDataSet          map[int64]*RoomData `protobuf:"bytes,1,rep,name=room_data_set,json=roomDataSet" json:"room_data_set,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RoomByIDsResp) Reset()         { *m = RoomByIDsResp{} }
func (m *RoomByIDsResp) String() string { return proto.CompactTextString(m) }
func (*RoomByIDsResp) ProtoMessage()    {}
func (*RoomByIDsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{4}
}
func (m *RoomByIDsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomByIDsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomByIDsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomByIDsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomByIDsResp.Merge(dst, src)
}
func (m *RoomByIDsResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomByIDsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomByIDsResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomByIDsResp proto.InternalMessageInfo

func (m *RoomByIDsResp) GetRoomDataSet() map[int64]*RoomData {
	if m != nil {
		return m.RoomDataSet
	}
	return nil
}

type RoomOnlineListReq struct {
	Filter               string   `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	Sort                 string   `protobuf:"bytes,2,opt,name=sort,proto3" json:"sort,omitempty"`
	Page                 int64    `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
	PageSize             int64    `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Fields               []string `protobuf:"bytes,5,rep,name=fields" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomOnlineListReq) Reset()         { *m = RoomOnlineListReq{} }
func (m *RoomOnlineListReq) String() string { return proto.CompactTextString(m) }
func (*RoomOnlineListReq) ProtoMessage()    {}
func (*RoomOnlineListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{5}
}
func (m *RoomOnlineListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomOnlineListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomOnlineListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomOnlineListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomOnlineListReq.Merge(dst, src)
}
func (m *RoomOnlineListReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomOnlineListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomOnlineListReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomOnlineListReq proto.InternalMessageInfo

func (m *RoomOnlineListReq) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *RoomOnlineListReq) GetSort() string {
	if m != nil {
		return m.Sort
	}
	return ""
}

func (m *RoomOnlineListReq) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *RoomOnlineListReq) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *RoomOnlineListReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type RoomOnlineListResp struct {
	RoomDataList         map[int64]*RoomData `protobuf:"bytes,1,rep,name=room_data_list,json=roomDataList" json:"room_data_list,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RoomOnlineListResp) Reset()         { *m = RoomOnlineListResp{} }
func (m *RoomOnlineListResp) String() string { return proto.CompactTextString(m) }
func (*RoomOnlineListResp) ProtoMessage()    {}
func (*RoomOnlineListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{6}
}
func (m *RoomOnlineListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomOnlineListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomOnlineListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomOnlineListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomOnlineListResp.Merge(dst, src)
}
func (m *RoomOnlineListResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomOnlineListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomOnlineListResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomOnlineListResp proto.InternalMessageInfo

func (m *RoomOnlineListResp) GetRoomDataList() map[int64]*RoomData {
	if m != nil {
		return m.RoomDataList
	}
	return nil
}

type RoomCreateReq struct {
	Uid                  int64    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	RoomId               int64    `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomCreateReq) Reset()         { *m = RoomCreateReq{} }
func (m *RoomCreateReq) String() string { return proto.CompactTextString(m) }
func (*RoomCreateReq) ProtoMessage()    {}
func (*RoomCreateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{7}
}
func (m *RoomCreateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomCreateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomCreateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomCreateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomCreateReq.Merge(dst, src)
}
func (m *RoomCreateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomCreateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomCreateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomCreateReq proto.InternalMessageInfo

func (m *RoomCreateReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RoomCreateReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type RoomCreateResp struct {
	RoomId               int64    `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomCreateResp) Reset()         { *m = RoomCreateResp{} }
func (m *RoomCreateResp) String() string { return proto.CompactTextString(m) }
func (*RoomCreateResp) ProtoMessage()    {}
func (*RoomCreateResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{8}
}
func (m *RoomCreateResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomCreateResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomCreateResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomCreateResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomCreateResp.Merge(dst, src)
}
func (m *RoomCreateResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomCreateResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomCreateResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomCreateResp proto.InternalMessageInfo

func (m *RoomCreateResp) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type UpdateResp struct {
	AffectedRows         int64    `protobuf:"varint,1,opt,name=affected_rows,json=affectedRows,proto3" json:"affected_rows,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateResp) Reset()         { *m = UpdateResp{} }
func (m *UpdateResp) String() string { return proto.CompactTextString(m) }
func (*UpdateResp) ProtoMessage()    {}
func (*UpdateResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{9}
}
func (m *UpdateResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateResp.Merge(dst, src)
}
func (m *UpdateResp) XXX_Size() int {
	return m.Size()
}
func (m *UpdateResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateResp.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateResp proto.InternalMessageInfo

func (m *UpdateResp) GetAffectedRows() int64 {
	if m != nil {
		return m.AffectedRows
	}
	return 0
}

type RoomUpdateReq struct {
	Fields               []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" validate:"required"`
	RoomId               int64    `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	Title                string   `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Cover                string   `protobuf:"bytes,4,opt,name=cover,proto3" json:"cover,omitempty"`
	Tags                 string   `protobuf:"bytes,5,opt,name=tags,proto3" json:"tags,omitempty"`
	Background           string   `protobuf:"bytes,6,opt,name=background,proto3" json:"background,omitempty"`
	Description          string   `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	LiveStartTime        int64    `protobuf:"varint,8,opt,name=live_start_time,json=liveStartTime,proto3" json:"live_start_time,omitempty"`
	LiveScreenType       int64    `protobuf:"varint,9,opt,name=live_screen_type,json=liveScreenType,proto3" json:"live_screen_type,omitempty"`
	LockStatus           int64    `protobuf:"varint,10,opt,name=lock_status,json=lockStatus,proto3" json:"lock_status,omitempty"`
	LockTime             int64    `protobuf:"varint,11,opt,name=lock_time,json=lockTime,proto3" json:"lock_time,omitempty"`
	HiddenTime           int64    `protobuf:"varint,12,opt,name=hidden_time,json=hiddenTime,proto3" json:"hidden_time,omitempty"`
	AreaId               int64    `protobuf:"varint,13,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty"`
	AnchorRoundSwitch    int64    `protobuf:"varint,14,opt,name=anchor_round_switch,json=anchorRoundSwitch,proto3" json:"anchor_round_switch,omitempty"`
	AnchorRecordSwitch   int64    `protobuf:"varint,15,opt,name=anchor_record_switch,json=anchorRecordSwitch,proto3" json:"anchor_record_switch,omitempty"`
	LiveType             int64    `protobuf:"varint,16,opt,name=live_type,json=liveType,proto3" json:"live_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomUpdateReq) Reset()         { *m = RoomUpdateReq{} }
func (m *RoomUpdateReq) String() string { return proto.CompactTextString(m) }
func (*RoomUpdateReq) ProtoMessage()    {}
func (*RoomUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{10}
}
func (m *RoomUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomUpdateReq.Merge(dst, src)
}
func (m *RoomUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomUpdateReq proto.InternalMessageInfo

func (m *RoomUpdateReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RoomUpdateReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomUpdateReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RoomUpdateReq) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *RoomUpdateReq) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *RoomUpdateReq) GetBackground() string {
	if m != nil {
		return m.Background
	}
	return ""
}

func (m *RoomUpdateReq) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RoomUpdateReq) GetLiveStartTime() int64 {
	if m != nil {
		return m.LiveStartTime
	}
	return 0
}

func (m *RoomUpdateReq) GetLiveScreenType() int64 {
	if m != nil {
		return m.LiveScreenType
	}
	return 0
}

func (m *RoomUpdateReq) GetLockStatus() int64 {
	if m != nil {
		return m.LockStatus
	}
	return 0
}

func (m *RoomUpdateReq) GetLockTime() int64 {
	if m != nil {
		return m.LockTime
	}
	return 0
}

func (m *RoomUpdateReq) GetHiddenTime() int64 {
	if m != nil {
		return m.HiddenTime
	}
	return 0
}

func (m *RoomUpdateReq) GetAreaId() int64 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (m *RoomUpdateReq) GetAnchorRoundSwitch() int64 {
	if m != nil {
		return m.AnchorRoundSwitch
	}
	return 0
}

func (m *RoomUpdateReq) GetAnchorRecordSwitch() int64 {
	if m != nil {
		return m.AnchorRecordSwitch
	}
	return 0
}

func (m *RoomUpdateReq) GetLiveType() int64 {
	if m != nil {
		return m.LiveType
	}
	return 0
}

type RoomBatchUpdateReq struct {
	Reqs                 []*RoomUpdateReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RoomBatchUpdateReq) Reset()         { *m = RoomBatchUpdateReq{} }
func (m *RoomBatchUpdateReq) String() string { return proto.CompactTextString(m) }
func (*RoomBatchUpdateReq) ProtoMessage()    {}
func (*RoomBatchUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{11}
}
func (m *RoomBatchUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomBatchUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomBatchUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomBatchUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomBatchUpdateReq.Merge(dst, src)
}
func (m *RoomBatchUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomBatchUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomBatchUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomBatchUpdateReq proto.InternalMessageInfo

func (m *RoomBatchUpdateReq) GetReqs() []*RoomUpdateReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type AnchorData struct {
	Uid                  int64      `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	ProfileType          int64      `protobuf:"varint,2,opt,name=profile_type,json=profileType,proto3" json:"profile_type,omitempty" validate:"gt=0,required"`
	Exp                  []*ExpData `protobuf:"bytes,3,rep,name=exp" json:"exp,omitempty" validate:"gt=0,required"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AnchorData) Reset()         { *m = AnchorData{} }
func (m *AnchorData) String() string { return proto.CompactTextString(m) }
func (*AnchorData) ProtoMessage()    {}
func (*AnchorData) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{12}
}
func (m *AnchorData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorData.Merge(dst, src)
}
func (m *AnchorData) XXX_Size() int {
	return m.Size()
}
func (m *AnchorData) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorData.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorData proto.InternalMessageInfo

func (m *AnchorData) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AnchorData) GetProfileType() int64 {
	if m != nil {
		return m.ProfileType
	}
	return 0
}

func (m *AnchorData) GetExp() []*ExpData {
	if m != nil {
		return m.Exp
	}
	return nil
}

type AnchorUpdateReq struct {
	Fields               []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" validate:"required"`
	Uid                  int64    `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	ProfileType          int64    `protobuf:"varint,3,opt,name=profile_type,json=profileType,proto3" json:"profile_type,omitempty"`
	SanScore             int64    `protobuf:"varint,4,opt,name=san_score,json=sanScore,proto3" json:"san_score,omitempty"`
	RoundStatus          int64    `protobuf:"varint,5,opt,name=round_status,json=roundStatus,proto3" json:"round_status,omitempty"`
	RecordStatus         int64    `protobuf:"varint,6,opt,name=record_status,json=recordStatus,proto3" json:"record_status,omitempty"`
	Exp                  int64    `protobuf:"varint,7,opt,name=exp,proto3" json:"exp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnchorUpdateReq) Reset()         { *m = AnchorUpdateReq{} }
func (m *AnchorUpdateReq) String() string { return proto.CompactTextString(m) }
func (*AnchorUpdateReq) ProtoMessage()    {}
func (*AnchorUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{13}
}
func (m *AnchorUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorUpdateReq.Merge(dst, src)
}
func (m *AnchorUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *AnchorUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorUpdateReq proto.InternalMessageInfo

func (m *AnchorUpdateReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *AnchorUpdateReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AnchorUpdateReq) GetProfileType() int64 {
	if m != nil {
		return m.ProfileType
	}
	return 0
}

func (m *AnchorUpdateReq) GetSanScore() int64 {
	if m != nil {
		return m.SanScore
	}
	return 0
}

func (m *AnchorUpdateReq) GetRoundStatus() int64 {
	if m != nil {
		return m.RoundStatus
	}
	return 0
}

func (m *AnchorUpdateReq) GetRecordStatus() int64 {
	if m != nil {
		return m.RecordStatus
	}
	return 0
}

func (m *AnchorUpdateReq) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type AnchorBatchUpdateReq struct {
	Reqs                 []*AnchorUpdateReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AnchorBatchUpdateReq) Reset()         { *m = AnchorBatchUpdateReq{} }
func (m *AnchorBatchUpdateReq) String() string { return proto.CompactTextString(m) }
func (*AnchorBatchUpdateReq) ProtoMessage()    {}
func (*AnchorBatchUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{14}
}
func (m *AnchorBatchUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorBatchUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorBatchUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorBatchUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorBatchUpdateReq.Merge(dst, src)
}
func (m *AnchorBatchUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *AnchorBatchUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorBatchUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorBatchUpdateReq proto.InternalMessageInfo

func (m *AnchorBatchUpdateReq) GetReqs() []*AnchorUpdateReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type AnchorIncreReq struct {
	ReqId                string   `protobuf:"bytes,1,opt,name=req_id,json=reqId,proto3" json:"req_id,omitempty" validate:"required"`
	Fields               []string `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty" validate:"required"`
	Uid                  int64    `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty" validate:"gt=0,required"`
	SanScore             int64    `protobuf:"varint,4,opt,name=san_score,json=sanScore,proto3" json:"san_score,omitempty"`
	Exp                  int64    `protobuf:"varint,5,opt,name=exp,proto3" json:"exp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnchorIncreReq) Reset()         { *m = AnchorIncreReq{} }
func (m *AnchorIncreReq) String() string { return proto.CompactTextString(m) }
func (*AnchorIncreReq) ProtoMessage()    {}
func (*AnchorIncreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{15}
}
func (m *AnchorIncreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorIncreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorIncreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorIncreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorIncreReq.Merge(dst, src)
}
func (m *AnchorIncreReq) XXX_Size() int {
	return m.Size()
}
func (m *AnchorIncreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorIncreReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorIncreReq proto.InternalMessageInfo

func (m *AnchorIncreReq) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *AnchorIncreReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *AnchorIncreReq) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AnchorIncreReq) GetSanScore() int64 {
	if m != nil {
		return m.SanScore
	}
	return 0
}

func (m *AnchorIncreReq) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

type AnchorBatchIncreReq struct {
	Reqs                 []*AnchorIncreReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AnchorBatchIncreReq) Reset()         { *m = AnchorBatchIncreReq{} }
func (m *AnchorBatchIncreReq) String() string { return proto.CompactTextString(m) }
func (*AnchorBatchIncreReq) ProtoMessage()    {}
func (*AnchorBatchIncreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{16}
}
func (m *AnchorBatchIncreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorBatchIncreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorBatchIncreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorBatchIncreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorBatchIncreReq.Merge(dst, src)
}
func (m *AnchorBatchIncreReq) XXX_Size() int {
	return m.Size()
}
func (m *AnchorBatchIncreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorBatchIncreReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorBatchIncreReq proto.InternalMessageInfo

func (m *AnchorBatchIncreReq) GetReqs() []*AnchorIncreReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type RoomExtendUpdateReq struct {
	Fields               []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" validate:"required"`
	RoomId               int64    `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	KeyFrame             string   `protobuf:"bytes,3,opt,name=key_frame,json=keyFrame,proto3" json:"key_frame,omitempty"`
	DanmuCount           int64    `protobuf:"varint,4,opt,name=danmu_count,json=danmuCount,proto3" json:"danmu_count,omitempty"`
	PopularityCount      int64    `protobuf:"varint,5,opt,name=popularity_count,json=popularityCount,proto3" json:"popularity_count,omitempty"`
	AudienceCount        int64    `protobuf:"varint,6,opt,name=audience_count,json=audienceCount,proto3" json:"audience_count,omitempty"`
	GiftCount            int64    `protobuf:"varint,7,opt,name=gift_count,json=giftCount,proto3" json:"gift_count,omitempty"`
	GiftGoldAmount       int64    `protobuf:"varint,8,opt,name=gift_gold_amount,json=giftGoldAmount,proto3" json:"gift_gold_amount,omitempty"`
	GiftGoldCount        int64    `protobuf:"varint,9,opt,name=gift_gold_count,json=giftGoldCount,proto3" json:"gift_gold_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomExtendUpdateReq) Reset()         { *m = RoomExtendUpdateReq{} }
func (m *RoomExtendUpdateReq) String() string { return proto.CompactTextString(m) }
func (*RoomExtendUpdateReq) ProtoMessage()    {}
func (*RoomExtendUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{17}
}
func (m *RoomExtendUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomExtendUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomExtendUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomExtendUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomExtendUpdateReq.Merge(dst, src)
}
func (m *RoomExtendUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomExtendUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomExtendUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomExtendUpdateReq proto.InternalMessageInfo

func (m *RoomExtendUpdateReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RoomExtendUpdateReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetKeyFrame() string {
	if m != nil {
		return m.KeyFrame
	}
	return ""
}

func (m *RoomExtendUpdateReq) GetDanmuCount() int64 {
	if m != nil {
		return m.DanmuCount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetPopularityCount() int64 {
	if m != nil {
		return m.PopularityCount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetAudienceCount() int64 {
	if m != nil {
		return m.AudienceCount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetGiftCount() int64 {
	if m != nil {
		return m.GiftCount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetGiftGoldAmount() int64 {
	if m != nil {
		return m.GiftGoldAmount
	}
	return 0
}

func (m *RoomExtendUpdateReq) GetGiftGoldCount() int64 {
	if m != nil {
		return m.GiftGoldCount
	}
	return 0
}

type RoomExtendBatchUpdateReq struct {
	Reqs                 []*RoomExtendUpdateReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *RoomExtendBatchUpdateReq) Reset()         { *m = RoomExtendBatchUpdateReq{} }
func (m *RoomExtendBatchUpdateReq) String() string { return proto.CompactTextString(m) }
func (*RoomExtendBatchUpdateReq) ProtoMessage()    {}
func (*RoomExtendBatchUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{18}
}
func (m *RoomExtendBatchUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomExtendBatchUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomExtendBatchUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomExtendBatchUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomExtendBatchUpdateReq.Merge(dst, src)
}
func (m *RoomExtendBatchUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomExtendBatchUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomExtendBatchUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomExtendBatchUpdateReq proto.InternalMessageInfo

func (m *RoomExtendBatchUpdateReq) GetReqs() []*RoomExtendUpdateReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type RoomExtendIncreReq struct {
	ReqId                string   `protobuf:"bytes,1,opt,name=req_id,json=reqId,proto3" json:"req_id,omitempty" validate:"required"`
	Fields               []string `protobuf:"bytes,2,rep,name=fields" json:"fields,omitempty" validate:"required"`
	RoomId               int64    `protobuf:"varint,3,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	DanmuCount           int64    `protobuf:"varint,4,opt,name=danmu_count,json=danmuCount,proto3" json:"danmu_count,omitempty"`
	PopularityCount      int64    `protobuf:"varint,5,opt,name=popularity_count,json=popularityCount,proto3" json:"popularity_count,omitempty"`
	AudienceCount        int64    `protobuf:"varint,6,opt,name=audience_count,json=audienceCount,proto3" json:"audience_count,omitempty"`
	GiftCount            int64    `protobuf:"varint,7,opt,name=gift_count,json=giftCount,proto3" json:"gift_count,omitempty"`
	GiftGoldAmount       int64    `protobuf:"varint,8,opt,name=gift_gold_amount,json=giftGoldAmount,proto3" json:"gift_gold_amount,omitempty"`
	GiftGoldCount        int64    `protobuf:"varint,9,opt,name=gift_gold_count,json=giftGoldCount,proto3" json:"gift_gold_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomExtendIncreReq) Reset()         { *m = RoomExtendIncreReq{} }
func (m *RoomExtendIncreReq) String() string { return proto.CompactTextString(m) }
func (*RoomExtendIncreReq) ProtoMessage()    {}
func (*RoomExtendIncreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{19}
}
func (m *RoomExtendIncreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomExtendIncreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomExtendIncreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomExtendIncreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomExtendIncreReq.Merge(dst, src)
}
func (m *RoomExtendIncreReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomExtendIncreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomExtendIncreReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomExtendIncreReq proto.InternalMessageInfo

func (m *RoomExtendIncreReq) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *RoomExtendIncreReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RoomExtendIncreReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomExtendIncreReq) GetDanmuCount() int64 {
	if m != nil {
		return m.DanmuCount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetPopularityCount() int64 {
	if m != nil {
		return m.PopularityCount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetAudienceCount() int64 {
	if m != nil {
		return m.AudienceCount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetGiftCount() int64 {
	if m != nil {
		return m.GiftCount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetGiftGoldAmount() int64 {
	if m != nil {
		return m.GiftGoldAmount
	}
	return 0
}

func (m *RoomExtendIncreReq) GetGiftGoldCount() int64 {
	if m != nil {
		return m.GiftGoldCount
	}
	return 0
}

type RoomExtendBatchIncreReq struct {
	Reqs                 []*RoomExtendIncreReq `protobuf:"bytes,1,rep,name=reqs" json:"reqs,omitempty" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *RoomExtendBatchIncreReq) Reset()         { *m = RoomExtendBatchIncreReq{} }
func (m *RoomExtendBatchIncreReq) String() string { return proto.CompactTextString(m) }
func (*RoomExtendBatchIncreReq) ProtoMessage()    {}
func (*RoomExtendBatchIncreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{20}
}
func (m *RoomExtendBatchIncreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomExtendBatchIncreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomExtendBatchIncreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomExtendBatchIncreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomExtendBatchIncreReq.Merge(dst, src)
}
func (m *RoomExtendBatchIncreReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomExtendBatchIncreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomExtendBatchIncreReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomExtendBatchIncreReq proto.InternalMessageInfo

func (m *RoomExtendBatchIncreReq) GetReqs() []*RoomExtendIncreReq {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type RoomTagSetReq struct {
	Fields               []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" validate:"required"`
	RoomId               int64    `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty" validate:"gt=0,required"`
	TagType              int64    `protobuf:"varint,3,opt,name=tag_type,json=tagType,proto3" json:"tag_type,omitempty" validate:"gt=0,required"`
	TagValue             int64    `protobuf:"varint,4,opt,name=tag_value,json=tagValue,proto3" json:"tag_value,omitempty"`
	TagAttribute         string   `protobuf:"bytes,5,opt,name=tag_attribute,json=tagAttribute,proto3" json:"tag_attribute,omitempty"`
	TagExpireAt          int64    `protobuf:"varint,6,opt,name=tag_expire_at,json=tagExpireAt,proto3" json:"tag_expire_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomTagSetReq) Reset()         { *m = RoomTagSetReq{} }
func (m *RoomTagSetReq) String() string { return proto.CompactTextString(m) }
func (*RoomTagSetReq) ProtoMessage()    {}
func (*RoomTagSetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{21}
}
func (m *RoomTagSetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomTagSetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomTagSetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomTagSetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomTagSetReq.Merge(dst, src)
}
func (m *RoomTagSetReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomTagSetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomTagSetReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomTagSetReq proto.InternalMessageInfo

func (m *RoomTagSetReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *RoomTagSetReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomTagSetReq) GetTagType() int64 {
	if m != nil {
		return m.TagType
	}
	return 0
}

func (m *RoomTagSetReq) GetTagValue() int64 {
	if m != nil {
		return m.TagValue
	}
	return 0
}

func (m *RoomTagSetReq) GetTagAttribute() string {
	if m != nil {
		return m.TagAttribute
	}
	return ""
}

func (m *RoomTagSetReq) GetTagExpireAt() int64 {
	if m != nil {
		return m.TagExpireAt
	}
	return 0
}

type AnchorTagSetReq struct {
	Fields               []string `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" validate:"required"`
	AnchorId             int64    `protobuf:"varint,2,opt,name=anchor_id,json=anchorId,proto3" json:"anchor_id,omitempty" validate:"gt=0,required"`
	TagType              int64    `protobuf:"varint,3,opt,name=tag_type,json=tagType,proto3" json:"tag_type,omitempty" validate:"gt=0,required"`
	TagValue             int64    `protobuf:"varint,4,opt,name=tag_value,json=tagValue,proto3" json:"tag_value,omitempty"`
	TagAttribute         string   `protobuf:"bytes,5,opt,name=tag_attribute,json=tagAttribute,proto3" json:"tag_attribute,omitempty"`
	TagExpireAt          int64    `protobuf:"varint,6,opt,name=tag_expire_at,json=tagExpireAt,proto3" json:"tag_expire_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnchorTagSetReq) Reset()         { *m = AnchorTagSetReq{} }
func (m *AnchorTagSetReq) String() string { return proto.CompactTextString(m) }
func (*AnchorTagSetReq) ProtoMessage()    {}
func (*AnchorTagSetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_api_5e82c9cace3801b5, []int{22}
}
func (m *AnchorTagSetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnchorTagSetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnchorTagSetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AnchorTagSetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnchorTagSetReq.Merge(dst, src)
}
func (m *AnchorTagSetReq) XXX_Size() int {
	return m.Size()
}
func (m *AnchorTagSetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AnchorTagSetReq.DiscardUnknown(m)
}

var xxx_messageInfo_AnchorTagSetReq proto.InternalMessageInfo

func (m *AnchorTagSetReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *AnchorTagSetReq) GetAnchorId() int64 {
	if m != nil {
		return m.AnchorId
	}
	return 0
}

func (m *AnchorTagSetReq) GetTagType() int64 {
	if m != nil {
		return m.TagType
	}
	return 0
}

func (m *AnchorTagSetReq) GetTagValue() int64 {
	if m != nil {
		return m.TagValue
	}
	return 0
}

func (m *AnchorTagSetReq) GetTagAttribute() string {
	if m != nil {
		return m.TagAttribute
	}
	return ""
}

func (m *AnchorTagSetReq) GetTagExpireAt() int64 {
	if m != nil {
		return m.TagExpireAt
	}
	return 0
}

func init() {
	proto.RegisterType((*ExpData)(nil), "live.xanchor.v1.ExpData")
	proto.RegisterType((*TagData)(nil), "live.xanchor.v1.TagData")
	proto.RegisterType((*RoomData)(nil), "live.xanchor.v1.RoomData")
	proto.RegisterType((*RoomByIDsReq)(nil), "live.xanchor.v1.RoomByIDsReq")
	proto.RegisterType((*RoomByIDsResp)(nil), "live.xanchor.v1.RoomByIDsResp")
	proto.RegisterMapType((map[int64]*RoomData)(nil), "live.xanchor.v1.RoomByIDsResp.RoomDataSetEntry")
	proto.RegisterType((*RoomOnlineListReq)(nil), "live.xanchor.v1.RoomOnlineListReq")
	proto.RegisterType((*RoomOnlineListResp)(nil), "live.xanchor.v1.RoomOnlineListResp")
	proto.RegisterMapType((map[int64]*RoomData)(nil), "live.xanchor.v1.RoomOnlineListResp.RoomDataListEntry")
	proto.RegisterType((*RoomCreateReq)(nil), "live.xanchor.v1.RoomCreateReq")
	proto.RegisterType((*RoomCreateResp)(nil), "live.xanchor.v1.RoomCreateResp")
	proto.RegisterType((*UpdateResp)(nil), "live.xanchor.v1.UpdateResp")
	proto.RegisterType((*RoomUpdateReq)(nil), "live.xanchor.v1.RoomUpdateReq")
	proto.RegisterType((*RoomBatchUpdateReq)(nil), "live.xanchor.v1.RoomBatchUpdateReq")
	proto.RegisterType((*AnchorData)(nil), "live.xanchor.v1.AnchorData")
	proto.RegisterType((*AnchorUpdateReq)(nil), "live.xanchor.v1.AnchorUpdateReq")
	proto.RegisterType((*AnchorBatchUpdateReq)(nil), "live.xanchor.v1.AnchorBatchUpdateReq")
	proto.RegisterType((*AnchorIncreReq)(nil), "live.xanchor.v1.AnchorIncreReq")
	proto.RegisterType((*AnchorBatchIncreReq)(nil), "live.xanchor.v1.AnchorBatchIncreReq")
	proto.RegisterType((*RoomExtendUpdateReq)(nil), "live.xanchor.v1.RoomExtendUpdateReq")
	proto.RegisterType((*RoomExtendBatchUpdateReq)(nil), "live.xanchor.v1.RoomExtendBatchUpdateReq")
	proto.RegisterType((*RoomExtendIncreReq)(nil), "live.xanchor.v1.RoomExtendIncreReq")
	proto.RegisterType((*RoomExtendBatchIncreReq)(nil), "live.xanchor.v1.RoomExtendBatchIncreReq")
	proto.RegisterType((*RoomTagSetReq)(nil), "live.xanchor.v1.RoomTagSetReq")
	proto.RegisterType((*AnchorTagSetReq)(nil), "live.xanchor.v1.AnchorTagSetReq")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// XAnchorClient is the client API for XAnchor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type XAnchorClient interface {
	// FetchRoomByIDs 查询房间信息
	FetchRoomByIDs(ctx context.Context, in *RoomByIDsReq, opts ...grpc.CallOption) (*RoomByIDsResp, error)
	// RoomOnlineList 在线房间列表
	RoomOnlineList(ctx context.Context, in *RoomOnlineListReq, opts ...grpc.CallOption) (*RoomOnlineListResp, error)
	// RoomCreate 房间创建
	RoomCreate(ctx context.Context, in *RoomCreateReq, opts ...grpc.CallOption) (*RoomCreateResp, error)
	// RoomUpdate 房间信息更新
	RoomUpdate(ctx context.Context, in *RoomUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomBatchUpdate 房间信息批量更新
	RoomBatchUpdate(ctx context.Context, in *RoomBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomExtendUpdate 房间扩展信息更新
	RoomExtendUpdate(ctx context.Context, in *RoomExtendUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomExtendBatchUpdate 房间扩展信息批量更新
	RoomExtendBatchUpdate(ctx context.Context, in *RoomExtendBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomExtendIncre 房间信息增量更新
	RoomExtendIncre(ctx context.Context, in *RoomExtendIncreReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomExtendBatchIncre 房间信息批量增量更新
	RoomExtendBatchIncre(ctx context.Context, in *RoomExtendBatchIncreReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// RoomTagSet 房间Tag更新
	RoomTagSet(ctx context.Context, in *RoomTagSetReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// AnchorUpdate 主播信息更新
	AnchorUpdate(ctx context.Context, in *AnchorUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// AnchorBatchUpdate 主播信息批量更新
	AnchorBatchUpdate(ctx context.Context, in *AnchorBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// AnchorIncre 主播信息增量更新
	AnchorIncre(ctx context.Context, in *AnchorIncreReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// AnchorBatchIncre 主播信息批量增量更新
	AnchorBatchIncre(ctx context.Context, in *AnchorBatchIncreReq, opts ...grpc.CallOption) (*UpdateResp, error)
	// AnchorTagSet 主播Tag更新
	AnchorTagSet(ctx context.Context, in *AnchorTagSetReq, opts ...grpc.CallOption) (*UpdateResp, error)
}

type xAnchorClient struct {
	cc *grpc.ClientConn
}

func NewXAnchorClient(cc *grpc.ClientConn) XAnchorClient {
	return &xAnchorClient{cc}
}

func (c *xAnchorClient) FetchRoomByIDs(ctx context.Context, in *RoomByIDsReq, opts ...grpc.CallOption) (*RoomByIDsResp, error) {
	out := new(RoomByIDsResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/FetchRoomByIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) RoomOnlineList(ctx context.Context, in *RoomOnlineListReq, opts ...grpc.CallOption) (*RoomOnlineListResp, error) {
	out := new(RoomOnlineListResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/RoomOnlineList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) RoomCreate(ctx context.Context, in *RoomCreateReq, opts ...grpc.CallOption) (*RoomCreateResp, error) {
	out := new(RoomCreateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/RoomCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) RoomUpdate(ctx context.Context, in *RoomUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/RoomUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) RoomBatchUpdate(ctx context.Context, in *RoomBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/RoomBatchUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) RoomExtendUpdate(ctx context.Context, in *RoomExtendUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/RoomExtendUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) RoomExtendBatchUpdate(ctx context.Context, in *RoomExtendBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/RoomExtendBatchUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) RoomExtendIncre(ctx context.Context, in *RoomExtendIncreReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/RoomExtendIncre", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) RoomExtendBatchIncre(ctx context.Context, in *RoomExtendBatchIncreReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/RoomExtendBatchIncre", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) RoomTagSet(ctx context.Context, in *RoomTagSetReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/RoomTagSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) AnchorUpdate(ctx context.Context, in *AnchorUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/AnchorUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) AnchorBatchUpdate(ctx context.Context, in *AnchorBatchUpdateReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/AnchorBatchUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) AnchorIncre(ctx context.Context, in *AnchorIncreReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/AnchorIncre", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) AnchorBatchIncre(ctx context.Context, in *AnchorBatchIncreReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/AnchorBatchIncre", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xAnchorClient) AnchorTagSet(ctx context.Context, in *AnchorTagSetReq, opts ...grpc.CallOption) (*UpdateResp, error) {
	out := new(UpdateResp)
	err := c.cc.Invoke(ctx, "/live.xanchor.v1.XAnchor/AnchorTagSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// XAnchorServer is the server API for XAnchor service.
type XAnchorServer interface {
	// FetchRoomByIDs 查询房间信息
	FetchRoomByIDs(context.Context, *RoomByIDsReq) (*RoomByIDsResp, error)
	// RoomOnlineList 在线房间列表
	RoomOnlineList(context.Context, *RoomOnlineListReq) (*RoomOnlineListResp, error)
	// RoomCreate 房间创建
	RoomCreate(context.Context, *RoomCreateReq) (*RoomCreateResp, error)
	// RoomUpdate 房间信息更新
	RoomUpdate(context.Context, *RoomUpdateReq) (*UpdateResp, error)
	// RoomBatchUpdate 房间信息批量更新
	RoomBatchUpdate(context.Context, *RoomBatchUpdateReq) (*UpdateResp, error)
	// RoomExtendUpdate 房间扩展信息更新
	RoomExtendUpdate(context.Context, *RoomExtendUpdateReq) (*UpdateResp, error)
	// RoomExtendBatchUpdate 房间扩展信息批量更新
	RoomExtendBatchUpdate(context.Context, *RoomExtendBatchUpdateReq) (*UpdateResp, error)
	// RoomExtendIncre 房间信息增量更新
	RoomExtendIncre(context.Context, *RoomExtendIncreReq) (*UpdateResp, error)
	// RoomExtendBatchIncre 房间信息批量增量更新
	RoomExtendBatchIncre(context.Context, *RoomExtendBatchIncreReq) (*UpdateResp, error)
	// RoomTagSet 房间Tag更新
	RoomTagSet(context.Context, *RoomTagSetReq) (*UpdateResp, error)
	// AnchorUpdate 主播信息更新
	AnchorUpdate(context.Context, *AnchorUpdateReq) (*UpdateResp, error)
	// AnchorBatchUpdate 主播信息批量更新
	AnchorBatchUpdate(context.Context, *AnchorBatchUpdateReq) (*UpdateResp, error)
	// AnchorIncre 主播信息增量更新
	AnchorIncre(context.Context, *AnchorIncreReq) (*UpdateResp, error)
	// AnchorBatchIncre 主播信息批量增量更新
	AnchorBatchIncre(context.Context, *AnchorBatchIncreReq) (*UpdateResp, error)
	// AnchorTagSet 主播Tag更新
	AnchorTagSet(context.Context, *AnchorTagSetReq) (*UpdateResp, error)
}

func RegisterXAnchorServer(s *grpc.Server, srv XAnchorServer) {
	s.RegisterService(&_XAnchor_serviceDesc, srv)
}

func _XAnchor_FetchRoomByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomByIDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).FetchRoomByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/FetchRoomByIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).FetchRoomByIDs(ctx, req.(*RoomByIDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_RoomOnlineList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomOnlineListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).RoomOnlineList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/RoomOnlineList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).RoomOnlineList(ctx, req.(*RoomOnlineListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_RoomCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).RoomCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/RoomCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).RoomCreate(ctx, req.(*RoomCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_RoomUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).RoomUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/RoomUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).RoomUpdate(ctx, req.(*RoomUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_RoomBatchUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomBatchUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).RoomBatchUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/RoomBatchUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).RoomBatchUpdate(ctx, req.(*RoomBatchUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_RoomExtendUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomExtendUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).RoomExtendUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/RoomExtendUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).RoomExtendUpdate(ctx, req.(*RoomExtendUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_RoomExtendBatchUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomExtendBatchUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).RoomExtendBatchUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/RoomExtendBatchUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).RoomExtendBatchUpdate(ctx, req.(*RoomExtendBatchUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_RoomExtendIncre_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomExtendIncreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).RoomExtendIncre(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/RoomExtendIncre",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).RoomExtendIncre(ctx, req.(*RoomExtendIncreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_RoomExtendBatchIncre_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomExtendBatchIncreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).RoomExtendBatchIncre(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/RoomExtendBatchIncre",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).RoomExtendBatchIncre(ctx, req.(*RoomExtendBatchIncreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_RoomTagSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomTagSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).RoomTagSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/RoomTagSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).RoomTagSet(ctx, req.(*RoomTagSetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_AnchorUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).AnchorUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/AnchorUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).AnchorUpdate(ctx, req.(*AnchorUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_AnchorBatchUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorBatchUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).AnchorBatchUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/AnchorBatchUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).AnchorBatchUpdate(ctx, req.(*AnchorBatchUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_AnchorIncre_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorIncreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).AnchorIncre(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/AnchorIncre",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).AnchorIncre(ctx, req.(*AnchorIncreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_AnchorBatchIncre_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorBatchIncreReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).AnchorBatchIncre(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/AnchorBatchIncre",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).AnchorBatchIncre(ctx, req.(*AnchorBatchIncreReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _XAnchor_AnchorTagSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnchorTagSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XAnchorServer).AnchorTagSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/live.xanchor.v1.XAnchor/AnchorTagSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XAnchorServer).AnchorTagSet(ctx, req.(*AnchorTagSetReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _XAnchor_serviceDesc = grpc.ServiceDesc{
	ServiceName: "live.xanchor.v1.XAnchor",
	HandlerType: (*XAnchorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchRoomByIDs",
			Handler:    _XAnchor_FetchRoomByIDs_Handler,
		},
		{
			MethodName: "RoomOnlineList",
			Handler:    _XAnchor_RoomOnlineList_Handler,
		},
		{
			MethodName: "RoomCreate",
			Handler:    _XAnchor_RoomCreate_Handler,
		},
		{
			MethodName: "RoomUpdate",
			Handler:    _XAnchor_RoomUpdate_Handler,
		},
		{
			MethodName: "RoomBatchUpdate",
			Handler:    _XAnchor_RoomBatchUpdate_Handler,
		},
		{
			MethodName: "RoomExtendUpdate",
			Handler:    _XAnchor_RoomExtendUpdate_Handler,
		},
		{
			MethodName: "RoomExtendBatchUpdate",
			Handler:    _XAnchor_RoomExtendBatchUpdate_Handler,
		},
		{
			MethodName: "RoomExtendIncre",
			Handler:    _XAnchor_RoomExtendIncre_Handler,
		},
		{
			MethodName: "RoomExtendBatchIncre",
			Handler:    _XAnchor_RoomExtendBatchIncre_Handler,
		},
		{
			MethodName: "RoomTagSet",
			Handler:    _XAnchor_RoomTagSet_Handler,
		},
		{
			MethodName: "AnchorUpdate",
			Handler:    _XAnchor_AnchorUpdate_Handler,
		},
		{
			MethodName: "AnchorBatchUpdate",
			Handler:    _XAnchor_AnchorBatchUpdate_Handler,
		},
		{
			MethodName: "AnchorIncre",
			Handler:    _XAnchor_AnchorIncre_Handler,
		},
		{
			MethodName: "AnchorBatchIncre",
			Handler:    _XAnchor_AnchorBatchIncre_Handler,
		},
		{
			MethodName: "AnchorTagSet",
			Handler:    _XAnchor_AnchorTagSet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/service/live/xanchor/api/grpc/v1/api.proto",
}

func (m *ExpData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Level))
	}
	if m.NextLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NextLevel))
	}
	if m.LevelColor != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LevelColor))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Exp))
	}
	if m.CurrentLevelExp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.CurrentLevelExp))
	}
	if m.NextLevelExp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.NextLevelExp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TagData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TagId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagId))
	}
	if m.TagType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagType))
	}
	if m.TagValue != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagValue))
	}
	if len(m.TagAttribute) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TagAttribute)))
		i += copy(dAtA[i:], m.TagAttribute)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.ShortId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ShortId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if len(m.Tags) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tags)))
		i += copy(dAtA[i:], m.Tags)
	}
	if len(m.Background) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Background)))
		i += copy(dAtA[i:], m.Background)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.LiveStatus != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveStatus))
	}
	if m.LiveStartTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveStartTime))
	}
	if m.LiveScreenType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveScreenType))
	}
	if m.LiveMark != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveMark))
	}
	if m.LockStatus != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LockStatus))
	}
	if m.LockTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LockTime))
	}
	if m.HiddenStatus != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HiddenStatus))
	}
	if m.HiddenTime != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HiddenTime))
	}
	if m.AreaId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaId))
	}
	if len(m.AreaName) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.AreaName)))
		i += copy(dAtA[i:], m.AreaName)
	}
	if m.ParentAreaId != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ParentAreaId))
	}
	if len(m.ParentAreaName) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ParentAreaName)))
		i += copy(dAtA[i:], m.ParentAreaName)
	}
	if len(m.Keyframe) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Keyframe)))
		i += copy(dAtA[i:], m.Keyframe)
	}
	if m.PopularityCount != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PopularityCount))
	}
	if len(m.RoomTagList) > 0 {
		for _, msg := range m.RoomTagList {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AnchorTagList) > 0 {
		for _, msg := range m.AnchorTagList {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AnchorProfileType != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorProfileType))
	}
	if len(m.AnchorExp) > 0 {
		for _, msg := range m.AnchorExp {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AnchorRoundSwitch != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRoundSwitch))
	}
	if m.AnchorRoundStatus != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRoundStatus))
	}
	if m.AnchorRecordSwitch != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRecordSwitch))
	}
	if m.AnchorRecordStatus != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRecordStatus))
	}
	if m.AnchorSan != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorSan))
	}
	if m.LiveType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomByIDsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomByIDsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		dAtA2 := make([]byte, len(m.RoomIds)*10)
		var j1 int
		for _, num1 := range m.RoomIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Uids) > 0 {
		dAtA4 := make([]byte, len(m.Uids)*10)
		var j3 int
		for _, num1 := range m.Uids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DefaultFields != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DefaultFields))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomByIDsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomByIDsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomDataSet) > 0 {
		for k, _ := range m.RoomDataSet {
			dAtA[i] = 0xa
			i++
			v := m.RoomDataSet[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomOnlineListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOnlineListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Filter) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	if len(m.Sort) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Sort)))
		i += copy(dAtA[i:], m.Sort)
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Page))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PageSize))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomOnlineListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOnlineListResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomDataList) > 0 {
		for k, _ := range m.RoomDataList {
			dAtA[i] = 0xa
			i++
			v := m.RoomDataList[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomCreateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomCreateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomCreateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomCreateResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AffectedRows != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AffectedRows))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if len(m.Tags) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Tags)))
		i += copy(dAtA[i:], m.Tags)
	}
	if len(m.Background) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Background)))
		i += copy(dAtA[i:], m.Background)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.LiveStartTime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveStartTime))
	}
	if m.LiveScreenType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveScreenType))
	}
	if m.LockStatus != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LockStatus))
	}
	if m.LockTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LockTime))
	}
	if m.HiddenTime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.HiddenTime))
	}
	if m.AreaId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AreaId))
	}
	if m.AnchorRoundSwitch != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRoundSwitch))
	}
	if m.AnchorRecordSwitch != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorRecordSwitch))
	}
	if m.LiveType != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.LiveType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomBatchUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomBatchUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.ProfileType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ProfileType))
	}
	if len(m.Exp) > 0 {
		for _, msg := range m.Exp {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.ProfileType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ProfileType))
	}
	if m.SanScore != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SanScore))
	}
	if m.RoundStatus != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoundStatus))
	}
	if m.RecordStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RecordStatus))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Exp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorBatchUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorBatchUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorIncreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorIncreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReqId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ReqId)))
		i += copy(dAtA[i:], m.ReqId)
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Uid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Uid))
	}
	if m.SanScore != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SanScore))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Exp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorBatchIncreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorBatchIncreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomExtendUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomExtendUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if len(m.KeyFrame) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.KeyFrame)))
		i += copy(dAtA[i:], m.KeyFrame)
	}
	if m.DanmuCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DanmuCount))
	}
	if m.PopularityCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PopularityCount))
	}
	if m.AudienceCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AudienceCount))
	}
	if m.GiftCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftCount))
	}
	if m.GiftGoldAmount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftGoldAmount))
	}
	if m.GiftGoldCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftGoldCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomExtendBatchUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomExtendBatchUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomExtendIncreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomExtendIncreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReqId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.ReqId)))
		i += copy(dAtA[i:], m.ReqId)
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.DanmuCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.DanmuCount))
	}
	if m.PopularityCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PopularityCount))
	}
	if m.AudienceCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AudienceCount))
	}
	if m.GiftCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftCount))
	}
	if m.GiftGoldAmount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftGoldAmount))
	}
	if m.GiftGoldCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.GiftGoldCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomExtendBatchIncreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomExtendBatchIncreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, msg := range m.Reqs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RoomTagSetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomTagSetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.RoomId))
	}
	if m.TagType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagType))
	}
	if m.TagValue != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagValue))
	}
	if len(m.TagAttribute) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TagAttribute)))
		i += copy(dAtA[i:], m.TagAttribute)
	}
	if m.TagExpireAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagExpireAt))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AnchorTagSetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnchorTagSetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.AnchorId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.AnchorId))
	}
	if m.TagType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagType))
	}
	if m.TagValue != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagValue))
	}
	if len(m.TagAttribute) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.TagAttribute)))
		i += copy(dAtA[i:], m.TagAttribute)
	}
	if m.TagExpireAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TagExpireAt))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ExpData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovApi(uint64(m.Level))
	}
	if m.NextLevel != 0 {
		n += 1 + sovApi(uint64(m.NextLevel))
	}
	if m.LevelColor != 0 {
		n += 1 + sovApi(uint64(m.LevelColor))
	}
	if m.Exp != 0 {
		n += 1 + sovApi(uint64(m.Exp))
	}
	if m.CurrentLevelExp != 0 {
		n += 1 + sovApi(uint64(m.CurrentLevelExp))
	}
	if m.NextLevelExp != 0 {
		n += 1 + sovApi(uint64(m.NextLevelExp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TagData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TagId != 0 {
		n += 1 + sovApi(uint64(m.TagId))
	}
	if m.TagType != 0 {
		n += 1 + sovApi(uint64(m.TagType))
	}
	if m.TagValue != 0 {
		n += 1 + sovApi(uint64(m.TagValue))
	}
	l = len(m.TagAttribute)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.ShortId != 0 {
		n += 1 + sovApi(uint64(m.ShortId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Background)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.LiveStatus != 0 {
		n += 1 + sovApi(uint64(m.LiveStatus))
	}
	if m.LiveStartTime != 0 {
		n += 1 + sovApi(uint64(m.LiveStartTime))
	}
	if m.LiveScreenType != 0 {
		n += 1 + sovApi(uint64(m.LiveScreenType))
	}
	if m.LiveMark != 0 {
		n += 1 + sovApi(uint64(m.LiveMark))
	}
	if m.LockStatus != 0 {
		n += 1 + sovApi(uint64(m.LockStatus))
	}
	if m.LockTime != 0 {
		n += 1 + sovApi(uint64(m.LockTime))
	}
	if m.HiddenStatus != 0 {
		n += 1 + sovApi(uint64(m.HiddenStatus))
	}
	if m.HiddenTime != 0 {
		n += 2 + sovApi(uint64(m.HiddenTime))
	}
	if m.AreaId != 0 {
		n += 2 + sovApi(uint64(m.AreaId))
	}
	l = len(m.AreaName)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.ParentAreaId != 0 {
		n += 2 + sovApi(uint64(m.ParentAreaId))
	}
	l = len(m.ParentAreaName)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	l = len(m.Keyframe)
	if l > 0 {
		n += 2 + l + sovApi(uint64(l))
	}
	if m.PopularityCount != 0 {
		n += 2 + sovApi(uint64(m.PopularityCount))
	}
	if len(m.RoomTagList) > 0 {
		for _, e := range m.RoomTagList {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if len(m.AnchorTagList) > 0 {
		for _, e := range m.AnchorTagList {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.AnchorProfileType != 0 {
		n += 2 + sovApi(uint64(m.AnchorProfileType))
	}
	if len(m.AnchorExp) > 0 {
		for _, e := range m.AnchorExp {
			l = e.Size()
			n += 2 + l + sovApi(uint64(l))
		}
	}
	if m.AnchorRoundSwitch != 0 {
		n += 2 + sovApi(uint64(m.AnchorRoundSwitch))
	}
	if m.AnchorRoundStatus != 0 {
		n += 2 + sovApi(uint64(m.AnchorRoundStatus))
	}
	if m.AnchorRecordSwitch != 0 {
		n += 2 + sovApi(uint64(m.AnchorRecordSwitch))
	}
	if m.AnchorRecordStatus != 0 {
		n += 2 + sovApi(uint64(m.AnchorRecordStatus))
	}
	if m.AnchorSan != 0 {
		n += 2 + sovApi(uint64(m.AnchorSan))
	}
	if m.LiveType != 0 {
		n += 2 + sovApi(uint64(m.LiveType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomByIDsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		l = 0
		for _, e := range m.RoomIds {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.DefaultFields != 0 {
		n += 1 + sovApi(uint64(m.DefaultFields))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomByIDsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomDataSet) > 0 {
		for k, v := range m.RoomDataSet {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomOnlineListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovApi(uint64(m.Page))
	}
	if m.PageSize != 0 {
		n += 1 + sovApi(uint64(m.PageSize))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomOnlineListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomDataList) > 0 {
		for k, v := range m.RoomDataList {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomCreateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomCreateResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AffectedRows != 0 {
		n += 1 + sovApi(uint64(m.AffectedRows))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Background)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.LiveStartTime != 0 {
		n += 1 + sovApi(uint64(m.LiveStartTime))
	}
	if m.LiveScreenType != 0 {
		n += 1 + sovApi(uint64(m.LiveScreenType))
	}
	if m.LockStatus != 0 {
		n += 1 + sovApi(uint64(m.LockStatus))
	}
	if m.LockTime != 0 {
		n += 1 + sovApi(uint64(m.LockTime))
	}
	if m.HiddenTime != 0 {
		n += 1 + sovApi(uint64(m.HiddenTime))
	}
	if m.AreaId != 0 {
		n += 1 + sovApi(uint64(m.AreaId))
	}
	if m.AnchorRoundSwitch != 0 {
		n += 1 + sovApi(uint64(m.AnchorRoundSwitch))
	}
	if m.AnchorRecordSwitch != 0 {
		n += 1 + sovApi(uint64(m.AnchorRecordSwitch))
	}
	if m.LiveType != 0 {
		n += 2 + sovApi(uint64(m.LiveType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomBatchUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.ProfileType != 0 {
		n += 1 + sovApi(uint64(m.ProfileType))
	}
	if len(m.Exp) > 0 {
		for _, e := range m.Exp {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.ProfileType != 0 {
		n += 1 + sovApi(uint64(m.ProfileType))
	}
	if m.SanScore != 0 {
		n += 1 + sovApi(uint64(m.SanScore))
	}
	if m.RoundStatus != 0 {
		n += 1 + sovApi(uint64(m.RoundStatus))
	}
	if m.RecordStatus != 0 {
		n += 1 + sovApi(uint64(m.RecordStatus))
	}
	if m.Exp != 0 {
		n += 1 + sovApi(uint64(m.Exp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorBatchUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorIncreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Uid != 0 {
		n += 1 + sovApi(uint64(m.Uid))
	}
	if m.SanScore != 0 {
		n += 1 + sovApi(uint64(m.SanScore))
	}
	if m.Exp != 0 {
		n += 1 + sovApi(uint64(m.Exp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorBatchIncreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomExtendUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	l = len(m.KeyFrame)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DanmuCount != 0 {
		n += 1 + sovApi(uint64(m.DanmuCount))
	}
	if m.PopularityCount != 0 {
		n += 1 + sovApi(uint64(m.PopularityCount))
	}
	if m.AudienceCount != 0 {
		n += 1 + sovApi(uint64(m.AudienceCount))
	}
	if m.GiftCount != 0 {
		n += 1 + sovApi(uint64(m.GiftCount))
	}
	if m.GiftGoldAmount != 0 {
		n += 1 + sovApi(uint64(m.GiftGoldAmount))
	}
	if m.GiftGoldCount != 0 {
		n += 1 + sovApi(uint64(m.GiftGoldCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomExtendBatchUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomExtendIncreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.DanmuCount != 0 {
		n += 1 + sovApi(uint64(m.DanmuCount))
	}
	if m.PopularityCount != 0 {
		n += 1 + sovApi(uint64(m.PopularityCount))
	}
	if m.AudienceCount != 0 {
		n += 1 + sovApi(uint64(m.AudienceCount))
	}
	if m.GiftCount != 0 {
		n += 1 + sovApi(uint64(m.GiftCount))
	}
	if m.GiftGoldAmount != 0 {
		n += 1 + sovApi(uint64(m.GiftGoldAmount))
	}
	if m.GiftGoldCount != 0 {
		n += 1 + sovApi(uint64(m.GiftGoldCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomExtendBatchIncreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for _, e := range m.Reqs {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomTagSetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.RoomId != 0 {
		n += 1 + sovApi(uint64(m.RoomId))
	}
	if m.TagType != 0 {
		n += 1 + sovApi(uint64(m.TagType))
	}
	if m.TagValue != 0 {
		n += 1 + sovApi(uint64(m.TagValue))
	}
	l = len(m.TagAttribute)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TagExpireAt != 0 {
		n += 1 + sovApi(uint64(m.TagExpireAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnchorTagSetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.AnchorId != 0 {
		n += 1 + sovApi(uint64(m.AnchorId))
	}
	if m.TagType != 0 {
		n += 1 + sovApi(uint64(m.TagType))
	}
	if m.TagValue != 0 {
		n += 1 + sovApi(uint64(m.TagValue))
	}
	l = len(m.TagAttribute)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TagExpireAt != 0 {
		n += 1 + sovApi(uint64(m.TagExpireAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ExpData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLevel", wireType)
			}
			m.NextLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextLevel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelColor", wireType)
			}
			m.LevelColor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelColor |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentLevelExp", wireType)
			}
			m.CurrentLevelExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentLevelExp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextLevelExp", wireType)
			}
			m.NextLevelExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextLevelExp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagId", wireType)
			}
			m.TagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagType", wireType)
			}
			m.TagType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			m.TagValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagAttribute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagAttribute = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortId", wireType)
			}
			m.ShortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShortId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Background = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStatus", wireType)
			}
			m.LiveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStartTime", wireType)
			}
			m.LiveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveScreenType", wireType)
			}
			m.LiveScreenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveScreenType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveMark", wireType)
			}
			m.LiveMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveMark |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockStatus", wireType)
			}
			m.LockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTime", wireType)
			}
			m.LockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenStatus", wireType)
			}
			m.HiddenStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HiddenStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenTime", wireType)
			}
			m.HiddenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HiddenTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AreaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAreaId", wireType)
			}
			m.ParentAreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentAreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAreaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentAreaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyframe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyframe = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PopularityCount", wireType)
			}
			m.PopularityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PopularityCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomTagList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomTagList = append(m.RoomTagList, &TagData{})
			if err := m.RoomTagList[len(m.RoomTagList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorTagList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnchorTagList = append(m.AnchorTagList, &TagData{})
			if err := m.AnchorTagList[len(m.AnchorTagList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorProfileType", wireType)
			}
			m.AnchorProfileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorProfileType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorExp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnchorExp = append(m.AnchorExp, &ExpData{})
			if err := m.AnchorExp[len(m.AnchorExp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRoundSwitch", wireType)
			}
			m.AnchorRoundSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRoundSwitch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRoundStatus", wireType)
			}
			m.AnchorRoundStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRoundStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRecordSwitch", wireType)
			}
			m.AnchorRecordSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRecordSwitch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRecordStatus", wireType)
			}
			m.AnchorRecordStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRecordStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorSan", wireType)
			}
			m.AnchorSan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorSan |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveType", wireType)
			}
			m.LiveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomByIDsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomByIDsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomByIDsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoomIds = append(m.RoomIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoomIds) == 0 {
					m.RoomIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoomIds = append(m.RoomIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomIds", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFields", wireType)
			}
			m.DefaultFields = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultFields |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomByIDsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomByIDsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomByIDsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomDataSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoomDataSet == nil {
				m.RoomDataSet = make(map[int64]*RoomData)
			}
			var mapkey int64
			var mapvalue *RoomData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoomData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoomDataSet[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOnlineListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOnlineListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOnlineListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOnlineListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOnlineListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOnlineListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomDataList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoomDataList == nil {
				m.RoomDataList = make(map[int64]*RoomData)
			}
			var mapkey int64
			var mapvalue *RoomData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoomData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoomDataList[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomCreateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomCreateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomCreateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomCreateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomCreateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomCreateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedRows", wireType)
			}
			m.AffectedRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedRows |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Background = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStartTime", wireType)
			}
			m.LiveStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveScreenType", wireType)
			}
			m.LiveScreenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveScreenType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockStatus", wireType)
			}
			m.LockStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTime", wireType)
			}
			m.LockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenTime", wireType)
			}
			m.HiddenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HiddenTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRoundSwitch", wireType)
			}
			m.AnchorRoundSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRoundSwitch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorRecordSwitch", wireType)
			}
			m.AnchorRecordSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorRecordSwitch |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveType", wireType)
			}
			m.LiveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomBatchUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomBatchUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomBatchUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &RoomUpdateReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileType", wireType)
			}
			m.ProfileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProfileType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exp = append(m.Exp, &ExpData{})
			if err := m.Exp[len(m.Exp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileType", wireType)
			}
			m.ProfileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProfileType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SanScore", wireType)
			}
			m.SanScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SanScore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundStatus", wireType)
			}
			m.RoundStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordStatus", wireType)
			}
			m.RecordStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorBatchUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorBatchUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorBatchUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &AnchorUpdateReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorIncreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorIncreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorIncreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SanScore", wireType)
			}
			m.SanScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SanScore |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorBatchIncreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorBatchIncreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorBatchIncreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &AnchorIncreReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomExtendUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomExtendUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomExtendUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DanmuCount", wireType)
			}
			m.DanmuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DanmuCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PopularityCount", wireType)
			}
			m.PopularityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PopularityCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudienceCount", wireType)
			}
			m.AudienceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AudienceCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftCount", wireType)
			}
			m.GiftCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGoldAmount", wireType)
			}
			m.GiftGoldAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGoldAmount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGoldCount", wireType)
			}
			m.GiftGoldCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGoldCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomExtendBatchUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomExtendBatchUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomExtendBatchUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &RoomExtendUpdateReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomExtendIncreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomExtendIncreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomExtendIncreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DanmuCount", wireType)
			}
			m.DanmuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DanmuCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PopularityCount", wireType)
			}
			m.PopularityCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PopularityCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudienceCount", wireType)
			}
			m.AudienceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AudienceCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftCount", wireType)
			}
			m.GiftCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGoldAmount", wireType)
			}
			m.GiftGoldAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGoldAmount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGoldCount", wireType)
			}
			m.GiftGoldCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGoldCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomExtendBatchIncreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomExtendBatchIncreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomExtendBatchIncreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqs = append(m.Reqs, &RoomExtendIncreReq{})
			if err := m.Reqs[len(m.Reqs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomTagSetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomTagSetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomTagSetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagType", wireType)
			}
			m.TagType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			m.TagValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagAttribute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagAttribute = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpireAt", wireType)
			}
			m.TagExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagExpireAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnchorTagSetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnchorTagSetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnchorTagSetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorId", wireType)
			}
			m.AnchorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnchorId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagType", wireType)
			}
			m.TagType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			m.TagValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagAttribute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagAttribute = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpireAt", wireType)
			}
			m.TagExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagExpireAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("app/service/live/xanchor/api/grpc/v1/api.proto", fileDescriptor_api_5e82c9cace3801b5)
}

var fileDescriptor_api_5e82c9cace3801b5 = []byte{
	// 2005 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x59, 0x5f, 0x6f, 0x23, 0x57,
	0x15, 0x97, 0xed, 0x38, 0xb6, 0x8f, 0xe3, 0x3f, 0xb9, 0x49, 0x9b, 0x59, 0xa7, 0x9b, 0x04, 0x87,
	0x45, 0x59, 0x89, 0xda, 0xdd, 0x94, 0x55, 0x69, 0xa1, 0x82, 0x64, 0x37, 0x4b, 0xa3, 0xee, 0xd2,
	0x62, 0xa7, 0xd0, 0x16, 0x21, 0xeb, 0x66, 0xe6, 0x66, 0x32, 0xb2, 0x3d, 0x33, 0xb9, 0x73, 0xed,
	0x4d, 0x2a, 0x3e, 0x00, 0x0f, 0x3c, 0xf0, 0xc4, 0x13, 0xdf, 0x05, 0x89, 0x17, 0x78, 0x41, 0xea,
	0x27, 0xa8, 0xd0, 0x7e, 0x02, 0x54, 0x09, 0x78, 0x43, 0xe8, 0xde, 0x73, 0xc7, 0x1e, 0x8f, 0xff,
	0x4d, 0xba, 0x68, 0x85, 0xc4, 0x53, 0x3c, 0x67, 0x7e, 0xe7, 0xdc, 0x7b, 0x7e, 0xf7, 0xdc, 0xf3,
	0x67, 0x02, 0x0d, 0xea, 0xfb, 0xcd, 0x80, 0xf1, 0xa1, 0x63, 0xb2, 0x66, 0xcf, 0x19, 0xb2, 0xe6,
	0x35, 0x75, 0xcd, 0x4b, 0x8f, 0x37, 0xa9, 0xef, 0x34, 0x6d, 0xee, 0x9b, 0xcd, 0xe1, 0x03, 0xf9,
	0xbb, 0xe1, 0x73, 0x4f, 0x78, 0xa4, 0x22, 0x31, 0x0d, 0x8d, 0x69, 0x0c, 0x1f, 0xd4, 0xde, 0xb4,
	0x1d, 0x71, 0x39, 0x38, 0x6f, 0x98, 0x5e, 0xbf, 0x69, 0x7b, 0xb6, 0xd7, 0x54, 0xb8, 0xf3, 0xc1,
	0x85, 0x7a, 0x52, 0x0f, 0xea, 0x17, 0xea, 0xd7, 0xff, 0x95, 0x86, 0xdc, 0xc9, 0xb5, 0xff, 0x98,
	0x0a, 0x4a, 0x0e, 0x21, 0xdb, 0x63, 0x43, 0xd6, 0x33, 0x52, 0x7b, 0xa9, 0x83, 0xcc, 0xf1, 0x1b,
	0x5f, 0x7f, 0xb5, 0x6b, 0x0c, 0x69, 0xcf, 0xb1, 0xa8, 0x60, 0xef, 0xd5, 0x6d, 0xf1, 0xfe, 0x5b,
	0xdf, 0xe5, 0xec, 0x6a, 0xe0, 0x70, 0x66, 0xd5, 0x5b, 0x08, 0x25, 0x3f, 0x00, 0x70, 0xd9, 0xb5,
	0xe8, 0xa0, 0x62, 0x3a, 0x81, 0x62, 0x41, 0xe2, 0x9f, 0x2a, 0xe5, 0xf7, 0xa1, 0xa8, 0xf4, 0x3a,
	0xa6, 0xd7, 0xf3, 0xb8, 0x91, 0x49, 0xa0, 0x0d, 0x4a, 0xe1, 0x91, 0xc4, 0x93, 0x06, 0x64, 0xd8,
	0xb5, 0x6f, 0xac, 0x24, 0x50, 0x93, 0x40, 0xf2, 0x01, 0xac, 0x9b, 0x03, 0xce, 0x99, 0xab, 0xb7,
	0xdb, 0x91, 0xda, 0xd9, 0x04, 0xda, 0x15, 0xad, 0xa6, 0x76, 0x7d, 0x72, 0xed, 0x93, 0x63, 0x28,
	0x8f, 0xbd, 0x56, 0x66, 0x56, 0x13, 0x98, 0x59, 0x1b, 0x79, 0x7e, 0x72, 0xed, 0xd7, 0xff, 0x9e,
	0x82, 0xdc, 0x19, 0xb5, 0x15, 0xf3, 0x6f, 0xc3, 0xaa, 0xa0, 0x76, 0xc7, 0xb1, 0x92, 0x51, 0x2f,
	0xa8, 0x7d, 0x6a, 0x91, 0x77, 0x20, 0x2f, 0x95, 0xc4, 0x8d, 0xcf, 0x12, 0x11, 0x9f, 0x13, 0xd4,
	0x3e, 0xbb, 0xf1, 0x19, 0x79, 0x17, 0x0a, 0x52, 0x71, 0x48, 0x7b, 0x03, 0x96, 0x88, 0x74, 0xb9,
	0xce, 0xcf, 0x25, 0x9a, 0xfc, 0x10, 0x4a, 0x52, 0x95, 0x0a, 0xc1, 0x9d, 0xf3, 0x81, 0x60, 0x8a,
	0xfc, 0xc2, 0xf1, 0xd6, 0xd7, 0x5f, 0xed, 0x6e, 0x8c, 0xd5, 0x23, 0x2e, 0x0b, 0x6a, 0x1f, 0x85,
	0xe0, 0xfa, 0x3f, 0x8a, 0x90, 0x6f, 0x79, 0x5e, 0x5f, 0xf9, 0xdc, 0x80, 0xcc, 0x20, 0xa1, 0xc3,
	0x12, 0x48, 0x1e, 0x42, 0x8e, 0x7b, 0x5e, 0x5f, 0x92, 0x94, 0xc4, 0xdb, 0x55, 0x09, 0x46, 0x96,
	0x82, 0x4b, 0x8f, 0x0b, 0xa9, 0x97, 0xc4, 0xd7, 0x9c, 0x42, 0x9f, 0x5a, 0xe4, 0x4d, 0xc8, 0x0a,
	0x47, 0xf4, 0x96, 0xba, 0x88, 0x28, 0xb2, 0x09, 0x59, 0xd3, 0x1b, 0x32, 0xae, 0x02, 0xaa, 0xd0,
	0xc2, 0x07, 0x42, 0x60, 0x45, 0x50, 0x3b, 0x50, 0xe1, 0x51, 0x68, 0xa9, 0xdf, 0x64, 0x07, 0xe0,
	0x9c, 0x9a, 0x5d, 0x9b, 0x7b, 0x03, 0xd7, 0x32, 0x72, 0xea, 0x4d, 0x44, 0x42, 0xf6, 0xa0, 0x68,
	0xb1, 0xc0, 0xe4, 0x8e, 0x2f, 0x1c, 0xcf, 0x35, 0xf2, 0x0a, 0x10, 0x15, 0xa9, 0x7b, 0xe3, 0x0c,
	0x59, 0x27, 0x10, 0x54, 0x0c, 0x02, 0xa3, 0x90, 0xe8, 0xde, 0x38, 0x43, 0xd6, 0x56, 0x78, 0xf2,
	0x18, 0x2a, 0xa1, 0x3a, 0x17, 0x1d, 0xe1, 0xf4, 0x99, 0x01, 0x09, 0x4c, 0x94, 0xb4, 0x09, 0x2e,
	0xce, 0x9c, 0x3e, 0x23, 0x4f, 0xa0, 0x8a, 0x56, 0x4c, 0xce, 0x98, 0x8b, 0x61, 0x58, 0x4c, 0x60,
	0xa6, 0xac, 0xcc, 0x28, 0x25, 0x15, 0x8d, 0xdb, 0x50, 0x50, 0x76, 0xfa, 0x94, 0x77, 0x8d, 0x35,
	0x69, 0xa0, 0x95, 0x97, 0x82, 0x67, 0x94, 0x77, 0xc9, 0x2e, 0x14, 0x7b, 0x9e, 0xd9, 0x0d, 0x3d,
	0x2d, 0xa9, 0xd7, 0x20, 0x45, 0xda, 0x17, 0xa9, 0x2d, 0x01, 0xca, 0x8b, 0xb2, 0xd6, 0xf6, 0xcc,
	0xae, 0xda, 0xe2, 0x11, 0x94, 0x2e, 0x1d, 0xcb, 0x62, 0x6e, 0xa8, 0x5f, 0x49, 0x72, 0x4b, 0x51,
	0x45, 0xdb, 0xdf, 0x85, 0xa2, 0x36, 0xa1, 0x56, 0xa8, 0xe2, 0x06, 0x50, 0xa4, 0xd6, 0x78, 0x08,
	0x39, 0xca, 0x19, 0x95, 0xe1, 0xb5, 0x9e, 0x24, 0x2c, 0x25, 0xf8, 0xd4, 0x22, 0xdf, 0x83, 0x82,
	0x52, 0x73, 0x69, 0x9f, 0x19, 0x64, 0x71, 0x84, 0xe5, 0x25, 0xf2, 0xa7, 0xb4, 0xcf, 0x64, 0xde,
	0xf1, 0xa9, 0x4a, 0x60, 0xe1, 0x9a, 0x1b, 0x49, 0x3c, 0x42, 0x9d, 0x23, 0x5c, 0xf9, 0x08, 0xaa,
	0x51, 0x1b, 0x6a, 0x03, 0x9b, 0x8b, 0x37, 0x50, 0x1e, 0x1b, 0x50, 0xdb, 0xa8, 0x41, 0xbe, 0xcb,
	0x6e, 0x2e, 0xb8, 0x54, 0x7d, 0x4d, 0x85, 0xe7, 0xe8, 0x99, 0xdc, 0x87, 0xaa, 0xef, 0xf9, 0x83,
	0x1e, 0xe5, 0x8e, 0xb8, 0xe9, 0x98, 0xde, 0xc0, 0x15, 0xc6, 0xeb, 0x8a, 0xb5, 0xca, 0x58, 0xfe,
	0x48, 0x8a, 0x65, 0x32, 0x51, 0x37, 0x5a, 0x66, 0x94, 0x9e, 0x13, 0x08, 0x63, 0x6b, 0x2f, 0x73,
	0x50, 0x3c, 0x34, 0x1a, 0xb1, 0x9a, 0xd6, 0xd0, 0x69, 0xb2, 0x55, 0x94, 0xf0, 0x33, 0x6a, 0x3f,
	0x75, 0x02, 0x41, 0x7e, 0x0c, 0x15, 0x44, 0x8c, 0xf5, 0x8d, 0x25, 0xfa, 0x25, 0x14, 0x85, 0x16,
	0x1a, 0xb0, 0xa1, 0x2d, 0xf8, 0xdc, 0xbb, 0x70, 0x7a, 0x0c, 0x83, 0xf8, 0x8e, 0xda, 0xed, 0x3a,
	0xbe, 0xfa, 0x18, 0xdf, 0xa8, 0x48, 0x7d, 0x07, 0x40, 0xe3, 0x65, 0xc6, 0xaf, 0xcd, 0x59, 0x4c,
	0x57, 0xd3, 0x56, 0x01, 0x45, 0xb2, 0x5c, 0x8c, 0x17, 0x52, 0x37, 0xbc, 0x13, 0x3c, 0x77, 0x84,
	0x79, 0x69, 0x6c, 0x47, 0x17, 0x6a, 0xc9, 0x37, 0x6d, 0xf5, 0x62, 0x1a, 0x8f, 0xd1, 0xfb, 0xc6,
	0x34, 0x1e, 0x83, 0xf4, 0x2d, 0xd8, 0x0c, 0xf1, 0xcc, 0xf4, 0xf8, 0x68, 0x81, 0xbb, 0x4a, 0x81,
	0x68, 0x05, 0xf5, 0x4a, 0xaf, 0x30, 0xad, 0x81, 0x4b, 0xec, 0xcc, 0xd0, 0xc0, 0x35, 0xee, 0x8e,
	0x9c, 0x0f, 0xa8, 0x6b, 0xec, 0x2a, 0x9c, 0x76, 0xb1, 0x4d, 0xdd, 0xd1, 0x2d, 0x56, 0x0c, 0xee,
	0x8d, 0x6f, 0xb1, 0x24, 0xae, 0xfe, 0x6b, 0x58, 0x93, 0x69, 0xff, 0xf8, 0xe6, 0xf4, 0x71, 0xd0,
	0x62, 0x57, 0xe4, 0x0e, 0xe4, 0x75, 0x2a, 0x0f, 0x8c, 0xd4, 0x5e, 0xe6, 0x20, 0xd3, 0xca, 0x61,
	0xb6, 0x0e, 0x64, 0xc2, 0x1c, 0x48, 0x71, 0x5a, 0x89, 0xd5, 0x6f, 0xf2, 0x3a, 0xac, 0x5e, 0x38,
	0xac, 0x67, 0x05, 0x46, 0x66, 0x2f, 0x73, 0x50, 0x68, 0xe9, 0x27, 0x72, 0x0f, 0xca, 0x16, 0xbb,
	0xa0, 0x83, 0x9e, 0xe8, 0xe8, 0xf7, 0xaa, 0x15, 0x68, 0x95, 0xb4, 0xf4, 0x89, 0x12, 0xd6, 0xff,
	0x98, 0x82, 0x52, 0x64, 0xf9, 0xc0, 0x27, 0x6d, 0x1d, 0x78, 0x16, 0x15, 0xb4, 0x13, 0x30, 0xa1,
	0x36, 0x51, 0x3c, 0x6c, 0x4e, 0x9d, 0xe5, 0x84, 0x5a, 0x23, 0x2c, 0x5d, 0x6d, 0x26, 0x4e, 0x5c,
	0xc1, 0x6f, 0x30, 0x1e, 0xb5, 0xa4, 0xf6, 0x19, 0x54, 0xe3, 0x00, 0x52, 0x85, 0x4c, 0x97, 0xdd,
	0x60, 0x8d, 0x6b, 0xc9, 0x9f, 0xa4, 0x09, 0x59, 0xac, 0xbb, 0xb2, 0x86, 0x15, 0x0f, 0xef, 0xcc,
	0x5c, 0x52, 0xc5, 0x0f, 0xe2, 0xde, 0x4b, 0x7f, 0x3f, 0x55, 0xff, 0x4d, 0x0a, 0xd6, 0xa5, 0xfc,
	0x23, 0xb7, 0xe7, 0xb8, 0x4c, 0xc6, 0xae, 0x64, 0x51, 0xd1, 0xd2, 0x13, 0x8c, 0x2b, 0xfb, 0x8a,
	0x16, 0xf9, 0x24, 0x29, 0x0c, 0x3c, 0x2e, 0xd4, 0x0a, 0x85, 0x96, 0xfa, 0x2d, 0x65, 0x3e, 0xb5,
	0x75, 0xb5, 0x6f, 0xa9, 0xdf, 0xf2, 0xc8, 0xe4, 0xdf, 0x4e, 0xe0, 0x7c, 0xc1, 0x34, 0x73, 0x79,
	0x29, 0x68, 0x3b, 0x5f, 0xb0, 0x08, 0xe7, 0xd9, 0x28, 0xe7, 0xf5, 0xbf, 0xa6, 0x80, 0xc4, 0xb7,
	0x12, 0xf8, 0xe4, 0x97, 0x50, 0x1e, 0x33, 0xaa, 0xee, 0x22, 0x52, 0xfa, 0x70, 0xa6, 0x7f, 0x93,
	0xca, 0x23, 0x97, 0xa5, 0x00, 0x89, 0x5d, 0xe3, 0x11, 0x51, 0xed, 0x73, 0xf4, 0x7e, 0x02, 0xf2,
	0xdf, 0xa2, 0xf6, 0x53, 0x8c, 0x8d, 0x47, 0x9c, 0x51, 0xc1, 0x24, 0xab, 0xb7, 0x6d, 0x4b, 0xb6,
	0x62, 0x6d, 0x49, 0xd8, 0x78, 0xd4, 0xef, 0x43, 0x39, 0x6a, 0x39, 0xf0, 0xa3, 0xd0, 0xd4, 0x04,
	0xf4, 0x01, 0xc0, 0x27, 0xbe, 0x15, 0xc2, 0xf6, 0xa1, 0x44, 0x2f, 0x2e, 0x98, 0x29, 0x98, 0xd5,
	0xe1, 0xde, 0xf3, 0x40, 0x83, 0xd7, 0x42, 0x61, 0xcb, 0x7b, 0x1e, 0xd4, 0xff, 0xb4, 0x82, 0x1b,
	0x0f, 0xf5, 0xae, 0x48, 0x73, 0x74, 0x62, 0x92, 0xfa, 0x05, 0xd9, 0x3c, 0xbc, 0x3e, 0xdf, 0xb0,
	0xa1, 0xda, 0x0c, 0xfb, 0xa2, 0x0c, 0x36, 0x3a, 0xb1, 0xf6, 0x67, 0x65, 0x56, 0xfb, 0x93, 0x9d,
	0xdb, 0xfe, 0xac, 0x2e, 0x6b, 0x7f, 0x72, 0xd3, 0xed, 0xcf, 0x77, 0xa6, 0xfb, 0x97, 0x3c, 0x5e,
	0xfc, 0xc9, 0x0e, 0xe5, 0x60, 0x46, 0x87, 0xa2, 0x7a, 0xa5, 0xa9, 0x1e, 0x24, 0xd6, 0x66, 0xc0,
	0xe2, 0x36, 0xa3, 0x18, 0x6b, 0x33, 0x62, 0x3d, 0xc2, 0xda, 0x54, 0x8f, 0xb0, 0x35, 0xee, 0x11,
	0xb0, 0x83, 0x09, 0xbb, 0x80, 0x39, 0x85, 0xa1, 0x3c, 0xaf, 0x30, 0xcc, 0x4b, 0xf4, 0x95, 0xb9,
	0x89, 0x7e, 0x22, 0x2f, 0x57, 0x63, 0x79, 0x99, 0xe2, 0x5d, 0x3e, 0xa6, 0xc2, 0xbc, 0x1c, 0x07,
	0xd2, 0x87, 0xb0, 0xc2, 0xd9, 0x55, 0xa0, 0x6f, 0xf0, 0xce, 0xcc, 0x6b, 0x34, 0x42, 0xcf, 0x0f,
	0x33, 0x65, 0xa4, 0xfe, 0xe7, 0x14, 0xc0, 0x91, 0x52, 0xfd, 0x46, 0x4d, 0xff, 0x8f, 0x60, 0x6d,
	0xa2, 0x36, 0x27, 0x09, 0xd4, 0xa2, 0x1f, 0xa9, 0xd9, 0x1f, 0xe0, 0x8c, 0x98, 0x59, 0x5c, 0xac,
	0x13, 0x4c, 0x8f, 0xf5, 0xdf, 0xa6, 0xa1, 0x82, 0x9e, 0xbc, 0xc4, 0x9d, 0xd3, 0xfe, 0xa7, 0x93,
	0xfa, 0xff, 0xad, 0x98, 0xff, 0x98, 0xbf, 0x27, 0x3c, 0xdc, 0x86, 0x42, 0x40, 0xdd, 0x4e, 0x60,
	0x7a, 0x7c, 0x94, 0xc6, 0x03, 0xea, 0xb6, 0xe5, 0xb3, 0xd4, 0x9f, 0x68, 0x21, 0xb2, 0xa8, 0xcf,
	0x23, 0xcd, 0xc3, 0x3e, 0x94, 0x26, 0x7b, 0x80, 0x55, 0x4c, 0x37, 0x3c, 0x5a, 0xfd, 0xab, 0x48,
	0x63, 0x0e, 0xb3, 0xad, 0xa4, 0x83, 0xc1, 0x26, 0xb2, 0x11, 0x8b, 0x9e, 0x67, 0x13, 0xd1, 0xb3,
	0x37, 0xc5, 0x78, 0x8c, 0xc2, 0x65, 0xf1, 0xf3, 0x65, 0x0a, 0xca, 0xa8, 0x72, 0xea, 0x9a, 0x5c,
	0x67, 0xe8, 0x55, 0xce, 0xae, 0xc2, 0x2c, 0xba, 0x68, 0x32, 0xe3, 0xec, 0xea, 0xd4, 0x8a, 0x1c,
	0x52, 0xfa, 0x56, 0x87, 0x94, 0x49, 0x7a, 0x48, 0x0b, 0x4f, 0x40, 0x33, 0x97, 0x1d, 0x33, 0x67,
	0xc2, 0x46, 0x84, 0xb9, 0x91, 0x5b, 0x4f, 0x27, 0x88, 0xdb, 0x9d, 0x43, 0x5c, 0x08, 0x5f, 0xc6,
	0xdb, 0xbf, 0xd3, 0xb0, 0x21, 0x2f, 0xea, 0xc9, 0xb5, 0x60, 0xae, 0xf5, 0xea, 0xab, 0xc4, 0x36,
	0x14, 0xba, 0xec, 0xa6, 0x83, 0x33, 0x42, 0x66, 0x34, 0x23, 0x3c, 0x51, 0x33, 0xc2, 0x2e, 0x14,
	0x2d, 0xea, 0xf6, 0x07, 0x7a, 0x3c, 0x40, 0xca, 0x40, 0x89, 0x70, 0x32, 0x98, 0x35, 0x44, 0x64,
	0x67, 0x0f, 0x11, 0xf7, 0xa0, 0x4c, 0x07, 0x96, 0xc3, 0x5c, 0x93, 0x69, 0x20, 0xc6, 0x6f, 0x29,
	0x94, 0x22, 0xec, 0x2e, 0x80, 0xed, 0x5c, 0x08, 0x0d, 0xc1, 0x38, 0x2e, 0x48, 0x09, 0xbe, 0x3e,
	0x80, 0xaa, 0x7a, 0x6d, 0x7b, 0x3d, 0xab, 0x43, 0xfb, 0x0a, 0x84, 0x35, 0xa5, 0x2c, 0xe5, 0x3f,
	0xf1, 0x7a, 0xd6, 0x91, 0x92, 0xca, 0xe2, 0x33, 0x46, 0xa2, 0x35, 0xac, 0x29, 0xa5, 0x10, 0xa8,
	0x2c, 0xd6, 0xfb, 0x60, 0x8c, 0xf9, 0x8f, 0xdd, 0x91, 0x9f, 0x4d, 0x1c, 0xf5, 0xb7, 0x67, 0x66,
	0xd8, 0xd8, 0xc1, 0x2d, 0x3b, 0xef, 0xdf, 0x65, 0x30, 0x97, 0xa3, 0xda, 0xab, 0xbb, 0x2b, 0x91,
	0xf0, 0xc8, 0xdc, 0x22, 0x3c, 0xfe, 0x1f, 0x22, 0xa0, 0x0b, 0x5b, 0xb1, 0x08, 0x18, 0x1d, 0xcb,
	0xc7, 0x13, 0x01, 0xb0, 0xbf, 0x20, 0x00, 0x92, 0xde, 0xf7, 0xdf, 0xa7, 0xb1, 0x1f, 0x3c, 0xa3,
	0x76, 0x9b, 0x89, 0x57, 0x79, 0xd3, 0xa3, 0x9f, 0x21, 0x33, 0xb7, 0xf9, 0x0c, 0xb9, 0x1d, 0xfd,
	0x0c, 0xa9, 0xd3, 0xe6, 0xe8, 0x43, 0xe3, 0x7e, 0xfc, 0x43, 0x23, 0xb6, 0x90, 0x13, 0xdf, 0x13,
	0x49, 0x1d, 0x41, 0xec, 0xda, 0x77, 0x38, 0xeb, 0xd0, 0xf0, 0xe0, 0x8b, 0x82, 0xda, 0x27, 0x4a,
	0x76, 0x24, 0xea, 0x7f, 0x18, 0x95, 0xed, 0x97, 0xa0, 0xe6, 0x5d, 0xd0, 0xa3, 0x6e, 0x52, 0x72,
	0xf2, 0x08, 0xff, 0x9f, 0xa7, 0xe7, 0xf0, 0x9f, 0x05, 0xc8, 0x7d, 0x8a, 0xfc, 0x90, 0x8f, 0xa0,
	0xfc, 0x84, 0x09, 0xf3, 0x72, 0x34, 0xf5, 0x92, 0xbb, 0x8b, 0x26, 0xe2, 0xab, 0xda, 0xce, 0xe2,
	0x81, 0x99, 0x7c, 0x86, 0x23, 0xd0, 0x78, 0xdc, 0x23, 0xf5, 0xa5, 0xf3, 0xe0, 0x55, 0x6d, 0x3f,
	0xc1, 0xcc, 0x48, 0x9e, 0x01, 0x8c, 0xa7, 0x2b, 0x32, 0x7b, 0x23, 0xa3, 0xa1, 0xae, 0xb6, 0xbb,
	0xf0, 0x7d, 0xe0, 0x93, 0x53, 0x34, 0x87, 0xe9, 0x96, 0x2c, 0xe9, 0x79, 0x6b, 0xdb, 0x53, 0xef,
	0x23, 0xe3, 0x5b, 0x1b, 0x2a, 0xb1, 0xa6, 0x9a, 0xcc, 0xf6, 0x68, 0xb2, 0x28, 0x2c, 0x36, 0xfa,
	0x09, 0x7e, 0x5c, 0x88, 0x16, 0x05, 0x92, 0xa8, 0x6e, 0x2c, 0x36, 0xdb, 0x81, 0xd7, 0x66, 0x16,
	0x29, 0x72, 0x7f, 0x81, 0xed, 0xdb, 0xec, 0x5b, 0x93, 0x11, 0xc9, 0x65, 0x24, 0x49, 0xb6, 0x5b,
	0x6c, 0xf4, 0x57, 0xb0, 0x39, 0x2b, 0xb1, 0x92, 0x83, 0x65, 0x9b, 0x4e, 0x66, 0x5e, 0xc7, 0x02,
	0xa6, 0x8b, 0x39, 0xb1, 0x30, 0xca, 0x25, 0x8b, 0x4d, 0x3d, 0x83, 0xb5, 0x68, 0xbf, 0x4b, 0x96,
	0xb6, 0xc3, 0x8b, 0xcd, 0xfd, 0x02, 0xd6, 0xa7, 0x7a, 0x6e, 0x72, 0x6f, 0x8e, 0xcd, 0xdb, 0x1c,
	0xd3, 0x87, 0x50, 0x8c, 0xb4, 0x97, 0x64, 0x59, 0xf3, 0xb9, 0x34, 0x56, 0xe3, 0xfd, 0xed, 0x8c,
	0x58, 0x9d, 0xd1, 0x02, 0x27, 0xe4, 0x52, 0x1f, 0xcc, 0x3c, 0x2e, 0x93, 0x1d, 0xcd, 0x71, 0xf5,
	0x2f, 0x2f, 0x76, 0x52, 0x5f, 0xbe, 0xd8, 0x49, 0xfd, 0xed, 0xc5, 0x4e, 0xea, 0xf3, 0xf4, 0xf0,
	0xc1, 0xf9, 0xaa, 0xfa, 0x8f, 0xe8, 0xdb, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x32, 0xbb, 0x1f,
	0x03, 0x83, 0x1d, 0x00, 0x00,
}
