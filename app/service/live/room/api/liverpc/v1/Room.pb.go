// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/Room.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type RoomAllLiveForBigdataReq struct {
}

func (m *RoomAllLiveForBigdataReq) Reset()         { *m = RoomAllLiveForBigdataReq{} }
func (m *RoomAllLiveForBigdataReq) String() string { return proto.CompactTextString(m) }
func (*RoomAllLiveForBigdataReq) ProtoMessage()    {}
func (*RoomAllLiveForBigdataReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{0}
}
func (m *RoomAllLiveForBigdataReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomAllLiveForBigdataReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomAllLiveForBigdataReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomAllLiveForBigdataReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomAllLiveForBigdataReq.Merge(dst, src)
}
func (m *RoomAllLiveForBigdataReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomAllLiveForBigdataReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomAllLiveForBigdataReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomAllLiveForBigdataReq proto.InternalMessageInfo

type RoomAllLiveForBigdataResp struct {
	// code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	// 房间信息map
	Data []*RoomAllLiveForBigdataResp_RoomInfo `protobuf:"bytes,3,rep,name=data" json:"data"`
}

func (m *RoomAllLiveForBigdataResp) Reset()         { *m = RoomAllLiveForBigdataResp{} }
func (m *RoomAllLiveForBigdataResp) String() string { return proto.CompactTextString(m) }
func (*RoomAllLiveForBigdataResp) ProtoMessage()    {}
func (*RoomAllLiveForBigdataResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{1}
}
func (m *RoomAllLiveForBigdataResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomAllLiveForBigdataResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomAllLiveForBigdataResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomAllLiveForBigdataResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomAllLiveForBigdataResp.Merge(dst, src)
}
func (m *RoomAllLiveForBigdataResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomAllLiveForBigdataResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomAllLiveForBigdataResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomAllLiveForBigdataResp proto.InternalMessageInfo

func (m *RoomAllLiveForBigdataResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RoomAllLiveForBigdataResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RoomAllLiveForBigdataResp) GetData() []*RoomAllLiveForBigdataResp_RoomInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type RoomAllLiveForBigdataResp_RoomInfo struct {
	// 房间id
	Roomid int64 `protobuf:"varint,1,opt,name=roomid,proto3" json:"roomid"`
	// 用户id
	Uid int64 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid"`
	// 创建时间
	CreateTime int64 `protobuf:"varint,3,opt,name=create_time,json=createTime,proto3" json:"create_time"`
	// 短位号
	ShortId int64 `protobuf:"varint,4,opt,name=short_id,json=shortId,proto3" json:"short_id"`
	// 在线人数
	Online int64 `protobuf:"varint,5,opt,name=online,proto3" json:"online"`
	// 分区id
	Area int64 `protobuf:"varint,6,opt,name=area,proto3" json:"area"`
	// 分区v2 id
	AreaV2Id int64 `protobuf:"varint,7,opt,name=area_v2_id,json=areaV2Id,proto3" json:"area_v2_id"`
	// 分区v2 父分区id
	AreaV2ParentId int64 `protobuf:"varint,8,opt,name=area_v2_parent_id,json=areaV2ParentId,proto3" json:"area_v2_parent_id"`
	// 关注人数
	Attentions int64 `protobuf:"varint,9,opt,name=attentions,proto3" json:"attentions"`
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) Reset()         { *m = RoomAllLiveForBigdataResp_RoomInfo{} }
func (m *RoomAllLiveForBigdataResp_RoomInfo) String() string { return proto.CompactTextString(m) }
func (*RoomAllLiveForBigdataResp_RoomInfo) ProtoMessage()    {}
func (*RoomAllLiveForBigdataResp_RoomInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{1, 0}
}
func (m *RoomAllLiveForBigdataResp_RoomInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomAllLiveForBigdataResp_RoomInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomAllLiveForBigdataResp_RoomInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomAllLiveForBigdataResp_RoomInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomAllLiveForBigdataResp_RoomInfo.Merge(dst, src)
}
func (m *RoomAllLiveForBigdataResp_RoomInfo) XXX_Size() int {
	return m.Size()
}
func (m *RoomAllLiveForBigdataResp_RoomInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomAllLiveForBigdataResp_RoomInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoomAllLiveForBigdataResp_RoomInfo proto.InternalMessageInfo

func (m *RoomAllLiveForBigdataResp_RoomInfo) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) GetShortId() int64 {
	if m != nil {
		return m.ShortId
	}
	return 0
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) GetOnline() int64 {
	if m != nil {
		return m.Online
	}
	return 0
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) GetArea() int64 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) GetAreaV2Id() int64 {
	if m != nil {
		return m.AreaV2Id
	}
	return 0
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) GetAreaV2ParentId() int64 {
	if m != nil {
		return m.AreaV2ParentId
	}
	return 0
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) GetAttentions() int64 {
	if m != nil {
		return m.Attentions
	}
	return 0
}

type RoomGetInfoByIdReq struct {
	// 房间id, 可以为短号
	Ids []int64 `protobuf:"varint,1,rep,packed,name=ids" json:"ids"`
	// 需要哪些字段, 不传默认所有
	Fields []string `protobuf:"bytes,2,rep,name=fields" json:"fields"`
}

func (m *RoomGetInfoByIdReq) Reset()         { *m = RoomGetInfoByIdReq{} }
func (m *RoomGetInfoByIdReq) String() string { return proto.CompactTextString(m) }
func (*RoomGetInfoByIdReq) ProtoMessage()    {}
func (*RoomGetInfoByIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{2}
}
func (m *RoomGetInfoByIdReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGetInfoByIdReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGetInfoByIdReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGetInfoByIdReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGetInfoByIdReq.Merge(dst, src)
}
func (m *RoomGetInfoByIdReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomGetInfoByIdReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGetInfoByIdReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGetInfoByIdReq proto.InternalMessageInfo

func (m *RoomGetInfoByIdReq) GetIds() []int64 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *RoomGetInfoByIdReq) GetFields() []string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type RoomGetInfoByIdResp struct {
	// code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	// 房间信息map
	Data map[int64]*RoomGetInfoByIdResp_RoomInfo `protobuf:"bytes,3,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RoomGetInfoByIdResp) Reset()         { *m = RoomGetInfoByIdResp{} }
func (m *RoomGetInfoByIdResp) String() string { return proto.CompactTextString(m) }
func (*RoomGetInfoByIdResp) ProtoMessage()    {}
func (*RoomGetInfoByIdResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{3}
}
func (m *RoomGetInfoByIdResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGetInfoByIdResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGetInfoByIdResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGetInfoByIdResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGetInfoByIdResp.Merge(dst, src)
}
func (m *RoomGetInfoByIdResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomGetInfoByIdResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGetInfoByIdResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGetInfoByIdResp proto.InternalMessageInfo

func (m *RoomGetInfoByIdResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RoomGetInfoByIdResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RoomGetInfoByIdResp) GetData() map[int64]*RoomGetInfoByIdResp_RoomInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type RoomGetInfoByIdResp_RoomInfo struct {
	// 房间id
	Roomid int64 `protobuf:"varint,1,opt,name=roomid,proto3" json:"roomid"`
	// 用户名, 不可靠.
	Uname string `protobuf:"bytes,2,opt,name=uname,proto3" json:"uname"`
	// 封面
	Cover string `protobuf:"bytes,3,opt,name=cover,proto3" json:"cover"`
	// 用户id
	Uid int64 `protobuf:"varint,4,opt,name=uid,proto3" json:"uid"`
	// 开播时间
	LiveTime string `protobuf:"bytes,5,opt,name=live_time,json=liveTime,proto3" json:"live_time"`
	// 轮播状态
	RoundStatus int64 `protobuf:"varint,6,opt,name=round_status,json=roundStatus,proto3" json:"round_status"`
	// 是否开播
	OnFlag int64 `protobuf:"varint,7,opt,name=on_flag,json=onFlag,proto3" json:"on_flag"`
	// 直播间标题
	Title string `protobuf:"bytes,8,opt,name=title,proto3" json:"title"`
	// 锁定到时间
	LockStatus string `protobuf:"bytes,9,opt,name=lock_status,json=lockStatus,proto3" json:"lock_status"`
	// 隐藏到时间
	HiddenStatus string `protobuf:"bytes,10,opt,name=hidden_status,json=hiddenStatus,proto3" json:"hidden_status"`
	// 也是封面...
	UserCover string `protobuf:"bytes,11,opt,name=user_cover,json=userCover,proto3" json:"user_cover"`
	// 短号
	ShortId int64 `protobuf:"varint,12,opt,name=short_id,json=shortId,proto3" json:"short_id"`
	// 在线人数
	Online int64 `protobuf:"varint,13,opt,name=online,proto3" json:"online"`
	// 分区id
	Area int64 `protobuf:"varint,14,opt,name=area,proto3" json:"area"`
	// 分区v2 id
	AreaV2Id int64 `protobuf:"varint,15,opt,name=area_v2_id,json=areaV2Id,proto3" json:"area_v2_id"`
	// 分区v2 父分区id
	AreaV2ParentId int64 `protobuf:"varint,16,opt,name=area_v2_parent_id,json=areaV2ParentId,proto3" json:"area_v2_parent_id"`
	// 分区v2名字 fields加了该字段才会给
	AreaV2Name string `protobuf:"bytes,17,opt,name=area_v2_name,json=areaV2Name,proto3" json:"area_v2_name"`
	// 分区v2父分区名字 fields加了该字段才会给
	AreaV2ParentName string `protobuf:"bytes,18,opt,name=area_v2_parent_name,json=areaV2ParentName,proto3" json:"area_v2_parent_name"`
	// 关注人数
	Attentions int64 `protobuf:"varint,19,opt,name=attentions,proto3" json:"attentions"`
}

func (m *RoomGetInfoByIdResp_RoomInfo) Reset()         { *m = RoomGetInfoByIdResp_RoomInfo{} }
func (m *RoomGetInfoByIdResp_RoomInfo) String() string { return proto.CompactTextString(m) }
func (*RoomGetInfoByIdResp_RoomInfo) ProtoMessage()    {}
func (*RoomGetInfoByIdResp_RoomInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{3, 1}
}
func (m *RoomGetInfoByIdResp_RoomInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGetInfoByIdResp_RoomInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGetInfoByIdResp_RoomInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGetInfoByIdResp_RoomInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGetInfoByIdResp_RoomInfo.Merge(dst, src)
}
func (m *RoomGetInfoByIdResp_RoomInfo) XXX_Size() int {
	return m.Size()
}
func (m *RoomGetInfoByIdResp_RoomInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGetInfoByIdResp_RoomInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGetInfoByIdResp_RoomInfo proto.InternalMessageInfo

func (m *RoomGetInfoByIdResp_RoomInfo) GetRoomid() int64 {
	if m != nil {
		return m.Roomid
	}
	return 0
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetUname() string {
	if m != nil {
		return m.Uname
	}
	return ""
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetCover() string {
	if m != nil {
		return m.Cover
	}
	return ""
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetLiveTime() string {
	if m != nil {
		return m.LiveTime
	}
	return ""
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetRoundStatus() int64 {
	if m != nil {
		return m.RoundStatus
	}
	return 0
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetOnFlag() int64 {
	if m != nil {
		return m.OnFlag
	}
	return 0
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetLockStatus() string {
	if m != nil {
		return m.LockStatus
	}
	return ""
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetHiddenStatus() string {
	if m != nil {
		return m.HiddenStatus
	}
	return ""
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetUserCover() string {
	if m != nil {
		return m.UserCover
	}
	return ""
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetShortId() int64 {
	if m != nil {
		return m.ShortId
	}
	return 0
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetOnline() int64 {
	if m != nil {
		return m.Online
	}
	return 0
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetArea() int64 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetAreaV2Id() int64 {
	if m != nil {
		return m.AreaV2Id
	}
	return 0
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetAreaV2ParentId() int64 {
	if m != nil {
		return m.AreaV2ParentId
	}
	return 0
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetAreaV2Name() string {
	if m != nil {
		return m.AreaV2Name
	}
	return ""
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetAreaV2ParentName() string {
	if m != nil {
		return m.AreaV2ParentName
	}
	return ""
}

func (m *RoomGetInfoByIdResp_RoomInfo) GetAttentions() int64 {
	if m != nil {
		return m.Attentions
	}
	return 0
}

type RoomGetStatusInfoByUidsReq struct {
	// 用户id
	Uids []int64 `protobuf:"varint,1,rep,packed,name=uids" json:"uids"`
	// 是否只获取在播的用户信息 默认0
	FilterOffline int64 `protobuf:"varint,2,opt,name=filter_offline,json=filterOffline,proto3" json:"filter_offline"`
	// 是否显示隐藏的房间 默认0
	ShowHidden int64 `protobuf:"varint,3,opt,name=show_hidden,json=showHidden,proto3" json:"show_hidden"`
	// 是否过滤首页黑名单的房间 默认0
	FilterIndexBlack int64 `protobuf:"varint,4,opt,name=filter_index_black,json=filterIndexBlack,proto3" json:"filter_index_black"`
	// 是否过滤放映厅 默认0
	FilterVideo int64 `protobuf:"varint,5,opt,name=filter_video,json=filterVideo,proto3" json:"filter_video"`
	// 是否需要横竖屏信息 默认0
	NeedBroadcastType int64 `protobuf:"varint,6,opt,name=need_broadcast_type,json=needBroadcastType,proto3" json:"need_broadcast_type"`
}

func (m *RoomGetStatusInfoByUidsReq) Reset()         { *m = RoomGetStatusInfoByUidsReq{} }
func (m *RoomGetStatusInfoByUidsReq) String() string { return proto.CompactTextString(m) }
func (*RoomGetStatusInfoByUidsReq) ProtoMessage()    {}
func (*RoomGetStatusInfoByUidsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{4}
}
func (m *RoomGetStatusInfoByUidsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGetStatusInfoByUidsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGetStatusInfoByUidsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGetStatusInfoByUidsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGetStatusInfoByUidsReq.Merge(dst, src)
}
func (m *RoomGetStatusInfoByUidsReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomGetStatusInfoByUidsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGetStatusInfoByUidsReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGetStatusInfoByUidsReq proto.InternalMessageInfo

func (m *RoomGetStatusInfoByUidsReq) GetUids() []int64 {
	if m != nil {
		return m.Uids
	}
	return nil
}

func (m *RoomGetStatusInfoByUidsReq) GetFilterOffline() int64 {
	if m != nil {
		return m.FilterOffline
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsReq) GetShowHidden() int64 {
	if m != nil {
		return m.ShowHidden
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsReq) GetFilterIndexBlack() int64 {
	if m != nil {
		return m.FilterIndexBlack
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsReq) GetFilterVideo() int64 {
	if m != nil {
		return m.FilterVideo
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsReq) GetNeedBroadcastType() int64 {
	if m != nil {
		return m.NeedBroadcastType
	}
	return 0
}

type RoomGetStatusInfoByUidsResp struct {
	//
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	//
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data map[int64]*RoomGetStatusInfoByUidsResp_RoomInfo `protobuf:"bytes,3,rep,name=data" json:"data" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RoomGetStatusInfoByUidsResp) Reset()         { *m = RoomGetStatusInfoByUidsResp{} }
func (m *RoomGetStatusInfoByUidsResp) String() string { return proto.CompactTextString(m) }
func (*RoomGetStatusInfoByUidsResp) ProtoMessage()    {}
func (*RoomGetStatusInfoByUidsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{5}
}
func (m *RoomGetStatusInfoByUidsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGetStatusInfoByUidsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGetStatusInfoByUidsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGetStatusInfoByUidsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGetStatusInfoByUidsResp.Merge(dst, src)
}
func (m *RoomGetStatusInfoByUidsResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomGetStatusInfoByUidsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGetStatusInfoByUidsResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGetStatusInfoByUidsResp proto.InternalMessageInfo

func (m *RoomGetStatusInfoByUidsResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp) GetData() map[int64]*RoomGetStatusInfoByUidsResp_RoomInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type RoomGetStatusInfoByUidsResp_RoomInfo struct {
	// 直播间标题
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title"`
	// 房间id
	RoomId int64 `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id"`
	// 用户id
	Uid int64 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid"`
	// 人气值
	Online int64 `protobuf:"varint,4,opt,name=online,proto3" json:"online"`
	// 开播时间
	LiveTime int64 `protobuf:"varint,5,opt,name=live_time,json=liveTime,proto3" json:"live_time"`
	// 1开播 2 轮播 0 未开播
	LiveStatus int64 `protobuf:"varint,6,opt,name=live_status,json=liveStatus,proto3" json:"live_status"`
	// 短号
	ShortId int64 `protobuf:"varint,7,opt,name=short_id,json=shortId,proto3" json:"short_id"`
	// 老的分区id (2,3)
	Area int64 `protobuf:"varint,8,opt,name=area,proto3" json:"area"`
	// 老的分区名字
	AreaName string `protobuf:"bytes,9,opt,name=area_name,json=areaName,proto3" json:"area_name"`
	// 子分区id (172,189)
	AreaV2Id int64 `protobuf:"varint,10,opt,name=area_v2_id,json=areaV2Id,proto3" json:"area_v2_id"`
	// 子分区名字
	AreaV2Name string `protobuf:"bytes,11,opt,name=area_v2_name,json=areaV2Name,proto3" json:"area_v2_name"`
	// 父分区名字
	AreaV2ParentName string `protobuf:"bytes,12,opt,name=area_v2_parent_name,json=areaV2ParentName,proto3" json:"area_v2_parent_name"`
	// 父分区id (1,2)
	AreaV2ParentId int64 `protobuf:"varint,13,opt,name=area_v2_parent_id,json=areaV2ParentId,proto3" json:"area_v2_parent_id"`
	// 老分区标签
	TagName string `protobuf:"bytes,14,opt,name=tag_name,json=tagName,proto3" json:"tag_name"`
	// 房间标签
	Tags string `protobuf:"bytes,15,opt,name=tags,proto3" json:"tags"`
	// 用户昵称
	Uname string `protobuf:"bytes,16,opt,name=uname,proto3" json:"uname"`
	// 用户设定的封面
	CoverFromUser string `protobuf:"bytes,17,opt,name=cover_from_user,json=coverFromUser,proto3" json:"cover_from_user"`
	// 关键帧
	Keyframe string `protobuf:"bytes,18,opt,name=keyframe,proto3" json:"keyframe"`
	// 锁定到的时间
	LockTill string `protobuf:"bytes,19,opt,name=lock_till,json=lockTill,proto3" json:"lock_till"`
	// 隐藏到的时间
	HiddenTill string `protobuf:"bytes,20,opt,name=hidden_till,json=hiddenTill,proto3" json:"hidden_till"`
	// 横竖屏，只有传了need_broadcast_type才会返回  0:横屏 1:竖屏 -1:异常情况
	BroadcastType int64 `protobuf:"varint,21,opt,name=broadcast_type,json=broadcastType,proto3" json:"broadcast_type"`
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) Reset()         { *m = RoomGetStatusInfoByUidsResp_RoomInfo{} }
func (m *RoomGetStatusInfoByUidsResp_RoomInfo) String() string { return proto.CompactTextString(m) }
func (*RoomGetStatusInfoByUidsResp_RoomInfo) ProtoMessage()    {}
func (*RoomGetStatusInfoByUidsResp_RoomInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{5, 1}
}
func (m *RoomGetStatusInfoByUidsResp_RoomInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomGetStatusInfoByUidsResp_RoomInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomGetStatusInfoByUidsResp_RoomInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomGetStatusInfoByUidsResp_RoomInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomGetStatusInfoByUidsResp_RoomInfo.Merge(dst, src)
}
func (m *RoomGetStatusInfoByUidsResp_RoomInfo) XXX_Size() int {
	return m.Size()
}
func (m *RoomGetStatusInfoByUidsResp_RoomInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomGetStatusInfoByUidsResp_RoomInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoomGetStatusInfoByUidsResp_RoomInfo proto.InternalMessageInfo

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetOnline() int64 {
	if m != nil {
		return m.Online
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetLiveTime() int64 {
	if m != nil {
		return m.LiveTime
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetLiveStatus() int64 {
	if m != nil {
		return m.LiveStatus
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetShortId() int64 {
	if m != nil {
		return m.ShortId
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetArea() int64 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetAreaName() string {
	if m != nil {
		return m.AreaName
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetAreaV2Id() int64 {
	if m != nil {
		return m.AreaV2Id
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetAreaV2Name() string {
	if m != nil {
		return m.AreaV2Name
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetAreaV2ParentName() string {
	if m != nil {
		return m.AreaV2ParentName
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetAreaV2ParentId() int64 {
	if m != nil {
		return m.AreaV2ParentId
	}
	return 0
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetTagName() string {
	if m != nil {
		return m.TagName
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetUname() string {
	if m != nil {
		return m.Uname
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetCoverFromUser() string {
	if m != nil {
		return m.CoverFromUser
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetKeyframe() string {
	if m != nil {
		return m.Keyframe
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetLockTill() string {
	if m != nil {
		return m.LockTill
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetHiddenTill() string {
	if m != nil {
		return m.HiddenTill
	}
	return ""
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) GetBroadcastType() int64 {
	if m != nil {
		return m.BroadcastType
	}
	return 0
}

type RoomMobileRoomInitReq struct {
	// 房间号或者短位号
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 语言  hant: 国际版繁体中文 hans: 国际版简体中文
	Lang string `protobuf:"bytes,2,opt,name=lang,proto3" json:"lang"`
}

func (m *RoomMobileRoomInitReq) Reset()         { *m = RoomMobileRoomInitReq{} }
func (m *RoomMobileRoomInitReq) String() string { return proto.CompactTextString(m) }
func (*RoomMobileRoomInitReq) ProtoMessage()    {}
func (*RoomMobileRoomInitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{6}
}
func (m *RoomMobileRoomInitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomMobileRoomInitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomMobileRoomInitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomMobileRoomInitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomMobileRoomInitReq.Merge(dst, src)
}
func (m *RoomMobileRoomInitReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomMobileRoomInitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomMobileRoomInitReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomMobileRoomInitReq proto.InternalMessageInfo

func (m *RoomMobileRoomInitReq) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoomMobileRoomInitReq) GetLang() string {
	if m != nil {
		return m.Lang
	}
	return ""
}

type RoomMobileRoomInitResp struct {
	// code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data *RoomMobileRoomInitResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *RoomMobileRoomInitResp) Reset()         { *m = RoomMobileRoomInitResp{} }
func (m *RoomMobileRoomInitResp) String() string { return proto.CompactTextString(m) }
func (*RoomMobileRoomInitResp) ProtoMessage()    {}
func (*RoomMobileRoomInitResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{7}
}
func (m *RoomMobileRoomInitResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomMobileRoomInitResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomMobileRoomInitResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomMobileRoomInitResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomMobileRoomInitResp.Merge(dst, src)
}
func (m *RoomMobileRoomInitResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomMobileRoomInitResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomMobileRoomInitResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomMobileRoomInitResp proto.InternalMessageInfo

func (m *RoomMobileRoomInitResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RoomMobileRoomInitResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RoomMobileRoomInitResp) GetData() *RoomMobileRoomInitResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type RoomMobileRoomInitResp_Data struct {
	// 房间号
	RoomId int64 `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id"`
	// 短号
	ShortId int64 `protobuf:"varint,2,opt,name=short_id,json=shortId,proto3" json:"short_id"`
	// 主播uid
	Uid int64 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid"`
	// 是否p2p
	NeedP2P int64 `protobuf:"varint,4,opt,name=need_p2p,json=needP2p,proto3" json:"need_p2p"`
	// 是否锁定
	IsLocked bool `protobuf:"varint,5,opt,name=is_locked,json=isLocked,proto3" json:"is_locked"`
	// 是否隐藏
	IsHidden bool `protobuf:"varint,6,opt,name=is_hidden,json=isHidden,proto3" json:"is_hidden"`
	// 锁定时间戳
	LockTill int64 `protobuf:"varint,7,opt,name=lock_till,json=lockTill,proto3" json:"lock_till"`
	// 隐藏时间戳
	HiddenTill int64 `protobuf:"varint,8,opt,name=hidden_till,json=hiddenTill,proto3" json:"hidden_till"`
	// 是否加密
	Encrypted bool `protobuf:"varint,9,opt,name=encrypted,proto3" json:"encrypted"`
	// 加密房间是否通过密码验证, encrypted=true时才有意义
	PwdVerified bool `protobuf:"varint,10,opt,name=pwd_verified,json=pwdVerified,proto3" json:"pwd_verified"`
	// 是否竖屏
	IsPortrait bool `protobuf:"varint,11,opt,name=is_portrait,json=isPortrait,proto3" json:"is_portrait"`
	// 开播状态 0：关播 1：直播 2：轮播
	LiveStatus int64 `protobuf:"varint,12,opt,name=live_status,json=liveStatus,proto3" json:"live_status"`
	// 特殊直播间值  0 为普通直播间 1为付费直播间
	IsSp int64 `protobuf:"varint,13,opt,name=is_sp,json=isSp,proto3" json:"is_sp"`
	// 特殊直播间标志  0 为普通直播间，1为付费直播间, 2为拜年祭直播间
	SpecialType int64 `protobuf:"varint,14,opt,name=special_type,json=specialType,proto3" json:"special_type"`
}

func (m *RoomMobileRoomInitResp_Data) Reset()         { *m = RoomMobileRoomInitResp_Data{} }
func (m *RoomMobileRoomInitResp_Data) String() string { return proto.CompactTextString(m) }
func (*RoomMobileRoomInitResp_Data) ProtoMessage()    {}
func (*RoomMobileRoomInitResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{7, 0}
}
func (m *RoomMobileRoomInitResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomMobileRoomInitResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomMobileRoomInitResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomMobileRoomInitResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomMobileRoomInitResp_Data.Merge(dst, src)
}
func (m *RoomMobileRoomInitResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *RoomMobileRoomInitResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomMobileRoomInitResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_RoomMobileRoomInitResp_Data proto.InternalMessageInfo

func (m *RoomMobileRoomInitResp_Data) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomMobileRoomInitResp_Data) GetShortId() int64 {
	if m != nil {
		return m.ShortId
	}
	return 0
}

func (m *RoomMobileRoomInitResp_Data) GetUid() int64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RoomMobileRoomInitResp_Data) GetNeedP2P() int64 {
	if m != nil {
		return m.NeedP2P
	}
	return 0
}

func (m *RoomMobileRoomInitResp_Data) GetIsLocked() bool {
	if m != nil {
		return m.IsLocked
	}
	return false
}

func (m *RoomMobileRoomInitResp_Data) GetIsHidden() bool {
	if m != nil {
		return m.IsHidden
	}
	return false
}

func (m *RoomMobileRoomInitResp_Data) GetLockTill() int64 {
	if m != nil {
		return m.LockTill
	}
	return 0
}

func (m *RoomMobileRoomInitResp_Data) GetHiddenTill() int64 {
	if m != nil {
		return m.HiddenTill
	}
	return 0
}

func (m *RoomMobileRoomInitResp_Data) GetEncrypted() bool {
	if m != nil {
		return m.Encrypted
	}
	return false
}

func (m *RoomMobileRoomInitResp_Data) GetPwdVerified() bool {
	if m != nil {
		return m.PwdVerified
	}
	return false
}

func (m *RoomMobileRoomInitResp_Data) GetIsPortrait() bool {
	if m != nil {
		return m.IsPortrait
	}
	return false
}

func (m *RoomMobileRoomInitResp_Data) GetLiveStatus() int64 {
	if m != nil {
		return m.LiveStatus
	}
	return 0
}

func (m *RoomMobileRoomInitResp_Data) GetIsSp() int64 {
	if m != nil {
		return m.IsSp
	}
	return 0
}

func (m *RoomMobileRoomInitResp_Data) GetSpecialType() int64 {
	if m != nil {
		return m.SpecialType
	}
	return 0
}

type RoomIncrDanmuSendNumReq struct {
	// 房间号
	RoomId int64 `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id"`
	// 弹幕类型0普通1抽奖
	Mode int64 `protobuf:"varint,2,opt,name=mode,proto3" json:"mode"`
}

func (m *RoomIncrDanmuSendNumReq) Reset()         { *m = RoomIncrDanmuSendNumReq{} }
func (m *RoomIncrDanmuSendNumReq) String() string { return proto.CompactTextString(m) }
func (*RoomIncrDanmuSendNumReq) ProtoMessage()    {}
func (*RoomIncrDanmuSendNumReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{8}
}
func (m *RoomIncrDanmuSendNumReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomIncrDanmuSendNumReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomIncrDanmuSendNumReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomIncrDanmuSendNumReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomIncrDanmuSendNumReq.Merge(dst, src)
}
func (m *RoomIncrDanmuSendNumReq) XXX_Size() int {
	return m.Size()
}
func (m *RoomIncrDanmuSendNumReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomIncrDanmuSendNumReq.DiscardUnknown(m)
}

var xxx_messageInfo_RoomIncrDanmuSendNumReq proto.InternalMessageInfo

func (m *RoomIncrDanmuSendNumReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomIncrDanmuSendNumReq) GetMode() int64 {
	if m != nil {
		return m.Mode
	}
	return 0
}

type RoomIncrDanmuSendNumResp struct {
	//
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	//
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	//
	Data *RoomIncrDanmuSendNumResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *RoomIncrDanmuSendNumResp) Reset()         { *m = RoomIncrDanmuSendNumResp{} }
func (m *RoomIncrDanmuSendNumResp) String() string { return proto.CompactTextString(m) }
func (*RoomIncrDanmuSendNumResp) ProtoMessage()    {}
func (*RoomIncrDanmuSendNumResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{9}
}
func (m *RoomIncrDanmuSendNumResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomIncrDanmuSendNumResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomIncrDanmuSendNumResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomIncrDanmuSendNumResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomIncrDanmuSendNumResp.Merge(dst, src)
}
func (m *RoomIncrDanmuSendNumResp) XXX_Size() int {
	return m.Size()
}
func (m *RoomIncrDanmuSendNumResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomIncrDanmuSendNumResp.DiscardUnknown(m)
}

var xxx_messageInfo_RoomIncrDanmuSendNumResp proto.InternalMessageInfo

func (m *RoomIncrDanmuSendNumResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *RoomIncrDanmuSendNumResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RoomIncrDanmuSendNumResp) GetData() *RoomIncrDanmuSendNumResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type RoomIncrDanmuSendNumResp_Data struct {
}

func (m *RoomIncrDanmuSendNumResp_Data) Reset()         { *m = RoomIncrDanmuSendNumResp_Data{} }
func (m *RoomIncrDanmuSendNumResp_Data) String() string { return proto.CompactTextString(m) }
func (*RoomIncrDanmuSendNumResp_Data) ProtoMessage()    {}
func (*RoomIncrDanmuSendNumResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_Room_fa88de92f5bc1f28, []int{9, 0}
}
func (m *RoomIncrDanmuSendNumResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomIncrDanmuSendNumResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomIncrDanmuSendNumResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RoomIncrDanmuSendNumResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomIncrDanmuSendNumResp_Data.Merge(dst, src)
}
func (m *RoomIncrDanmuSendNumResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *RoomIncrDanmuSendNumResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomIncrDanmuSendNumResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_RoomIncrDanmuSendNumResp_Data proto.InternalMessageInfo

func init() {
	proto.RegisterType((*RoomAllLiveForBigdataReq)(nil), "room.v1.RoomAllLiveForBigdataReq")
	proto.RegisterType((*RoomAllLiveForBigdataResp)(nil), "room.v1.RoomAllLiveForBigdataResp")
	proto.RegisterType((*RoomAllLiveForBigdataResp_RoomInfo)(nil), "room.v1.RoomAllLiveForBigdataResp.RoomInfo")
	proto.RegisterType((*RoomGetInfoByIdReq)(nil), "room.v1.RoomGetInfoByIdReq")
	proto.RegisterType((*RoomGetInfoByIdResp)(nil), "room.v1.RoomGetInfoByIdResp")
	proto.RegisterMapType((map[int64]*RoomGetInfoByIdResp_RoomInfo)(nil), "room.v1.RoomGetInfoByIdResp.DataEntry")
	proto.RegisterType((*RoomGetInfoByIdResp_RoomInfo)(nil), "room.v1.RoomGetInfoByIdResp.RoomInfo")
	proto.RegisterType((*RoomGetStatusInfoByUidsReq)(nil), "room.v1.RoomGetStatusInfoByUidsReq")
	proto.RegisterType((*RoomGetStatusInfoByUidsResp)(nil), "room.v1.RoomGetStatusInfoByUidsResp")
	proto.RegisterMapType((map[int64]*RoomGetStatusInfoByUidsResp_RoomInfo)(nil), "room.v1.RoomGetStatusInfoByUidsResp.DataEntry")
	proto.RegisterType((*RoomGetStatusInfoByUidsResp_RoomInfo)(nil), "room.v1.RoomGetStatusInfoByUidsResp.RoomInfo")
	proto.RegisterType((*RoomMobileRoomInitReq)(nil), "room.v1.RoomMobileRoomInitReq")
	proto.RegisterType((*RoomMobileRoomInitResp)(nil), "room.v1.RoomMobileRoomInitResp")
	proto.RegisterType((*RoomMobileRoomInitResp_Data)(nil), "room.v1.RoomMobileRoomInitResp.Data")
	proto.RegisterType((*RoomIncrDanmuSendNumReq)(nil), "room.v1.RoomIncrDanmuSendNumReq")
	proto.RegisterType((*RoomIncrDanmuSendNumResp)(nil), "room.v1.RoomIncrDanmuSendNumResp")
	proto.RegisterType((*RoomIncrDanmuSendNumResp_Data)(nil), "room.v1.RoomIncrDanmuSendNumResp.Data")
}
func (m *RoomAllLiveForBigdataReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomAllLiveForBigdataReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RoomAllLiveForBigdataResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomAllLiveForBigdataResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRoom(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Roomid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Roomid))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Uid))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.CreateTime))
	}
	if m.ShortId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.ShortId))
	}
	if m.Online != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Online))
	}
	if m.Area != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Area))
	}
	if m.AreaV2Id != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.AreaV2Id))
	}
	if m.AreaV2ParentId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.AreaV2ParentId))
	}
	if m.Attentions != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Attentions))
	}
	return i, nil
}

func (m *RoomGetInfoByIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGetInfoByIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		dAtA2 := make([]byte, len(m.Ids)*10)
		var j1 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoom(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *RoomGetInfoByIdResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGetInfoByIdResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0x1a
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRoom(uint64(msgSize))
			}
			mapSize := 1 + sovRoom(uint64(k)) + msgSize
			i = encodeVarintRoom(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRoom(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRoom(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *RoomGetInfoByIdResp_RoomInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGetInfoByIdResp_RoomInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Roomid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Roomid))
	}
	if len(m.Uname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Uname)))
		i += copy(dAtA[i:], m.Uname)
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if m.Uid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Uid))
	}
	if len(m.LiveTime) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.LiveTime)))
		i += copy(dAtA[i:], m.LiveTime)
	}
	if m.RoundStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.RoundStatus))
	}
	if m.OnFlag != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.OnFlag))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.LockStatus) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.LockStatus)))
		i += copy(dAtA[i:], m.LockStatus)
	}
	if len(m.HiddenStatus) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.HiddenStatus)))
		i += copy(dAtA[i:], m.HiddenStatus)
	}
	if len(m.UserCover) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.UserCover)))
		i += copy(dAtA[i:], m.UserCover)
	}
	if m.ShortId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.ShortId))
	}
	if m.Online != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Online))
	}
	if m.Area != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Area))
	}
	if m.AreaV2Id != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.AreaV2Id))
	}
	if m.AreaV2ParentId != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.AreaV2ParentId))
	}
	if len(m.AreaV2Name) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.AreaV2Name)))
		i += copy(dAtA[i:], m.AreaV2Name)
	}
	if len(m.AreaV2ParentName) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.AreaV2ParentName)))
		i += copy(dAtA[i:], m.AreaV2ParentName)
	}
	if m.Attentions != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Attentions))
	}
	return i, nil
}

func (m *RoomGetStatusInfoByUidsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGetStatusInfoByUidsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		dAtA5 := make([]byte, len(m.Uids)*10)
		var j4 int
		for _, num1 := range m.Uids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoom(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.FilterOffline != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.FilterOffline))
	}
	if m.ShowHidden != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.ShowHidden))
	}
	if m.FilterIndexBlack != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.FilterIndexBlack))
	}
	if m.FilterVideo != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.FilterVideo))
	}
	if m.NeedBroadcastType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.NeedBroadcastType))
	}
	return i, nil
}

func (m *RoomGetStatusInfoByUidsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGetStatusInfoByUidsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0x1a
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRoom(uint64(msgSize))
			}
			mapSize := 1 + sovRoom(uint64(k)) + msgSize
			i = encodeVarintRoom(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRoom(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRoom(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	return i, nil
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.RoomId))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Uid))
	}
	if m.Online != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Online))
	}
	if m.LiveTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.LiveTime))
	}
	if m.LiveStatus != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.LiveStatus))
	}
	if m.ShortId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.ShortId))
	}
	if m.Area != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Area))
	}
	if len(m.AreaName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.AreaName)))
		i += copy(dAtA[i:], m.AreaName)
	}
	if m.AreaV2Id != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.AreaV2Id))
	}
	if len(m.AreaV2Name) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.AreaV2Name)))
		i += copy(dAtA[i:], m.AreaV2Name)
	}
	if len(m.AreaV2ParentName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.AreaV2ParentName)))
		i += copy(dAtA[i:], m.AreaV2ParentName)
	}
	if m.AreaV2ParentId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.AreaV2ParentId))
	}
	if len(m.TagName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.TagName)))
		i += copy(dAtA[i:], m.TagName)
	}
	if len(m.Tags) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Tags)))
		i += copy(dAtA[i:], m.Tags)
	}
	if len(m.Uname) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Uname)))
		i += copy(dAtA[i:], m.Uname)
	}
	if len(m.CoverFromUser) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.CoverFromUser)))
		i += copy(dAtA[i:], m.CoverFromUser)
	}
	if len(m.Keyframe) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Keyframe)))
		i += copy(dAtA[i:], m.Keyframe)
	}
	if len(m.LockTill) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.LockTill)))
		i += copy(dAtA[i:], m.LockTill)
	}
	if len(m.HiddenTill) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.HiddenTill)))
		i += copy(dAtA[i:], m.HiddenTill)
	}
	if m.BroadcastType != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.BroadcastType))
	}
	return i, nil
}

func (m *RoomMobileRoomInitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomMobileRoomInitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Id))
	}
	if len(m.Lang) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Lang)))
		i += copy(dAtA[i:], m.Lang)
	}
	return i, nil
}

func (m *RoomMobileRoomInitResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomMobileRoomInitResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Data.Size()))
		n7, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *RoomMobileRoomInitResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomMobileRoomInitResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.RoomId))
	}
	if m.ShortId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.ShortId))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Uid))
	}
	if m.NeedP2P != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.NeedP2P))
	}
	if m.IsLocked {
		dAtA[i] = 0x28
		i++
		if m.IsLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsHidden {
		dAtA[i] = 0x30
		i++
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LockTill != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.LockTill))
	}
	if m.HiddenTill != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.HiddenTill))
	}
	if m.Encrypted {
		dAtA[i] = 0x48
		i++
		if m.Encrypted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PwdVerified {
		dAtA[i] = 0x50
		i++
		if m.PwdVerified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsPortrait {
		dAtA[i] = 0x58
		i++
		if m.IsPortrait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LiveStatus != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.LiveStatus))
	}
	if m.IsSp != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.IsSp))
	}
	if m.SpecialType != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.SpecialType))
	}
	return i, nil
}

func (m *RoomIncrDanmuSendNumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomIncrDanmuSendNumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.RoomId))
	}
	if m.Mode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Mode))
	}
	return i, nil
}

func (m *RoomIncrDanmuSendNumResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomIncrDanmuSendNumResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRoom(dAtA, i, uint64(m.Data.Size()))
		n8, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *RoomIncrDanmuSendNumResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomIncrDanmuSendNumResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintRoom(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RoomAllLiveForBigdataReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RoomAllLiveForBigdataResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRoom(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovRoom(uint64(l))
		}
	}
	return n
}

func (m *RoomAllLiveForBigdataResp_RoomInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Roomid != 0 {
		n += 1 + sovRoom(uint64(m.Roomid))
	}
	if m.Uid != 0 {
		n += 1 + sovRoom(uint64(m.Uid))
	}
	if m.CreateTime != 0 {
		n += 1 + sovRoom(uint64(m.CreateTime))
	}
	if m.ShortId != 0 {
		n += 1 + sovRoom(uint64(m.ShortId))
	}
	if m.Online != 0 {
		n += 1 + sovRoom(uint64(m.Online))
	}
	if m.Area != 0 {
		n += 1 + sovRoom(uint64(m.Area))
	}
	if m.AreaV2Id != 0 {
		n += 1 + sovRoom(uint64(m.AreaV2Id))
	}
	if m.AreaV2ParentId != 0 {
		n += 1 + sovRoom(uint64(m.AreaV2ParentId))
	}
	if m.Attentions != 0 {
		n += 1 + sovRoom(uint64(m.Attentions))
	}
	return n
}

func (m *RoomGetInfoByIdReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovRoom(uint64(e))
		}
		n += 1 + sovRoom(uint64(l)) + l
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovRoom(uint64(l))
		}
	}
	return n
}

func (m *RoomGetInfoByIdResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRoom(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoom(uint64(l))
			}
			mapEntrySize := 1 + sovRoom(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoom(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RoomGetInfoByIdResp_RoomInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Roomid != 0 {
		n += 1 + sovRoom(uint64(m.Roomid))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovRoom(uint64(m.Uid))
	}
	l = len(m.LiveTime)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.RoundStatus != 0 {
		n += 1 + sovRoom(uint64(m.RoundStatus))
	}
	if m.OnFlag != 0 {
		n += 1 + sovRoom(uint64(m.OnFlag))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	l = len(m.LockStatus)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	l = len(m.HiddenStatus)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	l = len(m.UserCover)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.ShortId != 0 {
		n += 1 + sovRoom(uint64(m.ShortId))
	}
	if m.Online != 0 {
		n += 1 + sovRoom(uint64(m.Online))
	}
	if m.Area != 0 {
		n += 1 + sovRoom(uint64(m.Area))
	}
	if m.AreaV2Id != 0 {
		n += 1 + sovRoom(uint64(m.AreaV2Id))
	}
	if m.AreaV2ParentId != 0 {
		n += 2 + sovRoom(uint64(m.AreaV2ParentId))
	}
	l = len(m.AreaV2Name)
	if l > 0 {
		n += 2 + l + sovRoom(uint64(l))
	}
	l = len(m.AreaV2ParentName)
	if l > 0 {
		n += 2 + l + sovRoom(uint64(l))
	}
	if m.Attentions != 0 {
		n += 2 + sovRoom(uint64(m.Attentions))
	}
	return n
}

func (m *RoomGetStatusInfoByUidsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovRoom(uint64(e))
		}
		n += 1 + sovRoom(uint64(l)) + l
	}
	if m.FilterOffline != 0 {
		n += 1 + sovRoom(uint64(m.FilterOffline))
	}
	if m.ShowHidden != 0 {
		n += 1 + sovRoom(uint64(m.ShowHidden))
	}
	if m.FilterIndexBlack != 0 {
		n += 1 + sovRoom(uint64(m.FilterIndexBlack))
	}
	if m.FilterVideo != 0 {
		n += 1 + sovRoom(uint64(m.FilterVideo))
	}
	if m.NeedBroadcastType != 0 {
		n += 1 + sovRoom(uint64(m.NeedBroadcastType))
	}
	return n
}

func (m *RoomGetStatusInfoByUidsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRoom(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoom(uint64(l))
			}
			mapEntrySize := 1 + sovRoom(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoom(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RoomGetStatusInfoByUidsResp_RoomInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.RoomId != 0 {
		n += 1 + sovRoom(uint64(m.RoomId))
	}
	if m.Uid != 0 {
		n += 1 + sovRoom(uint64(m.Uid))
	}
	if m.Online != 0 {
		n += 1 + sovRoom(uint64(m.Online))
	}
	if m.LiveTime != 0 {
		n += 1 + sovRoom(uint64(m.LiveTime))
	}
	if m.LiveStatus != 0 {
		n += 1 + sovRoom(uint64(m.LiveStatus))
	}
	if m.ShortId != 0 {
		n += 1 + sovRoom(uint64(m.ShortId))
	}
	if m.Area != 0 {
		n += 1 + sovRoom(uint64(m.Area))
	}
	l = len(m.AreaName)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.AreaV2Id != 0 {
		n += 1 + sovRoom(uint64(m.AreaV2Id))
	}
	l = len(m.AreaV2Name)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	l = len(m.AreaV2ParentName)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.AreaV2ParentId != 0 {
		n += 1 + sovRoom(uint64(m.AreaV2ParentId))
	}
	l = len(m.TagName)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 2 + l + sovRoom(uint64(l))
	}
	l = len(m.CoverFromUser)
	if l > 0 {
		n += 2 + l + sovRoom(uint64(l))
	}
	l = len(m.Keyframe)
	if l > 0 {
		n += 2 + l + sovRoom(uint64(l))
	}
	l = len(m.LockTill)
	if l > 0 {
		n += 2 + l + sovRoom(uint64(l))
	}
	l = len(m.HiddenTill)
	if l > 0 {
		n += 2 + l + sovRoom(uint64(l))
	}
	if m.BroadcastType != 0 {
		n += 2 + sovRoom(uint64(m.BroadcastType))
	}
	return n
}

func (m *RoomMobileRoomInitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRoom(uint64(m.Id))
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	return n
}

func (m *RoomMobileRoomInitResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRoom(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovRoom(uint64(l))
	}
	return n
}

func (m *RoomMobileRoomInitResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovRoom(uint64(m.RoomId))
	}
	if m.ShortId != 0 {
		n += 1 + sovRoom(uint64(m.ShortId))
	}
	if m.Uid != 0 {
		n += 1 + sovRoom(uint64(m.Uid))
	}
	if m.NeedP2P != 0 {
		n += 1 + sovRoom(uint64(m.NeedP2P))
	}
	if m.IsLocked {
		n += 2
	}
	if m.IsHidden {
		n += 2
	}
	if m.LockTill != 0 {
		n += 1 + sovRoom(uint64(m.LockTill))
	}
	if m.HiddenTill != 0 {
		n += 1 + sovRoom(uint64(m.HiddenTill))
	}
	if m.Encrypted {
		n += 2
	}
	if m.PwdVerified {
		n += 2
	}
	if m.IsPortrait {
		n += 2
	}
	if m.LiveStatus != 0 {
		n += 1 + sovRoom(uint64(m.LiveStatus))
	}
	if m.IsSp != 0 {
		n += 1 + sovRoom(uint64(m.IsSp))
	}
	if m.SpecialType != 0 {
		n += 1 + sovRoom(uint64(m.SpecialType))
	}
	return n
}

func (m *RoomIncrDanmuSendNumReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovRoom(uint64(m.RoomId))
	}
	if m.Mode != 0 {
		n += 1 + sovRoom(uint64(m.Mode))
	}
	return n
}

func (m *RoomIncrDanmuSendNumResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovRoom(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovRoom(uint64(l))
	}
	return n
}

func (m *RoomIncrDanmuSendNumResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovRoom(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRoom(x uint64) (n int) {
	return sovRoom(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RoomAllLiveForBigdataReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomAllLiveForBigdataReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomAllLiveForBigdataReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomAllLiveForBigdataResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomAllLiveForBigdataResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomAllLiveForBigdataResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &RoomAllLiveForBigdataResp_RoomInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomAllLiveForBigdataResp_RoomInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortId", wireType)
			}
			m.ShortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShortId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			m.Online = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Online |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2Id", wireType)
			}
			m.AreaV2Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2ParentId", wireType)
			}
			m.AreaV2ParentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2ParentId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attentions", wireType)
			}
			m.Attentions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attentions |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomGetInfoByIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomGetInfoByIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomGetInfoByIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRoom
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomGetInfoByIdResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomGetInfoByIdResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomGetInfoByIdResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int64]*RoomGetInfoByIdResp_RoomInfo)
			}
			var mapkey int64
			var mapvalue *RoomGetInfoByIdResp_RoomInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoom
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRoom
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoomGetInfoByIdResp_RoomInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoom(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoom
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomGetInfoByIdResp_RoomInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			m.Roomid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundStatus", wireType)
			}
			m.RoundStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnFlag", wireType)
			}
			m.OnFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnFlag |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HiddenStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserCover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortId", wireType)
			}
			m.ShortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShortId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			m.Online = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Online |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2Id", wireType)
			}
			m.AreaV2Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2ParentId", wireType)
			}
			m.AreaV2ParentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2ParentId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AreaV2Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2ParentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AreaV2ParentName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attentions", wireType)
			}
			m.Attentions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attentions |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomGetStatusInfoByUidsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomGetStatusInfoByUidsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomGetStatusInfoByUidsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRoom
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterOffline", wireType)
			}
			m.FilterOffline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterOffline |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowHidden", wireType)
			}
			m.ShowHidden = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowHidden |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterIndexBlack", wireType)
			}
			m.FilterIndexBlack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterIndexBlack |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterVideo", wireType)
			}
			m.FilterVideo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterVideo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedBroadcastType", wireType)
			}
			m.NeedBroadcastType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedBroadcastType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomGetStatusInfoByUidsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomGetStatusInfoByUidsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomGetStatusInfoByUidsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[int64]*RoomGetStatusInfoByUidsResp_RoomInfo)
			}
			var mapkey int64
			var mapvalue *RoomGetStatusInfoByUidsResp_RoomInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoom
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRoom
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoomGetStatusInfoByUidsResp_RoomInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoom(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoom
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomGetStatusInfoByUidsResp_RoomInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			m.Online = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Online |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveTime", wireType)
			}
			m.LiveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStatus", wireType)
			}
			m.LiveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortId", wireType)
			}
			m.ShortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShortId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AreaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2Id", wireType)
			}
			m.AreaV2Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AreaV2Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2ParentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AreaV2ParentName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaV2ParentId", wireType)
			}
			m.AreaV2ParentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaV2ParentId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverFromUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverFromUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyframe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyframe = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTill", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockTill = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenTill", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HiddenTill = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BroadcastType", wireType)
			}
			m.BroadcastType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BroadcastType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomMobileRoomInitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomMobileRoomInitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomMobileRoomInitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomMobileRoomInitResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomMobileRoomInitResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomMobileRoomInitResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &RoomMobileRoomInitResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomMobileRoomInitResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortId", wireType)
			}
			m.ShortId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShortId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedP2P", wireType)
			}
			m.NeedP2P = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedP2P |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocked = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTill", wireType)
			}
			m.LockTill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTill |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenTill", wireType)
			}
			m.HiddenTill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HiddenTill |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encrypted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Encrypted = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwdVerified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PwdVerified = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPortrait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPortrait = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStatus", wireType)
			}
			m.LiveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSp", wireType)
			}
			m.IsSp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsSp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialType", wireType)
			}
			m.SpecialType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpecialType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomIncrDanmuSendNumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomIncrDanmuSendNumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomIncrDanmuSendNumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomIncrDanmuSendNumResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomIncrDanmuSendNumResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomIncrDanmuSendNumResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &RoomIncrDanmuSendNumResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomIncrDanmuSendNumResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoom(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRoom
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoom(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoom = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoom   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("v1/Room.proto", fileDescriptor_Room_fa88de92f5bc1f28) }

var fileDescriptor_Room_fa88de92f5bc1f28 = []byte{
	// 1667 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x98, 0xcb, 0x6e, 0xdb, 0xcc,
	0x15, 0xc7, 0xa3, 0x8b, 0x25, 0xea, 0xc8, 0x52, 0x6c, 0x3a, 0x17, 0x45, 0x31, 0x44, 0x47, 0x75,
	0x1b, 0x23, 0x69, 0x9c, 0x46, 0x01, 0x8a, 0xa6, 0xd9, 0xb4, 0x8e, 0xeb, 0x54, 0x68, 0x92, 0xa6,
	0xe3, 0x24, 0x05, 0x0a, 0xa4, 0x04, 0x25, 0x8e, 0xe4, 0x81, 0x29, 0x52, 0x22, 0x29, 0xa5, 0xda,
	0x76, 0xd1, 0x75, 0x5f, 0xa1, 0xbb, 0xbe, 0x40, 0xdf, 0x20, 0x8b, 0xa2, 0xab, 0x00, 0xdd, 0x74,
	0x45, 0x14, 0xc9, 0x8e, 0xdf, 0x4b, 0x7c, 0x98, 0x33, 0x43, 0x91, 0xba, 0xdb, 0xc9, 0xb7, 0x19,
	0xce, 0xf9, 0xcf, 0x95, 0x33, 0xe7, 0xfc, 0x66, 0x48, 0x28, 0x8d, 0x1e, 0x3d, 0x24, 0x8e, 0xd3,
	0x3b, 0xec, 0xbb, 0x8e, 0xef, 0xa8, 0x79, 0x97, 0xe7, 0x47, 0x8f, 0xaa, 0x0f, 0xba, 0xcc, 0x3f,
	0x1b, 0xb6, 0x0e, 0xdb, 0x4e, 0xef, 0x61, 0xd7, 0xe9, 0x3a, 0x0f, 0xb1, 0xbc, 0x35, 0xec, 0xa0,
	0x85, 0x06, 0xe6, 0x44, 0xbb, 0x7a, 0x15, 0x2a, 0xbc, 0x97, 0x5f, 0x5b, 0xd6, 0x0b, 0x36, 0xa2,
	0x27, 0x8e, 0x7b, 0xc4, 0xba, 0xa6, 0xe1, 0x1b, 0x84, 0x0e, 0xea, 0xff, 0xcc, 0xc2, 0xad, 0x25,
	0x85, 0x5e, 0x5f, 0xdd, 0x85, 0x6c, 0xdb, 0x31, 0x69, 0x25, 0xb5, 0x97, 0x3a, 0xc8, 0x1c, 0x29,
	0x61, 0xa0, 0xa1, 0x4d, 0x30, 0x55, 0x6f, 0x41, 0xa6, 0xe7, 0x75, 0x2b, 0xe9, 0xbd, 0xd4, 0x41,
	0xe1, 0x28, 0x1f, 0x06, 0x1a, 0x37, 0x09, 0x4f, 0xd4, 0x26, 0x64, 0x79, 0x27, 0x95, 0xcc, 0x5e,
	0xe6, 0xa0, 0xd8, 0xb8, 0x7f, 0x28, 0x67, 0x7e, 0xb8, 0x74, 0x28, 0x2c, 0x69, 0xda, 0x1d, 0x47,
	0x8c, 0x82, 0x32, 0xa6, 0xd5, 0xbf, 0x65, 0x40, 0x89, 0x0a, 0xd5, 0x3a, 0xe4, 0x78, 0x57, 0xcc,
	0x94, 0x53, 0x82, 0x30, 0xd0, 0xa4, 0x42, 0xe4, 0x93, 0x4f, 0x6b, 0xc8, 0x4c, 0x9c, 0x56, 0x46,
	0x4c, 0x6b, 0xc8, 0x4c, 0xc2, 0x13, 0xf5, 0x67, 0x50, 0x6c, 0xbb, 0xd4, 0xf0, 0xa9, 0xee, 0xb3,
	0x1e, 0xad, 0x64, 0xb0, 0xca, 0xd5, 0x30, 0xd0, 0x92, 0x32, 0x01, 0x61, 0xbc, 0x61, 0x3d, 0xaa,
	0xde, 0x05, 0xc5, 0x3b, 0x73, 0x5c, 0x5f, 0x67, 0x66, 0x25, 0x8b, 0xd5, 0x37, 0xc3, 0x40, 0x9b,
	0x68, 0x24, 0x8f, 0xb9, 0xa6, 0xc9, 0x67, 0xe6, 0xd8, 0x16, 0xb3, 0x69, 0x65, 0x23, 0x9e, 0x99,
	0x50, 0x88, 0x7c, 0xf2, 0xe5, 0x34, 0x5c, 0x6a, 0x54, 0x72, 0xf1, 0x72, 0x72, 0x9b, 0x60, 0xaa,
	0xfe, 0x14, 0x80, 0x3f, 0xf5, 0x51, 0x83, 0x0f, 0x96, 0xc7, 0x3a, 0xe5, 0x30, 0xd0, 0x12, 0x2a,
	0x51, 0x78, 0xfe, 0x5d, 0xa3, 0x69, 0xaa, 0xbf, 0x82, 0xed, 0x48, 0xef, 0x1b, 0x2e, 0xb5, 0x71,
	0x86, 0x0a, 0x36, 0xba, 0x1e, 0x06, 0xda, 0x7c, 0x21, 0x29, 0x8b, 0xb6, 0xaf, 0x51, 0x68, 0x9a,
	0xea, 0x21, 0x80, 0xe1, 0xfb, 0xd4, 0xf6, 0x99, 0x63, 0x7b, 0x95, 0x42, 0x62, 0xbc, 0x89, 0x4a,
	0x12, 0xf9, 0xfa, 0x29, 0xa8, 0x7c, 0x1f, 0x9e, 0x53, 0x1f, 0xf7, 0x69, 0xdc, 0x34, 0x09, 0x1d,
	0xf0, 0xd5, 0x66, 0xa6, 0x57, 0x49, 0xed, 0x65, 0xa2, 0xd5, 0x66, 0xa6, 0x47, 0x78, 0xc2, 0x97,
	0xa4, 0xc3, 0xa8, 0x65, 0x7a, 0x95, 0xf4, 0x5e, 0xe6, 0xa0, 0x20, 0x96, 0x44, 0x28, 0x44, 0x3e,
	0xeb, 0xff, 0x51, 0x60, 0x67, 0xae, 0xd7, 0x6f, 0xf1, 0xbc, 0xe3, 0x29, 0xcf, 0xfb, 0xc9, 0x94,
	0xe7, 0xcd, 0x0c, 0x72, 0x78, 0x6c, 0xf8, 0xc6, 0x6f, 0x6c, 0xdf, 0x1d, 0xcf, 0x39, 0xdd, 0x9f,
	0xa1, 0x30, 0x29, 0x54, 0xb7, 0x20, 0x73, 0x4e, 0xc7, 0x62, 0x2a, 0x84, 0x67, 0xd5, 0xa7, 0xb0,
	0x31, 0x32, 0xac, 0x21, 0xc5, 0x19, 0x14, 0x1b, 0x3f, 0x5e, 0x39, 0x4a, 0xe4, 0xbc, 0x44, 0xb4,
	0xf9, 0x65, 0xfa, 0x17, 0xa9, 0xea, 0x7f, 0x73, 0x97, 0x74, 0x6a, 0x0d, 0x36, 0x86, 0xb6, 0xd1,
	0xa3, 0xf2, 0x9d, 0x0b, 0x61, 0xa0, 0x09, 0x81, 0x88, 0x07, 0xaf, 0xd0, 0x76, 0x46, 0xd4, 0x45,
	0xa7, 0x96, 0x15, 0x50, 0x20, 0xe2, 0x11, 0x85, 0x45, 0x76, 0x41, 0x58, 0xdc, 0x83, 0x82, 0xc5,
	0x46, 0x32, 0x28, 0x36, 0xb0, 0x7d, 0x29, 0x0c, 0xb4, 0x58, 0x24, 0x0a, 0xcf, 0x62, 0x40, 0x3c,
	0x86, 0x4d, 0xd7, 0x19, 0xda, 0xa6, 0xee, 0xf9, 0x86, 0x3f, 0xf4, 0xa4, 0x2f, 0x6f, 0x85, 0x81,
	0x36, 0xa5, 0x93, 0x22, 0x5a, 0xa7, 0x68, 0xa8, 0xfb, 0x90, 0x77, 0x6c, 0xbd, 0x63, 0x19, 0x5d,
	0xe9, 0xd7, 0xc5, 0x30, 0xd0, 0x22, 0x89, 0x87, 0xc7, 0x89, 0x65, 0x74, 0xf9, 0x2b, 0xf8, 0xcc,
	0xb7, 0x28, 0xba, 0xb1, 0x7c, 0x05, 0x14, 0x88, 0x78, 0xf0, 0xf0, 0xb5, 0x9c, 0xf6, 0x79, 0x34,
	0x74, 0x01, 0xab, 0x61, 0xf8, 0x26, 0x64, 0x02, 0xdc, 0x90, 0x03, 0xff, 0x1c, 0x4a, 0x67, 0xcc,
	0x34, 0xa9, 0x1d, 0xb5, 0x01, 0x6c, 0xb3, 0x1d, 0x06, 0xda, 0x74, 0x01, 0xd9, 0x14, 0xa6, 0x6c,
	0xf7, 0x00, 0x60, 0xe8, 0x51, 0x57, 0x17, 0x4b, 0x5a, 0xc4, 0x46, 0x18, 0x1b, 0xb1, 0x4a, 0x0a,
	0x3c, 0xff, 0x0c, 0xd7, 0x36, 0x49, 0x89, 0xcd, 0x8b, 0x51, 0xa2, 0xb4, 0x96, 0x12, 0xe5, 0x0b,
	0x50, 0xe2, 0xea, 0xd7, 0x50, 0x62, 0xeb, 0x32, 0x94, 0x68, 0xc0, 0x66, 0x54, 0x09, 0xfd, 0x6f,
	0x1b, 0xd7, 0x02, 0xf7, 0x3b, 0xa9, 0x13, 0x10, 0xed, 0x5e, 0x71, 0x5f, 0x3c, 0x81, 0x9d, 0x99,
	0x8e, 0xb1, 0xa9, 0x8a, 0x4d, 0x6f, 0x86, 0x81, 0xb6, 0xa8, 0x98, 0x6c, 0x25, 0x47, 0xc6, 0x7e,
	0xa6, 0x09, 0xb5, 0xb3, 0x96, 0x50, 0xdf, 0xa5, 0xa1, 0x2a, 0x23, 0x50, 0xec, 0xa3, 0x88, 0xc3,
	0xb7, 0x9c, 0x48, 0x74, 0xc0, 0x17, 0x76, 0x18, 0xb3, 0x0a, 0x17, 0x96, 0xdb, 0x04, 0x53, 0xf5,
	0x09, 0x94, 0x3b, 0xcc, 0xf2, 0xa9, 0xab, 0x3b, 0x9d, 0x0e, 0x6e, 0x91, 0x38, 0x41, 0xd4, 0x30,
	0xd0, 0x66, 0x4a, 0x48, 0x49, 0xd8, 0xbf, 0x17, 0x26, 0xf7, 0x4b, 0xef, 0xcc, 0xf9, 0xa0, 0x0b,
	0x17, 0x4a, 0x1e, 0x2b, 0x09, 0x99, 0x00, 0x37, 0x7e, 0x8b, 0x79, 0xf5, 0x18, 0x54, 0xd9, 0x25,
	0xb3, 0x4d, 0xfa, 0x17, 0xbd, 0x65, 0x19, 0xed, 0x73, 0x19, 0x9b, 0x37, 0xc2, 0x40, 0x5b, 0x50,
	0x4a, 0xb6, 0x84, 0xd6, 0xe4, 0xd2, 0x11, 0x57, 0x78, 0x2c, 0xca, 0x7a, 0x23, 0x66, 0x52, 0x47,
	0x9e, 0x3c, 0xb8, 0x37, 0x49, 0x9d, 0x14, 0x85, 0xf5, 0x8e, 0x1b, 0xea, 0x73, 0xd8, 0xb1, 0x29,
	0x35, 0xf5, 0x96, 0xeb, 0x18, 0x66, 0xdb, 0xf0, 0x7c, 0xdd, 0x1f, 0xf7, 0xa9, 0x8c, 0x63, 0xdc,
	0x9c, 0x05, 0xc5, 0x64, 0x9b, 0x8b, 0x47, 0x91, 0xf6, 0x66, 0xdc, 0xa7, 0xf5, 0x8f, 0x05, 0xb8,
	0xbd, 0x74, 0xb5, 0xbf, 0x05, 0xe1, 0x2f, 0xa6, 0x10, 0x7e, 0x38, 0x0b, 0xd7, 0x45, 0x83, 0xad,
	0x40, 0x79, 0x67, 0x35, 0xca, 0x9f, 0x4d, 0xa3, 0xfc, 0xc1, 0x85, 0x46, 0x5b, 0x84, 0xf4, 0x7f,
	0xe5, 0x13, 0x48, 0x9f, 0xa0, 0x2c, 0xb5, 0x04, 0x65, 0xfb, 0x80, 0xb7, 0x39, 0x7d, 0x72, 0x51,
	0x41, 0x22, 0x4a, 0x49, 0x50, 0xbf, 0x39, 0xb9, 0xca, 0x64, 0x16, 0x30, 0x3b, 0x26, 0x49, 0x76,
	0x29, 0x49, 0xe6, 0xb8, 0x9e, 0x59, 0xce, 0x75, 0xce, 0x56, 0x2e, 0x4f, 0x61, 0x5d, 0xb0, 0x35,
	0x96, 0x09, 0x70, 0x43, 0x32, 0x32, 0x09, 0xbd, 0xfc, 0x2a, 0xe8, 0x45, 0x40, 0x53, 0x16, 0x02,
	0xed, 0x1e, 0x14, 0x90, 0x06, 0x88, 0x88, 0x42, 0x7c, 0xf8, 0x4c, 0x44, 0x81, 0x33, 0x04, 0xc2,
	0x34, 0xfc, 0x60, 0x0d, 0xfc, 0x66, 0xd1, 0x55, 0xfc, 0x7a, 0x74, 0x6d, 0x5e, 0x16, 0x5d, 0x0b,
	0xc1, 0x5b, 0xba, 0x0c, 0x78, 0xef, 0x82, 0xe2, 0x1b, 0x5d, 0x31, 0x7c, 0x19, 0x87, 0xc7, 0xe5,
	0x8d, 0x34, 0x92, 0xf7, 0x8d, 0x2e, 0x0e, 0xb5, 0x0b, 0x59, 0xdf, 0xe8, 0x7a, 0x78, 0x16, 0x14,
	0xc4, 0xf2, 0x72, 0x9b, 0x60, 0x1a, 0x5f, 0x1c, 0xb6, 0x96, 0x5c, 0x1c, 0x9e, 0xc2, 0x55, 0x3c,
	0xcf, 0xf4, 0x8e, 0xeb, 0xf4, 0x74, 0x7e, 0xa6, 0x49, 0xc6, 0xef, 0x84, 0x81, 0x36, 0x5b, 0x44,
	0x4a, 0x28, 0x9c, 0xb8, 0x4e, 0xef, 0xad, 0x47, 0x5d, 0xf5, 0x00, 0x94, 0x73, 0x3a, 0xee, 0xb8,
	0x31, 0xde, 0x71, 0x92, 0x91, 0x46, 0x26, 0x39, 0xf4, 0x45, 0x7e, 0x48, 0xfb, 0xcc, 0xb2, 0x10,
	0xe5, 0xd1, 0x1d, 0x23, 0x12, 0x89, 0xc2, 0xb3, 0x6f, 0x98, 0x65, 0x71, 0x5f, 0x94, 0x87, 0x33,
	0xd6, 0xbe, 0x16, 0x9f, 0xf3, 0x09, 0x99, 0x80, 0x30, 0xb0, 0xc5, 0x13, 0x28, 0xcf, 0xf0, 0xec,
	0x7a, 0x0c, 0xef, 0x19, 0x94, 0x95, 0x5a, 0x53, 0x18, 0x7b, 0x09, 0xd7, 0x79, 0xd8, 0xbe, 0x74,
	0x5a, 0xcc, 0xa2, 0x22, 0x80, 0x99, 0xcf, 0x8f, 0x8b, 0x1b, 0x90, 0x9e, 0x5c, 0xc9, 0x72, 0x61,
	0xa0, 0xa5, 0x99, 0x49, 0xd2, 0x0c, 0xdd, 0xd9, 0x32, 0xec, 0x08, 0x5d, 0xb8, 0xde, 0xdc, 0x26,
	0x98, 0xd6, 0xff, 0x9a, 0x83, 0x1b, 0x8b, 0xfa, 0xfb, 0x16, 0x20, 0x1e, 0x4d, 0x80, 0xc8, 0x11,
	0xb5, 0x3f, 0x85, 0xa8, 0xf9, 0x71, 0x90, 0x85, 0x73, 0x18, 0x0c, 0xb3, 0x90, 0xe5, 0x05, 0x49,
	0xf2, 0xa4, 0x96, 0x93, 0x27, 0x19, 0xdc, 0xe9, 0x55, 0xc1, 0xbd, 0x02, 0x51, 0x77, 0x41, 0xc1,
	0xa3, 0xa4, 0xdf, 0xe8, 0x27, 0xbf, 0x9d, 0x22, 0x8d, 0xe4, 0x79, 0xee, 0x75, 0xa3, 0xcf, 0x7d,
	0x83, 0x79, 0x3a, 0xdf, 0x7e, 0x6a, 0x22, 0xa7, 0x14, 0xe1, 0x1b, 0x13, 0x91, 0x28, 0xcc, 0x7b,
	0x81, 0x39, 0x59, 0x57, 0x9e, 0xb4, 0xb9, 0xa9, 0xba, 0xf2, 0x9c, 0x55, 0x98, 0x27, 0x4f, 0xd9,
	0x29, 0x9f, 0xcb, 0x27, 0xf8, 0xb7, 0xde, 0xe7, 0x94, 0x98, 0x7f, 0xcb, 0x7c, 0xee, 0x3e, 0x14,
	0xa8, 0xdd, 0x76, 0xc7, 0x7d, 0x9f, 0x9a, 0x08, 0x2e, 0x39, 0x93, 0x89, 0x48, 0xe2, 0x2c, 0x3f,
	0xaa, 0xfb, 0x1f, 0x4c, 0x7d, 0x44, 0x5d, 0xd6, 0x61, 0x54, 0xb0, 0x4b, 0x11, 0x2c, 0x4a, 0xea,
	0xa4, 0xd8, 0xff, 0x60, 0xbe, 0x93, 0x06, 0x9f, 0x13, 0xf3, 0xf4, 0xbe, 0xe3, 0xfa, 0xae, 0xc1,
	0x7c, 0xe4, 0x97, 0x22, 0xe6, 0x94, 0x90, 0x09, 0x30, 0xef, 0xb5, 0xcc, 0xcf, 0x52, 0x7c, 0x73,
	0x3d, 0xc5, 0x6b, 0xb0, 0xc1, 0x3c, 0xdd, 0xeb, 0x4b, 0x38, 0x21, 0x1f, 0x50, 0x20, 0x59, 0xe6,
	0x9d, 0xf6, 0xf9, 0xc4, 0xbd, 0x3e, 0x6d, 0x33, 0xc3, 0x12, 0x71, 0x55, 0x8e, 0xef, 0x18, 0x49,
	0x9d, 0x14, 0xa5, 0x85, 0x31, 0xf5, 0x1e, 0x6e, 0x0a, 0x8f, 0x6c, 0xbb, 0xc7, 0x86, 0xdd, 0x1b,
	0x9e, 0x52, 0xdb, 0x7c, 0x35, 0xec, 0xf1, 0xa8, 0xba, 0x98, 0xfb, 0xed, 0x42, 0xb6, 0xc7, 0x43,
	0x25, 0x1d, 0x87, 0x4a, 0x0f, 0x43, 0x85, 0xa7, 0xf5, 0x7f, 0xa4, 0xc4, 0x1f, 0x8d, 0xf9, 0xfe,
	0x7f, 0x98, 0x2f, 0xc7, 0xd4, 0xdc, 0x97, 0xe3, 0xa2, 0x91, 0x16, 0xc7, 0x59, 0x4e, 0x84, 0x59,
	0xe3, 0x63, 0x06, 0xb2, 0xbc, 0xa5, 0xfa, 0x1e, 0xae, 0x19, 0x96, 0xa5, 0xe3, 0xfa, 0x77, 0x1c,
	0x57, 0x6f, 0x89, 0x9f, 0x1e, 0xea, 0x9d, 0x75, 0x3f, 0x45, 0x06, 0xd5, 0xfa, 0xfa, 0xff, 0x26,
	0xea, 0xef, 0xa0, 0xdc, 0xa5, 0xbe, 0xce, 0xec, 0x8e, 0xa3, 0xb7, 0xc6, 0x3a, 0x33, 0xd5, 0xdb,
	0xcb, 0xbf, 0x46, 0x07, 0xd5, 0xdd, 0x55, 0x9f, 0xaa, 0xaa, 0x09, 0x37, 0x79, 0x67, 0xc2, 0x4d,
	0x26, 0x7d, 0xe2, 0xf5, 0xf8, 0x47, 0xeb, 0x2f, 0x46, 0x83, 0xea, 0xfe, 0x45, 0x6e, 0x4f, 0xea,
	0x1f, 0xa0, 0xdc, 0x9b, 0xa2, 0x96, 0x5a, 0x5b, 0x89, 0xb4, 0x41, 0x55, 0x5b, 0x83, 0x3c, 0xf5,
	0x8f, 0xb0, 0xc5, 0x66, 0xb6, 0x48, 0xdd, 0x5b, 0xb3, 0x83, 0x83, 0xea, 0x9d, 0xb5, 0x7b, 0x7c,
	0xb4, 0xfb, 0xef, 0xcf, 0xb5, 0xd4, 0xa7, 0xcf, 0xb5, 0xd4, 0xff, 0x3f, 0xd7, 0x52, 0x7f, 0xff,
	0x52, 0xbb, 0xf2, 0xe9, 0x4b, 0xed, 0xca, 0xff, 0xbe, 0xd4, 0xae, 0xfc, 0x29, 0x3d, 0x7a, 0xd4,
	0xca, 0xe1, 0x0f, 0xb6, 0xc7, 0xdf, 0x07, 0x00, 0x00, 0xff, 0xff, 0xf7, 0xf6, 0x57, 0xe0, 0xa9,
	0x13, 0x00, 0x00,
}
