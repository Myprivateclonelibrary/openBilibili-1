// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v0/PayLive.proto

package v0

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type PayLiveAddReq struct {
	// 平台
	Platform string `protobuf:"bytes,1,opt,name=platform,proto3" json:"platform"`
	// 商品名称
	RoomId int64 `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id"`
	// 商品名称
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title"`
	// 鉴权状态，1开，0关
	Status int64 `protobuf:"varint,4,opt,name=status,proto3" json:"status"`
	// 开始时间
	StartTime string `protobuf:"bytes,5,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	// 结束时间
	EndTime string `protobuf:"bytes,6,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	// 正片结束时间
	LiveEndTime string `protobuf:"bytes,7,opt,name=live_end_time,json=liveEndTime,proto3" json:"live_end_time"`
	// 正片保底图
	LivePic string `protobuf:"bytes,8,opt,name=live_pic,json=livePic,proto3" json:"live_pic"`
	// 广告图
	AdPic string `protobuf:"bytes,9,opt,name=ad_pic,json=adPic,proto3" json:"ad_pic"`
	// 购买链接
	GoodsLink string `protobuf:"bytes,10,opt,name=goods_link,json=goodsLink,proto3" json:"goods_link"`
	// 门票id，逗号分隔
	GoodsId string `protobuf:"bytes,11,opt,name=goods_id,json=goodsId,proto3" json:"goods_id"`
	// 引导购票id
	BuyGoodsId int64 `protobuf:"varint,12,opt,name=buy_goods_id,json=buyGoodsId,proto3" json:"buy_goods_id"`
	// ip限制，0不限制，1仅限大陆，2仅限港澳台，3大陆+港澳台
	IpLimit int64 `protobuf:"varint,13,opt,name=ip_limit,json=ipLimit,proto3" json:"ip_limit"`
}

func (m *PayLiveAddReq) Reset()         { *m = PayLiveAddReq{} }
func (m *PayLiveAddReq) String() string { return proto.CompactTextString(m) }
func (*PayLiveAddReq) ProtoMessage()    {}
func (*PayLiveAddReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{0}
}
func (m *PayLiveAddReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveAddReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveAddReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveAddReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveAddReq.Merge(dst, src)
}
func (m *PayLiveAddReq) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveAddReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveAddReq.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveAddReq proto.InternalMessageInfo

func (m *PayLiveAddReq) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *PayLiveAddReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *PayLiveAddReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *PayLiveAddReq) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *PayLiveAddReq) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *PayLiveAddReq) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *PayLiveAddReq) GetLiveEndTime() string {
	if m != nil {
		return m.LiveEndTime
	}
	return ""
}

func (m *PayLiveAddReq) GetLivePic() string {
	if m != nil {
		return m.LivePic
	}
	return ""
}

func (m *PayLiveAddReq) GetAdPic() string {
	if m != nil {
		return m.AdPic
	}
	return ""
}

func (m *PayLiveAddReq) GetGoodsLink() string {
	if m != nil {
		return m.GoodsLink
	}
	return ""
}

func (m *PayLiveAddReq) GetGoodsId() string {
	if m != nil {
		return m.GoodsId
	}
	return ""
}

func (m *PayLiveAddReq) GetBuyGoodsId() int64 {
	if m != nil {
		return m.BuyGoodsId
	}
	return 0
}

func (m *PayLiveAddReq) GetIpLimit() int64 {
	if m != nil {
		return m.IpLimit
	}
	return 0
}

type PayLiveAddResp struct {
	// 返回code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// 返回msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	// 返回data
	Data *PayLiveAddResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *PayLiveAddResp) Reset()         { *m = PayLiveAddResp{} }
func (m *PayLiveAddResp) String() string { return proto.CompactTextString(m) }
func (*PayLiveAddResp) ProtoMessage()    {}
func (*PayLiveAddResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{1}
}
func (m *PayLiveAddResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveAddResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveAddResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveAddResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveAddResp.Merge(dst, src)
}
func (m *PayLiveAddResp) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveAddResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveAddResp.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveAddResp proto.InternalMessageInfo

func (m *PayLiveAddResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *PayLiveAddResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *PayLiveAddResp) GetData() *PayLiveAddResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type PayLiveAddResp_Data struct {
}

func (m *PayLiveAddResp_Data) Reset()         { *m = PayLiveAddResp_Data{} }
func (m *PayLiveAddResp_Data) String() string { return proto.CompactTextString(m) }
func (*PayLiveAddResp_Data) ProtoMessage()    {}
func (*PayLiveAddResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{1, 0}
}
func (m *PayLiveAddResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveAddResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveAddResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveAddResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveAddResp_Data.Merge(dst, src)
}
func (m *PayLiveAddResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveAddResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveAddResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveAddResp_Data proto.InternalMessageInfo

type PayLiveUpdateReq struct {
	// id
	LiveId int64 `protobuf:"varint,1,opt,name=live_id,json=liveId,proto3" json:"live_id"`
	// 平台
	Platform string `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform"`
	// 商品名称
	RoomId int64 `protobuf:"varint,3,opt,name=room_id,json=roomId,proto3" json:"room_id"`
	// 商品名称
	Title string `protobuf:"bytes,4,opt,name=title,proto3" json:"title"`
	// 鉴权状态，1开，0关
	Status int64 `protobuf:"varint,5,opt,name=status,proto3" json:"status"`
	// 开始时间
	StartTime string `protobuf:"bytes,6,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	// 结束时间
	EndTime string `protobuf:"bytes,7,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	// 正片结束时间
	LiveEndTime string `protobuf:"bytes,8,opt,name=live_end_time,json=liveEndTime,proto3" json:"live_end_time"`
	// 正片保底图
	LivePic string `protobuf:"bytes,9,opt,name=live_pic,json=livePic,proto3" json:"live_pic"`
	// 广告图
	AdPic string `protobuf:"bytes,10,opt,name=ad_pic,json=adPic,proto3" json:"ad_pic"`
	// 购买链接
	GoodsLink string `protobuf:"bytes,11,opt,name=goods_link,json=goodsLink,proto3" json:"goods_link"`
	// 门票id，逗号分隔
	GoodsId string `protobuf:"bytes,12,opt,name=goods_id,json=goodsId,proto3" json:"goods_id"`
	// 引导购票id
	BuyGoodsId int64 `protobuf:"varint,13,opt,name=buy_goods_id,json=buyGoodsId,proto3" json:"buy_goods_id"`
	// ip限制，0不限制，1仅限大陆，2仅限港澳台，3大陆+港澳台
	IpLimit int64 `protobuf:"varint,14,opt,name=ip_limit,json=ipLimit,proto3" json:"ip_limit"`
}

func (m *PayLiveUpdateReq) Reset()         { *m = PayLiveUpdateReq{} }
func (m *PayLiveUpdateReq) String() string { return proto.CompactTextString(m) }
func (*PayLiveUpdateReq) ProtoMessage()    {}
func (*PayLiveUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{2}
}
func (m *PayLiveUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveUpdateReq.Merge(dst, src)
}
func (m *PayLiveUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveUpdateReq proto.InternalMessageInfo

func (m *PayLiveUpdateReq) GetLiveId() int64 {
	if m != nil {
		return m.LiveId
	}
	return 0
}

func (m *PayLiveUpdateReq) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *PayLiveUpdateReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *PayLiveUpdateReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *PayLiveUpdateReq) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *PayLiveUpdateReq) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *PayLiveUpdateReq) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *PayLiveUpdateReq) GetLiveEndTime() string {
	if m != nil {
		return m.LiveEndTime
	}
	return ""
}

func (m *PayLiveUpdateReq) GetLivePic() string {
	if m != nil {
		return m.LivePic
	}
	return ""
}

func (m *PayLiveUpdateReq) GetAdPic() string {
	if m != nil {
		return m.AdPic
	}
	return ""
}

func (m *PayLiveUpdateReq) GetGoodsLink() string {
	if m != nil {
		return m.GoodsLink
	}
	return ""
}

func (m *PayLiveUpdateReq) GetGoodsId() string {
	if m != nil {
		return m.GoodsId
	}
	return ""
}

func (m *PayLiveUpdateReq) GetBuyGoodsId() int64 {
	if m != nil {
		return m.BuyGoodsId
	}
	return 0
}

func (m *PayLiveUpdateReq) GetIpLimit() int64 {
	if m != nil {
		return m.IpLimit
	}
	return 0
}

type PayLiveUpdateResp struct {
	// 返回code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// 返回msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	// 返回data
	Data *PayLiveUpdateResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *PayLiveUpdateResp) Reset()         { *m = PayLiveUpdateResp{} }
func (m *PayLiveUpdateResp) String() string { return proto.CompactTextString(m) }
func (*PayLiveUpdateResp) ProtoMessage()    {}
func (*PayLiveUpdateResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{3}
}
func (m *PayLiveUpdateResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveUpdateResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveUpdateResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveUpdateResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveUpdateResp.Merge(dst, src)
}
func (m *PayLiveUpdateResp) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveUpdateResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveUpdateResp.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveUpdateResp proto.InternalMessageInfo

func (m *PayLiveUpdateResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *PayLiveUpdateResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *PayLiveUpdateResp) GetData() *PayLiveUpdateResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type PayLiveUpdateResp_Data struct {
}

func (m *PayLiveUpdateResp_Data) Reset()         { *m = PayLiveUpdateResp_Data{} }
func (m *PayLiveUpdateResp_Data) String() string { return proto.CompactTextString(m) }
func (*PayLiveUpdateResp_Data) ProtoMessage()    {}
func (*PayLiveUpdateResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{3, 0}
}
func (m *PayLiveUpdateResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveUpdateResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveUpdateResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveUpdateResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveUpdateResp_Data.Merge(dst, src)
}
func (m *PayLiveUpdateResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveUpdateResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveUpdateResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveUpdateResp_Data proto.InternalMessageInfo

type PayLiveGetListReq struct {
	// 房间id
	RoomId int64 `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id"`
	// 商品名称
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title"`
	// ip限制
	IpLimit int64 `protobuf:"varint,3,opt,name=ip_limit,json=ipLimit,proto3" json:"ip_limit"`
	// 页号，0开始
	PageNum int64 `protobuf:"varint,4,opt,name=page_num,json=pageNum,proto3" json:"page_num"`
	// 每页个数
	PageSize int64 `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size"`
}

func (m *PayLiveGetListReq) Reset()         { *m = PayLiveGetListReq{} }
func (m *PayLiveGetListReq) String() string { return proto.CompactTextString(m) }
func (*PayLiveGetListReq) ProtoMessage()    {}
func (*PayLiveGetListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{4}
}
func (m *PayLiveGetListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveGetListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveGetListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveGetListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveGetListReq.Merge(dst, src)
}
func (m *PayLiveGetListReq) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveGetListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveGetListReq.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveGetListReq proto.InternalMessageInfo

func (m *PayLiveGetListReq) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *PayLiveGetListReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *PayLiveGetListReq) GetIpLimit() int64 {
	if m != nil {
		return m.IpLimit
	}
	return 0
}

func (m *PayLiveGetListReq) GetPageNum() int64 {
	if m != nil {
		return m.PageNum
	}
	return 0
}

func (m *PayLiveGetListReq) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

type PayLiveGetListResp struct {
	// 返回code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// 返回msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	// 返回data
	Data *PayLiveGetListResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *PayLiveGetListResp) Reset()         { *m = PayLiveGetListResp{} }
func (m *PayLiveGetListResp) String() string { return proto.CompactTextString(m) }
func (*PayLiveGetListResp) ProtoMessage()    {}
func (*PayLiveGetListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{5}
}
func (m *PayLiveGetListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveGetListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveGetListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveGetListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveGetListResp.Merge(dst, src)
}
func (m *PayLiveGetListResp) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveGetListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveGetListResp.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveGetListResp proto.InternalMessageInfo

func (m *PayLiveGetListResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *PayLiveGetListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *PayLiveGetListResp) GetData() *PayLiveGetListResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type PayLiveGetListResp_PageInfo struct {
	// 记录总数
	TotalCount int64 `protobuf:"varint,1,opt,name=total_count,json=totalCount,proto3" json:"total_count"`
	// 当前页号
	PageNum int64 `protobuf:"varint,2,opt,name=page_num,json=pageNum,proto3" json:"page_num"`
}

func (m *PayLiveGetListResp_PageInfo) Reset()         { *m = PayLiveGetListResp_PageInfo{} }
func (m *PayLiveGetListResp_PageInfo) String() string { return proto.CompactTextString(m) }
func (*PayLiveGetListResp_PageInfo) ProtoMessage()    {}
func (*PayLiveGetListResp_PageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{5, 0}
}
func (m *PayLiveGetListResp_PageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveGetListResp_PageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveGetListResp_PageInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveGetListResp_PageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveGetListResp_PageInfo.Merge(dst, src)
}
func (m *PayLiveGetListResp_PageInfo) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveGetListResp_PageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveGetListResp_PageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveGetListResp_PageInfo proto.InternalMessageInfo

func (m *PayLiveGetListResp_PageInfo) GetTotalCount() int64 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *PayLiveGetListResp_PageInfo) GetPageNum() int64 {
	if m != nil {
		return m.PageNum
	}
	return 0
}

type PayLiveGetListResp_GoodsInfo struct {
	// 房间id
	RoomId int64 `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id"`
	// 付费直播id
	LiveId int64 `protobuf:"varint,2,opt,name=live_id,json=liveId,proto3" json:"live_id"`
	// 标题
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title"`
	// 平台
	Platform string `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform"`
	// 生效状态，1生效，0未生效
	PayLiveStatus int64 `protobuf:"varint,5,opt,name=pay_live_status,json=payLiveStatus,proto3" json:"pay_live_status"`
	// 开始购票时间
	StartTime string `protobuf:"bytes,6,opt,name=start_time,json=startTime,proto3" json:"start_time"`
	// 结束购票时间
	EndTime string `protobuf:"bytes,7,opt,name=end_time,json=endTime,proto3" json:"end_time"`
	// 正片结束
	LiveEndTime string `protobuf:"bytes,8,opt,name=live_end_time,json=liveEndTime,proto3" json:"live_end_time"`
	// 正片保底图
	LivePic string `protobuf:"bytes,9,opt,name=live_pic,json=livePic,proto3" json:"live_pic"`
	// 广告图
	AdPic string `protobuf:"bytes,10,opt,name=ad_pic,json=adPic,proto3" json:"ad_pic"`
	// 购票链接
	GoodsLink string `protobuf:"bytes,11,opt,name=goods_link,json=goodsLink,proto3" json:"goods_link"`
	// 购票id
	GoodsId string `protobuf:"bytes,12,opt,name=goods_id,json=goodsId,proto3" json:"goods_id"`
	// 引导购票id
	BuyGoodsId int64 `protobuf:"varint,13,opt,name=buy_goods_id,json=buyGoodsId,proto3" json:"buy_goods_id"`
	// ip限制
	IpLimit int64 `protobuf:"varint,14,opt,name=ip_limit,json=ipLimit,proto3" json:"ip_limit"`
	// 鉴权状态，0关闭，1开启
	Status int64 `protobuf:"varint,15,opt,name=status,proto3" json:"status"`
}

func (m *PayLiveGetListResp_GoodsInfo) Reset()         { *m = PayLiveGetListResp_GoodsInfo{} }
func (m *PayLiveGetListResp_GoodsInfo) String() string { return proto.CompactTextString(m) }
func (*PayLiveGetListResp_GoodsInfo) ProtoMessage()    {}
func (*PayLiveGetListResp_GoodsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{5, 1}
}
func (m *PayLiveGetListResp_GoodsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveGetListResp_GoodsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveGetListResp_GoodsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveGetListResp_GoodsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveGetListResp_GoodsInfo.Merge(dst, src)
}
func (m *PayLiveGetListResp_GoodsInfo) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveGetListResp_GoodsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveGetListResp_GoodsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveGetListResp_GoodsInfo proto.InternalMessageInfo

func (m *PayLiveGetListResp_GoodsInfo) GetRoomId() int64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *PayLiveGetListResp_GoodsInfo) GetLiveId() int64 {
	if m != nil {
		return m.LiveId
	}
	return 0
}

func (m *PayLiveGetListResp_GoodsInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *PayLiveGetListResp_GoodsInfo) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *PayLiveGetListResp_GoodsInfo) GetPayLiveStatus() int64 {
	if m != nil {
		return m.PayLiveStatus
	}
	return 0
}

func (m *PayLiveGetListResp_GoodsInfo) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *PayLiveGetListResp_GoodsInfo) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *PayLiveGetListResp_GoodsInfo) GetLiveEndTime() string {
	if m != nil {
		return m.LiveEndTime
	}
	return ""
}

func (m *PayLiveGetListResp_GoodsInfo) GetLivePic() string {
	if m != nil {
		return m.LivePic
	}
	return ""
}

func (m *PayLiveGetListResp_GoodsInfo) GetAdPic() string {
	if m != nil {
		return m.AdPic
	}
	return ""
}

func (m *PayLiveGetListResp_GoodsInfo) GetGoodsLink() string {
	if m != nil {
		return m.GoodsLink
	}
	return ""
}

func (m *PayLiveGetListResp_GoodsInfo) GetGoodsId() string {
	if m != nil {
		return m.GoodsId
	}
	return ""
}

func (m *PayLiveGetListResp_GoodsInfo) GetBuyGoodsId() int64 {
	if m != nil {
		return m.BuyGoodsId
	}
	return 0
}

func (m *PayLiveGetListResp_GoodsInfo) GetIpLimit() int64 {
	if m != nil {
		return m.IpLimit
	}
	return 0
}

func (m *PayLiveGetListResp_GoodsInfo) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

type PayLiveGetListResp_Data struct {
	//
	PageInfo *PayLiveGetListResp_PageInfo `protobuf:"bytes,1,opt,name=page_info,json=pageInfo" json:"page_info"`
	//
	GoodsInfo []*PayLiveGetListResp_GoodsInfo `protobuf:"bytes,2,rep,name=goods_info,json=goodsInfo" json:"goods_info"`
}

func (m *PayLiveGetListResp_Data) Reset()         { *m = PayLiveGetListResp_Data{} }
func (m *PayLiveGetListResp_Data) String() string { return proto.CompactTextString(m) }
func (*PayLiveGetListResp_Data) ProtoMessage()    {}
func (*PayLiveGetListResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{5, 2}
}
func (m *PayLiveGetListResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveGetListResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveGetListResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveGetListResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveGetListResp_Data.Merge(dst, src)
}
func (m *PayLiveGetListResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveGetListResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveGetListResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveGetListResp_Data proto.InternalMessageInfo

func (m *PayLiveGetListResp_Data) GetPageInfo() *PayLiveGetListResp_PageInfo {
	if m != nil {
		return m.PageInfo
	}
	return nil
}

func (m *PayLiveGetListResp_Data) GetGoodsInfo() []*PayLiveGetListResp_GoodsInfo {
	if m != nil {
		return m.GoodsInfo
	}
	return nil
}

type PayLiveCloseReq struct {
	// 直播id
	LiveId int64 `protobuf:"varint,1,opt,name=live_id,json=liveId,proto3" json:"live_id"`
}

func (m *PayLiveCloseReq) Reset()         { *m = PayLiveCloseReq{} }
func (m *PayLiveCloseReq) String() string { return proto.CompactTextString(m) }
func (*PayLiveCloseReq) ProtoMessage()    {}
func (*PayLiveCloseReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{6}
}
func (m *PayLiveCloseReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveCloseReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveCloseReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveCloseReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveCloseReq.Merge(dst, src)
}
func (m *PayLiveCloseReq) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveCloseReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveCloseReq.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveCloseReq proto.InternalMessageInfo

func (m *PayLiveCloseReq) GetLiveId() int64 {
	if m != nil {
		return m.LiveId
	}
	return 0
}

type PayLiveCloseResp struct {
	// 返回code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// 返回msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	// 返回data
	Data *PayLiveCloseResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *PayLiveCloseResp) Reset()         { *m = PayLiveCloseResp{} }
func (m *PayLiveCloseResp) String() string { return proto.CompactTextString(m) }
func (*PayLiveCloseResp) ProtoMessage()    {}
func (*PayLiveCloseResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{7}
}
func (m *PayLiveCloseResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveCloseResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveCloseResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveCloseResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveCloseResp.Merge(dst, src)
}
func (m *PayLiveCloseResp) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveCloseResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveCloseResp.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveCloseResp proto.InternalMessageInfo

func (m *PayLiveCloseResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *PayLiveCloseResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *PayLiveCloseResp) GetData() *PayLiveCloseResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type PayLiveCloseResp_Data struct {
}

func (m *PayLiveCloseResp_Data) Reset()         { *m = PayLiveCloseResp_Data{} }
func (m *PayLiveCloseResp_Data) String() string { return proto.CompactTextString(m) }
func (*PayLiveCloseResp_Data) ProtoMessage()    {}
func (*PayLiveCloseResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{7, 0}
}
func (m *PayLiveCloseResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveCloseResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveCloseResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveCloseResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveCloseResp_Data.Merge(dst, src)
}
func (m *PayLiveCloseResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveCloseResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveCloseResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveCloseResp_Data proto.InternalMessageInfo

type PayLiveOpenReq struct {
	// 直播id
	LiveId int64 `protobuf:"varint,1,opt,name=live_id,json=liveId,proto3" json:"live_id"`
}

func (m *PayLiveOpenReq) Reset()         { *m = PayLiveOpenReq{} }
func (m *PayLiveOpenReq) String() string { return proto.CompactTextString(m) }
func (*PayLiveOpenReq) ProtoMessage()    {}
func (*PayLiveOpenReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{8}
}
func (m *PayLiveOpenReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveOpenReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveOpenReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveOpenReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveOpenReq.Merge(dst, src)
}
func (m *PayLiveOpenReq) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveOpenReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveOpenReq.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveOpenReq proto.InternalMessageInfo

func (m *PayLiveOpenReq) GetLiveId() int64 {
	if m != nil {
		return m.LiveId
	}
	return 0
}

type PayLiveOpenResp struct {
	// 返回code
	Code int64 `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	// 返回msg
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg"`
	// 返回data
	Data *PayLiveOpenResp_Data `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *PayLiveOpenResp) Reset()         { *m = PayLiveOpenResp{} }
func (m *PayLiveOpenResp) String() string { return proto.CompactTextString(m) }
func (*PayLiveOpenResp) ProtoMessage()    {}
func (*PayLiveOpenResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{9}
}
func (m *PayLiveOpenResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveOpenResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveOpenResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveOpenResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveOpenResp.Merge(dst, src)
}
func (m *PayLiveOpenResp) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveOpenResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveOpenResp.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveOpenResp proto.InternalMessageInfo

func (m *PayLiveOpenResp) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *PayLiveOpenResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *PayLiveOpenResp) GetData() *PayLiveOpenResp_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

type PayLiveOpenResp_Data struct {
}

func (m *PayLiveOpenResp_Data) Reset()         { *m = PayLiveOpenResp_Data{} }
func (m *PayLiveOpenResp_Data) String() string { return proto.CompactTextString(m) }
func (*PayLiveOpenResp_Data) ProtoMessage()    {}
func (*PayLiveOpenResp_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_PayLive_994e7b0f12a11a5e, []int{9, 0}
}
func (m *PayLiveOpenResp_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayLiveOpenResp_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayLiveOpenResp_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PayLiveOpenResp_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayLiveOpenResp_Data.Merge(dst, src)
}
func (m *PayLiveOpenResp_Data) XXX_Size() int {
	return m.Size()
}
func (m *PayLiveOpenResp_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_PayLiveOpenResp_Data.DiscardUnknown(m)
}

var xxx_messageInfo_PayLiveOpenResp_Data proto.InternalMessageInfo

func init() {
	proto.RegisterType((*PayLiveAddReq)(nil), "av.v0.PayLiveAddReq")
	proto.RegisterType((*PayLiveAddResp)(nil), "av.v0.PayLiveAddResp")
	proto.RegisterType((*PayLiveAddResp_Data)(nil), "av.v0.PayLiveAddResp.Data")
	proto.RegisterType((*PayLiveUpdateReq)(nil), "av.v0.PayLiveUpdateReq")
	proto.RegisterType((*PayLiveUpdateResp)(nil), "av.v0.PayLiveUpdateResp")
	proto.RegisterType((*PayLiveUpdateResp_Data)(nil), "av.v0.PayLiveUpdateResp.Data")
	proto.RegisterType((*PayLiveGetListReq)(nil), "av.v0.PayLiveGetListReq")
	proto.RegisterType((*PayLiveGetListResp)(nil), "av.v0.PayLiveGetListResp")
	proto.RegisterType((*PayLiveGetListResp_PageInfo)(nil), "av.v0.PayLiveGetListResp.PageInfo")
	proto.RegisterType((*PayLiveGetListResp_GoodsInfo)(nil), "av.v0.PayLiveGetListResp.GoodsInfo")
	proto.RegisterType((*PayLiveGetListResp_Data)(nil), "av.v0.PayLiveGetListResp.Data")
	proto.RegisterType((*PayLiveCloseReq)(nil), "av.v0.PayLiveCloseReq")
	proto.RegisterType((*PayLiveCloseResp)(nil), "av.v0.PayLiveCloseResp")
	proto.RegisterType((*PayLiveCloseResp_Data)(nil), "av.v0.PayLiveCloseResp.Data")
	proto.RegisterType((*PayLiveOpenReq)(nil), "av.v0.PayLiveOpenReq")
	proto.RegisterType((*PayLiveOpenResp)(nil), "av.v0.PayLiveOpenResp")
	proto.RegisterType((*PayLiveOpenResp_Data)(nil), "av.v0.PayLiveOpenResp.Data")
}
func (m *PayLiveAddReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveAddReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Platform) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.RoomId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Status))
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	if len(m.LiveEndTime) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.LiveEndTime)))
		i += copy(dAtA[i:], m.LiveEndTime)
	}
	if len(m.LivePic) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.LivePic)))
		i += copy(dAtA[i:], m.LivePic)
	}
	if len(m.AdPic) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.AdPic)))
		i += copy(dAtA[i:], m.AdPic)
	}
	if len(m.GoodsLink) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.GoodsLink)))
		i += copy(dAtA[i:], m.GoodsLink)
	}
	if len(m.GoodsId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.GoodsId)))
		i += copy(dAtA[i:], m.GoodsId)
	}
	if m.BuyGoodsId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.BuyGoodsId))
	}
	if m.IpLimit != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.IpLimit))
	}
	return i, nil
}

func (m *PayLiveAddResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveAddResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Data.Size()))
		n1, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *PayLiveAddResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveAddResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PayLiveUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LiveId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.LiveId))
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.RoomId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.RoomId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Status))
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	if len(m.LiveEndTime) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.LiveEndTime)))
		i += copy(dAtA[i:], m.LiveEndTime)
	}
	if len(m.LivePic) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.LivePic)))
		i += copy(dAtA[i:], m.LivePic)
	}
	if len(m.AdPic) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.AdPic)))
		i += copy(dAtA[i:], m.AdPic)
	}
	if len(m.GoodsLink) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.GoodsLink)))
		i += copy(dAtA[i:], m.GoodsLink)
	}
	if len(m.GoodsId) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.GoodsId)))
		i += copy(dAtA[i:], m.GoodsId)
	}
	if m.BuyGoodsId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.BuyGoodsId))
	}
	if m.IpLimit != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.IpLimit))
	}
	return i, nil
}

func (m *PayLiveUpdateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveUpdateResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Data.Size()))
		n2, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *PayLiveUpdateResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveUpdateResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PayLiveGetListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveGetListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.RoomId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.IpLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.IpLimit))
	}
	if m.PageNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.PageNum))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *PayLiveGetListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveGetListResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Data.Size()))
		n3, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *PayLiveGetListResp_PageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveGetListResp_PageInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.TotalCount))
	}
	if m.PageNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.PageNum))
	}
	return i, nil
}

func (m *PayLiveGetListResp_GoodsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveGetListResp_GoodsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.RoomId))
	}
	if m.LiveId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.LiveId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.PayLiveStatus != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.PayLiveStatus))
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	if len(m.LiveEndTime) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.LiveEndTime)))
		i += copy(dAtA[i:], m.LiveEndTime)
	}
	if len(m.LivePic) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.LivePic)))
		i += copy(dAtA[i:], m.LivePic)
	}
	if len(m.AdPic) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.AdPic)))
		i += copy(dAtA[i:], m.AdPic)
	}
	if len(m.GoodsLink) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.GoodsLink)))
		i += copy(dAtA[i:], m.GoodsLink)
	}
	if len(m.GoodsId) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.GoodsId)))
		i += copy(dAtA[i:], m.GoodsId)
	}
	if m.BuyGoodsId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.BuyGoodsId))
	}
	if m.IpLimit != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.IpLimit))
	}
	if m.Status != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *PayLiveGetListResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveGetListResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PageInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.PageInfo.Size()))
		n4, err := m.PageInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.GoodsInfo) > 0 {
		for _, msg := range m.GoodsInfo {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPayLive(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PayLiveCloseReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveCloseReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LiveId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.LiveId))
	}
	return i, nil
}

func (m *PayLiveCloseResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveCloseResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Data.Size()))
		n5, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *PayLiveCloseResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveCloseResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PayLiveOpenReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveOpenReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LiveId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.LiveId))
	}
	return i, nil
}

func (m *PayLiveOpenResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveOpenResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPayLive(dAtA, i, uint64(m.Data.Size()))
		n6, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *PayLiveOpenResp_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayLiveOpenResp_Data) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintPayLive(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PayLiveAddReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.RoomId != 0 {
		n += 1 + sovPayLive(uint64(m.RoomId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovPayLive(uint64(m.Status))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.LiveEndTime)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.LivePic)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.AdPic)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.GoodsLink)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.GoodsId)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.BuyGoodsId != 0 {
		n += 1 + sovPayLive(uint64(m.BuyGoodsId))
	}
	if m.IpLimit != 0 {
		n += 1 + sovPayLive(uint64(m.IpLimit))
	}
	return n
}

func (m *PayLiveAddResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPayLive(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovPayLive(uint64(l))
	}
	return n
}

func (m *PayLiveAddResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PayLiveUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiveId != 0 {
		n += 1 + sovPayLive(uint64(m.LiveId))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.RoomId != 0 {
		n += 1 + sovPayLive(uint64(m.RoomId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovPayLive(uint64(m.Status))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.LiveEndTime)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.LivePic)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.AdPic)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.GoodsLink)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.GoodsId)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.BuyGoodsId != 0 {
		n += 1 + sovPayLive(uint64(m.BuyGoodsId))
	}
	if m.IpLimit != 0 {
		n += 1 + sovPayLive(uint64(m.IpLimit))
	}
	return n
}

func (m *PayLiveUpdateResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPayLive(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovPayLive(uint64(l))
	}
	return n
}

func (m *PayLiveUpdateResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PayLiveGetListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovPayLive(uint64(m.RoomId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.IpLimit != 0 {
		n += 1 + sovPayLive(uint64(m.IpLimit))
	}
	if m.PageNum != 0 {
		n += 1 + sovPayLive(uint64(m.PageNum))
	}
	if m.PageSize != 0 {
		n += 1 + sovPayLive(uint64(m.PageSize))
	}
	return n
}

func (m *PayLiveGetListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPayLive(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovPayLive(uint64(l))
	}
	return n
}

func (m *PayLiveGetListResp_PageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalCount != 0 {
		n += 1 + sovPayLive(uint64(m.TotalCount))
	}
	if m.PageNum != 0 {
		n += 1 + sovPayLive(uint64(m.PageNum))
	}
	return n
}

func (m *PayLiveGetListResp_GoodsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovPayLive(uint64(m.RoomId))
	}
	if m.LiveId != 0 {
		n += 1 + sovPayLive(uint64(m.LiveId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.PayLiveStatus != 0 {
		n += 1 + sovPayLive(uint64(m.PayLiveStatus))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.LiveEndTime)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.LivePic)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.AdPic)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.GoodsLink)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	l = len(m.GoodsId)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.BuyGoodsId != 0 {
		n += 1 + sovPayLive(uint64(m.BuyGoodsId))
	}
	if m.IpLimit != 0 {
		n += 1 + sovPayLive(uint64(m.IpLimit))
	}
	if m.Status != 0 {
		n += 1 + sovPayLive(uint64(m.Status))
	}
	return n
}

func (m *PayLiveGetListResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageInfo != nil {
		l = m.PageInfo.Size()
		n += 1 + l + sovPayLive(uint64(l))
	}
	if len(m.GoodsInfo) > 0 {
		for _, e := range m.GoodsInfo {
			l = e.Size()
			n += 1 + l + sovPayLive(uint64(l))
		}
	}
	return n
}

func (m *PayLiveCloseReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiveId != 0 {
		n += 1 + sovPayLive(uint64(m.LiveId))
	}
	return n
}

func (m *PayLiveCloseResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPayLive(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovPayLive(uint64(l))
	}
	return n
}

func (m *PayLiveCloseResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PayLiveOpenReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiveId != 0 {
		n += 1 + sovPayLive(uint64(m.LiveId))
	}
	return n
}

func (m *PayLiveOpenResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovPayLive(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPayLive(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovPayLive(uint64(l))
	}
	return n
}

func (m *PayLiveOpenResp_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovPayLive(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPayLive(x uint64) (n int) {
	return sovPayLive(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PayLiveAddReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveAddReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveAddReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveEndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveEndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivePic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LivePic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdPic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdPic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyGoodsId", wireType)
			}
			m.BuyGoodsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyGoodsId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpLimit", wireType)
			}
			m.IpLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveAddResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveAddResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveAddResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &PayLiveAddResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveAddResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveId", wireType)
			}
			m.LiveId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveEndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveEndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivePic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LivePic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdPic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdPic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyGoodsId", wireType)
			}
			m.BuyGoodsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyGoodsId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpLimit", wireType)
			}
			m.IpLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveUpdateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveUpdateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveUpdateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &PayLiveUpdateResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveUpdateResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveGetListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveGetListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveGetListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpLimit", wireType)
			}
			m.IpLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNum", wireType)
			}
			m.PageNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveGetListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveGetListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveGetListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &PayLiveGetListResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveGetListResp_PageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNum", wireType)
			}
			m.PageNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveGetListResp_GoodsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoodsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoodsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveId", wireType)
			}
			m.LiveId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayLiveStatus", wireType)
			}
			m.PayLiveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayLiveStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveEndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveEndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivePic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LivePic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdPic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdPic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyGoodsId", wireType)
			}
			m.BuyGoodsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyGoodsId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpLimit", wireType)
			}
			m.IpLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveGetListResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PageInfo == nil {
				m.PageInfo = &PayLiveGetListResp_PageInfo{}
			}
			if err := m.PageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsInfo = append(m.GoodsInfo, &PayLiveGetListResp_GoodsInfo{})
			if err := m.GoodsInfo[len(m.GoodsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveCloseReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveCloseReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveCloseReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveId", wireType)
			}
			m.LiveId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveCloseResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveCloseResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveCloseResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &PayLiveCloseResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveCloseResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveOpenReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveOpenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveOpenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveId", wireType)
			}
			m.LiveId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveOpenResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayLiveOpenResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayLiveOpenResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayLive
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &PayLiveOpenResp_Data{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayLiveOpenResp_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPayLive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayLive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPayLive(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPayLive
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPayLive
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPayLive
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPayLive
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPayLive(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPayLive = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPayLive   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("v0/PayLive.proto", fileDescriptor_PayLive_994e7b0f12a11a5e) }

var fileDescriptor_PayLive_994e7b0f12a11a5e = []byte{
	// 1013 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x97, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xc0, 0xeb, 0xfc, 0x73, 0xf2, 0xd2, 0xb4, 0xdd, 0x81, 0xdd, 0xf5, 0x9a, 0x12, 0x97, 0xb0,
	0x52, 0x2b, 0xa4, 0xa6, 0x55, 0xd0, 0xc2, 0x42, 0x11, 0x12, 0x5d, 0xd0, 0xaa, 0x52, 0xb5, 0x54,
	0xb3, 0x70, 0xe1, 0x12, 0x39, 0xf1, 0x34, 0x8c, 0x36, 0xb1, 0x9d, 0x66, 0x12, 0xa9, 0xfb, 0x15,
	0x10, 0x02, 0xc4, 0xb7, 0x80, 0x2b, 0x7c, 0x07, 0x8e, 0x7b, 0xdc, 0x0b, 0x16, 0x6a, 0x6f, 0xfe,
	0x14, 0x68, 0x9e, 0x1d, 0xff, 0xa9, 0xe2, 0xac, 0xa3, 0x5e, 0x38, 0x70, 0x71, 0xdf, 0xbc, 0x79,
	0xef, 0x4d, 0xde, 0x9b, 0xdf, 0xbc, 0x99, 0xc2, 0xd6, 0xec, 0xf0, 0xe0, 0xcc, 0xbc, 0x3c, 0xe5,
	0x33, 0xd6, 0x76, 0x2f, 0x1c, 0xe1, 0x90, 0xb2, 0x39, 0x6b, 0xcf, 0x0e, 0xf5, 0xfd, 0x01, 0x17,
	0xdf, 0x4f, 0x7b, 0xed, 0xbe, 0x33, 0x3a, 0x18, 0x38, 0x03, 0xe7, 0x00, 0x67, 0x7b, 0xd3, 0x73,
	0x1c, 0xe1, 0x00, 0xa5, 0xc0, 0xab, 0xf5, 0x47, 0x09, 0x1a, 0x61, 0x9c, 0x2f, 0x2c, 0x8b, 0xb2,
	0x31, 0xd9, 0x83, 0xaa, 0x3b, 0x34, 0xc5, 0xb9, 0x73, 0x31, 0xd2, 0x94, 0x1d, 0x65, 0xaf, 0x76,
	0xbc, 0xee, 0x7b, 0x46, 0xa4, 0xa3, 0x91, 0x44, 0x1e, 0x82, 0x7a, 0xe1, 0x38, 0xa3, 0x2e, 0xb7,
	0xb4, 0xc2, 0x8e, 0xb2, 0x57, 0x3c, 0xae, 0xfb, 0x9e, 0x31, 0x57, 0xd1, 0x8a, 0x14, 0x4e, 0x2c,
	0x62, 0x40, 0x59, 0x70, 0x31, 0x64, 0x5a, 0x11, 0x83, 0xd5, 0x7c, 0xcf, 0x08, 0x14, 0x34, 0xf8,
	0x43, 0x5a, 0x50, 0x99, 0x08, 0x53, 0x4c, 0x27, 0x5a, 0x09, 0xa3, 0x80, 0xef, 0x19, 0xa1, 0x86,
	0x86, 0x7f, 0xc9, 0x3e, 0xc0, 0x44, 0x98, 0x17, 0xa2, 0x2b, 0xf8, 0x88, 0x69, 0x65, 0x8c, 0xb4,
	0xe1, 0x7b, 0x46, 0x42, 0x4b, 0x6b, 0x28, 0x7f, 0xc3, 0x47, 0x8c, 0xec, 0x42, 0x95, 0xd9, 0x56,
	0x60, 0x5c, 0x89, 0x73, 0x98, 0xeb, 0xa8, 0xca, 0x6c, 0x0b, 0x0d, 0x1f, 0x41, 0x63, 0xc8, 0x67,
	0xac, 0x1b, 0x59, 0xab, 0x68, 0x7d, 0xc7, 0xf7, 0x8c, 0xf4, 0x04, 0xad, 0xcb, 0xe1, 0x57, 0xa1,
	0xdb, 0x2e, 0x54, 0x71, 0xd6, 0xe5, 0x7d, 0xad, 0x1a, 0xc7, 0x9f, 0xeb, 0xa8, 0x2a, 0xa5, 0x33,
	0xde, 0x27, 0xef, 0x41, 0xc5, 0xb4, 0xd0, 0xac, 0x86, 0x66, 0x98, 0x5b, 0xa0, 0xa1, 0x65, 0xd3,
	0x92, 0x26, 0xfb, 0x00, 0x03, 0xc7, 0xb1, 0x26, 0xdd, 0x21, 0xb7, 0x5f, 0x68, 0x10, 0xa7, 0x16,
	0x6b, 0x69, 0x0d, 0xe5, 0x53, 0x6e, 0xbf, 0x90, 0x4b, 0x07, 0x13, 0xdc, 0xd2, 0xea, 0xf1, 0xd2,
	0x73, 0x1d, 0x55, 0x51, 0x3a, 0xb1, 0x48, 0x07, 0xd6, 0x7b, 0xd3, 0xcb, 0x6e, 0x64, 0xbc, 0x8e,
	0xc5, 0xdd, 0xf2, 0x3d, 0x23, 0xa5, 0xa7, 0xd0, 0x9b, 0x5e, 0x3e, 0x0d, 0x7d, 0x76, 0xa1, 0xca,
	0xdd, 0xee, 0x90, 0x8f, 0xb8, 0xd0, 0x1a, 0x68, 0x8f, 0xc1, 0xe7, 0x3a, 0xaa, 0x72, 0xf7, 0x54,
	0x0a, 0xad, 0x1f, 0x14, 0xd8, 0x48, 0x62, 0x33, 0x71, 0xc9, 0x36, 0x94, 0xfa, 0x8e, 0xc5, 0x90,
	0x99, 0xe2, 0x71, 0xd5, 0xf7, 0x0c, 0x1c, 0x53, 0xfc, 0x92, 0x07, 0x50, 0x1c, 0x4d, 0x06, 0xc8,
	0x49, 0xed, 0x58, 0xf5, 0x3d, 0x43, 0x0e, 0xa9, 0xfc, 0x90, 0xc7, 0x50, 0xb2, 0x4c, 0x61, 0x22,
	0x1f, 0xf5, 0x8e, 0xde, 0x46, 0x8e, 0xdb, 0xe9, 0xe8, 0xed, 0x2f, 0x4d, 0x61, 0x06, 0x41, 0xa5,
	0x2d, 0xc5, 0xaf, 0x5e, 0x81, 0x92, 0xd4, 0xb7, 0xfe, 0x2e, 0xc1, 0x56, 0x68, 0xff, 0xad, 0x6b,
	0x99, 0x82, 0x49, 0x8e, 0x1f, 0x02, 0xee, 0x82, 0x4c, 0x5d, 0x89, 0xe9, 0x0c, 0x55, 0xb4, 0x22,
	0x85, 0x13, 0x2b, 0x45, 0x7b, 0x21, 0x2f, 0xed, 0xc5, 0x1c, 0xb4, 0x97, 0xde, 0x48, 0x7b, 0x39,
	0x27, 0xed, 0x95, 0x55, 0x68, 0x57, 0x57, 0xa2, 0xbd, 0xba, 0x32, 0xed, 0xb5, 0x7c, 0xb4, 0x43,
	0x3e, 0xda, 0xeb, 0xab, 0xd0, 0xbe, 0xbe, 0x0a, 0xed, 0x8d, 0x15, 0x69, 0xdf, 0x58, 0x46, 0xfb,
	0x2f, 0x0a, 0xdc, 0xb9, 0xc1, 0xd7, 0x6d, 0x80, 0x3f, 0x4a, 0x01, 0xff, 0x6e, 0x1a, 0xf8, 0x78,
	0x81, 0xe5, 0xcc, 0xbf, 0x8e, 0x7f, 0xd3, 0x53, 0x26, 0x4e, 0xf9, 0x44, 0x84, 0xd0, 0xcf, 0x21,
	0x55, 0x72, 0x40, 0x5a, 0xc8, 0x80, 0x34, 0x59, 0x99, 0xe2, 0x92, 0xca, 0x48, 0x43, 0xd7, 0x1c,
	0xb0, 0xae, 0x3d, 0x1d, 0x85, 0xdd, 0x3b, 0x38, 0x3e, 0xa1, 0x8e, 0xaa, 0x52, 0x7a, 0x36, 0x1d,
	0x91, 0x0f, 0xa0, 0x86, 0xca, 0x09, 0x7f, 0xc9, 0x42, 0xf2, 0x1b, 0xbe, 0x67, 0xc4, 0x4a, 0x8a,
	0x4e, 0xcf, 0xf9, 0x4b, 0xd6, 0xfa, 0xb3, 0x0a, 0xe4, 0x66, 0x6a, 0xb7, 0xa9, 0xf7, 0x67, 0xa9,
	0x7a, 0x37, 0xd3, 0xf5, 0x4e, 0xac, 0xb0, 0xb8, 0xe0, 0x0c, 0xaa, 0x67, 0xe6, 0x80, 0x9d, 0xd8,
	0xe7, 0x0e, 0x39, 0x84, 0xba, 0x70, 0x84, 0x39, 0xec, 0xf6, 0x9d, 0xa9, 0x2d, 0xc2, 0x5f, 0xb2,
	0xe9, 0x7b, 0x46, 0x52, 0x4d, 0x01, 0x07, 0x4f, 0xa4, 0x9c, 0x2a, 0x50, 0x61, 0x49, 0x81, 0xf4,
	0x5f, 0xcb, 0x50, 0x0b, 0xc0, 0x94, 0x0b, 0xe5, 0xdb, 0xc7, 0x44, 0x8b, 0x2b, 0x64, 0xb7, 0xb8,
	0x37, 0x5e, 0xc0, 0xc9, 0x1e, 0x58, 0x5a, 0xda, 0x03, 0x8f, 0x60, 0xd3, 0x35, 0x2f, 0xbb, 0xb8,
	0x42, 0xaa, 0x8b, 0xbd, 0xe5, 0x7b, 0xc6, 0xcd, 0x29, 0xda, 0x70, 0x83, 0x12, 0x3f, 0xff, 0xbf,
	0xab, 0xfd, 0x07, 0xbb, 0x5a, 0xe2, 0x26, 0xda, 0xcc, 0xba, 0x89, 0xf4, 0xdf, 0x94, 0xa0, 0xdd,
	0x90, 0x67, 0xe1, 0xf9, 0xe5, 0xf6, 0xb9, 0x83, 0x48, 0xd6, 0x3b, 0xad, 0xec, 0x83, 0x34, 0x3f,
	0x30, 0x89, 0x33, 0x2e, 0x1d, 0x83, 0x33, 0x8e, 0x80, 0xd3, 0x79, 0xc5, 0x30, 0x60, 0x61, 0xa7,
	0xb8, 0x57, 0xef, 0xbc, 0x9f, 0x1d, 0x30, 0x3a, 0x19, 0xc9, 0xb2, 0x62, 0xc8, 0xa0, 0xac, 0x72,
	0xaa, 0xf5, 0x31, 0x6c, 0x86, 0xae, 0x4f, 0x86, 0xce, 0x24, 0xff, 0x23, 0xa0, 0xf5, 0x93, 0x12,
	0xbd, 0x1f, 0x42, 0xcf, 0xdb, 0xb4, 0x9b, 0x4f, 0x53, 0xed, 0x66, 0x3b, 0x9d, 0x54, 0x14, 0x7f,
	0x79, 0x77, 0xff, 0x28, 0x7a, 0x5e, 0x7d, 0xed, 0x32, 0x3b, 0x7f, 0x26, 0x3f, 0x2a, 0x51, 0x0d,
	0x02, 0xc7, 0xdb, 0x24, 0xf2, 0x49, 0x2a, 0x91, 0x77, 0xd2, 0x89, 0xcc, 0xc3, 0x2f, 0xcd, 0xa3,
	0xf3, 0x7b, 0x01, 0xd4, 0xd0, 0x81, 0x74, 0xa0, 0x68, 0x5a, 0x16, 0x79, 0x7b, 0xc1, 0x03, 0x6f,
	0xac, 0xdf, 0x5d, 0xf8, 0xec, 0x23, 0x47, 0x50, 0x99, 0xe2, 0x85, 0x48, 0xee, 0x2f, 0xbe, 0x26,
	0xc7, 0xba, 0x96, 0x75, 0x7f, 0x92, 0xcf, 0x41, 0x1d, 0x04, 0x0c, 0x11, 0x2d, 0x03, 0xad, 0xb1,
	0xfe, 0x20, 0x13, 0x3a, 0xf2, 0x18, 0xca, 0x7d, 0xb9, 0x5d, 0xe4, 0xde, 0xc2, 0x3d, 0x1c, 0xeb,
	0xf7, 0x33, 0xf6, 0x96, 0x3c, 0x82, 0x92, 0xe3, 0x32, 0x9b, 0xdc, 0x5d, 0x54, 0xb3, 0xb1, 0x7e,
	0x6f, 0x71, 0x29, 0x8f, 0xb7, 0xff, 0xba, 0x6a, 0x2a, 0xaf, 0xae, 0x9a, 0xca, 0x3f, 0x57, 0x4d,
	0xe5, 0xe7, 0xeb, 0xe6, 0xda, 0xab, 0xeb, 0xe6, 0xda, 0xeb, 0xeb, 0xe6, 0xda, 0x77, 0x85, 0xd9,
	0x61, 0xaf, 0x82, 0xff, 0xb1, 0x7d, 0xf8, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc5, 0xda, 0x3b,
	0x94, 0xfb, 0x0d, 0x00, 0x00,
}
