// Code generated by $GOPATH/src/go-common/app/tool/cache/mc. DO NOT EDIT.

/*
  Package bnj is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=timeFinishKey
		CacheTimeFinish(c context.Context) (int64, error)
		// mc: -key=timeFinishKey -expire=d.timeFinishExpire -encode=raw
		AddCacheTimeFinish(c context.Context, value int64) error
		// mc: -key=lessTimeKey
		CacheLessTime(c context.Context) (int64, error)
		// mc: -key=lessTimeKey -expire=d.lessTimeExpire -encode=raw
		AddCacheLessTime(c context.Context, value int64) error
	}
*/

package bnj

import (
	"context"
	"fmt"
	"strconv"

	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
)

var _ _mc

// CacheTimeFinish get data from mc
func (d *Dao) CacheTimeFinish(c context.Context) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := timeFinishKey()
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheTimeFinish")
		log.Errorv(c, log.KV("CacheTimeFinish", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheTimeFinish")
		log.Errorv(c, log.KV("CacheTimeFinish", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheTimeFinish")
		log.Errorv(c, log.KV("CacheTimeFinish", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheTimeFinish Set data to mc
func (d *Dao) AddCacheTimeFinish(c context.Context, val int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := timeFinishKey()
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.timeFinishExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheTimeFinish")
		log.Errorv(c, log.KV("AddCacheTimeFinish", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLessTime get data from mc
func (d *Dao) CacheLessTime(c context.Context) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := lessTimeKey()
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheLessTime")
		log.Errorv(c, log.KV("CacheLessTime", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLessTime")
		log.Errorv(c, log.KV("CacheLessTime", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLessTime")
		log.Errorv(c, log.KV("CacheLessTime", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheLessTime Set data to mc
func (d *Dao) AddCacheLessTime(c context.Context, val int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := lessTimeKey()
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.lessTimeExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheLessTime")
		log.Errorv(c, log.KV("AddCacheLessTime", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
