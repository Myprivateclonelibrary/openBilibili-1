// Code generated by $GOPATH/src/go-common/app/tool/cache/mc. DO NOT EDIT.

/*
  Package like is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=likeKey
		CacheLike(c context.Context, id int64) (*likemdl.Item, error)
		// mc: -key=likeKey
		CacheLikes(c context.Context, id []int64) (map[int64]*likemdl.Item, error)
		// mc: -key=likeKey -expire=d.mcPerpetualExpire -encode=json
		AddCacheLikes(c context.Context, items map[int64]*likemdl.Item) error
		// mc: -key=likeKey -expire=d.mcPerpetualExpire -encode=json
		AddCacheLike(c context.Context, key int64, value *likemdl.Item) error
		// mc: -key=actSubjectKey
		CacheActSubject(c context.Context, id int64) (*likemdl.SubjectItem, error)
		// mc: -key=actSubjectKey -expire=d.mcPerpetualExpire -encode=pb
		AddCacheActSubject(c context.Context, key int64, value *likemdl.SubjectItem) error
		// mc: -key=actSubjectMaxIDKey
		CacheActSubjectMaxID(c context.Context) (res int64, err error)
		// mc: -key=actSubjectMaxIDKey -expire=d.mcPerpetualExpire -encode=raw
		AddCacheActSubjectMaxID(c context.Context, sid int64) error
		// mc: -key=likeMaxIDKey
		CacheLikeMaxID(c context.Context) (res int64, err error)
		// mc: -key=likeMaxIDKey -expire=d.mcPerpetualExpire -encode=raw
		AddCacheLikeMaxID(c context.Context, lid int64) error
		//mc: -key=likeMissionBuffKey
		CacheLikeMissionBuff(c context.Context, sid int64, mid int64) (res int64, err error)
		//mc: -key=likeMissionBuffKey
		AddCacheLikeMissionBuff(c context.Context, sid int64, val int64, mid int64) error
		//mc: -key=likeMissionGroupIDkey
		CacheMissionGroupItems(ctx context.Context, lids []int64) (map[int64]*likemdl.MissionGroup, error)
		//mc: -key=likeMissionGroupIDkey -expire=d.mcItemExpire -encode=pb
		AddCacheMissionGroupItems(ctx context.Context, val map[int64]*likemdl.MissionGroup) error
		//mc: -key=likeActMissionKey
		CacheActMission(c context.Context, sid int64, lid int64, mid int64) (res int64, err error)
		//mc: -key=likeActMissionKey -expire=d.mcPerpetualExpire -encode=raw
		AddCacheActMission(c context.Context, sid int64, val int64, lid int64, mid int64) error
		//mc: -key=actAchieveKey
		CacheActLikeAchieves(c context.Context, sid int64) (res *likemdl.Achievements, err error)
		//mc: -key=actAchieveKey -expire=d.mcItemExpire -encode=pb
		AddCacheActLikeAchieves(c context.Context, sid int64, res *likemdl.Achievements) error
		//mc: -key=actMissionFriendsKey
		CacheActMissionFriends(c context.Context, sid int64, lid int64) (res *likemdl.ActMissionGroups, err error)
		//mc: -key=actMissionFriendsKey
		DelCacheActMissionFriends(c context.Context, sid int64, lid int64) error
		//mc: -key=actMissionFriendsKey -expire=d.mcItemExpire -encode=pb
		AddCacheActMissionFriends(c context.Context, sid int64, res *likemdl.ActMissionGroups, lid int64) error
		//mc: -key=actUserAchieveKey
		CacheActUserAchieve(c context.Context, id int64) (res *likemdl.ActLikeUserAchievement, err error)
		//mc: -key=actUserAchieveKey -expire=d.mcItemExpire -encode=pb
		AddCacheActUserAchieve(c context.Context, id int64, val *likemdl.ActLikeUserAchievement) error
		//mc: -key=actUserAchieveAwardKey
		CacheActUserAward(c context.Context, id int64) (res int64, err error)
		//mc: -key=actUserAchieveAwardKey -expire=d.mcPerpetualExpire -encode=raw
		AddCacheActUserAward(c context.Context, id int64, val int64) error
		// mc: -key=subjectStatKey
		CacheSubjectStat(c context.Context, sid int64) (*likemdl.SubjectStat, error)
		// mc: -key=subjectStatKey -expire=d.mcSubStatExpire -encode=json
		AddCacheSubjectStat(c context.Context, sid int64, value *likemdl.SubjectStat) error
		// mc: -key=viewRankKey
		CacheViewRank(c context.Context, sid int64) (string, error)
		// mc: -key=viewRankKey -expire=d.mcViewRankExpire -encode=raw
		AddCacheViewRank(c context.Context, sid int64, value string) error
		// mc: -key=likeContentKey
		CacheLikeContent(c context.Context, lids []int64) (res map[int64]*likemdl.LikeContent, err error)
		// mc: -key=likeContentKey -expire=d.mcPerpetualExpire -encode=pb
		AddCacheLikeContent(c context.Context, val map[int64]*likemdl.LikeContent) error
		// mc: -key=sourceItemKey
		CacheSourceItemData(c context.Context, sid int64) ([]int64, error)
		// mc: -key=sourceItemKey -expire=d.mcSourceItemExpire -encode=json
		AddCacheSourceItemData(c context.Context, sid int64, lids []int64) error
		// mc: -key=subjectProtocolKey
		CacheActSubjectProtocol(c context.Context, sid int64) (res *likemdl.ActSubjectProtocol, err error)
		// mc: -key=subjectProtocolKey -expire=d.mcProtocolExpire -encode=pb
		AddCacheActSubjectProtocol(c context.Context, sid int64, value *likemdl.ActSubjectProtocol) error
	}
*/

package like

import (
	"context"
	"fmt"
	"strconv"

	likemdl "go-common/app/interface/main/activity/model/like"
	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
)

var _ _mc

// CacheLike get data from mc
func (d *Dao) CacheLike(c context.Context, id int64) (res *likemdl.Item, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := likeKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheLike")
		log.Errorv(c, log.KV("CacheLike", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &likemdl.Item{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLike")
		log.Errorv(c, log.KV("CacheLike", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLikes get data from mc
func (d *Dao) CacheLikes(c context.Context, ids []int64) (res map[int64]*likemdl.Item, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := likeKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	replies, err := conn.GetMulti(keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLikes")
		log.Errorv(c, log.KV("CacheLikes", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for key, reply := range replies {
		var v *likemdl.Item
		v = &likemdl.Item{}
		err = conn.Scan(reply, v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheLikes")
			log.Errorv(c, log.KV("CacheLikes", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.Item, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheLikes Set data to mc
func (d *Dao) AddCacheLikes(c context.Context, values map[int64]*likemdl.Item) (err error) {
	if len(values) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	for id, val := range values {
		key := likeKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagJSON}
		if err = conn.Set(item); err != nil {
			prom.BusinessErrCount.Incr("mc:AddCacheLikes")
			log.Errorv(c, log.KV("AddCacheLikes", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// AddCacheLike Set data to mc
func (d *Dao) AddCacheLike(c context.Context, id int64, val *likemdl.Item) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := likeKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheLike")
		log.Errorv(c, log.KV("AddCacheLike", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActSubject get data from mc
func (d *Dao) CacheActSubject(c context.Context, id int64) (res *likemdl.SubjectItem, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actSubjectKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheActSubject")
		log.Errorv(c, log.KV("CacheActSubject", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &likemdl.SubjectItem{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActSubject")
		log.Errorv(c, log.KV("CacheActSubject", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActSubject Set data to mc
func (d *Dao) AddCacheActSubject(c context.Context, id int64, val *likemdl.SubjectItem) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actSubjectKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheActSubject")
		log.Errorv(c, log.KV("AddCacheActSubject", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActSubjectMaxID get data from mc
func (d *Dao) CacheActSubjectMaxID(c context.Context) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actSubjectMaxIDKey()
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheActSubjectMaxID")
		log.Errorv(c, log.KV("CacheActSubjectMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActSubjectMaxID")
		log.Errorv(c, log.KV("CacheActSubjectMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActSubjectMaxID")
		log.Errorv(c, log.KV("CacheActSubjectMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheActSubjectMaxID Set data to mc
func (d *Dao) AddCacheActSubjectMaxID(c context.Context, val int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actSubjectMaxIDKey()
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheActSubjectMaxID")
		log.Errorv(c, log.KV("AddCacheActSubjectMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLikeMaxID get data from mc
func (d *Dao) CacheLikeMaxID(c context.Context) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := likeMaxIDKey()
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheLikeMaxID")
		log.Errorv(c, log.KV("CacheLikeMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLikeMaxID")
		log.Errorv(c, log.KV("CacheLikeMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLikeMaxID")
		log.Errorv(c, log.KV("CacheLikeMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheLikeMaxID Set data to mc
func (d *Dao) AddCacheLikeMaxID(c context.Context, val int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := likeMaxIDKey()
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheLikeMaxID")
		log.Errorv(c, log.KV("AddCacheLikeMaxID", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLikeMissionBuff get data from mc
func (d *Dao) CacheLikeMissionBuff(c context.Context, id int64, mid int64) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := likeMissionBuffKey(id, mid)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheLikeMissionBuff")
		log.Errorv(c, log.KV("CacheLikeMissionBuff", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLikeMissionBuff")
		log.Errorv(c, log.KV("CacheLikeMissionBuff", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLikeMissionBuff")
		log.Errorv(c, log.KV("CacheLikeMissionBuff", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheLikeMissionBuff Set data to mc
func (d *Dao) AddCacheLikeMissionBuff(c context.Context, id int64, val int64, mid int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := likeMissionBuffKey(id, mid)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheLikeMissionBuff")
		log.Errorv(c, log.KV("AddCacheLikeMissionBuff", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheMissionGroupItems get data from mc
func (d *Dao) CacheMissionGroupItems(c context.Context, ids []int64) (res map[int64]*likemdl.MissionGroup, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := likeMissionGroupIDkey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	replies, err := conn.GetMulti(keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheMissionGroupItems")
		log.Errorv(c, log.KV("CacheMissionGroupItems", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for key, reply := range replies {
		var v *likemdl.MissionGroup
		v = &likemdl.MissionGroup{}
		err = conn.Scan(reply, v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheMissionGroupItems")
			log.Errorv(c, log.KV("CacheMissionGroupItems", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.MissionGroup, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheMissionGroupItems Set data to mc
func (d *Dao) AddCacheMissionGroupItems(c context.Context, values map[int64]*likemdl.MissionGroup) (err error) {
	if len(values) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	for id, val := range values {
		key := likeMissionGroupIDkey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcItemExpire, Flags: memcache.FlagProtobuf}
		if err = conn.Set(item); err != nil {
			prom.BusinessErrCount.Incr("mc:AddCacheMissionGroupItems")
			log.Errorv(c, log.KV("AddCacheMissionGroupItems", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheActMission get data from mc
func (d *Dao) CacheActMission(c context.Context, id int64, lid int64, mid int64) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := likeActMissionKey(id, lid, mid)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheActMission")
		log.Errorv(c, log.KV("CacheActMission", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActMission")
		log.Errorv(c, log.KV("CacheActMission", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActMission")
		log.Errorv(c, log.KV("CacheActMission", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheActMission Set data to mc
func (d *Dao) AddCacheActMission(c context.Context, id int64, val int64, lid int64, mid int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := likeActMissionKey(id, lid, mid)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheActMission")
		log.Errorv(c, log.KV("AddCacheActMission", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActLikeAchieves get data from mc
func (d *Dao) CacheActLikeAchieves(c context.Context, id int64) (res *likemdl.Achievements, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actAchieveKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheActLikeAchieves")
		log.Errorv(c, log.KV("CacheActLikeAchieves", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &likemdl.Achievements{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActLikeAchieves")
		log.Errorv(c, log.KV("CacheActLikeAchieves", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActLikeAchieves Set data to mc
func (d *Dao) AddCacheActLikeAchieves(c context.Context, id int64, val *likemdl.Achievements) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actAchieveKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcItemExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheActLikeAchieves")
		log.Errorv(c, log.KV("AddCacheActLikeAchieves", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActMissionFriends get data from mc
func (d *Dao) CacheActMissionFriends(c context.Context, id int64, lid int64) (res *likemdl.ActMissionGroups, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actMissionFriendsKey(id, lid)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheActMissionFriends")
		log.Errorv(c, log.KV("CacheActMissionFriends", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &likemdl.ActMissionGroups{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActMissionFriends")
		log.Errorv(c, log.KV("CacheActMissionFriends", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheActMissionFriends delete data from mc
func (d *Dao) DelCacheActMissionFriends(c context.Context, id int64, lid int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actMissionFriendsKey(id, lid)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheActMissionFriends")
		log.Errorv(c, log.KV("DelCacheActMissionFriends", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActMissionFriends Set data to mc
func (d *Dao) AddCacheActMissionFriends(c context.Context, id int64, val *likemdl.ActMissionGroups, lid int64) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actMissionFriendsKey(id, lid)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcItemExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheActMissionFriends")
		log.Errorv(c, log.KV("AddCacheActMissionFriends", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActUserAchieve get data from mc
func (d *Dao) CacheActUserAchieve(c context.Context, id int64) (res *likemdl.ActLikeUserAchievement, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actUserAchieveKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheActUserAchieve")
		log.Errorv(c, log.KV("CacheActUserAchieve", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &likemdl.ActLikeUserAchievement{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActUserAchieve")
		log.Errorv(c, log.KV("CacheActUserAchieve", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActUserAchieve Set data to mc
func (d *Dao) AddCacheActUserAchieve(c context.Context, id int64, val *likemdl.ActLikeUserAchievement) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actUserAchieveKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcItemExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheActUserAchieve")
		log.Errorv(c, log.KV("AddCacheActUserAchieve", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActUserAward get data from mc
func (d *Dao) CacheActUserAward(c context.Context, id int64) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actUserAchieveAwardKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheActUserAward")
		log.Errorv(c, log.KV("CacheActUserAward", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActUserAward")
		log.Errorv(c, log.KV("CacheActUserAward", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActUserAward")
		log.Errorv(c, log.KV("CacheActUserAward", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheActUserAward Set data to mc
func (d *Dao) AddCacheActUserAward(c context.Context, id int64, val int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := actUserAchieveAwardKey(id)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheActUserAward")
		log.Errorv(c, log.KV("AddCacheActUserAward", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheSubjectStat get data from mc
func (d *Dao) CacheSubjectStat(c context.Context, id int64) (res *likemdl.SubjectStat, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := subjectStatKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheSubjectStat")
		log.Errorv(c, log.KV("CacheSubjectStat", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &likemdl.SubjectStat{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheSubjectStat")
		log.Errorv(c, log.KV("CacheSubjectStat", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheSubjectStat Set data to mc
func (d *Dao) AddCacheSubjectStat(c context.Context, id int64, val *likemdl.SubjectStat) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := subjectStatKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcSubStatExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheSubjectStat")
		log.Errorv(c, log.KV("AddCacheSubjectStat", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheViewRank get data from mc
func (d *Dao) CacheViewRank(c context.Context, id int64) (res string, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := viewRankKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheViewRank")
		log.Errorv(c, log.KV("CacheViewRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	err = conn.Scan(reply, &res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheViewRank")
		log.Errorv(c, log.KV("CacheViewRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheViewRank Set data to mc
func (d *Dao) AddCacheViewRank(c context.Context, id int64, val string) (err error) {
	if len(val) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := viewRankKey(id)
	bs := []byte(val)
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcViewRankExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheViewRank")
		log.Errorv(c, log.KV("AddCacheViewRank", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLikeContent get data from mc
func (d *Dao) CacheLikeContent(c context.Context, ids []int64) (res map[int64]*likemdl.LikeContent, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := likeContentKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	replies, err := conn.GetMulti(keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLikeContent")
		log.Errorv(c, log.KV("CacheLikeContent", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for key, reply := range replies {
		var v *likemdl.LikeContent
		v = &likemdl.LikeContent{}
		err = conn.Scan(reply, v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheLikeContent")
			log.Errorv(c, log.KV("CacheLikeContent", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*likemdl.LikeContent, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheLikeContent Set data to mc
func (d *Dao) AddCacheLikeContent(c context.Context, values map[int64]*likemdl.LikeContent) (err error) {
	if len(values) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	for id, val := range values {
		key := likeContentKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcPerpetualExpire, Flags: memcache.FlagProtobuf}
		if err = conn.Set(item); err != nil {
			prom.BusinessErrCount.Incr("mc:AddCacheLikeContent")
			log.Errorv(c, log.KV("AddCacheLikeContent", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheSourceItemData get data from mc
func (d *Dao) CacheSourceItemData(c context.Context, id int64) (res []int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := sourceItemKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheSourceItemData")
		log.Errorv(c, log.KV("CacheSourceItemData", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = []int64{}
	err = conn.Scan(reply, &res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheSourceItemData")
		log.Errorv(c, log.KV("CacheSourceItemData", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheSourceItemData Set data to mc
func (d *Dao) AddCacheSourceItemData(c context.Context, id int64, val []int64) (err error) {
	if len(val) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := sourceItemKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcSourceItemExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheSourceItemData")
		log.Errorv(c, log.KV("AddCacheSourceItemData", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheActSubjectProtocol get data from mc
func (d *Dao) CacheActSubjectProtocol(c context.Context, id int64) (res *likemdl.ActSubjectProtocol, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := subjectProtocolKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheActSubjectProtocol")
		log.Errorv(c, log.KV("CacheActSubjectProtocol", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &likemdl.ActSubjectProtocol{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheActSubjectProtocol")
		log.Errorv(c, log.KV("CacheActSubjectProtocol", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheActSubjectProtocol Set data to mc
func (d *Dao) AddCacheActSubjectProtocol(c context.Context, id int64, val *likemdl.ActSubjectProtocol) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := subjectProtocolKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcProtocolExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheActSubjectProtocol")
		log.Errorv(c, log.KV("AddCacheActSubjectProtocol", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
