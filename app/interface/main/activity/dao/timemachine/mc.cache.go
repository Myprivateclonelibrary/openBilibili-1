// Code generated by $GOPATH/src/go-common/app/tool/cache/mc. DO NOT EDIT.

/*
  Package timemachine is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// mc: -key=timemachineKey -expire=d.mcTmExpire -encode=pb
		AddCacheTimemachine(c context.Context, mid int64, data *timemachine.Item) error
		// mc: -key=timemachineKey
		CacheTimemachine(c context.Context, mid int64) (*timemachine.Item, error)
	}
*/

package timemachine

import (
	"context"
	"fmt"

	"go-common/app/interface/main/activity/model/timemachine"
	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
)

var _ _mc

// AddCacheTimemachine Set data to mc
func (d *Dao) AddCacheTimemachine(c context.Context, id int64, val *timemachine.Item) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := timemachineKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcTmExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheTimemachine")
		log.Errorv(c, log.KV("AddCacheTimemachine", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheTimemachine get data from mc
func (d *Dao) CacheTimemachine(c context.Context, id int64) (res *timemachine.Item, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := timemachineKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheTimemachine")
		log.Errorv(c, log.KV("CacheTimemachine", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &timemachine.Item{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheTimemachine")
		log.Errorv(c, log.KV("CacheTimemachine", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
