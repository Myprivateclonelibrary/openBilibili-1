// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: subject.proto

package like

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import go_common_library_time "go-common/library/time"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SubjectItem struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Oid                  int64                       `protobuf:"varint,2,opt,name=Oid,proto3" json:"oid"`
	Type                 int64                       `protobuf:"varint,3,opt,name=Type,proto3" json:"type"`
	State                int64                       `protobuf:"varint,4,opt,name=State,proto3" json:"state"`
	Stime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Stime,proto3,casttype=go-common/library/time.Time" json:"stime"`
	Etime                go_common_library_time.Time `protobuf:"varint,6,opt,name=Etime,proto3,casttype=go-common/library/time.Time" json:"etime"`
	Ctime                go_common_library_time.Time `protobuf:"varint,7,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,8,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Name                 string                      `protobuf:"bytes,9,opt,name=Name,proto3" json:"name"`
	Author               string                      `protobuf:"bytes,10,opt,name=Author,proto3" json:"author"`
	ActURL               string                      `protobuf:"bytes,11,opt,name=ActURL,proto3" json:"act_url"`
	Lstime               go_common_library_time.Time `protobuf:"varint,12,opt,name=Lstime,proto3,casttype=go-common/library/time.Time" json:"lstime"`
	Letime               go_common_library_time.Time `protobuf:"varint,13,opt,name=Letime,proto3,casttype=go-common/library/time.Time" json:"letime"`
	Cover                string                      `protobuf:"bytes,14,opt,name=Cover,proto3" json:"cover"`
	Dic                  string                      `protobuf:"bytes,15,opt,name=Dic,proto3" json:"dic"`
	Flag                 int64                       `protobuf:"varint,16,opt,name=Flag,proto3" json:"flag"`
	Uetime               go_common_library_time.Time `protobuf:"varint,17,opt,name=Uetime,proto3,casttype=go-common/library/time.Time" json:"uetime"`
	Ustime               go_common_library_time.Time `protobuf:"varint,18,opt,name=Ustime,proto3,casttype=go-common/library/time.Time" json:"ustime"`
	Level                int64                       `protobuf:"varint,19,opt,name=Level,proto3" json:"level"`
	H5Cover              string                      `protobuf:"bytes,20,opt,name=H5_cover,json=H5Cover,proto3" json:"h5_cover"`
	Rank                 int64                       `protobuf:"varint,21,opt,name=Rank,proto3" json:"rank"`
	LikeLimit            int64                       `protobuf:"varint,22,opt,name=LikeLimit,proto3" json:"like_limit"`
	AndroidURL           string                      `protobuf:"bytes,23,opt,name=AndroidURL,proto3" json:"android_url"`
	IosURL               string                      `protobuf:"bytes,24,opt,name=IosURL,proto3" json:"ios_url"`
	DailyLikeLimit       int64                       `protobuf:"varint,25,opt,name=DailyLikeLimit,proto3" json:"daily_like_limit"`
	DailySingleLikeLimit int64                       `protobuf:"varint,26,opt,name=DailySingleLikeLimit,proto3" json:"daily_single_like_limit"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *SubjectItem) Reset()         { *m = SubjectItem{} }
func (m *SubjectItem) String() string { return proto.CompactTextString(m) }
func (*SubjectItem) ProtoMessage()    {}
func (*SubjectItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_subject_b37c2a1aa27d8997, []int{0}
}
func (m *SubjectItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubjectItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubjectItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SubjectItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubjectItem.Merge(dst, src)
}
func (m *SubjectItem) XXX_Size() int {
	return m.Size()
}
func (m *SubjectItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SubjectItem.DiscardUnknown(m)
}

var xxx_messageInfo_SubjectItem proto.InternalMessageInfo

type LikeContent struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Message              string                      `protobuf:"bytes,2,opt,name=Message,proto3" json:"message"`
	IP                   int64                       `protobuf:"varint,3,opt,name=IP,proto3" json:"ip"`
	Plat                 int64                       `protobuf:"varint,4,opt,name=Plat,proto3" json:"plat"`
	Device               int64                       `protobuf:"varint,5,opt,name=Device,proto3" json:"device"`
	Ctime                go_common_library_time.Time `protobuf:"varint,6,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Mtime                go_common_library_time.Time `protobuf:"varint,7,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Image                string                      `protobuf:"bytes,8,opt,name=Image,proto3" json:"image"`
	Reply                string                      `protobuf:"bytes,9,opt,name=Reply,proto3" json:"reply"`
	Link                 string                      `protobuf:"bytes,10,opt,name=Link,proto3" json:"link"`
	ExName               string                      `protobuf:"bytes,11,opt,name=ExName,proto3" json:"ex_name"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *LikeContent) Reset()         { *m = LikeContent{} }
func (m *LikeContent) String() string { return proto.CompactTextString(m) }
func (*LikeContent) ProtoMessage()    {}
func (*LikeContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_subject_b37c2a1aa27d8997, []int{1}
}
func (m *LikeContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LikeContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LikeContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LikeContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LikeContent.Merge(dst, src)
}
func (m *LikeContent) XXX_Size() int {
	return m.Size()
}
func (m *LikeContent) XXX_DiscardUnknown() {
	xxx_messageInfo_LikeContent.DiscardUnknown(m)
}

var xxx_messageInfo_LikeContent proto.InternalMessageInfo

type ActSubjectProtocol struct {
	ID                   int64                       `protobuf:"varint,1,opt,name=ID,proto3" json:"id"`
	Sid                  int64                       `protobuf:"varint,2,opt,name=Sid,proto3" json:"sid"`
	Protocol             string                      `protobuf:"bytes,3,opt,name=Protocol,proto3" json:"protocol"`
	Mtime                go_common_library_time.Time `protobuf:"varint,4,opt,name=Mtime,proto3,casttype=go-common/library/time.Time" json:"mtime"`
	Ctime                go_common_library_time.Time `protobuf:"varint,5,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Types                string                      `protobuf:"bytes,6,opt,name=Types,proto3" json:"types"`
	Tags                 string                      `protobuf:"bytes,7,opt,name=Tags,proto3" json:"tags"`
	Pubtime              go_common_library_time.Time `protobuf:"varint,8,opt,name=Pubtime,proto3,casttype=go-common/library/time.Time" json:"pubtime"`
	Deltime              go_common_library_time.Time `protobuf:"varint,9,opt,name=Deltime,proto3,casttype=go-common/library/time.Time" json:"deltime"`
	Editime              go_common_library_time.Time `protobuf:"varint,10,opt,name=Editime,proto3,casttype=go-common/library/time.Time" json:"editime"`
	Hot                  int64                       `protobuf:"varint,11,opt,name=Hot,proto3" json:"hot"`
	BgmID                int64                       `protobuf:"varint,12,opt,name=BgmID,proto3" json:"bgm_id"`
	PasterID             int64                       `protobuf:"varint,13,opt,name=PasterID,proto3" json:"paster_id"`
	Oids                 string                      `protobuf:"bytes,14,opt,name=Oids,proto3" json:"oids"`
	ScreenSet            int64                       `protobuf:"varint,15,opt,name=ScreenSet,proto3" json:"screen_set"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *ActSubjectProtocol) Reset()         { *m = ActSubjectProtocol{} }
func (m *ActSubjectProtocol) String() string { return proto.CompactTextString(m) }
func (*ActSubjectProtocol) ProtoMessage()    {}
func (*ActSubjectProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_subject_b37c2a1aa27d8997, []int{2}
}
func (m *ActSubjectProtocol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActSubjectProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActSubjectProtocol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActSubjectProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActSubjectProtocol.Merge(dst, src)
}
func (m *ActSubjectProtocol) XXX_Size() int {
	return m.Size()
}
func (m *ActSubjectProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_ActSubjectProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_ActSubjectProtocol proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SubjectItem)(nil), "activity.service.SubjectItem")
	proto.RegisterType((*LikeContent)(nil), "activity.service.LikeContent")
	proto.RegisterType((*ActSubjectProtocol)(nil), "activity.service.ActSubjectProtocol")
}
func (m *SubjectItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubjectItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.ID))
	}
	if m.Oid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Oid))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Type))
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.State))
	}
	if m.Stime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Stime))
	}
	if m.Etime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Etime))
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Mtime))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if len(m.ActURL) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.ActURL)))
		i += copy(dAtA[i:], m.ActURL)
	}
	if m.Lstime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Lstime))
	}
	if m.Letime != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Letime))
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if len(m.Dic) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Dic)))
		i += copy(dAtA[i:], m.Dic)
	}
	if m.Flag != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Flag))
	}
	if m.Uetime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Uetime))
	}
	if m.Ustime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Ustime))
	}
	if m.Level != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Level))
	}
	if len(m.H5Cover) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.H5Cover)))
		i += copy(dAtA[i:], m.H5Cover)
	}
	if m.Rank != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Rank))
	}
	if m.LikeLimit != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.LikeLimit))
	}
	if len(m.AndroidURL) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.AndroidURL)))
		i += copy(dAtA[i:], m.AndroidURL)
	}
	if len(m.IosURL) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.IosURL)))
		i += copy(dAtA[i:], m.IosURL)
	}
	if m.DailyLikeLimit != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.DailyLikeLimit))
	}
	if m.DailySingleLikeLimit != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.DailySingleLikeLimit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LikeContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LikeContent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.ID))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.IP != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.IP))
	}
	if m.Plat != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Plat))
	}
	if m.Device != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Device))
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Mtime))
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Reply) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if len(m.Link) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Link)))
		i += copy(dAtA[i:], m.Link)
	}
	if len(m.ExName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.ExName)))
		i += copy(dAtA[i:], m.ExName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ActSubjectProtocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActSubjectProtocol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.ID))
	}
	if m.Sid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Sid))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.Mtime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Mtime))
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Ctime))
	}
	if len(m.Types) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Types)))
		i += copy(dAtA[i:], m.Types)
	}
	if len(m.Tags) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Tags)))
		i += copy(dAtA[i:], m.Tags)
	}
	if m.Pubtime != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Pubtime))
	}
	if m.Deltime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Deltime))
	}
	if m.Editime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Editime))
	}
	if m.Hot != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.Hot))
	}
	if m.BgmID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.BgmID))
	}
	if m.PasterID != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.PasterID))
	}
	if len(m.Oids) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintSubject(dAtA, i, uint64(len(m.Oids)))
		i += copy(dAtA[i:], m.Oids)
	}
	if m.ScreenSet != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintSubject(dAtA, i, uint64(m.ScreenSet))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSubject(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SubjectItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubject(uint64(m.ID))
	}
	if m.Oid != 0 {
		n += 1 + sovSubject(uint64(m.Oid))
	}
	if m.Type != 0 {
		n += 1 + sovSubject(uint64(m.Type))
	}
	if m.State != 0 {
		n += 1 + sovSubject(uint64(m.State))
	}
	if m.Stime != 0 {
		n += 1 + sovSubject(uint64(m.Stime))
	}
	if m.Etime != 0 {
		n += 1 + sovSubject(uint64(m.Etime))
	}
	if m.Ctime != 0 {
		n += 1 + sovSubject(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovSubject(uint64(m.Mtime))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.ActURL)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.Lstime != 0 {
		n += 1 + sovSubject(uint64(m.Lstime))
	}
	if m.Letime != 0 {
		n += 1 + sovSubject(uint64(m.Letime))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Dic)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.Flag != 0 {
		n += 2 + sovSubject(uint64(m.Flag))
	}
	if m.Uetime != 0 {
		n += 2 + sovSubject(uint64(m.Uetime))
	}
	if m.Ustime != 0 {
		n += 2 + sovSubject(uint64(m.Ustime))
	}
	if m.Level != 0 {
		n += 2 + sovSubject(uint64(m.Level))
	}
	l = len(m.H5Cover)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	if m.Rank != 0 {
		n += 2 + sovSubject(uint64(m.Rank))
	}
	if m.LikeLimit != 0 {
		n += 2 + sovSubject(uint64(m.LikeLimit))
	}
	l = len(m.AndroidURL)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	l = len(m.IosURL)
	if l > 0 {
		n += 2 + l + sovSubject(uint64(l))
	}
	if m.DailyLikeLimit != 0 {
		n += 2 + sovSubject(uint64(m.DailyLikeLimit))
	}
	if m.DailySingleLikeLimit != 0 {
		n += 2 + sovSubject(uint64(m.DailySingleLikeLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LikeContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubject(uint64(m.ID))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.IP != 0 {
		n += 1 + sovSubject(uint64(m.IP))
	}
	if m.Plat != 0 {
		n += 1 + sovSubject(uint64(m.Plat))
	}
	if m.Device != 0 {
		n += 1 + sovSubject(uint64(m.Device))
	}
	if m.Ctime != 0 {
		n += 1 + sovSubject(uint64(m.Ctime))
	}
	if m.Mtime != 0 {
		n += 1 + sovSubject(uint64(m.Mtime))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.ExName)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActSubjectProtocol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSubject(uint64(m.ID))
	}
	if m.Sid != 0 {
		n += 1 + sovSubject(uint64(m.Sid))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.Mtime != 0 {
		n += 1 + sovSubject(uint64(m.Mtime))
	}
	if m.Ctime != 0 {
		n += 1 + sovSubject(uint64(m.Ctime))
	}
	l = len(m.Types)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.Pubtime != 0 {
		n += 1 + sovSubject(uint64(m.Pubtime))
	}
	if m.Deltime != 0 {
		n += 1 + sovSubject(uint64(m.Deltime))
	}
	if m.Editime != 0 {
		n += 1 + sovSubject(uint64(m.Editime))
	}
	if m.Hot != 0 {
		n += 1 + sovSubject(uint64(m.Hot))
	}
	if m.BgmID != 0 {
		n += 1 + sovSubject(uint64(m.BgmID))
	}
	if m.PasterID != 0 {
		n += 1 + sovSubject(uint64(m.PasterID))
	}
	l = len(m.Oids)
	if l > 0 {
		n += 1 + l + sovSubject(uint64(l))
	}
	if m.ScreenSet != 0 {
		n += 1 + sovSubject(uint64(m.ScreenSet))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSubject(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSubject(x uint64) (n int) {
	return sovSubject(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SubjectItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubjectItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubjectItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lstime", wireType)
			}
			m.Lstime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lstime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Letime", wireType)
			}
			m.Letime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Letime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uetime", wireType)
			}
			m.Uetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uetime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ustime", wireType)
			}
			m.Ustime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ustime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H5Cover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.H5Cover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikeLimit", wireType)
			}
			m.LikeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LikeLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IosURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IosURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyLikeLimit", wireType)
			}
			m.DailyLikeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyLikeLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailySingleLikeLimit", wireType)
			}
			m.DailySingleLikeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailySingleLikeLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LikeContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LikeContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LikeContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			m.IP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IP |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plat", wireType)
			}
			m.Plat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Plat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			m.Device = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Device |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActSubjectProtocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActSubjectProtocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActSubjectProtocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			m.Mtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubtime", wireType)
			}
			m.Pubtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pubtime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deltime", wireType)
			}
			m.Deltime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deltime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Editime", wireType)
			}
			m.Editime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Editime |= (go_common_library_time.Time(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hot", wireType)
			}
			m.Hot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hot |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgmID", wireType)
			}
			m.BgmID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BgmID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasterID", wireType)
			}
			m.PasterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PasterID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubject
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oids = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenSet", wireType)
			}
			m.ScreenSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScreenSet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubject(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSubject
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSubject(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSubject
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubject
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSubject
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSubject
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSubject(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSubject = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSubject   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("subject.proto", fileDescriptor_subject_b37c2a1aa27d8997) }

var fileDescriptor_subject_b37c2a1aa27d8997 = []byte{
	// 1007 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0xb6, 0xac, 0xff, 0x55, 0xec, 0xb8, 0x5b, 0x37, 0x61, 0x7e, 0x20, 0x1a, 0x2e, 0x8a, 0x3a,
	0x45, 0x63, 0x1d, 0x8a, 0xdc, 0x8a, 0x02, 0xb2, 0xe5, 0xc2, 0x02, 0x94, 0x5a, 0x58, 0x25, 0x97,
	0x5e, 0x84, 0x15, 0xb9, 0xa1, 0xb7, 0x22, 0xb9, 0x04, 0xb9, 0x32, 0xa2, 0x37, 0xe9, 0x3b, 0xf4,
	0xde, 0x57, 0x68, 0x8e, 0x79, 0x02, 0xa2, 0x71, 0x6f, 0x7c, 0x84, 0x9e, 0x8a, 0x99, 0x5d, 0x99,
	0x6a, 0xd1, 0xd6, 0x82, 0x73, 0x13, 0xbf, 0x99, 0xef, 0xd3, 0xec, 0xb7, 0xb3, 0x33, 0x64, 0x27,
	0x5b, 0xcc, 0x7e, 0x12, 0x9e, 0x3e, 0x4e, 0x52, 0xa5, 0x15, 0xdd, 0xe3, 0x9e, 0x96, 0x57, 0x52,
	0x2f, 0x8f, 0x33, 0x91, 0x5e, 0x49, 0x4f, 0x3c, 0x7e, 0x1e, 0x48, 0x7d, 0xb9, 0x98, 0x1d, 0x7b,
	0x2a, 0xea, 0x05, 0x2a, 0x50, 0x3d, 0x4c, 0x9c, 0x2d, 0xde, 0xe0, 0x17, 0x7e, 0xe0, 0x2f, 0x23,
	0x70, 0xf8, 0x5b, 0x9b, 0x74, 0x26, 0x46, 0x72, 0xa8, 0x45, 0x44, 0x1f, 0x90, 0xed, 0xe1, 0xc0,
	0xa9, 0x1c, 0x54, 0x8e, 0xaa, 0x27, 0x8d, 0x22, 0x77, 0xb7, 0xa5, 0xcf, 0xb6, 0x87, 0x03, 0xfa,
	0x88, 0x54, 0x2f, 0xa4, 0xef, 0x6c, 0x63, 0xa0, 0x59, 0xe4, 0x6e, 0x55, 0x49, 0x9f, 0x01, 0x46,
	0x9f, 0x92, 0xda, 0xab, 0x65, 0x22, 0x9c, 0x2a, 0xc6, 0x5a, 0x45, 0xee, 0xd6, 0xf4, 0x32, 0x11,
	0x0c, 0x51, 0xea, 0x92, 0xfa, 0x44, 0x73, 0x2d, 0x9c, 0x1a, 0x86, 0xdb, 0x45, 0xee, 0xd6, 0x33,
	0x00, 0x98, 0xc1, 0xe9, 0x77, 0x90, 0x20, 0x23, 0xe1, 0xd4, 0x31, 0xe1, 0xc8, 0x24, 0xc8, 0x48,
	0xfc, 0x99, 0xbb, 0x4f, 0x02, 0xf5, 0xdc, 0x53, 0x51, 0xa4, 0xe2, 0x5e, 0x28, 0x67, 0x29, 0x4f,
	0x97, 0x3d, 0x88, 0x1c, 0xbf, 0x92, 0x11, 0xf2, 0x65, 0x84, 0xfc, 0x33, 0xe4, 0x37, 0x4a, 0xbe,
	0xd8, 0x88, 0x7f, 0xb6, 0xe2, 0x9f, 0x22, 0xbf, 0x59, 0xf2, 0xbd, 0x8d, 0xf8, 0xa7, 0x2b, 0xfe,
	0x4b, 0xe4, 0xb7, 0x4a, 0x7e, 0xb4, 0x11, 0x1f, 0x69, 0x60, 0xdf, 0x0f, 0x3c, 0x12, 0x4e, 0xfb,
	0xa0, 0x72, 0xd4, 0x36, 0xf6, 0xc5, 0x3c, 0x12, 0x0c, 0x51, 0x7a, 0x48, 0x1a, 0xfd, 0x85, 0xbe,
	0x54, 0xa9, 0x43, 0x30, 0x4e, 0x8a, 0xdc, 0x6d, 0x70, 0x44, 0x98, 0x8d, 0xd0, 0xcf, 0x49, 0xa3,
	0xef, 0xe9, 0xd7, 0x6c, 0xe4, 0x74, 0x30, 0xa7, 0x53, 0xe4, 0x6e, 0x93, 0x7b, 0x7a, 0xba, 0x48,
	0x43, 0x66, 0x43, 0xb4, 0x4f, 0x1a, 0x23, 0xb4, 0xd5, 0xb9, 0x87, 0x75, 0x3e, 0x03, 0xa1, 0x70,
	0x23, 0xa3, 0x2d, 0x11, 0x25, 0xd0, 0x59, 0x67, 0x67, 0x4d, 0x42, 0x6c, 0x26, 0x81, 0x69, 0xd0,
	0x0d, 0xa7, 0xea, 0x4a, 0xa4, 0xce, 0x2e, 0x56, 0x8a, 0xdd, 0xe0, 0x01, 0xc0, 0x0c, 0x0e, 0x7d,
	0x36, 0x90, 0x9e, 0x73, 0x1f, 0xc3, 0xd8, 0x67, 0xbe, 0xf4, 0x18, 0x60, 0x60, 0xd4, 0xf7, 0x21,
	0x0f, 0x9c, 0xbd, 0xb2, 0xcf, 0xde, 0x84, 0x3c, 0x60, 0x88, 0x42, 0x71, 0xaf, 0x4d, 0x71, 0x9f,
	0x94, 0xc5, 0x2d, 0x36, 0x2b, 0xce, 0x10, 0x51, 0xc2, 0x58, 0x44, 0xd7, 0x24, 0x36, 0xb3, 0xc8,
	0x10, 0xe1, 0x7c, 0x23, 0x71, 0x25, 0x42, 0xe7, 0xd3, 0xb2, 0xdb, 0x43, 0x00, 0x98, 0xc1, 0xe9,
	0x97, 0xa4, 0x75, 0xfe, 0x62, 0x8a, 0x47, 0x76, 0xf6, 0xf1, 0x90, 0xf7, 0x8a, 0xdc, 0x6d, 0x5d,
	0x5a, 0x8c, 0x35, 0xcf, 0x5f, 0x18, 0x23, 0x9e, 0x92, 0x1a, 0xe3, 0xf1, 0xdc, 0xf9, 0xac, 0x3c,
	0x6d, 0xca, 0xe3, 0x39, 0x43, 0x94, 0x7e, 0x4d, 0xda, 0x23, 0x39, 0x17, 0x23, 0x19, 0x49, 0xed,
	0x3c, 0xc0, 0x94, 0xdd, 0x22, 0x77, 0x49, 0x28, 0xe7, 0x62, 0x1a, 0x02, 0xca, 0xca, 0x04, 0xda,
	0x23, 0xa4, 0x1f, 0xfb, 0xa9, 0x92, 0x3e, 0x34, 0xc9, 0x43, 0xfc, 0xdb, 0xfb, 0x45, 0xee, 0x76,
	0xb8, 0x41, 0xb1, 0x51, 0xd6, 0x52, 0xa0, 0xa3, 0x86, 0x2a, 0x83, 0x64, 0xa7, 0xec, 0x28, 0xa9,
	0x32, 0xd3, 0x51, 0x26, 0x44, 0xbf, 0x25, 0xbb, 0x03, 0x2e, 0xc3, 0x65, 0x59, 0xc8, 0x23, 0x2c,
	0x64, 0xbf, 0xc8, 0xdd, 0x3d, 0x1f, 0x22, 0xd3, 0xb5, 0x72, 0xfe, 0x91, 0x4b, 0x2f, 0xc8, 0x3e,
	0x22, 0x13, 0x19, 0x07, 0xa1, 0x28, 0x35, 0x1e, 0xa3, 0xc6, 0x93, 0x22, 0x77, 0x1f, 0x1a, 0x8d,
	0x0c, 0x13, 0xd6, 0xa5, 0xfe, 0x95, 0x78, 0xf8, 0x4b, 0x95, 0x74, 0xe0, 0xeb, 0x54, 0xc5, 0x5a,
	0xc4, 0xfa, 0x3f, 0x27, 0xd9, 0x17, 0xa4, 0xf9, 0x52, 0x64, 0x19, 0x0f, 0x04, 0x4e, 0x33, 0x7b,
	0xb8, 0xc8, 0x40, 0x6c, 0x15, 0x43, 0xfa, 0xd8, 0xce, 0x34, 0x43, 0x4f, 0xd8, 0xf6, 0x70, 0x0c,
	0xf7, 0x32, 0x0e, 0xb9, 0xb6, 0xe3, 0x0c, 0xef, 0x25, 0x09, 0xb9, 0x66, 0x88, 0xc2, 0x73, 0x1d,
	0x08, 0x98, 0xc3, 0x76, 0x9a, 0xe1, 0x73, 0xf5, 0x11, 0x61, 0x36, 0x52, 0x0e, 0x9c, 0xc6, 0x47,
	0x0e, 0x9c, 0xe6, 0xdd, 0x06, 0x8e, 0x4b, 0xea, 0xc3, 0x08, 0x8e, 0xdf, 0x2a, 0xdf, 0xa0, 0x04,
	0x80, 0x19, 0x1c, 0x12, 0x98, 0x48, 0xc2, 0xa5, 0x1d, 0x49, 0x98, 0x90, 0x02, 0xc0, 0x0c, 0x0e,
	0x1e, 0x8c, 0x64, 0x3c, 0xb7, 0x23, 0x09, 0x3d, 0x08, 0x25, 0xf4, 0x26, 0xa0, 0xd0, 0x3c, 0x67,
	0x6f, 0x71, 0xa4, 0xad, 0x8d, 0x23, 0xf1, 0x76, 0x8a, 0x53, 0xcd, 0x86, 0x0e, 0x7f, 0xad, 0x13,
	0xda, 0xf7, 0xb4, 0x5d, 0x3d, 0x63, 0xd8, 0x45, 0x9e, 0x0a, 0xff, 0x6f, 0xfd, 0x4c, 0xfe, 0xbe,
	0x7e, 0x32, 0x58, 0x3f, 0x13, 0xe9, 0xd3, 0x23, 0xd2, 0x5a, 0xd1, 0xf1, 0xba, 0xec, 0x8b, 0x4a,
	0x2c, 0xc6, 0x6e, 0xa2, 0xa5, 0x71, 0xb5, 0xbb, 0x19, 0x77, 0x73, 0x71, 0xf5, 0xbb, 0x5d, 0x9c,
	0x4b, 0xea, 0xb0, 0x12, 0x33, 0xbc, 0x78, 0xeb, 0x2b, 0x6c, 0xca, 0x8c, 0x19, 0x1c, 0x37, 0x29,
	0x0f, 0x32, 0xbc, 0x58, 0xeb, 0xab, 0xe6, 0x41, 0xc6, 0x10, 0xa5, 0x03, 0xd2, 0x1c, 0x2f, 0x66,
	0x6b, 0xab, 0xe6, 0x2b, 0x30, 0x36, 0x31, 0xd0, 0x6d, 0x25, 0xac, 0xa8, 0xa0, 0x32, 0x10, 0x21,
	0xaa, 0xb4, 0x4b, 0x15, 0xdf, 0x40, 0xb7, 0xaa, 0x58, 0x2a, 0xa8, 0x9c, 0xf9, 0x12, 0x55, 0x48,
	0xa9, 0x22, 0x0c, 0x74, 0xab, 0x8a, 0xa5, 0xc2, 0xad, 0x9e, 0x2b, 0x8d, 0x6d, 0x62, 0x6f, 0xf5,
	0x52, 0x69, 0x06, 0x18, 0x3d, 0x20, 0xf5, 0x93, 0x20, 0x1a, 0x0e, 0xec, 0xb6, 0xc2, 0x77, 0x34,
	0x0b, 0xa2, 0xa9, 0xf4, 0x99, 0x09, 0xd0, 0x67, 0xa4, 0x35, 0xe6, 0x99, 0x16, 0xe9, 0x70, 0x60,
	0xf7, 0xd1, 0x4e, 0x91, 0xbb, 0xed, 0x04, 0x31, 0xc8, 0xbb, 0x09, 0x83, 0xaf, 0x17, 0xd2, 0xcf,
	0xec, 0xd2, 0x41, 0x5f, 0x95, 0xf4, 0x33, 0x86, 0x28, 0xcc, 0xd2, 0x89, 0x97, 0x0a, 0x11, 0x4f,
	0x84, 0xc6, 0xc5, 0x63, 0x67, 0x69, 0x86, 0xe0, 0x34, 0x13, 0x9a, 0x95, 0x09, 0x27, 0xdd, 0x77,
	0x1f, 0xba, 0x5b, 0xef, 0x3f, 0x74, 0xb7, 0xde, 0x5d, 0x77, 0x2b, 0xef, 0xaf, 0xbb, 0x95, 0xdf,
	0xaf, 0xbb, 0x95, 0x9f, 0xff, 0xe8, 0x6e, 0xfd, 0x58, 0x83, 0x11, 0x35, 0x6b, 0x60, 0xe3, 0x7d,
	0xf3, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x16, 0x10, 0xf6, 0xe0, 0xa9, 0x09, 0x00, 0x00,
}
