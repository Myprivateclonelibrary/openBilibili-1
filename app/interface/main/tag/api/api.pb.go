// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/interface/main/tag/api/api.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TagRPCClient is the client API for TagRPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TagRPCClient interface {
	// Tag get tag info by tag id.
	Tag(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (*TagReply, error)
	// TagByName get tag info by tag name.
	TagByName(ctx context.Context, in *TagByNameReq, opts ...grpc.CallOption) (*TagReply, error)
	// Tags get tags info by tag ids.
	Tags(ctx context.Context, in *TagsReq, opts ...grpc.CallOption) (*TagsReply, error)
	// TagByNames get tags info by tag names.
	TagByNames(ctx context.Context, in *TagByNamesReq, opts ...grpc.CallOption) (*TagsReply, error)
	// Channel get a channel info, include tags, and channel synonyms.
	Channel(ctx context.Context, in *ChannelReq, opts ...grpc.CallOption) (*ChannelReply, error)
	// ChannelCategory get channels categories by from that international version or normal app version.
	ChannelCategory(ctx context.Context, in *ChannelCategoryReq, opts ...grpc.CallOption) (*ChannelCategoryReply, error)
	// ChanneList get channels by channel category id and the app version.
	ChanneList(ctx context.Context, in *ChanneListReq, opts ...grpc.CallOption) (*ChannelsReply, error)
	// ChannelRecommend get a recommend channel list by mid.
	ChannelRecommend(ctx context.Context, in *ChannelRecommendReq, opts ...grpc.CallOption) (*ChannelsReply, error)
	// ChannelDiscovery get a channel list by mid and channel state (3>2>1)
	ChannelDiscovery(ctx context.Context, in *ChannelDiscoveryReq, opts ...grpc.CallOption) (*ChannelsReply, error)
	// ChannelSquare get channel infos and archives.
	ChannelSquare(ctx context.Context, in *ChannelSquareReq, opts ...grpc.CallOption) (*ChannelSquareReply, error)
	// ChannelResources resource feed under channel.
	ChannelResources(ctx context.Context, in *ChannelResourcesReq, opts ...grpc.CallOption) (*ChannelResourcesReply, error)
	// ChannelCheckBack resource channel checkback.
	ChannelCheckBack(ctx context.Context, in *ChannelCheckBackReq, opts ...grpc.CallOption) (*ChannelCheckBackReply, error)
}

type tagRPCClient struct {
	cc *grpc.ClientConn
}

func NewTagRPCClient(cc *grpc.ClientConn) TagRPCClient {
	return &tagRPCClient{cc}
}

func (c *tagRPCClient) Tag(ctx context.Context, in *TagReq, opts ...grpc.CallOption) (*TagReply, error) {
	out := new(TagReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/Tag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) TagByName(ctx context.Context, in *TagByNameReq, opts ...grpc.CallOption) (*TagReply, error) {
	out := new(TagReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/TagByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) Tags(ctx context.Context, in *TagsReq, opts ...grpc.CallOption) (*TagsReply, error) {
	out := new(TagsReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/Tags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) TagByNames(ctx context.Context, in *TagByNamesReq, opts ...grpc.CallOption) (*TagsReply, error) {
	out := new(TagsReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/TagByNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) Channel(ctx context.Context, in *ChannelReq, opts ...grpc.CallOption) (*ChannelReply, error) {
	out := new(ChannelReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/Channel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) ChannelCategory(ctx context.Context, in *ChannelCategoryReq, opts ...grpc.CallOption) (*ChannelCategoryReply, error) {
	out := new(ChannelCategoryReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/ChannelCategory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) ChanneList(ctx context.Context, in *ChanneListReq, opts ...grpc.CallOption) (*ChannelsReply, error) {
	out := new(ChannelsReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/ChanneList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) ChannelRecommend(ctx context.Context, in *ChannelRecommendReq, opts ...grpc.CallOption) (*ChannelsReply, error) {
	out := new(ChannelsReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/ChannelRecommend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) ChannelDiscovery(ctx context.Context, in *ChannelDiscoveryReq, opts ...grpc.CallOption) (*ChannelsReply, error) {
	out := new(ChannelsReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/ChannelDiscovery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) ChannelSquare(ctx context.Context, in *ChannelSquareReq, opts ...grpc.CallOption) (*ChannelSquareReply, error) {
	out := new(ChannelSquareReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/ChannelSquare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) ChannelResources(ctx context.Context, in *ChannelResourcesReq, opts ...grpc.CallOption) (*ChannelResourcesReply, error) {
	out := new(ChannelResourcesReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/ChannelResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagRPCClient) ChannelCheckBack(ctx context.Context, in *ChannelCheckBackReq, opts ...grpc.CallOption) (*ChannelCheckBackReply, error) {
	out := new(ChannelCheckBackReply)
	err := c.cc.Invoke(ctx, "/main.community.tag.v1.TagRPC/ChannelCheckBack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagRPCServer is the server API for TagRPC service.
type TagRPCServer interface {
	// Tag get tag info by tag id.
	Tag(context.Context, *TagReq) (*TagReply, error)
	// TagByName get tag info by tag name.
	TagByName(context.Context, *TagByNameReq) (*TagReply, error)
	// Tags get tags info by tag ids.
	Tags(context.Context, *TagsReq) (*TagsReply, error)
	// TagByNames get tags info by tag names.
	TagByNames(context.Context, *TagByNamesReq) (*TagsReply, error)
	// Channel get a channel info, include tags, and channel synonyms.
	Channel(context.Context, *ChannelReq) (*ChannelReply, error)
	// ChannelCategory get channels categories by from that international version or normal app version.
	ChannelCategory(context.Context, *ChannelCategoryReq) (*ChannelCategoryReply, error)
	// ChanneList get channels by channel category id and the app version.
	ChanneList(context.Context, *ChanneListReq) (*ChannelsReply, error)
	// ChannelRecommend get a recommend channel list by mid.
	ChannelRecommend(context.Context, *ChannelRecommendReq) (*ChannelsReply, error)
	// ChannelDiscovery get a channel list by mid and channel state (3>2>1)
	ChannelDiscovery(context.Context, *ChannelDiscoveryReq) (*ChannelsReply, error)
	// ChannelSquare get channel infos and archives.
	ChannelSquare(context.Context, *ChannelSquareReq) (*ChannelSquareReply, error)
	// ChannelResources resource feed under channel.
	ChannelResources(context.Context, *ChannelResourcesReq) (*ChannelResourcesReply, error)
	// ChannelCheckBack resource channel checkback.
	ChannelCheckBack(context.Context, *ChannelCheckBackReq) (*ChannelCheckBackReply, error)
}

func RegisterTagRPCServer(s *grpc.Server, srv TagRPCServer) {
	s.RegisterService(&_TagRPC_serviceDesc, srv)
}

func _TagRPC_Tag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).Tag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/Tag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).Tag(ctx, req.(*TagReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_TagByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagByNameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).TagByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/TagByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).TagByName(ctx, req.(*TagByNameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_Tags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).Tags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/Tags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).Tags(ctx, req.(*TagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_TagByNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagByNamesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).TagByNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/TagByNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).TagByNames(ctx, req.(*TagByNamesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_Channel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).Channel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/Channel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).Channel(ctx, req.(*ChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_ChannelCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelCategoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).ChannelCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/ChannelCategory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).ChannelCategory(ctx, req.(*ChannelCategoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_ChanneList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChanneListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).ChanneList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/ChanneList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).ChanneList(ctx, req.(*ChanneListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_ChannelRecommend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelRecommendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).ChannelRecommend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/ChannelRecommend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).ChannelRecommend(ctx, req.(*ChannelRecommendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_ChannelDiscovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelDiscoveryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).ChannelDiscovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/ChannelDiscovery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).ChannelDiscovery(ctx, req.(*ChannelDiscoveryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_ChannelSquare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelSquareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).ChannelSquare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/ChannelSquare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).ChannelSquare(ctx, req.(*ChannelSquareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_ChannelResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelResourcesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).ChannelResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/ChannelResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).ChannelResources(ctx, req.(*ChannelResourcesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagRPC_ChannelCheckBack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelCheckBackReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagRPCServer).ChannelCheckBack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/main.community.tag.v1.TagRPC/ChannelCheckBack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagRPCServer).ChannelCheckBack(ctx, req.(*ChannelCheckBackReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _TagRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "main.community.tag.v1.TagRPC",
	HandlerType: (*TagRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Tag",
			Handler:    _TagRPC_Tag_Handler,
		},
		{
			MethodName: "TagByName",
			Handler:    _TagRPC_TagByName_Handler,
		},
		{
			MethodName: "Tags",
			Handler:    _TagRPC_Tags_Handler,
		},
		{
			MethodName: "TagByNames",
			Handler:    _TagRPC_TagByNames_Handler,
		},
		{
			MethodName: "Channel",
			Handler:    _TagRPC_Channel_Handler,
		},
		{
			MethodName: "ChannelCategory",
			Handler:    _TagRPC_ChannelCategory_Handler,
		},
		{
			MethodName: "ChanneList",
			Handler:    _TagRPC_ChanneList_Handler,
		},
		{
			MethodName: "ChannelRecommend",
			Handler:    _TagRPC_ChannelRecommend_Handler,
		},
		{
			MethodName: "ChannelDiscovery",
			Handler:    _TagRPC_ChannelDiscovery_Handler,
		},
		{
			MethodName: "ChannelSquare",
			Handler:    _TagRPC_ChannelSquare_Handler,
		},
		{
			MethodName: "ChannelResources",
			Handler:    _TagRPC_ChannelResources_Handler,
		},
		{
			MethodName: "ChannelCheckBack",
			Handler:    _TagRPC_ChannelCheckBack_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "app/interface/main/tag/api/api.proto",
}

func init() {
	proto.RegisterFile("app/interface/main/tag/api/api.proto", fileDescriptor_api_396e783de651c045)
}

var fileDescriptor_api_396e783de651c045 = []byte{
	// 401 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xcd, 0x4a, 0xeb, 0x40,
	0x14, 0xc7, 0xe9, 0xbd, 0x97, 0xde, 0x7b, 0x07, 0x2e, 0xb7, 0x0c, 0xb8, 0x29, 0x18, 0x95, 0x16,
	0xb5, 0x7e, 0x24, 0x54, 0xdf, 0xa0, 0x51, 0x70, 0x21, 0x62, 0x35, 0x0b, 0x71, 0x77, 0x9a, 0x4e,
	0xa7, 0x43, 0x93, 0x4c, 0x9a, 0x99, 0x14, 0xf2, 0x86, 0x2e, 0x7d, 0x04, 0xe9, 0xc6, 0xd7, 0x90,
	0x93, 0xc4, 0x58, 0xc1, 0x7c, 0xe0, 0xa2, 0xd0, 0x39, 0xe7, 0x77, 0xfe, 0xbf, 0x99, 0xb3, 0x08,
	0xe9, 0x43, 0x18, 0x5a, 0x22, 0xd0, 0x2c, 0x9a, 0x81, 0xcb, 0x2c, 0x1f, 0x44, 0x60, 0x69, 0xe0,
	0x16, 0x84, 0x02, 0x7f, 0x66, 0x18, 0x49, 0x2d, 0xe9, 0x16, 0xd6, 0x4d, 0x57, 0xfa, 0x7e, 0x1c,
	0x08, 0x9d, 0x98, 0x1a, 0xb8, 0xb9, 0x1a, 0x76, 0x0f, 0x2b, 0x86, 0x23, 0xb6, 0x8c, 0x99, 0xd2,
	0x59, 0x40, 0x77, 0xbf, 0x92, 0x0c, 0xbd, 0x24, 0xe7, 0x4e, 0xb9, 0xd0, 0xf3, 0x78, 0x82, 0x2a,
	0x8b, 0x4b, 0x2e, 0xad, 0xb4, 0x3c, 0x89, 0x67, 0xe9, 0x29, 0x3d, 0xa4, 0xff, 0x32, 0xfc, 0xec,
	0xf5, 0x0f, 0x69, 0x3b, 0xc0, 0xef, 0x6e, 0x6d, 0x7a, 0x49, 0x7e, 0x3a, 0xc0, 0xe9, 0xb6, 0xf9,
	0xe5, 0x55, 0x4d, 0xa4, 0xd8, 0xb2, 0xbb, 0x53, 0xd5, 0x0e, 0xbd, 0x84, 0x8e, 0xc9, 0x5f, 0x07,
	0xf8, 0x28, 0xb9, 0x01, 0x9f, 0xd1, 0x5e, 0x39, 0x9d, 0x11, 0x8d, 0x22, 0xaf, 0xc8, 0x2f, 0x07,
	0xb8, 0xa2, 0x46, 0x39, 0xa8, 0x30, 0x68, 0xb7, 0xb2, 0x8f, 0x49, 0x0e, 0x21, 0x85, 0x5a, 0xd1,
	0x7e, 0xdd, 0xed, 0x1a, 0xa6, 0x8e, 0xc9, 0x6f, 0x7b, 0x0e, 0x41, 0xc0, 0x3c, 0xba, 0x57, 0x02,
	0xe7, 0x7d, 0xcc, 0xeb, 0xd5, 0x21, 0x18, 0x29, 0xc8, 0xff, 0xfc, 0x6c, 0x83, 0x66, 0x5c, 0x46,
	0x09, 0x1d, 0x54, 0xcf, 0xbd, 0x73, 0xa8, 0x38, 0x6e, 0x8a, 0xa2, 0xea, 0x81, 0x90, 0xac, 0x7e,
	0x2d, 0x94, 0x2e, 0xdd, 0xc9, 0x07, 0x82, 0x82, 0x6a, 0xca, 0xcb, 0xf7, 0x32, 0x25, 0x9d, 0xe2,
	0x51, 0x88, 0xb2, 0x60, 0x4a, 0x8f, 0xea, 0x5e, 0x9f, 0x83, 0xdf, 0xb1, 0x5c, 0x08, 0xe5, 0xca,
	0x15, 0x8b, 0x92, 0x3a, 0x4b, 0x01, 0x36, 0xb7, 0xb8, 0xe4, 0x5f, 0x5e, 0xb8, 0x5f, 0xc6, 0x10,
	0x31, 0x7a, 0x50, 0x3d, 0x96, 0x51, 0x98, 0x3f, 0x68, 0x06, 0xa2, 0xc4, 0xdb, 0x58, 0x98, 0x92,
	0x71, 0xe4, 0x32, 0x55, 0xbf, 0xb0, 0x1c, 0x44, 0xd5, 0x49, 0x63, 0xf6, 0xb3, 0xcd, 0x9e, 0x33,
	0x77, 0x31, 0x02, 0x77, 0x51, 0x67, 0x2b, 0xc0, 0x06, 0xb6, 0x0d, 0x36, 0xf4, 0x92, 0x51, 0xe7,
	0x69, 0x6d, 0xb4, 0x9e, 0xd7, 0x46, 0xeb, 0x65, 0x6d, 0xb4, 0x1e, 0x7f, 0xac, 0x86, 0x93, 0x76,
	0xfa, 0x09, 0x3a, 0x7f, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x8c, 0xe9, 0x6d, 0xda, 0x42, 0x05, 0x00,
	0x00,
}
