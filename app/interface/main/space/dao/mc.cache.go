// Code generated by $GOPATH/src/go-common/app/tool/cache/mc. DO NOT EDIT.

/*
  Package dao is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// get notice data from mc cache.
		// mc: -key=noticeKey
		CacheNotice(c context.Context, mid int64) (*model.Notice, error)
		// set notice data to mc cache.
		// mc: -key=noticeKey -expire=d.mcNoticeExpire -encode=pb
		AddCacheNotice(c context.Context, mid int64, data *model.Notice) error
		// mc: -key=noticeKey
		DelCacheNotice(c context.Context, mid int64) error
		// get top archive data from mc cache.
		// mc: -key=topArcKey
		CacheTopArc(c context.Context, mid int64) (*model.AidReason, error)
		// set top archive data to mc cache.
		// mc: -key=topArcKey -expire=d.mcTopArcExpire -encode=pb
		AddCacheTopArc(c context.Context, mid int64, data *model.AidReason) error
		// get top archive data from mc cache.
		// mc: -key=masterpieceKey
		CacheMasterpiece(c context.Context, mid int64) (*model.AidReasons, error)
		// set top archive data to mc cache.
		// mc: -key=masterpieceKey -expire=d.mcMpExpire -encode=pb
		AddCacheMasterpiece(c context.Context, mid int64, data *model.AidReasons) error
		// get theme data from mc cache.
		// mc: -key=themeKey
		CacheTheme(c context.Context, mid int64) (*model.ThemeDetails, error)
		// set theme data to mc cache.
		// mc: -key=themeKey -expire=d.mcThemeExpire -encode=pb
		AddCacheTheme(c context.Context, mid int64, data *model.ThemeDetails) error
		// mc: -key=themeKey
		DelCacheTheme(c context.Context, mid int64) error
		// get top dynamic id cache.
		// mc: -key=topDyKey
		CacheTopDynamic(c context.Context, key int64) (int64, error)
		// set top dynamic id cache.
		// mc: -key=topDyKey -expire=d.mcTopDyExpire -encode=raw
		AddCacheTopDynamic(c context.Context, key int64, value int64) error
	}
*/

package dao

import (
	"context"
	"fmt"
	"strconv"

	"go-common/app/interface/main/space/model"
	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
)

var _ _mc

// CacheNotice get notice data from mc cache.
func (d *Dao) CacheNotice(c context.Context, id int64) (res *model.Notice, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := noticeKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheNotice")
		log.Errorv(c, log.KV("CacheNotice", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.Notice{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheNotice")
		log.Errorv(c, log.KV("CacheNotice", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheNotice set notice data to mc cache.
func (d *Dao) AddCacheNotice(c context.Context, id int64, val *model.Notice) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := noticeKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcNoticeExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheNotice")
		log.Errorv(c, log.KV("AddCacheNotice", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheNotice delete data from mc
func (d *Dao) DelCacheNotice(c context.Context, id int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := noticeKey(id)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheNotice")
		log.Errorv(c, log.KV("DelCacheNotice", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheTopArc get top archive data from mc cache.
func (d *Dao) CacheTopArc(c context.Context, id int64) (res *model.AidReason, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := topArcKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheTopArc")
		log.Errorv(c, log.KV("CacheTopArc", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.AidReason{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheTopArc")
		log.Errorv(c, log.KV("CacheTopArc", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheTopArc set top archive data to mc cache.
func (d *Dao) AddCacheTopArc(c context.Context, id int64, val *model.AidReason) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := topArcKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcTopArcExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheTopArc")
		log.Errorv(c, log.KV("AddCacheTopArc", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheMasterpiece get top archive data from mc cache.
func (d *Dao) CacheMasterpiece(c context.Context, id int64) (res *model.AidReasons, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := masterpieceKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheMasterpiece")
		log.Errorv(c, log.KV("CacheMasterpiece", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.AidReasons{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheMasterpiece")
		log.Errorv(c, log.KV("CacheMasterpiece", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheMasterpiece set top archive data to mc cache.
func (d *Dao) AddCacheMasterpiece(c context.Context, id int64, val *model.AidReasons) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := masterpieceKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcMpExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheMasterpiece")
		log.Errorv(c, log.KV("AddCacheMasterpiece", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheTheme get theme data from mc cache.
func (d *Dao) CacheTheme(c context.Context, id int64) (res *model.ThemeDetails, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := themeKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheTheme")
		log.Errorv(c, log.KV("CacheTheme", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.ThemeDetails{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheTheme")
		log.Errorv(c, log.KV("CacheTheme", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheTheme set theme data to mc cache.
func (d *Dao) AddCacheTheme(c context.Context, id int64, val *model.ThemeDetails) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := themeKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcThemeExpire, Flags: memcache.FlagProtobuf}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheTheme")
		log.Errorv(c, log.KV("AddCacheTheme", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheTheme delete data from mc
func (d *Dao) DelCacheTheme(c context.Context, id int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := themeKey(id)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheTheme")
		log.Errorv(c, log.KV("DelCacheTheme", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheTopDynamic get top dynamic id cache.
func (d *Dao) CacheTopDynamic(c context.Context, id int64) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := topDyKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheTopDynamic")
		log.Errorv(c, log.KV("CacheTopDynamic", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheTopDynamic")
		log.Errorv(c, log.KV("CacheTopDynamic", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheTopDynamic")
		log.Errorv(c, log.KV("CacheTopDynamic", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// AddCacheTopDynamic set top dynamic id cache.
func (d *Dao) AddCacheTopDynamic(c context.Context, id int64, val int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := topDyKey(id)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcTopDyExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheTopDynamic")
		log.Errorv(c, log.KV("AddCacheTopDynamic", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
