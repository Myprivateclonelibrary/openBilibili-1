// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

/*
	Package v1 is a generated protocol buffer package.

	It is generated from these files:
		api.proto

	It has these top-level messages:
		AddHistoryReply
		AddHistoryReq
		ClearHistoryReply
		ClearHistoryReq
		DeleteReply
		DeleteReq
		FlushHistoryReply
		FlushHistoryReq
		HistoriesReply
		HistoriesReq
		HistoryCursorReply
		HistoryCursorReq
		ModelHistory
		ModelResource
		PositionReply
		PositionReq
		ProgressReply
		ProgressReq
*/
package v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AddHistoryReply struct {
}

func (m *AddHistoryReply) Reset()                    { *m = AddHistoryReply{} }
func (m *AddHistoryReply) String() string            { return proto.CompactTextString(m) }
func (*AddHistoryReply) ProtoMessage()               {}
func (*AddHistoryReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

type AddHistoryReq struct {
	Mid   int64         `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	Rtime int64         `protobuf:"varint,3,opt,name=rtime,proto3" json:"rtime,omitempty"`
	H     *ModelHistory `protobuf:"bytes,4,opt,name=h" json:"h,omitempty"`
}

func (m *AddHistoryReq) Reset()                    { *m = AddHistoryReq{} }
func (m *AddHistoryReq) String() string            { return proto.CompactTextString(m) }
func (*AddHistoryReq) ProtoMessage()               {}
func (*AddHistoryReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

func (m *AddHistoryReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *AddHistoryReq) GetRtime() int64 {
	if m != nil {
		return m.Rtime
	}
	return 0
}

func (m *AddHistoryReq) GetH() *ModelHistory {
	if m != nil {
		return m.H
	}
	return nil
}

type ClearHistoryReply struct {
}

func (m *ClearHistoryReply) Reset()                    { *m = ClearHistoryReply{} }
func (m *ClearHistoryReply) String() string            { return proto.CompactTextString(m) }
func (*ClearHistoryReply) ProtoMessage()               {}
func (*ClearHistoryReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

type ClearHistoryReq struct {
	Mid        int64    `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	Businesses []string `protobuf:"bytes,3,rep,name=businesses" json:"businesses,omitempty"`
}

func (m *ClearHistoryReq) Reset()                    { *m = ClearHistoryReq{} }
func (m *ClearHistoryReq) String() string            { return proto.CompactTextString(m) }
func (*ClearHistoryReq) ProtoMessage()               {}
func (*ClearHistoryReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

func (m *ClearHistoryReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ClearHistoryReq) GetBusinesses() []string {
	if m != nil {
		return m.Businesses
	}
	return nil
}

type DeleteReply struct {
}

func (m *DeleteReply) Reset()                    { *m = DeleteReply{} }
func (m *DeleteReply) String() string            { return proto.CompactTextString(m) }
func (*DeleteReply) ProtoMessage()               {}
func (*DeleteReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

type DeleteReq struct {
	Mid int64           `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	His []*ModelHistory `protobuf:"bytes,3,rep,name=his" json:"his,omitempty"`
}

func (m *DeleteReq) Reset()                    { *m = DeleteReq{} }
func (m *DeleteReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteReq) ProtoMessage()               {}
func (*DeleteReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

func (m *DeleteReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *DeleteReq) GetHis() []*ModelHistory {
	if m != nil {
		return m.His
	}
	return nil
}

type FlushHistoryReply struct {
}

func (m *FlushHistoryReply) Reset()                    { *m = FlushHistoryReply{} }
func (m *FlushHistoryReply) String() string            { return proto.CompactTextString(m) }
func (*FlushHistoryReply) ProtoMessage()               {}
func (*FlushHistoryReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

type FlushHistoryReq struct {
	Mids  []int64 `protobuf:"varint,2,rep,packed,name=mids" json:"mids,omitempty"`
	Stime int64   `protobuf:"varint,3,opt,name=stime,proto3" json:"stime,omitempty"`
}

func (m *FlushHistoryReq) Reset()                    { *m = FlushHistoryReq{} }
func (m *FlushHistoryReq) String() string            { return proto.CompactTextString(m) }
func (*FlushHistoryReq) ProtoMessage()               {}
func (*FlushHistoryReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

func (m *FlushHistoryReq) GetMids() []int64 {
	if m != nil {
		return m.Mids
	}
	return nil
}

func (m *FlushHistoryReq) GetStime() int64 {
	if m != nil {
		return m.Stime
	}
	return 0
}

type HistoriesReply struct {
	Res []*ModelResource `protobuf:"bytes,1,rep,name=res" json:"res,omitempty"`
}

func (m *HistoriesReply) Reset()                    { *m = HistoriesReply{} }
func (m *HistoriesReply) String() string            { return proto.CompactTextString(m) }
func (*HistoriesReply) ProtoMessage()               {}
func (*HistoriesReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

func (m *HistoriesReply) GetRes() []*ModelResource {
	if m != nil {
		return m.Res
	}
	return nil
}

type HistoriesReq struct {
	Mid      int64  `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	Business string `protobuf:"bytes,3,opt,name=business,proto3" json:"business,omitempty"`
	Pn       int32  `protobuf:"varint,4,opt,name=pn,proto3" json:"pn,omitempty"`
	Ps       int32  `protobuf:"varint,5,opt,name=ps,proto3" json:"ps,omitempty"`
}

func (m *HistoriesReq) Reset()                    { *m = HistoriesReq{} }
func (m *HistoriesReq) String() string            { return proto.CompactTextString(m) }
func (*HistoriesReq) ProtoMessage()               {}
func (*HistoriesReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

func (m *HistoriesReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *HistoriesReq) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

func (m *HistoriesReq) GetPn() int32 {
	if m != nil {
		return m.Pn
	}
	return 0
}

func (m *HistoriesReq) GetPs() int32 {
	if m != nil {
		return m.Ps
	}
	return 0
}

type HistoryCursorReply struct {
	Res []*ModelResource `protobuf:"bytes,1,rep,name=res" json:"res,omitempty"`
}

func (m *HistoryCursorReply) Reset()                    { *m = HistoryCursorReply{} }
func (m *HistoryCursorReply) String() string            { return proto.CompactTextString(m) }
func (*HistoryCursorReply) ProtoMessage()               {}
func (*HistoryCursorReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

func (m *HistoryCursorReply) GetRes() []*ModelResource {
	if m != nil {
		return m.Res
	}
	return nil
}

type HistoryCursorReq struct {
	Mid        int64    `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	Max        int64    `protobuf:"varint,3,opt,name=max,proto3" json:"max,omitempty"`
	ViewAt     int64    `protobuf:"varint,4,opt,name=view_at,json=viewAt,proto3" json:"view_at,omitempty"`
	Ps         int32    `protobuf:"varint,5,opt,name=ps,proto3" json:"ps,omitempty"`
	Business   string   `protobuf:"bytes,6,opt,name=business,proto3" json:"business,omitempty"`
	Businesses []string `protobuf:"bytes,7,rep,name=businesses" json:"businesses,omitempty"`
	Ip         string   `protobuf:"bytes,8,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *HistoryCursorReq) Reset()                    { *m = HistoryCursorReq{} }
func (m *HistoryCursorReq) String() string            { return proto.CompactTextString(m) }
func (*HistoryCursorReq) ProtoMessage()               {}
func (*HistoryCursorReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

func (m *HistoryCursorReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *HistoryCursorReq) GetMax() int64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *HistoryCursorReq) GetViewAt() int64 {
	if m != nil {
		return m.ViewAt
	}
	return 0
}

func (m *HistoryCursorReq) GetPs() int32 {
	if m != nil {
		return m.Ps
	}
	return 0
}

func (m *HistoryCursorReq) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

func (m *HistoryCursorReq) GetBusinesses() []string {
	if m != nil {
		return m.Businesses
	}
	return nil
}

func (m *HistoryCursorReq) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

type ModelHistory struct {
	Mid      int64  `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	Aid      int64  `protobuf:"varint,2,opt,name=aid,proto3" json:"aid,omitempty"`
	Sid      int64  `protobuf:"varint,3,opt,name=sid,proto3" json:"sid,omitempty"`
	Epid     int64  `protobuf:"varint,4,opt,name=epid,proto3" json:"epid,omitempty"`
	Tp       int32  `protobuf:"varint,5,opt,name=tp,proto3" json:"tp,omitempty"`
	Business string `protobuf:"bytes,6,opt,name=business,proto3" json:"business,omitempty"`
	Stp      int32  `protobuf:"varint,7,opt,name=stp,proto3" json:"stp,omitempty"`
	Cid      int64  `protobuf:"varint,8,opt,name=cid,proto3" json:"cid,omitempty"`
	Dt       int32  `protobuf:"varint,9,opt,name=dt,proto3" json:"dt,omitempty"`
	Pro      int64  `protobuf:"varint,10,opt,name=pro,proto3" json:"pro,omitempty"`
	Unix     int64  `protobuf:"varint,11,opt,name=unix,proto3" json:"unix,omitempty"`
}

func (m *ModelHistory) Reset()                    { *m = ModelHistory{} }
func (m *ModelHistory) String() string            { return proto.CompactTextString(m) }
func (*ModelHistory) ProtoMessage()               {}
func (*ModelHistory) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

func (m *ModelHistory) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ModelHistory) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *ModelHistory) GetSid() int64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *ModelHistory) GetEpid() int64 {
	if m != nil {
		return m.Epid
	}
	return 0
}

func (m *ModelHistory) GetTp() int32 {
	if m != nil {
		return m.Tp
	}
	return 0
}

func (m *ModelHistory) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

func (m *ModelHistory) GetStp() int32 {
	if m != nil {
		return m.Stp
	}
	return 0
}

func (m *ModelHistory) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *ModelHistory) GetDt() int32 {
	if m != nil {
		return m.Dt
	}
	return 0
}

func (m *ModelHistory) GetPro() int64 {
	if m != nil {
		return m.Pro
	}
	return 0
}

func (m *ModelHistory) GetUnix() int64 {
	if m != nil {
		return m.Unix
	}
	return 0
}

type ModelResource struct {
	Mid      int64  `protobuf:"varint,1,opt,name=mid,proto3" json:"mid,omitempty"`
	Oid      int64  `protobuf:"varint,2,opt,name=oid,proto3" json:"oid,omitempty"`
	Sid      int64  `protobuf:"varint,3,opt,name=sid,proto3" json:"sid,omitempty"`
	Epid     int64  `protobuf:"varint,4,opt,name=epid,proto3" json:"epid,omitempty"`
	Tp       int32  `protobuf:"varint,5,opt,name=tp,proto3" json:"tp,omitempty"`
	Stp      int32  `protobuf:"varint,6,opt,name=stp,proto3" json:"stp,omitempty"`
	Cid      int64  `protobuf:"varint,7,opt,name=cid,proto3" json:"cid,omitempty"`
	Business string `protobuf:"bytes,8,opt,name=business,proto3" json:"business,omitempty"`
	Dt       int32  `protobuf:"varint,9,opt,name=dt,proto3" json:"dt,omitempty"`
	Pro      int64  `protobuf:"varint,10,opt,name=pro,proto3" json:"pro,omitempty"`
	Unix     int64  `protobuf:"varint,11,opt,name=unix,proto3" json:"unix,omitempty"`
}

func (m *ModelResource) Reset()                    { *m = ModelResource{} }
func (m *ModelResource) String() string            { return proto.CompactTextString(m) }
func (*ModelResource) ProtoMessage()               {}
func (*ModelResource) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{13} }

func (m *ModelResource) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ModelResource) GetOid() int64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

func (m *ModelResource) GetSid() int64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *ModelResource) GetEpid() int64 {
	if m != nil {
		return m.Epid
	}
	return 0
}

func (m *ModelResource) GetTp() int32 {
	if m != nil {
		return m.Tp
	}
	return 0
}

func (m *ModelResource) GetStp() int32 {
	if m != nil {
		return m.Stp
	}
	return 0
}

func (m *ModelResource) GetCid() int64 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *ModelResource) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

func (m *ModelResource) GetDt() int32 {
	if m != nil {
		return m.Dt
	}
	return 0
}

func (m *ModelResource) GetPro() int64 {
	if m != nil {
		return m.Pro
	}
	return 0
}

func (m *ModelResource) GetUnix() int64 {
	if m != nil {
		return m.Unix
	}
	return 0
}

type PositionReply struct {
	Res *ModelHistory `protobuf:"bytes,1,opt,name=res" json:"res,omitempty"`
}

func (m *PositionReply) Reset()                    { *m = PositionReply{} }
func (m *PositionReply) String() string            { return proto.CompactTextString(m) }
func (*PositionReply) ProtoMessage()               {}
func (*PositionReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{14} }

func (m *PositionReply) GetRes() *ModelHistory {
	if m != nil {
		return m.Res
	}
	return nil
}

type PositionReq struct {
	Mid      int64  `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	Aid      int64  `protobuf:"varint,3,opt,name=aid,proto3" json:"aid,omitempty"`
	Business string `protobuf:"bytes,4,opt,name=business,proto3" json:"business,omitempty"`
}

func (m *PositionReq) Reset()                    { *m = PositionReq{} }
func (m *PositionReq) String() string            { return proto.CompactTextString(m) }
func (*PositionReq) ProtoMessage()               {}
func (*PositionReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{15} }

func (m *PositionReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *PositionReq) GetAid() int64 {
	if m != nil {
		return m.Aid
	}
	return 0
}

func (m *PositionReq) GetBusiness() string {
	if m != nil {
		return m.Business
	}
	return ""
}

type ProgressReply struct {
	Res map[int64]*ModelHistory `protobuf:"bytes,1,rep,name=res" json:"res,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ProgressReply) Reset()                    { *m = ProgressReply{} }
func (m *ProgressReply) String() string            { return proto.CompactTextString(m) }
func (*ProgressReply) ProtoMessage()               {}
func (*ProgressReply) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{16} }

func (m *ProgressReply) GetRes() map[int64]*ModelHistory {
	if m != nil {
		return m.Res
	}
	return nil
}

type ProgressReq struct {
	Mid  int64   `protobuf:"varint,2,opt,name=mid,proto3" json:"mid,omitempty"`
	Aids []int64 `protobuf:"varint,3,rep,packed,name=aids" json:"aids,omitempty"`
}

func (m *ProgressReq) Reset()                    { *m = ProgressReq{} }
func (m *ProgressReq) String() string            { return proto.CompactTextString(m) }
func (*ProgressReq) ProtoMessage()               {}
func (*ProgressReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{17} }

func (m *ProgressReq) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ProgressReq) GetAids() []int64 {
	if m != nil {
		return m.Aids
	}
	return nil
}

func init() {
	proto.RegisterType((*AddHistoryReply)(nil), "community.service.history.AddHistoryReply")
	proto.RegisterType((*AddHistoryReq)(nil), "community.service.history.AddHistoryReq")
	proto.RegisterType((*ClearHistoryReply)(nil), "community.service.history.ClearHistoryReply")
	proto.RegisterType((*ClearHistoryReq)(nil), "community.service.history.ClearHistoryReq")
	proto.RegisterType((*DeleteReply)(nil), "community.service.history.DeleteReply")
	proto.RegisterType((*DeleteReq)(nil), "community.service.history.DeleteReq")
	proto.RegisterType((*FlushHistoryReply)(nil), "community.service.history.FlushHistoryReply")
	proto.RegisterType((*FlushHistoryReq)(nil), "community.service.history.FlushHistoryReq")
	proto.RegisterType((*HistoriesReply)(nil), "community.service.history.HistoriesReply")
	proto.RegisterType((*HistoriesReq)(nil), "community.service.history.HistoriesReq")
	proto.RegisterType((*HistoryCursorReply)(nil), "community.service.history.HistoryCursorReply")
	proto.RegisterType((*HistoryCursorReq)(nil), "community.service.history.HistoryCursorReq")
	proto.RegisterType((*ModelHistory)(nil), "community.service.history.ModelHistory")
	proto.RegisterType((*ModelResource)(nil), "community.service.history.ModelResource")
	proto.RegisterType((*PositionReply)(nil), "community.service.history.PositionReply")
	proto.RegisterType((*PositionReq)(nil), "community.service.history.PositionReq")
	proto.RegisterType((*ProgressReply)(nil), "community.service.history.ProgressReply")
	proto.RegisterType((*ProgressReq)(nil), "community.service.history.ProgressReq")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for History service

type HistoryClient interface {
	// AddHistory add hisotry progress into hbase.
	AddHistory(ctx context.Context, in *AddHistoryReq, opts ...grpc.CallOption) (*AddHistoryReply, error)
	// Progress get view progress from cache/hbase.
	Progress(ctx context.Context, in *ProgressReq, opts ...grpc.CallOption) (*ProgressReply, error)
	// Position get view progress from cache/hbase.
	Position(ctx context.Context, in *PositionReq, opts ...grpc.CallOption) (*PositionReply, error)
	// ClearHistory clear user's historys.
	ClearHistory(ctx context.Context, in *ClearHistoryReq, opts ...grpc.CallOption) (*ClearHistoryReply, error)
	// Histories return the user all av  history.
	Histories(ctx context.Context, in *HistoriesReq, opts ...grpc.CallOption) (*HistoriesReply, error)
	// HistoryCursor return the user all av  history.
	HistoryCursor(ctx context.Context, in *HistoryCursorReq, opts ...grpc.CallOption) (*HistoryCursorReply, error)
	// Delete .
	Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteReply, error)
	// FlushHistory flush to hbase from cache.
	FlushHistory(ctx context.Context, in *FlushHistoryReq, opts ...grpc.CallOption) (*FlushHistoryReply, error)
}

type historyClient struct {
	cc *grpc.ClientConn
}

func NewHistoryClient(cc *grpc.ClientConn) HistoryClient {
	return &historyClient{cc}
}

func (c *historyClient) AddHistory(ctx context.Context, in *AddHistoryReq, opts ...grpc.CallOption) (*AddHistoryReply, error) {
	out := new(AddHistoryReply)
	err := grpc.Invoke(ctx, "/community.service.history.History/AddHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyClient) Progress(ctx context.Context, in *ProgressReq, opts ...grpc.CallOption) (*ProgressReply, error) {
	out := new(ProgressReply)
	err := grpc.Invoke(ctx, "/community.service.history.History/Progress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyClient) Position(ctx context.Context, in *PositionReq, opts ...grpc.CallOption) (*PositionReply, error) {
	out := new(PositionReply)
	err := grpc.Invoke(ctx, "/community.service.history.History/Position", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyClient) ClearHistory(ctx context.Context, in *ClearHistoryReq, opts ...grpc.CallOption) (*ClearHistoryReply, error) {
	out := new(ClearHistoryReply)
	err := grpc.Invoke(ctx, "/community.service.history.History/ClearHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyClient) Histories(ctx context.Context, in *HistoriesReq, opts ...grpc.CallOption) (*HistoriesReply, error) {
	out := new(HistoriesReply)
	err := grpc.Invoke(ctx, "/community.service.history.History/Histories", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyClient) HistoryCursor(ctx context.Context, in *HistoryCursorReq, opts ...grpc.CallOption) (*HistoryCursorReply, error) {
	out := new(HistoryCursorReply)
	err := grpc.Invoke(ctx, "/community.service.history.History/HistoryCursor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyClient) Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteReply, error) {
	out := new(DeleteReply)
	err := grpc.Invoke(ctx, "/community.service.history.History/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyClient) FlushHistory(ctx context.Context, in *FlushHistoryReq, opts ...grpc.CallOption) (*FlushHistoryReply, error) {
	out := new(FlushHistoryReply)
	err := grpc.Invoke(ctx, "/community.service.history.History/FlushHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for History service

type HistoryServer interface {
	// AddHistory add hisotry progress into hbase.
	AddHistory(context.Context, *AddHistoryReq) (*AddHistoryReply, error)
	// Progress get view progress from cache/hbase.
	Progress(context.Context, *ProgressReq) (*ProgressReply, error)
	// Position get view progress from cache/hbase.
	Position(context.Context, *PositionReq) (*PositionReply, error)
	// ClearHistory clear user's historys.
	ClearHistory(context.Context, *ClearHistoryReq) (*ClearHistoryReply, error)
	// Histories return the user all av  history.
	Histories(context.Context, *HistoriesReq) (*HistoriesReply, error)
	// HistoryCursor return the user all av  history.
	HistoryCursor(context.Context, *HistoryCursorReq) (*HistoryCursorReply, error)
	// Delete .
	Delete(context.Context, *DeleteReq) (*DeleteReply, error)
	// FlushHistory flush to hbase from cache.
	FlushHistory(context.Context, *FlushHistoryReq) (*FlushHistoryReply, error)
}

func RegisterHistoryServer(s *grpc.Server, srv HistoryServer) {
	s.RegisterService(&_History_serviceDesc, srv)
}

func _History_AddHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).AddHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.history.History/AddHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).AddHistory(ctx, req.(*AddHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _History_Progress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProgressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).Progress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.history.History/Progress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).Progress(ctx, req.(*ProgressReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _History_Position_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PositionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).Position(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.history.History/Position",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).Position(ctx, req.(*PositionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _History_ClearHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).ClearHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.history.History/ClearHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).ClearHistory(ctx, req.(*ClearHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _History_Histories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HistoriesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).Histories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.history.History/Histories",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).Histories(ctx, req.(*HistoriesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _History_HistoryCursor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HistoryCursorReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).HistoryCursor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.history.History/HistoryCursor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).HistoryCursor(ctx, req.(*HistoryCursorReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _History_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.history.History/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).Delete(ctx, req.(*DeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _History_FlushHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlushHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServer).FlushHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/community.service.history.History/FlushHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServer).FlushHistory(ctx, req.(*FlushHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _History_serviceDesc = grpc.ServiceDesc{
	ServiceName: "community.service.history.History",
	HandlerType: (*HistoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddHistory",
			Handler:    _History_AddHistory_Handler,
		},
		{
			MethodName: "Progress",
			Handler:    _History_Progress_Handler,
		},
		{
			MethodName: "Position",
			Handler:    _History_Position_Handler,
		},
		{
			MethodName: "ClearHistory",
			Handler:    _History_ClearHistory_Handler,
		},
		{
			MethodName: "Histories",
			Handler:    _History_Histories_Handler,
		},
		{
			MethodName: "HistoryCursor",
			Handler:    _History_HistoryCursor_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _History_Delete_Handler,
		},
		{
			MethodName: "FlushHistory",
			Handler:    _History_FlushHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func (m *AddHistoryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddHistoryReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AddHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Rtime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Rtime))
	}
	if m.H != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.H.Size()))
		n1, err := m.H.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ClearHistoryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearHistoryReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ClearHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Businesses) > 0 {
		for _, s := range m.Businesses {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DeleteReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeleteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.His) > 0 {
		for _, msg := range m.His {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlushHistoryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushHistoryReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FlushHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mids) > 0 {
		dAtA3 := make([]byte, len(m.Mids)*10)
		var j2 int
		for _, num1 := range m.Mids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.Stime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Stime))
	}
	return i, nil
}

func (m *HistoriesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoriesReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Res) > 0 {
		for _, msg := range m.Res {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HistoriesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoriesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	if m.Pn != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pn))
	}
	if m.Ps != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
	}
	return i, nil
}

func (m *HistoryCursorReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoryCursorReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Res) > 0 {
		for _, msg := range m.Res {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HistoryCursorReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoryCursorReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Max != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Max))
	}
	if m.ViewAt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.ViewAt))
	}
	if m.Ps != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Ps))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	if len(m.Businesses) > 0 {
		for _, s := range m.Businesses {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	return i, nil
}

func (m *ModelHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Aid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if m.Sid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Sid))
	}
	if m.Epid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Epid))
	}
	if m.Tp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Tp))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	if m.Stp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Stp))
	}
	if m.Cid != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
	}
	if m.Dt != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Dt))
	}
	if m.Pro != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pro))
	}
	if m.Unix != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Unix))
	}
	return i, nil
}

func (m *ModelResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelResource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Oid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Oid))
	}
	if m.Sid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Sid))
	}
	if m.Epid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Epid))
	}
	if m.Tp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Tp))
	}
	if m.Stp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Stp))
	}
	if m.Cid != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Cid))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	if m.Dt != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Dt))
	}
	if m.Pro != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Pro))
	}
	if m.Unix != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Unix))
	}
	return i, nil
}

func (m *PositionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Res != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Res.Size()))
		n4, err := m.Res.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *PositionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PositionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if m.Aid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Aid))
	}
	if len(m.Business) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Business)))
		i += copy(dAtA[i:], m.Business)
	}
	return i, nil
}

func (m *ProgressReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProgressReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Res) > 0 {
		for k, _ := range m.Res {
			dAtA[i] = 0xa
			i++
			v := m.Res[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovApi(uint64(msgSize))
			}
			mapSize := 1 + sovApi(uint64(k)) + msgSize
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintApi(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintApi(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	return i, nil
}

func (m *ProgressReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProgressReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Mid))
	}
	if len(m.Aids) > 0 {
		dAtA7 := make([]byte, len(m.Aids)*10)
		var j6 int
		for _, num1 := range m.Aids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AddHistoryReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AddHistoryReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Rtime != 0 {
		n += 1 + sovApi(uint64(m.Rtime))
	}
	if m.H != nil {
		l = m.H.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ClearHistoryReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ClearHistoryReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if len(m.Businesses) > 0 {
		for _, s := range m.Businesses {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *DeleteReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeleteReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if len(m.His) > 0 {
		for _, e := range m.His {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *FlushHistoryReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FlushHistoryReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Mids) > 0 {
		l = 0
		for _, e := range m.Mids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.Stime != 0 {
		n += 1 + sovApi(uint64(m.Stime))
	}
	return n
}

func (m *HistoriesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Res) > 0 {
		for _, e := range m.Res {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *HistoriesReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Pn != 0 {
		n += 1 + sovApi(uint64(m.Pn))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	return n
}

func (m *HistoryCursorReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Res) > 0 {
		for _, e := range m.Res {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *HistoryCursorReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Max != 0 {
		n += 1 + sovApi(uint64(m.Max))
	}
	if m.ViewAt != 0 {
		n += 1 + sovApi(uint64(m.ViewAt))
	}
	if m.Ps != 0 {
		n += 1 + sovApi(uint64(m.Ps))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Businesses) > 0 {
		for _, s := range m.Businesses {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ModelHistory) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	if m.Sid != 0 {
		n += 1 + sovApi(uint64(m.Sid))
	}
	if m.Epid != 0 {
		n += 1 + sovApi(uint64(m.Epid))
	}
	if m.Tp != 0 {
		n += 1 + sovApi(uint64(m.Tp))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Stp != 0 {
		n += 1 + sovApi(uint64(m.Stp))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	if m.Dt != 0 {
		n += 1 + sovApi(uint64(m.Dt))
	}
	if m.Pro != 0 {
		n += 1 + sovApi(uint64(m.Pro))
	}
	if m.Unix != 0 {
		n += 1 + sovApi(uint64(m.Unix))
	}
	return n
}

func (m *ModelResource) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Oid != 0 {
		n += 1 + sovApi(uint64(m.Oid))
	}
	if m.Sid != 0 {
		n += 1 + sovApi(uint64(m.Sid))
	}
	if m.Epid != 0 {
		n += 1 + sovApi(uint64(m.Epid))
	}
	if m.Tp != 0 {
		n += 1 + sovApi(uint64(m.Tp))
	}
	if m.Stp != 0 {
		n += 1 + sovApi(uint64(m.Stp))
	}
	if m.Cid != 0 {
		n += 1 + sovApi(uint64(m.Cid))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Dt != 0 {
		n += 1 + sovApi(uint64(m.Dt))
	}
	if m.Pro != 0 {
		n += 1 + sovApi(uint64(m.Pro))
	}
	if m.Unix != 0 {
		n += 1 + sovApi(uint64(m.Unix))
	}
	return n
}

func (m *PositionReply) Size() (n int) {
	var l int
	_ = l
	if m.Res != nil {
		l = m.Res.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *PositionReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if m.Aid != 0 {
		n += 1 + sovApi(uint64(m.Aid))
	}
	l = len(m.Business)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ProgressReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Res) > 0 {
		for k, v := range m.Res {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ProgressReq) Size() (n int) {
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovApi(uint64(m.Mid))
	}
	if len(m.Aids) > 0 {
		l = 0
		for _, e := range m.Aids {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddHistoryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddHistoryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddHistoryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtime", wireType)
			}
			m.Rtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.H == nil {
				m.H = &ModelHistory{}
			}
			if err := m.H.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearHistoryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearHistoryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearHistoryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Businesses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Businesses = append(m.Businesses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field His", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.His = append(m.His, &ModelHistory{})
			if err := m.His[len(m.His)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushHistoryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushHistoryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushHistoryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mids = append(m.Mids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mids = append(m.Mids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mids", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoriesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoriesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoriesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res, &ModelResource{})
			if err := m.Res[len(m.Res)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoriesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoriesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoriesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pn", wireType)
			}
			m.Pn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pn |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoryCursorReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoryCursorReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoryCursorReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res, &ModelResource{})
			if err := m.Res[len(m.Res)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoryCursorReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoryCursorReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoryCursorReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewAt", wireType)
			}
			m.ViewAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ps", wireType)
			}
			m.Ps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ps |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Businesses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Businesses = append(m.Businesses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epid", wireType)
			}
			m.Epid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stp", wireType)
			}
			m.Stp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dt", wireType)
			}
			m.Dt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pro", wireType)
			}
			m.Pro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unix", wireType)
			}
			m.Unix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unix |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epid", wireType)
			}
			m.Epid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			m.Tp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stp", wireType)
			}
			m.Stp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dt", wireType)
			}
			m.Dt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pro", wireType)
			}
			m.Pro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unix", wireType)
			}
			m.Unix = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unix |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Res == nil {
				m.Res = &ModelHistory{}
			}
			if err := m.Res.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PositionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PositionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PositionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Business", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Business = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProgressReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProgressReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProgressReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Res == nil {
				m.Res = make(map[int64]*ModelHistory)
			}
			var mapkey int64
			var mapvalue *ModelHistory
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ModelHistory{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Res[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProgressReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProgressReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProgressReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Aids = append(m.Aids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Aids = append(m.Aids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Aids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 789 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0xd3, 0x4a,
	0x10, 0x3e, 0x1b, 0xe7, 0x77, 0xd2, 0xf4, 0x67, 0x4f, 0xa5, 0xe3, 0xe3, 0x8b, 0x28, 0xb2, 0x8e,
	0x7a, 0xc2, 0x5f, 0xa4, 0xb6, 0x42, 0xa2, 0x45, 0x5c, 0x94, 0x00, 0x42, 0x88, 0x4a, 0x95, 0x2f,
	0x10, 0x42, 0x95, 0x2a, 0x37, 0x5e, 0x91, 0x55, 0x13, 0xaf, 0xeb, 0x5d, 0x87, 0xe6, 0x4d, 0xb8,
	0xe7, 0x92, 0x6b, 0xde, 0x81, 0x4b, 0x9e, 0x00, 0x50, 0x79, 0x11, 0xb4, 0x6b, 0xbb, 0xfe, 0x69,
	0xea, 0xba, 0xe5, 0x6e, 0x66, 0x34, 0xf3, 0xed, 0xf7, 0xcd, 0x8e, 0x77, 0x0c, 0x2d, 0xdb, 0xa3,
	0x03, 0xcf, 0x67, 0x82, 0xe1, 0x7f, 0x47, 0x6c, 0x3a, 0x0d, 0x5c, 0x2a, 0xe6, 0x03, 0x4e, 0xfc,
	0x19, 0x1d, 0x91, 0xc1, 0x98, 0x72, 0xc1, 0xfc, 0xb9, 0xb9, 0x06, 0x2b, 0x7b, 0x8e, 0xf3, 0x32,
	0xf4, 0x2c, 0xe2, 0x4d, 0xe6, 0xa6, 0x0b, 0x9d, 0x74, 0xe8, 0x14, 0xaf, 0x82, 0x36, 0xa5, 0x8e,
	0x5e, 0xe9, 0xa1, 0xbe, 0x66, 0x49, 0x13, 0xaf, 0x43, 0xcd, 0x17, 0x74, 0x4a, 0x74, 0x4d, 0xc5,
	0x42, 0x07, 0x3f, 0x04, 0x34, 0xd6, 0xab, 0x3d, 0xd4, 0x6f, 0x6f, 0xfd, 0x3f, 0xb8, 0xf2, 0xc8,
	0xc1, 0x3e, 0x73, 0xc8, 0x24, 0x86, 0x47, 0x63, 0xf3, 0x6f, 0x58, 0x1b, 0x4e, 0x88, 0xed, 0x67,
	0x48, 0x0c, 0x61, 0x25, 0x1b, 0x5c, 0x44, 0xa3, 0x0b, 0x70, 0x1c, 0x70, 0xea, 0x12, 0xce, 0x09,
	0xd7, 0xb5, 0x9e, 0xd6, 0x6f, 0x59, 0xa9, 0x88, 0xd9, 0x81, 0xf6, 0x33, 0x32, 0x21, 0x82, 0x84,
	0x98, 0x6f, 0xa1, 0x15, 0xbb, 0x8b, 0xd0, 0x76, 0x40, 0x1b, 0xd3, 0x10, 0xe6, 0x06, 0x02, 0x64,
	0x8d, 0x94, 0xf0, 0x62, 0x12, 0xf0, 0x71, 0x46, 0xc2, 0x63, 0x58, 0xc9, 0x06, 0x4f, 0x31, 0x86,
	0xea, 0x94, 0x3a, 0x5c, 0xaf, 0xf4, 0xb4, 0xbe, 0x66, 0x29, 0x5b, 0xf6, 0x92, 0xa7, 0x7b, 0xa9,
	0x1c, 0xf3, 0x35, 0x2c, 0x87, 0x75, 0x94, 0x70, 0x05, 0x87, 0x77, 0x41, 0xf3, 0x09, 0xd7, 0x91,
	0xa2, 0xd7, 0xbf, 0x8e, 0x9e, 0x45, 0x38, 0x0b, 0xfc, 0x11, 0xb1, 0x64, 0x91, 0x79, 0x08, 0x4b,
	0x29, 0xb4, 0x45, 0xe2, 0x0d, 0x68, 0xc6, 0x8d, 0x53, 0x44, 0x5a, 0xd6, 0x85, 0x8f, 0x97, 0xa1,
	0xe2, 0xb9, 0xea, 0x62, 0x6b, 0x56, 0xc5, 0x73, 0x95, 0xcf, 0xf5, 0x5a, 0xe4, 0x73, 0xf3, 0x00,
	0x70, 0xa4, 0x71, 0x18, 0xf8, 0x9c, 0xf9, 0x7f, 0xce, 0xf7, 0x33, 0x82, 0xd5, 0x1c, 0xe4, 0x22,
	0xd2, 0x32, 0x62, 0x9f, 0x45, 0x8d, 0x93, 0x26, 0xfe, 0x07, 0x1a, 0x33, 0x4a, 0x3e, 0x1c, 0xd9,
	0x42, 0xf1, 0xd5, 0xac, 0xba, 0x74, 0xf7, 0x44, 0x9e, 0x73, 0x46, 0x6f, 0x3d, 0xa7, 0x37, 0x3b,
	0x56, 0x8d, 0xfc, 0x58, 0x49, 0x2c, 0xea, 0xe9, 0x4d, 0x55, 0x55, 0xa1, 0x9e, 0xf9, 0x1d, 0xc1,
	0x52, 0x7a, 0x26, 0x62, 0xa6, 0x28, 0xc3, 0xd4, 0x4e, 0xb8, 0xdb, 0x61, 0x84, 0x53, 0x27, 0xe6,
	0xce, 0xa9, 0x23, 0x87, 0x83, 0x78, 0xd4, 0x89, 0x88, 0x2b, 0x5b, 0x1e, 0x25, 0xbc, 0x98, 0xb6,
	0xf0, 0x0a, 0x69, 0x4b, 0x44, 0xe1, 0xe9, 0x0d, 0x95, 0x2c, 0x4d, 0x19, 0x19, 0x51, 0x47, 0x31,
	0xd5, 0x2c, 0x69, 0x4a, 0x3c, 0x47, 0xe8, 0xad, 0x10, 0xcf, 0x11, 0x32, 0xc3, 0xf3, 0x99, 0x0e,
	0x61, 0x86, 0xe7, 0x33, 0xc9, 0x22, 0x70, 0xe9, 0x99, 0xde, 0x0e, 0x59, 0x48, 0xdb, 0xfc, 0x81,
	0xa0, 0x93, 0xb9, 0xa5, 0xc5, 0x0a, 0x59, 0xa2, 0x90, 0xdd, 0x5a, 0x61, 0xa4, 0xa2, 0x7e, 0x49,
	0x45, 0x23, 0x51, 0x91, 0xee, 0x42, 0xf3, 0xf2, 0xb0, 0xde, 0x42, 0xe1, 0x2b, 0xe8, 0x1c, 0x30,
	0x4e, 0x05, 0x65, 0x6e, 0x38, 0xbd, 0x3b, 0xf1, 0xf4, 0xde, 0xe8, 0x35, 0x53, 0xc3, 0xbb, 0x0f,
	0xed, 0x04, 0xeb, 0x8a, 0xb1, 0xb5, 0x93, 0xc6, 0xd8, 0x39, 0x41, 0xd5, 0xac, 0x20, 0xf3, 0x0b,
	0x82, 0xce, 0x81, 0xcf, 0xde, 0xfb, 0x84, 0x47, 0x2f, 0xc1, 0x30, 0xfd, 0x65, 0x6d, 0x16, 0x70,
	0xcb, 0x94, 0x0d, 0x2c, 0xc2, 0x9f, 0xbb, 0x22, 0x62, 0x69, 0x1c, 0x41, 0x33, 0x0e, 0x48, 0x42,
	0x27, 0x64, 0x1e, 0xdf, 0xe6, 0x09, 0x99, 0xe3, 0x27, 0x50, 0x9b, 0xd9, 0x93, 0x80, 0x28, 0xda,
	0x37, 0x68, 0x40, 0x58, 0xb5, 0x5b, 0x79, 0x84, 0xcc, 0x6d, 0x68, 0x27, 0xe7, 0x2f, 0x6a, 0x03,
	0x86, 0xaa, 0x2d, 0x1f, 0x43, 0x2d, 0x7c, 0x0c, 0xa5, 0xbd, 0xf5, 0xa9, 0x0e, 0x8d, 0xf8, 0x2b,
	0x3a, 0x06, 0x48, 0xf6, 0x10, 0x2e, 0x7a, 0x41, 0x32, 0xeb, 0xca, 0xb8, 0x5b, 0x32, 0x53, 0xb6,
	0xf2, 0x10, 0x9a, 0x31, 0x49, 0xbc, 0x51, 0xaa, 0x93, 0xa7, 0x46, 0xbf, 0x6c, 0xc7, 0x15, 0x7a,
	0x34, 0x09, 0xc5, 0xe8, 0xc9, 0xb8, 0x14, 0xa3, 0x67, 0x46, 0x74, 0x0c, 0x4b, 0xe9, 0x15, 0x89,
	0x8b, 0x74, 0xe7, 0x76, 0xa9, 0x71, 0xbf, 0x74, 0xae, 0x3c, 0xe9, 0x08, 0x5a, 0x17, 0xeb, 0x03,
	0x17, 0xcd, 0x42, 0x7a, 0xc9, 0x18, 0x77, 0xca, 0x25, 0xca, 0x03, 0x4e, 0xa0, 0x93, 0x79, 0xee,
	0xf1, 0xbd, 0x6b, 0x6b, 0x93, 0xc5, 0x60, 0x3c, 0x28, 0x9f, 0x2c, 0x0f, 0x7b, 0x03, 0xf5, 0xf0,
	0x37, 0x00, 0xff, 0x57, 0x50, 0x78, 0xf1, 0xa7, 0x60, 0x6c, 0x94, 0xc8, 0x8a, 0xee, 0x23, 0xbd,
	0xef, 0x0b, 0xef, 0x23, 0xf7, 0x63, 0x50, 0x78, 0x1f, 0x97, 0xfe, 0x2c, 0x9e, 0xae, 0x7f, 0x3d,
	0xef, 0xa2, 0x6f, 0xe7, 0x5d, 0xf4, 0xf3, 0xbc, 0x8b, 0x3e, 0xfe, 0xea, 0xfe, 0xf5, 0xae, 0x32,
	0xdb, 0x3c, 0xae, 0xab, 0x9f, 0xbd, 0xed, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd7, 0xf8, 0x12,
	0xbe, 0xf9, 0x09, 0x00, 0x00,
}
