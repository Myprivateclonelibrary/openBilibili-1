// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gift.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type From int32

const (
	From_None   From = 0
	From_Gold   From = 1
	From_Silver From = 2
)

var From_name = map[int32]string{
	0: "None",
	1: "Gold",
	2: "Silver",
}
var From_value = map[string]int32{
	"None":   0,
	"Gold":   1,
	"Silver": 2,
}

func (x From) String() string {
	return proto.EnumName(From_name, int32(x))
}
func (From) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{0}
}

type UserAction int32

const (
	UserAction_ActionNone UserAction = 0
	UserAction_StopPush   UserAction = 1
)

var UserAction_name = map[int32]string{
	0: "ActionNone",
	1: "StopPush",
}
var UserAction_value = map[string]int32{
	"ActionNone": 0,
	"StopPush":   1,
}

func (x UserAction) String() string {
	return proto.EnumName(UserAction_name, int32(x))
}
func (UserAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{1}
}

type DailyBagReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DailyBagReq) Reset()         { *m = DailyBagReq{} }
func (m *DailyBagReq) String() string { return proto.CompactTextString(m) }
func (*DailyBagReq) ProtoMessage()    {}
func (*DailyBagReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{0}
}
func (m *DailyBagReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagReq.Merge(dst, src)
}
func (m *DailyBagReq) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagReq.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagReq proto.InternalMessageInfo

type DailyBagResp struct {
	BagStatus            int64                   `protobuf:"varint,1,opt,name=bag_status,json=bagStatus,proto3" json:"bag_status"`
	BagExpireStatus      int64                   `protobuf:"varint,2,opt,name=bag_expire_status,json=bagExpireStatus,proto3" json:"bag_expire_status"`
	BagToast             *DailyBagResp_BagToast  `protobuf:"bytes,3,opt,name=bag_toast,json=bagToast" json:"bag_toast"`
	BagList              []*DailyBagResp_BagList `protobuf:"bytes,4,rep,name=bag_list,json=bagList" json:"bag_list"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *DailyBagResp) Reset()         { *m = DailyBagResp{} }
func (m *DailyBagResp) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp) ProtoMessage()    {}
func (*DailyBagResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{1}
}
func (m *DailyBagResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp.Merge(dst, src)
}
func (m *DailyBagResp) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp proto.InternalMessageInfo

type DailyBagResp_BagToast struct {
	ToastStatus          int64    `protobuf:"varint,1,opt,name=toast_status,json=toastStatus,proto3" json:"toast_status"`
	ToastMessage         string   `protobuf:"bytes,2,opt,name=toast_message,json=toastMessage,proto3" json:"toast_message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DailyBagResp_BagToast) Reset()         { *m = DailyBagResp_BagToast{} }
func (m *DailyBagResp_BagToast) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp_BagToast) ProtoMessage()    {}
func (*DailyBagResp_BagToast) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{1, 0}
}
func (m *DailyBagResp_BagToast) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp_BagToast) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp_BagToast.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp_BagToast) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp_BagToast.Merge(dst, src)
}
func (m *DailyBagResp_BagToast) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp_BagToast) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp_BagToast.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp_BagToast proto.InternalMessageInfo

type DailyBagResp_BagList struct {
	Type                 int64                            `protobuf:"varint,1,opt,name=type,proto3" json:"type"`
	BagName              string                           `protobuf:"bytes,2,opt,name=bag_name,json=bagName,proto3" json:"bag_name"`
	Source               *DailyBagResp_BagList_Source     `protobuf:"bytes,3,opt,name=source" json:"source"`
	GiftList             []*DailyBagResp_BagList_GiftList `protobuf:"bytes,4,rep,name=gift_list,json=giftList" json:"gift_list"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DailyBagResp_BagList) Reset()         { *m = DailyBagResp_BagList{} }
func (m *DailyBagResp_BagList) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp_BagList) ProtoMessage()    {}
func (*DailyBagResp_BagList) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{1, 1}
}
func (m *DailyBagResp_BagList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp_BagList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp_BagList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp_BagList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp_BagList.Merge(dst, src)
}
func (m *DailyBagResp_BagList) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp_BagList) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp_BagList.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp_BagList proto.InternalMessageInfo

type DailyBagResp_BagList_Source struct {
	MedalId              int64    `protobuf:"varint,1,opt,name=medal_id,json=medalId,proto3" json:"medal_id"`
	MedalName            string   `protobuf:"bytes,2,opt,name=medal_name,json=medalName,proto3" json:"medal_name"`
	Level                int64    `protobuf:"varint,3,opt,name=level,proto3" json:"level"`
	UserLevel            int64    `protobuf:"varint,4,opt,name=user_level,json=userLevel,proto3" json:"user_level"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DailyBagResp_BagList_Source) Reset()         { *m = DailyBagResp_BagList_Source{} }
func (m *DailyBagResp_BagList_Source) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp_BagList_Source) ProtoMessage()    {}
func (*DailyBagResp_BagList_Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{1, 1, 0}
}
func (m *DailyBagResp_BagList_Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp_BagList_Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp_BagList_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp_BagList_Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp_BagList_Source.Merge(dst, src)
}
func (m *DailyBagResp_BagList_Source) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp_BagList_Source) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp_BagList_Source.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp_BagList_Source proto.InternalMessageInfo

type DailyBagResp_BagList_GiftList struct {
	GiftId               string   `protobuf:"bytes,1,opt,name=gift_id,json=giftId,proto3" json:"gift_id"`
	GiftNum              int64    `protobuf:"varint,2,opt,name=gift_num,json=giftNum,proto3" json:"gift_num"`
	ExpireAt             int64    `protobuf:"varint,3,opt,name=expire_at,json=expireAt,proto3" json:"expire_at"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DailyBagResp_BagList_GiftList) Reset()         { *m = DailyBagResp_BagList_GiftList{} }
func (m *DailyBagResp_BagList_GiftList) String() string { return proto.CompactTextString(m) }
func (*DailyBagResp_BagList_GiftList) ProtoMessage()    {}
func (*DailyBagResp_BagList_GiftList) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{1, 1, 1}
}
func (m *DailyBagResp_BagList_GiftList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyBagResp_BagList_GiftList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyBagResp_BagList_GiftList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DailyBagResp_BagList_GiftList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyBagResp_BagList_GiftList.Merge(dst, src)
}
func (m *DailyBagResp_BagList_GiftList) XXX_Size() int {
	return m.Size()
}
func (m *DailyBagResp_BagList_GiftList) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyBagResp_BagList_GiftList.DiscardUnknown(m)
}

var xxx_messageInfo_DailyBagResp_BagList_GiftList proto.InternalMessageInfo

type GiftConfigReq struct {
	Platform             string   `protobuf:"bytes,1,opt,name=platform,proto3" json:"platform,omitempty" form:"platform"`
	Build                int64    `protobuf:"varint,2,opt,name=build,proto3" json:"build,omitempty" form:"build"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GiftConfigReq) Reset()         { *m = GiftConfigReq{} }
func (m *GiftConfigReq) String() string { return proto.CompactTextString(m) }
func (*GiftConfigReq) ProtoMessage()    {}
func (*GiftConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{2}
}
func (m *GiftConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiftConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiftConfigReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GiftConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiftConfigReq.Merge(dst, src)
}
func (m *GiftConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *GiftConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GiftConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_GiftConfigReq proto.InternalMessageInfo

type GiftConfigResp struct {
	List                 []*GiftConfigResp_Config `protobuf:"bytes,1,rep,name=list" json:"list"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GiftConfigResp) Reset()         { *m = GiftConfigResp{} }
func (m *GiftConfigResp) String() string { return proto.CompactTextString(m) }
func (*GiftConfigResp) ProtoMessage()    {}
func (*GiftConfigResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{3}
}
func (m *GiftConfigResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiftConfigResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiftConfigResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GiftConfigResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiftConfigResp.Merge(dst, src)
}
func (m *GiftConfigResp) XXX_Size() int {
	return m.Size()
}
func (m *GiftConfigResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GiftConfigResp.DiscardUnknown(m)
}

var xxx_messageInfo_GiftConfigResp proto.InternalMessageInfo

type GiftConfigResp_Config struct {
	Id                   int64                      `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Name                 string                     `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Price                int64                      `protobuf:"varint,3,opt,name=price,proto3" json:"price"`
	Type                 int64                      `protobuf:"varint,4,opt,name=type,proto3" json:"type"`
	CoinType             string                     `protobuf:"bytes,5,opt,name=coin_type,json=coinType,proto3" json:"coin_type"`
	BagGift              int64                      `protobuf:"varint,6,opt,name=bag_gift,json=bagGift,proto3" json:"bag_gift"`
	Effect               int64                      `protobuf:"varint,7,opt,name=effect,proto3" json:"effect"`
	CornerMark           string                     `protobuf:"bytes,8,opt,name=corner_mark,json=cornerMark,proto3" json:"corner_mark"`
	Broadcast            int64                      `protobuf:"varint,9,opt,name=broadcast,proto3" json:"broadcast"`
	Draw                 int64                      `protobuf:"varint,10,opt,name=draw,proto3" json:"draw"`
	StayTime             int64                      `protobuf:"varint,11,opt,name=stay_time,json=stayTime,proto3" json:"stay_time"`
	AnimationFrameNum    int64                      `protobuf:"varint,12,opt,name=animation_frame_num,json=animationFrameNum,proto3" json:"animation_frame_num"`
	Desc                 string                     `protobuf:"bytes,13,opt,name=desc,proto3" json:"desc"`
	Rule                 string                     `protobuf:"bytes,14,opt,name=rule,proto3" json:"rule"`
	Rights               string                     `protobuf:"bytes,15,opt,name=rights,proto3" json:"rights"`
	PrivilegeRequired    int64                      `protobuf:"varint,16,opt,name=privilege_required,json=privilegeRequired,proto3" json:"privilege_required"`
	CountMap             []*GiftConfigResp_CountMap `protobuf:"bytes,17,rep,name=count_map,json=countMap" json:"count_map"`
	ImgBasic             string                     `protobuf:"bytes,18,opt,name=img_basic,json=imgBasic,proto3" json:"img_basic"`
	ImgDynamic           string                     `protobuf:"bytes,19,opt,name=img_dynamic,json=imgDynamic,proto3" json:"img_dynamic"`
	FrameAnimation       string                     `protobuf:"bytes,20,opt,name=frame_animation,json=frameAnimation,proto3" json:"frame_animation"`
	Gif                  string                     `protobuf:"bytes,21,opt,name=gif,proto3" json:"gif"`
	Webp                 string                     `protobuf:"bytes,22,opt,name=webp,proto3" json:"webp"`
	FullScWeb            string                     `protobuf:"bytes,23,opt,name=full_sc_web,json=fullScWeb,proto3" json:"full_sc_web"`
	FullScHorizontal     string                     `protobuf:"bytes,24,opt,name=full_sc_horizontal,json=fullScHorizontal,proto3" json:"full_sc_horizontal"`
	FullScVertical       string                     `protobuf:"bytes,25,opt,name=full_sc_vertical,json=fullScVertical,proto3" json:"full_sc_vertical"`
	FullScHorizontalSvga string                     `protobuf:"bytes,26,opt,name=full_sc_horizontal_svga,json=fullScHorizontalSvga,proto3" json:"full_sc_horizontal_svga"`
	FullScVerticalSvga   string                     `protobuf:"bytes,27,opt,name=full_sc_vertical_svga,json=fullScVerticalSvga,proto3" json:"full_sc_vertical_svga"`
	BulletHead           string                     `protobuf:"bytes,28,opt,name=bullet_head,json=bulletHead,proto3" json:"bullet_head"`
	BulletTail           string                     `protobuf:"bytes,29,opt,name=bullet_tail,json=bulletTail,proto3" json:"bullet_tail"`
	LimitInterval        int64                      `protobuf:"varint,30,opt,name=limit_interval,json=limitInterval,proto3" json:"limit_interval"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *GiftConfigResp_Config) Reset()         { *m = GiftConfigResp_Config{} }
func (m *GiftConfigResp_Config) String() string { return proto.CompactTextString(m) }
func (*GiftConfigResp_Config) ProtoMessage()    {}
func (*GiftConfigResp_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{3, 0}
}
func (m *GiftConfigResp_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiftConfigResp_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiftConfigResp_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GiftConfigResp_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiftConfigResp_Config.Merge(dst, src)
}
func (m *GiftConfigResp_Config) XXX_Size() int {
	return m.Size()
}
func (m *GiftConfigResp_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_GiftConfigResp_Config.DiscardUnknown(m)
}

var xxx_messageInfo_GiftConfigResp_Config proto.InternalMessageInfo

type GiftConfigResp_CountMap struct {
	Num                  int64    `protobuf:"varint,1,opt,name=num,proto3" json:"num"`
	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GiftConfigResp_CountMap) Reset()         { *m = GiftConfigResp_CountMap{} }
func (m *GiftConfigResp_CountMap) String() string { return proto.CompactTextString(m) }
func (*GiftConfigResp_CountMap) ProtoMessage()    {}
func (*GiftConfigResp_CountMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{3, 1}
}
func (m *GiftConfigResp_CountMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiftConfigResp_CountMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiftConfigResp_CountMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GiftConfigResp_CountMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiftConfigResp_CountMap.Merge(dst, src)
}
func (m *GiftConfigResp_CountMap) XXX_Size() int {
	return m.Size()
}
func (m *GiftConfigResp_CountMap) XXX_DiscardUnknown() {
	xxx_messageInfo_GiftConfigResp_CountMap.DiscardUnknown(m)
}

var xxx_messageInfo_GiftConfigResp_CountMap proto.InternalMessageInfo

type NeedTipRechargeReq struct {
	// 来源 1金瓜子 2 银瓜子
	From From `protobuf:"varint,1,opt,name=from,proto3,enum=live.approom.v1.From" json:"from,omitempty" form:"from" validate:"required"`
	// 需要的金瓜子  如果From=2　那么直接传0
	NeedGold int64 `protobuf:"varint,2,opt,name=needGold,proto3" json:"needGold,omitempty" form:"needGold"`
	// 平台 android ios
	Platform             string   `protobuf:"bytes,3,opt,name=platform,proto3" json:"platform,omitempty" form:"platform" validate:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NeedTipRechargeReq) Reset()         { *m = NeedTipRechargeReq{} }
func (m *NeedTipRechargeReq) String() string { return proto.CompactTextString(m) }
func (*NeedTipRechargeReq) ProtoMessage()    {}
func (*NeedTipRechargeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{4}
}
func (m *NeedTipRechargeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NeedTipRechargeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NeedTipRechargeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NeedTipRechargeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NeedTipRechargeReq.Merge(dst, src)
}
func (m *NeedTipRechargeReq) XXX_Size() int {
	return m.Size()
}
func (m *NeedTipRechargeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NeedTipRechargeReq.DiscardUnknown(m)
}

var xxx_messageInfo_NeedTipRechargeReq proto.InternalMessageInfo

type NeedTipRechargeResp struct {
	// 是否展示
	Show int32 `protobuf:"varint,1,opt,name=show,proto3" json:"show"`
	// bp
	Bp float32 `protobuf:"fixed32,2,opt,name=bp,proto3" json:"bp"`
	// bp券
	BpCoupon float32 `protobuf:"fixed32,3,opt,name=bpCoupon,proto3" json:"bpCoupon"`
	// 需要充值的金瓜子
	RechargeGold         int64    `protobuf:"varint,4,opt,name=rechargeGold,proto3" json:"rechargeGold"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NeedTipRechargeResp) Reset()         { *m = NeedTipRechargeResp{} }
func (m *NeedTipRechargeResp) String() string { return proto.CompactTextString(m) }
func (*NeedTipRechargeResp) ProtoMessage()    {}
func (*NeedTipRechargeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{5}
}
func (m *NeedTipRechargeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NeedTipRechargeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NeedTipRechargeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NeedTipRechargeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NeedTipRechargeResp.Merge(dst, src)
}
func (m *NeedTipRechargeResp) XXX_Size() int {
	return m.Size()
}
func (m *NeedTipRechargeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_NeedTipRechargeResp.DiscardUnknown(m)
}

var xxx_messageInfo_NeedTipRechargeResp proto.InternalMessageInfo

type TipRechargeActionReq struct {
	// 来源 1金瓜子 2 银瓜子
	From From `protobuf:"varint,1,opt,name=from,proto3,enum=live.approom.v1.From" json:"from,omitempty" form:"from" validate:"required"`
	// 行为 1 停止推送
	Action               UserAction `protobuf:"varint,2,opt,name=action,proto3,enum=live.approom.v1.UserAction" json:"action,omitempty" form:"action" validate:"required"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TipRechargeActionReq) Reset()         { *m = TipRechargeActionReq{} }
func (m *TipRechargeActionReq) String() string { return proto.CompactTextString(m) }
func (*TipRechargeActionReq) ProtoMessage()    {}
func (*TipRechargeActionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{6}
}
func (m *TipRechargeActionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TipRechargeActionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TipRechargeActionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TipRechargeActionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TipRechargeActionReq.Merge(dst, src)
}
func (m *TipRechargeActionReq) XXX_Size() int {
	return m.Size()
}
func (m *TipRechargeActionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TipRechargeActionReq.DiscardUnknown(m)
}

var xxx_messageInfo_TipRechargeActionReq proto.InternalMessageInfo

type TipRechargeActionResp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TipRechargeActionResp) Reset()         { *m = TipRechargeActionResp{} }
func (m *TipRechargeActionResp) String() string { return proto.CompactTextString(m) }
func (*TipRechargeActionResp) ProtoMessage()    {}
func (*TipRechargeActionResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_gift_0ba80813e5e87937, []int{7}
}
func (m *TipRechargeActionResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TipRechargeActionResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TipRechargeActionResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TipRechargeActionResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TipRechargeActionResp.Merge(dst, src)
}
func (m *TipRechargeActionResp) XXX_Size() int {
	return m.Size()
}
func (m *TipRechargeActionResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TipRechargeActionResp.DiscardUnknown(m)
}

var xxx_messageInfo_TipRechargeActionResp proto.InternalMessageInfo

func init() {
	proto.RegisterType((*DailyBagReq)(nil), "live.approom.v1.DailyBagReq")
	proto.RegisterType((*DailyBagResp)(nil), "live.approom.v1.DailyBagResp")
	proto.RegisterType((*DailyBagResp_BagToast)(nil), "live.approom.v1.DailyBagResp.BagToast")
	proto.RegisterType((*DailyBagResp_BagList)(nil), "live.approom.v1.DailyBagResp.BagList")
	proto.RegisterType((*DailyBagResp_BagList_Source)(nil), "live.approom.v1.DailyBagResp.BagList.Source")
	proto.RegisterType((*DailyBagResp_BagList_GiftList)(nil), "live.approom.v1.DailyBagResp.BagList.GiftList")
	proto.RegisterType((*GiftConfigReq)(nil), "live.approom.v1.GiftConfigReq")
	proto.RegisterType((*GiftConfigResp)(nil), "live.approom.v1.GiftConfigResp")
	proto.RegisterType((*GiftConfigResp_Config)(nil), "live.approom.v1.GiftConfigResp.Config")
	proto.RegisterType((*GiftConfigResp_CountMap)(nil), "live.approom.v1.GiftConfigResp.CountMap")
	proto.RegisterType((*NeedTipRechargeReq)(nil), "live.approom.v1.NeedTipRechargeReq")
	proto.RegisterType((*NeedTipRechargeResp)(nil), "live.approom.v1.NeedTipRechargeResp")
	proto.RegisterType((*TipRechargeActionReq)(nil), "live.approom.v1.TipRechargeActionReq")
	proto.RegisterType((*TipRechargeActionResp)(nil), "live.approom.v1.TipRechargeActionResp")
	proto.RegisterEnum("live.approom.v1.From", From_name, From_value)
	proto.RegisterEnum("live.approom.v1.UserAction", UserAction_name, UserAction_value)
}
func (m *DailyBagReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BagStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.BagStatus))
	}
	if m.BagExpireStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.BagExpireStatus))
	}
	if m.BagToast != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.BagToast.Size()))
		n1, err := m.BagToast.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.BagList) > 0 {
		for _, msg := range m.BagList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGift(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp_BagToast) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp_BagToast) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ToastStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.ToastStatus))
	}
	if len(m.ToastMessage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.ToastMessage)))
		i += copy(dAtA[i:], m.ToastMessage)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp_BagList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp_BagList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Type))
	}
	if len(m.BagName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.BagName)))
		i += copy(dAtA[i:], m.BagName)
	}
	if m.Source != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Source.Size()))
		n2, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.GiftList) > 0 {
		for _, msg := range m.GiftList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintGift(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp_BagList_Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp_BagList_Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MedalId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.MedalId))
	}
	if len(m.MedalName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.MedalName)))
		i += copy(dAtA[i:], m.MedalName)
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Level))
	}
	if m.UserLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.UserLevel))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DailyBagResp_BagList_GiftList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyBagResp_BagList_GiftList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GiftId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.GiftId)))
		i += copy(dAtA[i:], m.GiftId)
	}
	if m.GiftNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.GiftNum))
	}
	if m.ExpireAt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.ExpireAt))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GiftConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftConfigReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Platform) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.Build != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Build))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GiftConfigResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftConfigResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGift(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GiftConfigResp_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftConfigResp_Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Price != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Price))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Type))
	}
	if len(m.CoinType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.CoinType)))
		i += copy(dAtA[i:], m.CoinType)
	}
	if m.BagGift != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.BagGift))
	}
	if m.Effect != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Effect))
	}
	if len(m.CornerMark) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.CornerMark)))
		i += copy(dAtA[i:], m.CornerMark)
	}
	if m.Broadcast != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Broadcast))
	}
	if m.Draw != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Draw))
	}
	if m.StayTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.StayTime))
	}
	if m.AnimationFrameNum != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.AnimationFrameNum))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Rule) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.Rule)))
		i += copy(dAtA[i:], m.Rule)
	}
	if len(m.Rights) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.Rights)))
		i += copy(dAtA[i:], m.Rights)
	}
	if m.PrivilegeRequired != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.PrivilegeRequired))
	}
	if len(m.CountMap) > 0 {
		for _, msg := range m.CountMap {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintGift(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImgBasic) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.ImgBasic)))
		i += copy(dAtA[i:], m.ImgBasic)
	}
	if len(m.ImgDynamic) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.ImgDynamic)))
		i += copy(dAtA[i:], m.ImgDynamic)
	}
	if len(m.FrameAnimation) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.FrameAnimation)))
		i += copy(dAtA[i:], m.FrameAnimation)
	}
	if len(m.Gif) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.Gif)))
		i += copy(dAtA[i:], m.Gif)
	}
	if len(m.Webp) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.Webp)))
		i += copy(dAtA[i:], m.Webp)
	}
	if len(m.FullScWeb) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.FullScWeb)))
		i += copy(dAtA[i:], m.FullScWeb)
	}
	if len(m.FullScHorizontal) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.FullScHorizontal)))
		i += copy(dAtA[i:], m.FullScHorizontal)
	}
	if len(m.FullScVertical) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.FullScVertical)))
		i += copy(dAtA[i:], m.FullScVertical)
	}
	if len(m.FullScHorizontalSvga) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.FullScHorizontalSvga)))
		i += copy(dAtA[i:], m.FullScHorizontalSvga)
	}
	if len(m.FullScVerticalSvga) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.FullScVerticalSvga)))
		i += copy(dAtA[i:], m.FullScVerticalSvga)
	}
	if len(m.BulletHead) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.BulletHead)))
		i += copy(dAtA[i:], m.BulletHead)
	}
	if len(m.BulletTail) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.BulletTail)))
		i += copy(dAtA[i:], m.BulletTail)
	}
	if m.LimitInterval != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.LimitInterval))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GiftConfigResp_CountMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftConfigResp_CountMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Num))
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NeedTipRechargeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NeedTipRechargeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.From))
	}
	if m.NeedGold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.NeedGold))
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGift(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NeedTipRechargeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NeedTipRechargeResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Show != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Show))
	}
	if m.Bp != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Bp))))
		i += 4
	}
	if m.BpCoupon != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BpCoupon))))
		i += 4
	}
	if m.RechargeGold != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.RechargeGold))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TipRechargeActionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TipRechargeActionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.From))
	}
	if m.Action != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGift(dAtA, i, uint64(m.Action))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TipRechargeActionResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TipRechargeActionResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintGift(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DailyBagReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BagStatus != 0 {
		n += 1 + sovGift(uint64(m.BagStatus))
	}
	if m.BagExpireStatus != 0 {
		n += 1 + sovGift(uint64(m.BagExpireStatus))
	}
	if m.BagToast != nil {
		l = m.BagToast.Size()
		n += 1 + l + sovGift(uint64(l))
	}
	if len(m.BagList) > 0 {
		for _, e := range m.BagList {
			l = e.Size()
			n += 1 + l + sovGift(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp_BagToast) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToastStatus != 0 {
		n += 1 + sovGift(uint64(m.ToastStatus))
	}
	l = len(m.ToastMessage)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp_BagList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGift(uint64(m.Type))
	}
	l = len(m.BagName)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovGift(uint64(l))
	}
	if len(m.GiftList) > 0 {
		for _, e := range m.GiftList {
			l = e.Size()
			n += 1 + l + sovGift(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp_BagList_Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MedalId != 0 {
		n += 1 + sovGift(uint64(m.MedalId))
	}
	l = len(m.MedalName)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovGift(uint64(m.Level))
	}
	if m.UserLevel != 0 {
		n += 1 + sovGift(uint64(m.UserLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DailyBagResp_BagList_GiftList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GiftId)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.GiftNum != 0 {
		n += 1 + sovGift(uint64(m.GiftNum))
	}
	if m.ExpireAt != 0 {
		n += 1 + sovGift(uint64(m.ExpireAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GiftConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.Build != 0 {
		n += 1 + sovGift(uint64(m.Build))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GiftConfigResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovGift(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GiftConfigResp_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGift(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovGift(uint64(m.Price))
	}
	if m.Type != 0 {
		n += 1 + sovGift(uint64(m.Type))
	}
	l = len(m.CoinType)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.BagGift != 0 {
		n += 1 + sovGift(uint64(m.BagGift))
	}
	if m.Effect != 0 {
		n += 1 + sovGift(uint64(m.Effect))
	}
	l = len(m.CornerMark)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.Broadcast != 0 {
		n += 1 + sovGift(uint64(m.Broadcast))
	}
	if m.Draw != 0 {
		n += 1 + sovGift(uint64(m.Draw))
	}
	if m.StayTime != 0 {
		n += 1 + sovGift(uint64(m.StayTime))
	}
	if m.AnimationFrameNum != 0 {
		n += 1 + sovGift(uint64(m.AnimationFrameNum))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	l = len(m.Rule)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	l = len(m.Rights)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.PrivilegeRequired != 0 {
		n += 2 + sovGift(uint64(m.PrivilegeRequired))
	}
	if len(m.CountMap) > 0 {
		for _, e := range m.CountMap {
			l = e.Size()
			n += 2 + l + sovGift(uint64(l))
		}
	}
	l = len(m.ImgBasic)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.ImgDynamic)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.FrameAnimation)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.Gif)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.Webp)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.FullScWeb)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.FullScHorizontal)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.FullScVertical)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.FullScHorizontalSvga)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.FullScVerticalSvga)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.BulletHead)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	l = len(m.BulletTail)
	if l > 0 {
		n += 2 + l + sovGift(uint64(l))
	}
	if m.LimitInterval != 0 {
		n += 2 + sovGift(uint64(m.LimitInterval))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GiftConfigResp_CountMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovGift(uint64(m.Num))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NeedTipRechargeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovGift(uint64(m.From))
	}
	if m.NeedGold != 0 {
		n += 1 + sovGift(uint64(m.NeedGold))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovGift(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NeedTipRechargeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Show != 0 {
		n += 1 + sovGift(uint64(m.Show))
	}
	if m.Bp != 0 {
		n += 5
	}
	if m.BpCoupon != 0 {
		n += 5
	}
	if m.RechargeGold != 0 {
		n += 1 + sovGift(uint64(m.RechargeGold))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TipRechargeActionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovGift(uint64(m.From))
	}
	if m.Action != 0 {
		n += 1 + sovGift(uint64(m.Action))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TipRechargeActionResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGift(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGift(x uint64) (n int) {
	return sovGift(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DailyBagReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyBagReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyBagReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyBagResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyBagResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagStatus", wireType)
			}
			m.BagStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagExpireStatus", wireType)
			}
			m.BagExpireStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagExpireStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagToast", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BagToast == nil {
				m.BagToast = &DailyBagResp_BagToast{}
			}
			if err := m.BagToast.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BagList = append(m.BagList, &DailyBagResp_BagList{})
			if err := m.BagList[len(m.BagList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp_BagToast) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BagToast: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BagToast: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToastStatus", wireType)
			}
			m.ToastStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToastStatus |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToastMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToastMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp_BagList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BagList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BagList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &DailyBagResp_BagList_Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftList = append(m.GiftList, &DailyBagResp_BagList_GiftList{})
			if err := m.GiftList[len(m.GiftList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp_BagList_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedalId", wireType)
			}
			m.MedalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedalId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MedalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserLevel", wireType)
			}
			m.UserLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserLevel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyBagResp_BagList_GiftList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftNum", wireType)
			}
			m.GiftNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireAt", wireType)
			}
			m.ExpireAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			m.Build = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Build |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftConfigResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftConfigResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftConfigResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &GiftConfigResp_Config{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftConfigResp_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoinType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagGift", wireType)
			}
			m.BagGift = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagGift |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			m.Effect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Effect |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CornerMark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CornerMark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Broadcast", wireType)
			}
			m.Broadcast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Broadcast |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draw", wireType)
			}
			m.Draw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Draw |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StayTime", wireType)
			}
			m.StayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StayTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnimationFrameNum", wireType)
			}
			m.AnimationFrameNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnimationFrameNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rights = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegeRequired", wireType)
			}
			m.PrivilegeRequired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivilegeRequired |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountMap = append(m.CountMap, &GiftConfigResp_CountMap{})
			if err := m.CountMap[len(m.CountMap)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImgBasic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImgBasic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImgDynamic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImgDynamic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameAnimation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameAnimation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gif", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gif = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Webp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScWeb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScWeb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScHorizontal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScHorizontal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScVertical", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScVertical = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScHorizontalSvga", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScHorizontalSvga = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScVerticalSvga", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullScVerticalSvga = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletHead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BulletHead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletTail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BulletTail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitInterval", wireType)
			}
			m.LimitInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitInterval |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftConfigResp_CountMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NeedTipRechargeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NeedTipRechargeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NeedTipRechargeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (From(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedGold", wireType)
			}
			m.NeedGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedGold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGift
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NeedTipRechargeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NeedTipRechargeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NeedTipRechargeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Show", wireType)
			}
			m.Show = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Show |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bp", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Bp = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpCoupon", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BpCoupon = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeGold", wireType)
			}
			m.RechargeGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RechargeGold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TipRechargeActionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TipRechargeActionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TipRechargeActionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (From(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGift
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (UserAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TipRechargeActionResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGift
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TipRechargeActionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TipRechargeActionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGift(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGift
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGift(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGift
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGift
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGift
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGift
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGift
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGift(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGift = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGift   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("gift.proto", fileDescriptor_gift_0ba80813e5e87937) }

var fileDescriptor_gift_0ba80813e5e87937 = []byte{
	// 1620 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcd, 0x6f, 0xdb, 0xc8,
	0x15, 0x5f, 0xc9, 0x8a, 0x2c, 0x3d, 0xc9, 0xb2, 0x3c, 0xb1, 0x13, 0x46, 0xc9, 0x9a, 0x29, 0xb3,
	0x9b, 0x35, 0xdc, 0xae, 0xb2, 0xeb, 0x2d, 0x0a, 0x74, 0x51, 0x14, 0x88, 0x92, 0x6d, 0x12, 0x20,
	0x31, 0x16, 0x63, 0xa3, 0x05, 0x82, 0x02, 0xc4, 0x50, 0x1c, 0x51, 0x83, 0x25, 0x45, 0x86, 0x1f,
	0xf2, 0xba, 0xf7, 0xfe, 0x35, 0xbd, 0x14, 0xbd, 0xf5, 0xda, 0xd3, 0x1e, 0x73, 0x6d, 0x0f, 0x44,
	0xeb, 0x23, 0x8f, 0xfe, 0x0b, 0x8a, 0x79, 0xc3, 0x2f, 0x5b, 0x6a, 0x9c, 0x4b, 0x2f, 0xa3, 0xf7,
	0x7e, 0xef, 0x63, 0xde, 0x7b, 0xf3, 0x1e, 0x67, 0x04, 0xe0, 0x88, 0x59, 0x3c, 0x0e, 0x42, 0x3f,
	0xf6, 0xc9, 0xb6, 0x2b, 0x96, 0x7c, 0xcc, 0x82, 0x20, 0xf4, 0x7d, 0x6f, 0xbc, 0xfc, 0x7a, 0xf4,
	0xa5, 0x23, 0xe2, 0x79, 0x62, 0x8d, 0xa7, 0xbe, 0xf7, 0xc4, 0xf1, 0x1d, 0xff, 0x09, 0xea, 0x59,
	0xc9, 0x0c, 0x39, 0x64, 0x90, 0x52, 0xf6, 0xc6, 0x16, 0xf4, 0x9e, 0x33, 0xe1, 0x9e, 0x4f, 0x98,
	0x43, 0xf9, 0x3b, 0xe3, 0x9f, 0x9b, 0xd0, 0xaf, 0xf8, 0x28, 0x20, 0x5f, 0x02, 0x58, 0xcc, 0x31,
	0xa3, 0x98, 0xc5, 0x49, 0xa4, 0x35, 0x1e, 0x36, 0x0e, 0x36, 0x26, 0x83, 0x2c, 0xd5, 0x6b, 0x28,
	0xed, 0x5a, 0xcc, 0x39, 0x41, 0x92, 0x3c, 0x85, 0x1d, 0x29, 0xe0, 0x3f, 0x06, 0x22, 0xe4, 0x85,
	0x55, 0x13, 0xad, 0xf6, 0xb2, 0x54, 0x5f, 0x15, 0xd2, 0x6d, 0x8b, 0x39, 0xdf, 0x21, 0x92, 0xbb,
	0xa0, 0x20, 0xfd, 0x99, 0xb1, 0xcf, 0xa2, 0x58, 0xdb, 0x78, 0xd8, 0x38, 0xe8, 0x1d, 0x3d, 0x1e,
	0x5f, 0xcb, 0x72, 0x5c, 0x8f, 0x71, 0x3c, 0x61, 0xce, 0xa9, 0xd4, 0x9e, 0x6c, 0x65, 0xa9, 0x5e,
	0x19, 0xd3, 0x8e, 0x95, 0x0b, 0xc8, 0x31, 0x48, 0xda, 0x74, 0x45, 0x14, 0x6b, 0xad, 0x87, 0x1b,
	0x07, 0xbd, 0xa3, 0xcf, 0x6f, 0x74, 0xf9, 0x5a, 0x44, 0xf1, 0xa4, 0x9f, 0xa5, 0x7a, 0x69, 0x4a,
	0x37, 0x2d, 0x05, 0x8f, 0xce, 0xa0, 0x53, 0x6c, 0x4a, 0xbe, 0x81, 0x3e, 0x6e, 0x77, 0xb5, 0x46,
	0xc3, 0x2c, 0xd5, 0xaf, 0xe0, 0xb4, 0x87, 0x5c, 0x9e, 0xe4, 0xaf, 0x60, 0x4b, 0x09, 0x3d, 0x1e,
	0x45, 0xcc, 0xe1, 0x58, 0xa3, 0xee, 0x64, 0x27, 0x4b, 0xf5, 0xab, 0x02, 0xaa, 0x9c, 0xbc, 0x51,
	0xdc, 0xe8, 0xef, 0x2d, 0xd8, 0xcc, 0x63, 0x23, 0x0f, 0xa0, 0x15, 0x9f, 0x07, 0x3c, 0xdf, 0xb0,
	0x93, 0xa5, 0x3a, 0xf2, 0x14, 0x57, 0xf2, 0x85, 0x4a, 0x79, 0xc1, 0xbc, 0xc2, 0x79, 0x99, 0x8b,
	0xc4, 0x30, 0x97, 0x63, 0xe6, 0x71, 0xf2, 0x3d, 0xb4, 0x23, 0x3f, 0x09, 0xa7, 0x3c, 0x2f, 0xf6,
	0x2f, 0x3e, 0xaa, 0x32, 0xe3, 0x13, 0xb4, 0x99, 0x40, 0x96, 0xea, 0xb9, 0x3d, 0xcd, 0x7f, 0xc9,
	0x5b, 0xe8, 0xca, 0x0e, 0xad, 0x97, 0x7b, 0xfc, 0x71, 0x4e, 0x5f, 0x88, 0x59, 0x8c, 0x75, 0xc7,
	0x93, 0x2c, 0x9d, 0xd0, 0x8e, 0x93, 0x0b, 0x46, 0x7f, 0x6d, 0x40, 0x5b, 0x6d, 0x2d, 0x33, 0xf4,
	0xb8, 0xcd, 0x5c, 0x53, 0xd8, 0x79, 0x0d, 0x30, 0xc3, 0x02, 0xa3, 0x9b, 0x48, 0xbd, 0xb2, 0x65,
	0x0f, 0x2b, 0xb0, 0x56, 0x0c, 0xec, 0xe1, 0x0a, 0xa5, 0x5d, 0xa4, 0xb1, 0x20, 0x3a, 0xdc, 0x72,
	0xf9, 0x92, 0xbb, 0x58, 0x8f, 0x8d, 0x49, 0x37, 0x4b, 0x75, 0x05, 0x50, 0xf5, 0x23, 0xfd, 0x25,
	0x11, 0x0f, 0x4d, 0xa5, 0xd5, 0xaa, 0x66, 0xa2, 0x42, 0x69, 0x57, 0xd2, 0xaf, 0x25, 0x39, 0xfa,
	0x73, 0x03, 0x3a, 0x45, 0x62, 0xe4, 0x33, 0xd8, 0xc4, 0xb4, 0xf2, 0x98, 0xbb, 0x93, 0x5e, 0x96,
	0xea, 0x05, 0x44, 0xdb, 0x92, 0x78, 0x65, 0xcb, 0xd4, 0x10, 0x5a, 0x24, 0x5e, 0x3e, 0x3d, 0x98,
	0x5a, 0x81, 0x51, 0x34, 0x38, 0x4e, 0x3c, 0x72, 0x08, 0xdd, 0x7c, 0x9c, 0x58, 0x9c, 0xc7, 0x8b,
	0xa5, 0x2b, 0x41, 0xda, 0x51, 0xe4, 0xd3, 0xd8, 0x98, 0xc3, 0x96, 0x0c, 0xe3, 0x99, 0xbf, 0x98,
	0x09, 0x39, 0xec, 0xe4, 0x09, 0x74, 0x02, 0x97, 0xc5, 0x33, 0x3f, 0xf4, 0xf2, 0x60, 0x6e, 0x5f,
	0xa6, 0xfa, 0xb6, 0xe4, 0xbf, 0x35, 0x0a, 0x89, 0x41, 0x4b, 0x25, 0xf2, 0x18, 0x6e, 0x59, 0x89,
	0x70, 0xed, 0x3c, 0xa6, 0xe1, 0x65, 0xaa, 0xf7, 0x95, 0x36, 0xc2, 0x06, 0x55, 0x62, 0xe3, 0x7d,
	0x1f, 0x06, 0xf5, 0xad, 0xa2, 0x80, 0x3c, 0x87, 0x16, 0xb6, 0x43, 0x03, 0xdb, 0x61, 0x75, 0xa0,
	0xaf, 0xaa, 0x8f, 0x15, 0xa9, 0x9a, 0x1a, 0x3b, 0x00, 0xd7, 0xd1, 0xdf, 0x7a, 0xd0, 0x56, 0x22,
	0x72, 0x07, 0x9a, 0xe5, 0xb9, 0xb7, 0xb3, 0x54, 0x6f, 0x0a, 0x9b, 0x36, 0x85, 0x2d, 0xa7, 0xa2,
	0x76, 0xcc, 0xe8, 0x00, 0x0f, 0x18, 0x57, 0x79, 0xb6, 0x41, 0x28, 0xf2, 0x5e, 0xcf, 0xcf, 0x16,
	0x01, 0xaa, 0x7e, 0xca, 0xa1, 0x6a, 0xad, 0x1d, 0xaa, 0x43, 0xe8, 0x4e, 0x7d, 0xb1, 0x30, 0x51,
	0xe5, 0x16, 0xee, 0x80, 0xe5, 0x2e, 0x41, 0xda, 0x91, 0xe4, 0x69, 0x6d, 0x00, 0xe5, 0x49, 0x69,
	0xed, 0xea, 0x0c, 0x0b, 0x0c, 0x07, 0x50, 0x66, 0x4d, 0x0c, 0x68, 0xf3, 0xd9, 0x8c, 0x4f, 0x63,
	0x6d, 0x13, 0xd5, 0x70, 0xa4, 0x14, 0x42, 0xf3, 0x5f, 0xf2, 0x15, 0xf4, 0xa6, 0x7e, 0xb8, 0xe0,
	0xa1, 0xe9, 0xb1, 0xf0, 0x07, 0xad, 0x83, 0x5b, 0x6f, 0x67, 0xa9, 0x5e, 0x87, 0x29, 0x28, 0xe6,
	0x0d, 0x0b, 0x7f, 0x20, 0x3f, 0x87, 0xae, 0x15, 0xfa, 0xcc, 0x9e, 0xca, 0xcf, 0x68, 0xb7, 0xea,
	0x8c, 0x12, 0xa4, 0x15, 0x29, 0xb3, 0xb6, 0x43, 0x76, 0xa6, 0x41, 0x95, 0xb5, 0xe4, 0x29, 0xae,
	0x32, 0xeb, 0x28, 0x66, 0xe7, 0x66, 0x2c, 0x3c, 0xae, 0xf5, 0x2a, 0x57, 0x25, 0x48, 0x3b, 0x92,
	0x3c, 0x15, 0x1e, 0x27, 0x2f, 0xe0, 0x36, 0x5b, 0x08, 0x8f, 0xc5, 0xc2, 0x5f, 0x98, 0xb3, 0x90,
	0x79, 0x1c, 0x9b, 0xb8, 0x8f, 0x56, 0x77, 0xb3, 0x54, 0x5f, 0x27, 0xa6, 0x3b, 0x25, 0xf8, 0x3b,
	0x89, 0xc9, 0xce, 0x96, 0x21, 0xf1, 0x68, 0xaa, 0x6d, 0x55, 0xe7, 0x28, 0x79, 0x8a, 0xab, 0x94,
	0x86, 0x89, 0xcb, 0xb5, 0x41, 0x25, 0x95, 0x3c, 0xc5, 0x55, 0x56, 0x34, 0x14, 0xce, 0x3c, 0x8e,
	0xb4, 0x6d, 0x94, 0x63, 0x45, 0x15, 0x42, 0xf3, 0x5f, 0xf2, 0x1d, 0x90, 0x20, 0x14, 0x4b, 0xe1,
	0x72, 0x87, 0x9b, 0x21, 0x7f, 0x97, 0x88, 0x90, 0xdb, 0xda, 0x10, 0xe3, 0xbc, 0x93, 0xa5, 0xfa,
	0x1a, 0x29, 0xdd, 0x29, 0x31, 0x9a, 0x43, 0xe4, 0x54, 0x76, 0x44, 0xb2, 0x88, 0x4d, 0x8f, 0x05,
	0xda, 0x0e, 0x36, 0xf7, 0xc1, 0xcd, 0xcd, 0x9d, 0x2c, 0xe2, 0x37, 0x2c, 0x28, 0x7a, 0x27, 0x37,
	0x97, 0xbd, 0xa3, 0x04, 0xb2, 0xe2, 0xc2, 0x73, 0x4c, 0x8b, 0x45, 0x62, 0xaa, 0x91, 0xaa, 0xcf,
	0x4a, 0x90, 0x76, 0x84, 0xe7, 0x4c, 0x24, 0x25, 0x5b, 0x43, 0xc2, 0xf6, 0xf9, 0x82, 0x79, 0x62,
	0xaa, 0xdd, 0xae, 0x5a, 0xa3, 0x06, 0x53, 0x10, 0x9e, 0xf3, 0x5c, 0xd1, 0xe4, 0x37, 0xb0, 0xad,
	0x4a, 0x5f, 0x56, 0x5d, 0xdb, 0x55, 0xe3, 0x9f, 0xc9, 0xf1, 0xbf, 0x2a, 0xa2, 0x03, 0x04, 0x9e,
	0x16, 0x3c, 0xb9, 0x07, 0x1b, 0x8e, 0x98, 0x69, 0x7b, 0x68, 0xb1, 0x99, 0xa5, 0xba, 0x64, 0xa9,
	0x5c, 0xe4, 0xa9, 0x9c, 0x71, 0x2b, 0xd0, 0xee, 0x54, 0xa7, 0x22, 0x79, 0x8a, 0x2b, 0x79, 0x02,
	0xbd, 0x59, 0xe2, 0xba, 0x66, 0x34, 0x35, 0xcf, 0xb8, 0xa5, 0xdd, 0xad, 0x02, 0xad, 0xc1, 0xb4,
	0x2b, 0x99, 0x93, 0xe9, 0x1f, 0xb8, 0x45, 0x9e, 0x03, 0x29, 0x24, 0x73, 0x3f, 0x14, 0x7f, 0xf2,
	0x17, 0x31, 0x73, 0x35, 0x0d, 0xed, 0xf0, 0x88, 0x56, 0xa5, 0x74, 0xa8, 0xcc, 0x5f, 0x96, 0x08,
	0xf9, 0x2d, 0x0c, 0x0b, 0xbd, 0x25, 0x0f, 0x63, 0x31, 0x65, 0xae, 0x76, 0x0f, 0x7d, 0xec, 0x66,
	0xa9, 0xbe, 0x22, 0xa3, 0x03, 0xe5, 0xe1, 0xf7, 0x39, 0x4f, 0x28, 0xdc, 0x5d, 0xdd, 0xc7, 0x8c,
	0x96, 0x0e, 0xd3, 0x46, 0xe8, 0xe6, 0x7e, 0x96, 0xea, 0xff, 0x4b, 0x85, 0xee, 0x5e, 0x8f, 0xe7,
	0x64, 0xe9, 0x30, 0xf2, 0x1a, 0xf6, 0xae, 0xef, 0xab, 0x3c, 0xde, 0x47, 0x8f, 0xf7, 0xb2, 0x54,
	0x5f, 0xaf, 0x40, 0xc9, 0xd5, 0xe8, 0xd0, 0xdb, 0x57, 0xd0, 0xb3, 0x12, 0xd7, 0xe5, 0xb1, 0x39,
	0xe7, 0xcc, 0xd6, 0x1e, 0x54, 0x85, 0xad, 0xc1, 0x14, 0x14, 0xf3, 0x92, 0x33, 0xbb, 0x66, 0x11,
	0x33, 0xe1, 0x6a, 0x9f, 0xae, 0x58, 0x48, 0xb8, 0xb0, 0x38, 0x65, 0xc2, 0x25, 0xbf, 0x86, 0x81,
	0x2b, 0x3c, 0x11, 0x9b, 0x62, 0x11, 0xf3, 0x70, 0xc9, 0x5c, 0x6d, 0x1f, 0x47, 0x85, 0x64, 0xa9,
	0x7e, 0x4d, 0x42, 0xb7, 0x90, 0x7f, 0x95, 0xb3, 0xa3, 0x67, 0xd0, 0x29, 0x3a, 0x5e, 0x36, 0x8f,
	0xfc, 0x1c, 0xa8, 0xcf, 0x36, 0x36, 0x8f, 0x1c, 0x7f, 0xb9, 0xe0, 0x97, 0x97, 0xff, 0x18, 0xd7,
	0x3f, 0xdc, 0x92, 0xa7, 0xb8, 0x1a, 0xff, 0x6a, 0x00, 0x39, 0xe6, 0xdc, 0x3e, 0x15, 0x01, 0xe5,
	0xd3, 0x39, 0x0b, 0x71, 0x06, 0xc9, 0x31, 0xb4, 0x66, 0xa1, 0xaf, 0x1c, 0x0e, 0x8e, 0xf6, 0x56,
	0x26, 0x4f, 0x0a, 0x27, 0x8f, 0x2e, 0x53, 0x5d, 0x57, 0xf7, 0x94, 0xe4, 0x8d, 0x87, 0x4b, 0xe6,
	0x0a, 0x9b, 0xc5, 0xfc, 0x5b, 0xa3, 0x18, 0x6d, 0x83, 0xa2, 0x1f, 0x79, 0x25, 0x2e, 0x38, 0xb7,
	0x5f, 0xf8, 0xe5, 0x25, 0x57, 0xbb, 0x12, 0x0b, 0x89, 0x41, 0x4b, 0x25, 0xf2, 0xac, 0x76, 0x87,
	0x6e, 0x60, 0xe4, 0x5f, 0x5c, 0xa6, 0xfa, 0xa3, 0x6b, 0x77, 0xe8, 0xda, 0x1d, 0x4b, 0x43, 0xe3,
	0x2f, 0x0d, 0xb8, 0xbd, 0x92, 0x5c, 0x14, 0xc8, 0x92, 0x44, 0x73, 0xff, 0x0c, 0xb3, 0xbb, 0xa5,
	0x4a, 0x22, 0x79, 0x8a, 0xab, 0xbc, 0x01, 0xad, 0x00, 0xa3, 0x6c, 0xaa, 0x1b, 0xd0, 0x0a, 0x68,
	0xd3, 0x0a, 0xc8, 0x01, 0x74, 0xac, 0xe0, 0x99, 0x9f, 0x04, 0xfe, 0x02, 0x43, 0x6a, 0xe6, 0x17,
	0x4f, 0x8e, 0xd1, 0x92, 0x22, 0xbf, 0x84, 0x7e, 0x98, 0xef, 0x87, 0x19, 0xb7, 0xaa, 0xa7, 0x6b,
	0x1d, 0xa7, 0x57, 0x38, 0xe3, 0x1f, 0x0d, 0xd8, 0xad, 0x45, 0xfa, 0x74, 0x8a, 0x9f, 0x89, 0xff,
	0xc3, 0x61, 0xbc, 0x85, 0x36, 0x43, 0xe7, 0x98, 0xe4, 0xe0, 0xe8, 0xfe, 0x8a, 0x47, 0xf9, 0xc8,
	0x52, 0xfb, 0x4f, 0x3e, 0xbf, 0x4c, 0xf5, 0x9f, 0x29, 0xbf, 0xca, 0x68, 0xbd, 0xe7, 0xdc, 0xa3,
	0x71, 0x17, 0xf6, 0xd6, 0xe4, 0x10, 0x05, 0x87, 0x8f, 0x55, 0x12, 0xa4, 0x03, 0xad, 0x63, 0x7f,
	0xc1, 0x87, 0x9f, 0x48, 0x4a, 0xe6, 0x3d, 0x6c, 0x10, 0x80, 0xf6, 0x89, 0x70, 0x97, 0x3c, 0x1c,
	0x36, 0x0f, 0x0f, 0xd5, 0x23, 0x50, 0x59, 0x92, 0x01, 0x80, 0xa2, 0x72, 0x9b, 0x3e, 0x74, 0x4e,
	0x62, 0x3f, 0xf8, 0x3e, 0x89, 0xe6, 0xc3, 0xc6, 0xd1, 0x45, 0x13, 0x5a, 0x78, 0xd5, 0xbf, 0x84,
	0xae, 0x2d, 0xdf, 0xbd, 0xa6, 0xc5, 0x1c, 0xf2, 0xe0, 0x03, 0x6f, 0xe2, 0x77, 0xa3, 0x4f, 0x3f,
	0xf8, 0x62, 0x26, 0x7f, 0x84, 0xed, 0x6b, 0x1d, 0x43, 0x1e, 0xad, 0x58, 0xac, 0x0e, 0xcc, 0xe8,
	0xb3, 0x9b, 0x95, 0xa2, 0x80, 0x58, 0xb0, 0xb3, 0x52, 0x1d, 0xb2, 0xfa, 0x97, 0x69, 0x5d, 0x17,
	0x8c, 0x1e, 0x7f, 0x8c, 0x5a, 0x14, 0x90, 0x63, 0xe8, 0xe1, 0x7b, 0x76, 0xaa, 0xde, 0x73, 0xfb,
	0x1f, 0xbc, 0x35, 0xdf, 0x8d, 0xf4, 0x1b, 0x6e, 0xd5, 0xc9, 0xee, 0x4f, 0xff, 0xd9, 0xff, 0xe4,
	0xa7, 0x8b, 0xfd, 0xc6, 0xfb, 0x8b, 0xfd, 0xc6, 0xbf, 0x2f, 0xf6, 0x1b, 0x6f, 0x9b, 0xcb, 0xaf,
	0xad, 0x36, 0xfe, 0xcd, 0xfd, 0xe6, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x56, 0x8e, 0x1a, 0xf0,
	0x34, 0x0f, 0x00, 0x00,
}
