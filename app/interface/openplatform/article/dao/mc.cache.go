// Code generated by $GOPATH/src/go-common/app/tool/cache/mc. DO NOT EDIT.

/*
  Package dao is a generated mc cache package.
  It is generated from:
  type _mc interface {
		// 获取文集文章列表缓存
		//mc: -key=listArtsKey
		CacheListArts(c context.Context, id int64) (res []*model.ListArtMeta, err error)
		// 增加文集含有的文章列表缓存
		//mc: -key=listArtsKey -expire=d.mcListArtsExpire
		AddCacheListArts(c context.Context, id int64, arts []*model.ListArtMeta) (err error)
		// 获取文章所属文集
		//mc: -key=articleListKey -type=get
		ArticleListCache(c context.Context, id int64) (res int64, err error)
		// 增加文章所属文集缓存
		//mc: -key=articleListKey -expire=d.mcArtListExpire
		SetArticlesListCache(c context.Context, arts map[int64]int64) (err error)
		//mc: -key=listKey
		CacheList(c context.Context, id int64) (res *model.List, err error)
		//mc: -key=listKey -expire=d.mcListExpire
		AddCacheList(c context.Context, id int64, list *model.List) (err error)
		//mc: -key=listKey
		CacheLists(c context.Context, ids []int64) (res map[int64]*model.List, err error)
		//mc: -key=listKey -expire=d.mcListExpire
		AddCacheLists(c context.Context, lists map[int64]*model.List) (err error)
		//mc: -key=listArtsKey
		CacheListsArts(c context.Context, ids []int64) (res map[int64][]*model.ListArtMeta, err error)
		//mc: -key=listArtsKey -expire=d.mcListArtsExpire
		AddCacheListsArts(c context.Context, arts map[int64][]*model.ListArtMeta) (err error)
		//mc: -key=articleListKey
		CacheArtsListID(c context.Context, ids []int64) (res map[int64]int64, err error)
		//mc: -key=articleListKey -expire=d.mcArtListExpire
		AddCacheArtsListID(c context.Context, arts map[int64]int64) (err error)
		//mc: -key=upListsKey -expire=d.mcUpListsExpire
		AddCacheUpLists(c context.Context, mid int64, lists []int64) (err error)
		//mc: -key=upListsKey
		CacheUpLists(c context.Context, id int64) (res []int64, err error)
		//mc: -key=listReadCountKey -expire=d.mcListReadExpire
		AddCacheListReadCount(c context.Context, id int64, read int64) (err error)
		//mc: -key=listReadCountKey
		CacheListReadCount(c context.Context, id int64) (res int64, err error)
		//mc: -key=listReadCountKey
		CacheListsReadCount(c context.Context, ids []int64) (res map[int64]int64, err error)
		//mc: -key=hotspotsKey -expire=d.mcHotspotExpire
		AddCacheHotspots(c context.Context, hots []*model.Hotspot) (err error)
		//mc: -key=hotspotsKey
		DelCacheHotspots(c context.Context) (err error)
		//mc: -key=hotspotsKey
		cacheHotspots(c context.Context) (res []*model.Hotspot, err error)
		//mc: -key=mcHotspotKey
		CacheHotspot(c context.Context, id int64) (res *model.Hotspot, err error)
		//mc: -key=mcHotspotKey -expire=d.mcHotspotExpire
		AddCacheHotspot(c context.Context, id int64, val *model.Hotspot) (err error)
		// 增加作者状态缓存
		//mc: -key=mcAuthorKey -expire=d.mcAuthorExpire
		AddCacheAuthor(c context.Context, mid int64, author *model.AuthorLimit) (err error)
		//mc: -key=mcAuthorKey
		CacheAuthor(c context.Context, mid int64) (res *model.AuthorLimit, err error)
		//mc: -key=mcAuthorKey
		DelCacheAuthor(c context.Context, mid int64) (err error)
		//mc: -key=slideArticlesKey
		CacheListArtsId(c context.Context, buvid string) (*model.ArticleViewList, error)
		//mc: -key=slideArticlesKey -expire=d.mcArticlesIDExpire
		AddCacheListArtsId(c context.Context, buvid string, val *model.ArticleViewList) error
		//mc: -key=slideArticlesKey
		DelCacheListArtsId(c context.Context, buvid string) error
		//mc: -key=AnniversaryKey -expire=60*60*24*30
		CacheAnniversary(c context.Context, mid int64) (*model.AnniversaryInfo, error)
		//mc: -key=mcTagKey
		CacheAidsByTag(c context.Context, tag int64) (*model.TagArts, error)
		//mc: -key=mcTagKey -expire=d.mcArticleTagExpire
		AddCacheAidsByTag(c context.Context, tag int64, val *model.TagArts) error
		//mc: -key=mcUpStatKey -expire=d.mcUpStatDailyExpire
		CacheUpStatDaily(c context.Context, mid int64) (*model.UpStat, error)
		//mc: -key=mcUpStatKey -expire=d.mcUpStatDailyExpire
		AddCacheUpStatDaily(c context.Context, mid int64, val *model.UpStat) error
	}
*/

package dao

import (
	"context"
	"fmt"
	"strconv"

	"go-common/app/interface/openplatform/article/model"
	"go-common/library/cache/memcache"
	"go-common/library/log"
	"go-common/library/stat/prom"
)

var _ _mc

// CacheListArts 获取文集文章列表缓存
func (d *Dao) CacheListArts(c context.Context, id int64) (res []*model.ListArtMeta, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := listArtsKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheListArts")
		log.Errorv(c, log.KV("CacheListArts", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = []*model.ListArtMeta{}
	err = conn.Scan(reply, &res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheListArts")
		log.Errorv(c, log.KV("CacheListArts", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheListArts 增加文集含有的文章列表缓存
func (d *Dao) AddCacheListArts(c context.Context, id int64, val []*model.ListArtMeta) (err error) {
	if len(val) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := listArtsKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcListArtsExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheListArts")
		log.Errorv(c, log.KV("AddCacheListArts", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// ArticleListCache 获取文章所属文集
func (d *Dao) ArticleListCache(c context.Context, id int64) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := articleListKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:ArticleListCache")
		log.Errorv(c, log.KV("ArticleListCache", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:ArticleListCache")
		log.Errorv(c, log.KV("ArticleListCache", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:ArticleListCache")
		log.Errorv(c, log.KV("ArticleListCache", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// SetArticlesListCache 增加文章所属文集缓存
func (d *Dao) SetArticlesListCache(c context.Context, values map[int64]int64) (err error) {
	if len(values) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	for id, val := range values {
		key := articleListKey(id)
		bs := []byte(strconv.FormatInt(int64(val), 10))
		item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcArtListExpire, Flags: memcache.FlagRAW}
		if err = conn.Set(item); err != nil {
			prom.BusinessErrCount.Incr("mc:SetArticlesListCache")
			log.Errorv(c, log.KV("SetArticlesListCache", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheList get data from mc
func (d *Dao) CacheList(c context.Context, id int64) (res *model.List, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := listKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheList")
		log.Errorv(c, log.KV("CacheList", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.List{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheList")
		log.Errorv(c, log.KV("CacheList", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheList Set data to mc
func (d *Dao) AddCacheList(c context.Context, id int64, val *model.List) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := listKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcListExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheList")
		log.Errorv(c, log.KV("AddCacheList", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheLists get data from mc
func (d *Dao) CacheLists(c context.Context, ids []int64) (res map[int64]*model.List, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := listKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	replies, err := conn.GetMulti(keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheLists")
		log.Errorv(c, log.KV("CacheLists", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for key, reply := range replies {
		var v *model.List
		v = &model.List{}
		err = conn.Scan(reply, v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheLists")
			log.Errorv(c, log.KV("CacheLists", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64]*model.List, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheLists Set data to mc
func (d *Dao) AddCacheLists(c context.Context, values map[int64]*model.List) (err error) {
	if len(values) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	for id, val := range values {
		key := listKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcListExpire, Flags: memcache.FlagJSON}
		if err = conn.Set(item); err != nil {
			prom.BusinessErrCount.Incr("mc:AddCacheLists")
			log.Errorv(c, log.KV("AddCacheLists", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheListsArts get data from mc
func (d *Dao) CacheListsArts(c context.Context, ids []int64) (res map[int64][]*model.ListArtMeta, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := listArtsKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	replies, err := conn.GetMulti(keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheListsArts")
		log.Errorv(c, log.KV("CacheListsArts", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for key, reply := range replies {
		var v []*model.ListArtMeta
		v = []*model.ListArtMeta{}
		err = conn.Scan(reply, &v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheListsArts")
			log.Errorv(c, log.KV("CacheListsArts", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		if res == nil {
			res = make(map[int64][]*model.ListArtMeta, len(keys))
		}
		res[keysMap[key]] = v
	}
	return
}

// AddCacheListsArts Set data to mc
func (d *Dao) AddCacheListsArts(c context.Context, values map[int64][]*model.ListArtMeta) (err error) {
	if len(values) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	for id, val := range values {
		key := listArtsKey(id)
		item := &memcache.Item{Key: key, Object: val, Expiration: d.mcListArtsExpire, Flags: memcache.FlagJSON}
		if err = conn.Set(item); err != nil {
			prom.BusinessErrCount.Incr("mc:AddCacheListsArts")
			log.Errorv(c, log.KV("AddCacheListsArts", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// CacheArtsListID get data from mc
func (d *Dao) CacheArtsListID(c context.Context, ids []int64) (res map[int64]int64, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := articleListKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	replies, err := conn.GetMulti(keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheArtsListID")
		log.Errorv(c, log.KV("CacheArtsListID", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for key, reply := range replies {
		var v string
		err = conn.Scan(reply, &v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheArtsListID")
			log.Errorv(c, log.KV("CacheArtsListID", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		r, err := strconv.ParseInt(v, 10, 64)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheArtsListID")
			log.Errorv(c, log.KV("CacheArtsListID", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return res, err
		}
		if res == nil {
			res = make(map[int64]int64, len(keys))
		}
		res[keysMap[key]] = int64(r)
	}
	return
}

// AddCacheArtsListID Set data to mc
func (d *Dao) AddCacheArtsListID(c context.Context, values map[int64]int64) (err error) {
	if len(values) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	for id, val := range values {
		key := articleListKey(id)
		bs := []byte(strconv.FormatInt(int64(val), 10))
		item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcArtListExpire, Flags: memcache.FlagRAW}
		if err = conn.Set(item); err != nil {
			prom.BusinessErrCount.Incr("mc:AddCacheArtsListID")
			log.Errorv(c, log.KV("AddCacheArtsListID", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
	}
	return
}

// AddCacheUpLists Set data to mc
func (d *Dao) AddCacheUpLists(c context.Context, id int64, val []int64) (err error) {
	if len(val) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := upListsKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcUpListsExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheUpLists")
		log.Errorv(c, log.KV("AddCacheUpLists", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheUpLists get data from mc
func (d *Dao) CacheUpLists(c context.Context, id int64) (res []int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := upListsKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheUpLists")
		log.Errorv(c, log.KV("CacheUpLists", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = []int64{}
	err = conn.Scan(reply, &res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheUpLists")
		log.Errorv(c, log.KV("CacheUpLists", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheListReadCount Set data to mc
func (d *Dao) AddCacheListReadCount(c context.Context, id int64, val int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := listReadCountKey(id)
	bs := []byte(strconv.FormatInt(int64(val), 10))
	item := &memcache.Item{Key: key, Value: bs, Expiration: d.mcListReadExpire, Flags: memcache.FlagRAW}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheListReadCount")
		log.Errorv(c, log.KV("AddCacheListReadCount", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheListReadCount get data from mc
func (d *Dao) CacheListReadCount(c context.Context, id int64) (res int64, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := listReadCountKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheListReadCount")
		log.Errorv(c, log.KV("CacheListReadCount", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	var v string
	err = conn.Scan(reply, &v)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheListReadCount")
		log.Errorv(c, log.KV("CacheListReadCount", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	r, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheListReadCount")
		log.Errorv(c, log.KV("CacheListReadCount", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = int64(r)
	return
}

// CacheListsReadCount get data from mc
func (d *Dao) CacheListsReadCount(c context.Context, ids []int64) (res map[int64]int64, err error) {
	l := len(ids)
	if l == 0 {
		return
	}
	keysMap := make(map[string]int64, l)
	keys := make([]string, 0, l)
	for _, id := range ids {
		key := listReadCountKey(id)
		keysMap[key] = id
		keys = append(keys, key)
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	replies, err := conn.GetMulti(keys)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheListsReadCount")
		log.Errorv(c, log.KV("CacheListsReadCount", fmt.Sprintf("%+v", err)), log.KV("keys", keys))
		return
	}
	for key, reply := range replies {
		var v string
		err = conn.Scan(reply, &v)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheListsReadCount")
			log.Errorv(c, log.KV("CacheListsReadCount", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return
		}
		r, err := strconv.ParseInt(v, 10, 64)
		if err != nil {
			prom.BusinessErrCount.Incr("mc:CacheListsReadCount")
			log.Errorv(c, log.KV("CacheListsReadCount", fmt.Sprintf("%+v", err)), log.KV("key", key))
			return res, err
		}
		if res == nil {
			res = make(map[int64]int64, len(keys))
		}
		res[keysMap[key]] = int64(r)
	}
	return
}

// AddCacheHotspots Set data to mc
func (d *Dao) AddCacheHotspots(c context.Context, val []*model.Hotspot) (err error) {
	if len(val) == 0 {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := hotspotsKey()
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcHotspotExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheHotspots")
		log.Errorv(c, log.KV("AddCacheHotspots", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheHotspots delete data from mc
func (d *Dao) DelCacheHotspots(c context.Context) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := hotspotsKey()
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheHotspots")
		log.Errorv(c, log.KV("DelCacheHotspots", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// cacheHotspots get data from mc
func (d *Dao) cacheHotspots(c context.Context) (res []*model.Hotspot, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := hotspotsKey()
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:cacheHotspots")
		log.Errorv(c, log.KV("cacheHotspots", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = []*model.Hotspot{}
	err = conn.Scan(reply, &res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:cacheHotspots")
		log.Errorv(c, log.KV("cacheHotspots", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheHotspot get data from mc
func (d *Dao) CacheHotspot(c context.Context, id int64) (res *model.Hotspot, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := mcHotspotKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheHotspot")
		log.Errorv(c, log.KV("CacheHotspot", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.Hotspot{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheHotspot")
		log.Errorv(c, log.KV("CacheHotspot", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheHotspot Set data to mc
func (d *Dao) AddCacheHotspot(c context.Context, id int64, val *model.Hotspot) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := mcHotspotKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcHotspotExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheHotspot")
		log.Errorv(c, log.KV("AddCacheHotspot", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheAuthor 增加作者状态缓存
func (d *Dao) AddCacheAuthor(c context.Context, id int64, val *model.AuthorLimit) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := mcAuthorKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcAuthorExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheAuthor")
		log.Errorv(c, log.KV("AddCacheAuthor", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheAuthor get data from mc
func (d *Dao) CacheAuthor(c context.Context, id int64) (res *model.AuthorLimit, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := mcAuthorKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheAuthor")
		log.Errorv(c, log.KV("CacheAuthor", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.AuthorLimit{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheAuthor")
		log.Errorv(c, log.KV("CacheAuthor", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheAuthor delete data from mc
func (d *Dao) DelCacheAuthor(c context.Context, id int64) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := mcAuthorKey(id)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheAuthor")
		log.Errorv(c, log.KV("DelCacheAuthor", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheListArtsId get data from mc
func (d *Dao) CacheListArtsId(c context.Context, id string) (res *model.ArticleViewList, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := slideArticlesKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheListArtsId")
		log.Errorv(c, log.KV("CacheListArtsId", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.ArticleViewList{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheListArtsId")
		log.Errorv(c, log.KV("CacheListArtsId", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheListArtsId Set data to mc
func (d *Dao) AddCacheListArtsId(c context.Context, id string, val *model.ArticleViewList) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := slideArticlesKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcArticlesIDExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheListArtsId")
		log.Errorv(c, log.KV("AddCacheListArtsId", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// DelCacheListArtsId delete data from mc
func (d *Dao) DelCacheListArtsId(c context.Context, id string) (err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := slideArticlesKey(id)
	if err = conn.Delete(key); err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:DelCacheListArtsId")
		log.Errorv(c, log.KV("DelCacheListArtsId", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheAnniversary get data from mc
func (d *Dao) CacheAnniversary(c context.Context, id int64) (res *model.AnniversaryInfo, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := AnniversaryKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheAnniversary")
		log.Errorv(c, log.KV("CacheAnniversary", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.AnniversaryInfo{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheAnniversary")
		log.Errorv(c, log.KV("CacheAnniversary", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheAidsByTag get data from mc
func (d *Dao) CacheAidsByTag(c context.Context, id int64) (res *model.TagArts, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := mcTagKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheAidsByTag")
		log.Errorv(c, log.KV("CacheAidsByTag", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.TagArts{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheAidsByTag")
		log.Errorv(c, log.KV("CacheAidsByTag", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheAidsByTag Set data to mc
func (d *Dao) AddCacheAidsByTag(c context.Context, id int64, val *model.TagArts) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := mcTagKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcArticleTagExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheAidsByTag")
		log.Errorv(c, log.KV("AddCacheAidsByTag", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// CacheUpStatDaily get data from mc
func (d *Dao) CacheUpStatDaily(c context.Context, id int64) (res *model.UpStat, err error) {
	conn := d.mc.Get(c)
	defer conn.Close()
	key := mcUpStatKey(id)
	reply, err := conn.Get(key)
	if err != nil {
		if err == memcache.ErrNotFound {
			err = nil
			return
		}
		prom.BusinessErrCount.Incr("mc:CacheUpStatDaily")
		log.Errorv(c, log.KV("CacheUpStatDaily", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	res = &model.UpStat{}
	err = conn.Scan(reply, res)
	if err != nil {
		prom.BusinessErrCount.Incr("mc:CacheUpStatDaily")
		log.Errorv(c, log.KV("CacheUpStatDaily", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}

// AddCacheUpStatDaily Set data to mc
func (d *Dao) AddCacheUpStatDaily(c context.Context, id int64, val *model.UpStat) (err error) {
	if val == nil {
		return
	}
	conn := d.mc.Get(c)
	defer conn.Close()
	key := mcUpStatKey(id)
	item := &memcache.Item{Key: key, Object: val, Expiration: d.mcUpStatDailyExpire, Flags: memcache.FlagJSON}
	if err = conn.Set(item); err != nil {
		prom.BusinessErrCount.Incr("mc:AddCacheUpStatDaily")
		log.Errorv(c, log.KV("AddCacheUpStatDaily", fmt.Sprintf("%+v", err)), log.KV("key", key))
		return
	}
	return
}
